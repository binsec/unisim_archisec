/*** File generated by GenISSLib version 4.1.0: DO NOT MODIFY ***/
#ifndef __ppc64_ppc64dec_ppc64__isa_HH__
#define __ppc64_ppc64dec_ppc64__isa_HH__

#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

#include <vector>
#include <inttypes.h>
#include <cstring>
namespace ppc64 { namespace isa {
typedef uint32_t CodeType;

class Operation;
class DecodeTableEntry
{
public:
	DecodeTableEntry(CodeType opcode, CodeType opcode_mask, Operation *(*decode)(CodeType, uint64_t));
	CodeType opcode;
	CodeType opcode_mask;
	Operation *(*decode)(CodeType code, uint64_t addr);
};
class Decoder
{
public:
	typedef Operation operation_type;
	typedef uint64_t address_type;
	typedef CodeType code_type;
	enum { alignment = 32 };

	Decoder();
	virtual ~Decoder();

	Operation*NCDecode(uint64_t addr);
	Operation *NCDecode(uint64_t addr, CodeType code);
	std::vector<DecodeTableEntry > const& GetDecodeTable() const { return decode_table; };
	void SetLittleEndian();
	void SetBigEndian();
private:
	std::vector<DecodeTableEntry > decode_table;
};

} }

#include <iosfwd>
#include <inttypes.h>

namespace ppc64 { struct Arch; }

namespace ppc64 { namespace isa {
class Operation
{
public:
	Operation(CodeType code, uint64_t addr, const char *name);
	virtual ~Operation();
	inline uint64_t GetAddr() const { return addr; }
	inline void SetAddr(uint64_t _addr) { this->addr = _addr; }
	inline CodeType GetEncoding() const { return encoding; }
	inline unsigned int GetLength() const { return 32; }
	inline const char *GetName() const { return name; }
	inline bool Match(uint64_t _addr, CodeType _code) const { return (this->GetEncoding() ^ _code) == 0 and GetAddr() == _addr; }
	static unsigned int const minsize = 32;
	static unsigned int const maxsize = 32;
	virtual void disasm( std::ostream& os );
	virtual bool execute( Arch* cpu );
protected:
	CodeType encoding;
	uint64_t addr;
	const char *name;
};

} }
#endif
