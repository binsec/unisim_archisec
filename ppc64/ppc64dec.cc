#include "ppc64/ppc64dec.hh"

#include <arch.hh>
#include <unisim/component/cxx/processor/powerpc/isa/disasm.hh>
#include <unisim/component/cxx/processor/powerpc/isa/book_i/fixed_point/integer.hh>
//#include <unisim/component/cxx/processor/powerpc/isa/book_i/floating_point/floating.hh>
#include <unisim/util/likely/likely.hh>
#include <iostream>

//namespace ppc64
//{
	typedef unisim::component::cxx::processor::powerpc::CondPrint CondPrint;
	typedef unisim::component::cxx::processor::powerpc::GPRPrint GPRPrint;
	typedef unisim::component::cxx::processor::powerpc::FPRPrint FPRPrint;
	typedef unisim::component::cxx::processor::powerpc::CRPrint CRPrint;
	typedef unisim::component::cxx::processor::powerpc::EAPrint EAPrint;
	using unisim::component::cxx::processor::powerpc::Mask64;
	typedef ppc64::U64 LR;

	namespace ppc64
	{
	}

	// using ut::GenSPEFSCR_FOVF;
	// using ut::GenSPEFSCR_FUNF;
	// using ut::GenSPEFSCR_FINXS;
	// using ut::HasSPEFSCR_InvalidInput;
	// using ut::GenSPEFSCR_FG;
	// using ut::GenSPEFSCR_FX;
	// using ut::DoesSPEFSCR_TriggerException;
	// using ut::GenSPEFSCR_FG;

#if defined(__GNUC__) && ((__GNUC__ >= 2 && __GNUC_MINOR__ >= 96) || __GNUC__ >= 3)
#if defined(likely)
#undef likely
#endif

#if defined(unlikely)
#undef unlikely
#endif

#define likely(x)       __builtin_expect(Path::Test(x),1)
#define evenly(x)       (Path::Test(x))
#define unlikely(x)     __builtin_expect(Path::Test(x),0)
#else
#define likely(x)       (Path::Test(x))
#define evenly(x)       (Path::Test(x))
#define unlikely(x)     (Path::Test(x))
#endif

	namespace ppc64 { namespace isa {
	Operation::Operation(CodeType _code, uint64_t _addr, const char *_name)
:
	encoding(_code),
	addr(_addr),
	name(_name)
	{
	}

	Operation::~Operation()
	{
	}

	void Operation::disasm( std::ostream& os)
	{
		{ os << "???"; }}
	bool Operation::execute( Arch* cpu)
	{
		{
			throw 0;//ut::Untestable("not implemented");
			return false;
	}}
	class OpBcctr : public Operation
	{
	public:
		OpBcctr(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpBc : public Operation
	{
	public:
		OpBc(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpBclr : public Operation
	{
	public:
		OpBclr(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpB : public Operation
	{
	public:
		OpB(CodeType code, uint64_t addr);
		int32_t li24;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCrandc : public Operation
	{
	public:
		OpCrandc(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t ba;
		uint8_t bb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCrand : public Operation
	{
	public:
		OpCrand(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t ba;
		uint8_t bb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCreqv : public Operation
	{
	public:
		OpCreqv(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t ba;
		uint8_t bb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCrnand : public Operation
	{
	public:
		OpCrnand(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t ba;
		uint8_t bb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCrnor : public Operation
	{
	public:
		OpCrnor(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t ba;
		uint8_t bb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCrorc : public Operation
	{
	public:
		OpCrorc(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t ba;
		uint8_t bb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCror : public Operation
	{
	public:
		OpCror(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t ba;
		uint8_t bb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCrxor : public Operation
	{
	public:
		OpCrxor(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t ba;
		uint8_t bb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMcrf : public Operation
	{
	public:
		OpMcrf(CodeType code, uint64_t addr);
		uint8_t bft;
		uint8_t bfa;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAddc : public Operation
	{
	public:
		OpAddc(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAdde : public Operation
	{
	public:
		OpAdde(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAddic_ : public Operation
	{
	public:
		OpAddic_(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t simm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAddic : public Operation
	{
	public:
		OpAddic(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t simm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAddi : public Operation
	{
	public:
		OpAddi(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t simm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAdd : public Operation
	{
	public:
		OpAdd(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAddis : public Operation
	{
	public:
		OpAddis(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t simm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAddme : public Operation
	{
	public:
		OpAddme(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAddze : public Operation
	{
	public:
		OpAddze(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAndc : public Operation
	{
	public:
		OpAndc(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAndi_ : public Operation
	{
	public:
		OpAndi_(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint16_t uimm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAnd : public Operation
	{
	public:
		OpAnd(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpAndis_ : public Operation
	{
	public:
		OpAndis_(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint32_t uimm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCmp : public Operation
	{
	public:
		OpCmp(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCmpL : public Operation
	{
	public:
		OpCmpL(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCmpi : public Operation
	{
	public:
		OpCmpi(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		int16_t simm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCmpiL : public Operation
	{
	public:
		OpCmpiL(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		int16_t simm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCmpl : public Operation
	{
	public:
		OpCmpl(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCmplL : public Operation
	{
	public:
		OpCmplL(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCmpli : public Operation
	{
	public:
		OpCmpli(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint16_t uimm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCmpliL : public Operation
	{
	public:
		OpCmpliL(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint16_t uimm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCntlzw : public Operation
	{
	public:
		OpCntlzw(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpCntlzd : public Operation
	{
	public:
		OpCntlzd(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpDivw : public Operation
	{
	public:
		OpDivw(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S32 operator () ( S32 a, S32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpDivwu : public Operation
	{
	public:
		OpDivwu(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U32 operator () ( U32 a, U32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpDivd : public Operation
	{
	public:
		OpDivd(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S64 operator () ( S64 a, S64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpDivdu : public Operation
	{
	public:
		OpDivdu(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U64 operator () ( U64 a, U64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpEqv : public Operation
	{
	public:
		OpEqv(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpExtsb : public Operation
	{
	public:
		OpExtsb(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpExtsh : public Operation
	{
	public:
		OpExtsh(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpExtsw : public Operation
	{
	public:
		OpExtsw(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpIsel : public Operation
	{
	public:
		OpIsel(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t bc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLbz : public Operation
	{
	public:
		OpLbz(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLbzu : public Operation
	{
	public:
		OpLbzu(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLbzux : public Operation
	{
	public:
		OpLbzux(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLbzx : public Operation
	{
	public:
		OpLbzx(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLha : public Operation
	{
	public:
		OpLha(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLhau : public Operation
	{
	public:
		OpLhau(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLhaux : public Operation
	{
	public:
		OpLhaux(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLhax : public Operation
	{
	public:
		OpLhax(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLhz : public Operation
	{
	public:
		OpLhz(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLhzu : public Operation
	{
	public:
		OpLhzu(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLhzux : public Operation
	{
	public:
		OpLhzux(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLhzx : public Operation
	{
	public:
		OpLhzx(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLwz : public Operation
	{
	public:
		OpLwz(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLwzu : public Operation
	{
	public:
		OpLwzu(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLwzux : public Operation
	{
	public:
		OpLwzux(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLwzx : public Operation
	{
	public:
		OpLwzx(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLwa : public Operation
	{
	public:
		OpLwa(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLwaux : public Operation
	{
	public:
		OpLwaux(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLwax : public Operation
	{
	public:
		OpLwax(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLd : public Operation
	{
	public:
		OpLd(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLdx : public Operation
	{
	public:
		OpLdx(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLdu : public Operation
	{
	public:
		OpLdu(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLdux : public Operation
	{
	public:
		OpLdux(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMcrxr : public Operation
	{
	public:
		OpMcrxr(CodeType code, uint64_t addr);
		uint8_t crfD;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMfcr : public Operation
	{
	public:
		OpMfcr(CodeType code, uint64_t addr);
		uint8_t rd;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMtcrf : public Operation
	{
	public:
		OpMtcrf(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t crm;
		uint32_t crmask; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMulli : public Operation
	{
	public:
		OpMulli(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t simm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMulhw : public Operation
	{
	public:
		OpMulhw(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMulhwu : public Operation
	{
	public:
		OpMulhwu(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMullw : public Operation
	{
	public:
		OpMullw(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMulhd : public Operation
	{
	public:
		OpMulhd(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMulhdu : public Operation
	{
	public:
		OpMulhdu(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMulld : public Operation
	{
	public:
		OpMulld(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpNand : public Operation
	{
	public:
		OpNand(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpNeg : public Operation
	{
	public:
		OpNeg(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpNor : public Operation
	{
	public:
		OpNor(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpOrc : public Operation
	{
	public:
		OpOrc(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpOri : public Operation
	{
	public:
		OpOri(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint16_t uimm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpOr : public Operation
	{
	public:
		OpOr(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpOris : public Operation
	{
	public:
		OpOris(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint32_t uimm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpRlwimi : public Operation
	{
	public:
		OpRlwimi(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh;
		uint8_t mb;
		uint8_t me;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpRlwinm : public Operation
	{
	public:
		OpRlwinm(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh;
		uint8_t mb;
		uint8_t me;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpRlwnm : public Operation
	{
	public:
		OpRlwnm(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t mb;
		uint8_t me;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpRldicl : public Operation
	{
	public:
		OpRldicl(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t sh0;
		uint8_t rc;
		unsigned n;   uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpRldicr : public Operation
	{
	public:
		OpRldicr(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t me1;
		uint8_t me0;
		uint8_t sh0;
		uint8_t rc;
		unsigned n;   uint8_t me; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpRldic : public Operation
	{
	public:
		OpRldic(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t sh0;
		uint8_t rc;
		unsigned n;   uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpRldcl : public Operation
	{
	public:
		OpRldcl(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t rc;
		uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpRldcr : public Operation
	{
	public:
		OpRldcr(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t me1;
		uint8_t me0;
		uint8_t rc;
		uint8_t me; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpRldimi : public Operation
	{
	public:
		OpRldimi(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t sh0;
		uint8_t rc;
		uint8_t sh;   uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSlw : public Operation
	{
	public:
		OpSlw(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSrawi : public Operation
	{
	public:
		OpSrawi(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh;
		uint8_t rc;
		int32_t shifted_out; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSraw : public Operation
	{
	public:
		OpSraw(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSrw : public Operation
	{
	public:
		OpSrw(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSld : public Operation
	{
	public:
		OpSld(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSradi : public Operation
	{
	public:
		OpSradi(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t sh0;
		uint8_t rc;
		unsigned sh; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSrad : public Operation
	{
	public:
		OpSrad(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSrd : public Operation
	{
	public:
		OpSrd(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStb : public Operation
	{
	public:
		OpStb(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStbu : public Operation
	{
	public:
		OpStbu(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStbux : public Operation
	{
	public:
		OpStbux(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStbx : public Operation
	{
	public:
		OpStbx(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSth : public Operation
	{
	public:
		OpSth(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSthu : public Operation
	{
	public:
		OpSthu(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSthux : public Operation
	{
	public:
		OpSthux(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSthx : public Operation
	{
	public:
		OpSthx(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStw : public Operation
	{
	public:
		OpStw(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStwu : public Operation
	{
	public:
		OpStwu(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStwux : public Operation
	{
	public:
		OpStwux(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStwx : public Operation
	{
	public:
		OpStwx(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStd : public Operation
	{
	public:
		OpStd(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStdu : public Operation
	{
	public:
		OpStdu(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStdux : public Operation
	{
	public:
		OpStdux(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStdx : public Operation
	{
	public:
		OpStdx(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSubfc : public Operation
	{
	public:
		OpSubfc(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSubfe : public Operation
	{
	public:
		OpSubfe(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSubfic : public Operation
	{
	public:
		OpSubfic(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		int16_t simm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSubf : public Operation
	{
	public:
		OpSubf(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSubfme : public Operation
	{
	public:
		OpSubfme(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpSubfze : public Operation
	{
	public:
		OpSubfze(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpXori : public Operation
	{
	public:
		OpXori(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint16_t uimm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpXor : public Operation
	{
	public:
		OpXor(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpXoris : public Operation
	{
	public:
		OpXoris(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint32_t uimm;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFabs : public Operation
	{
	public:
		OpFabs(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFadd : public Operation
	{
	public:
		OpFadd(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFadds : public Operation
	{
	public:
		OpFadds(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFcmpo : public Operation
	{
	public:
		OpFcmpo(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t fa;
		uint8_t fb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFcmpu : public Operation
	{
	public:
		OpFcmpu(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t fa;
		uint8_t fb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFctiw : public Operation
	{
	public:
		OpFctiw(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFctiwz : public Operation
	{
	public:
		OpFctiwz(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFctid : public Operation
	{
	public:
		OpFctid(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFctidz : public Operation
	{
	public:
		OpFctidz(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFcfid : public Operation
	{
	public:
		OpFcfid(CodeType code, uint64_t addr);
		uint8_t frt;
		uint8_t frb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFdiv : public Operation
	{
	public:
		OpFdiv(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFdivs : public Operation
	{
	public:
		OpFdivs(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFmadd : public Operation
	{
	public:
		OpFmadd(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFmadds : public Operation
	{
	public:
		OpFmadds(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFmr : public Operation
	{
	public:
		OpFmr(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFmsub : public Operation
	{
	public:
		OpFmsub(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFmsubs : public Operation
	{
	public:
		OpFmsubs(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFmul : public Operation
	{
	public:
		OpFmul(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFmuls : public Operation
	{
	public:
		OpFmuls(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFnabs : public Operation
	{
	public:
		OpFnabs(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFneg : public Operation
	{
	public:
		OpFneg(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFnmadd : public Operation
	{
	public:
		OpFnmadd(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFnmadds : public Operation
	{
	public:
		OpFnmadds(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFnmsub : public Operation
	{
	public:
		OpFnmsub(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFnmsubs : public Operation
	{
	public:
		OpFnmsubs(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFrsp : public Operation
	{
	public:
		OpFrsp(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFsel : public Operation
	{
	public:
		OpFsel(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFsub : public Operation
	{
	public:
		OpFsub(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpFsubs : public Operation
	{
	public:
		OpFsubs(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLfd : public Operation
	{
	public:
		OpLfd(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLfdu : public Operation
	{
	public:
		OpLfdu(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLfdux : public Operation
	{
	public:
		OpLfdux(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLfdx : public Operation
	{
	public:
		OpLfdx(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLfs : public Operation
	{
	public:
		OpLfs(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLfsu : public Operation
	{
	public:
		OpLfsu(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLfsux : public Operation
	{
	public:
		OpLfsux(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpLfsx : public Operation
	{
	public:
		OpLfsx(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMcrfs : public Operation
	{
	public:
		OpMcrfs(CodeType code, uint64_t addr);
		uint8_t bft;
		uint8_t bfa;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMffs : public Operation
	{
	public:
		OpMffs(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMtfsb0 : public Operation
	{
	public:
		OpMtfsb0(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMtfsb1 : public Operation
	{
	public:
		OpMtfsb1(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMtfsfi : public Operation
	{
	public:
		OpMtfsfi(CodeType code, uint64_t addr);
		uint8_t bft;
		uint8_t w;
		uint8_t imm;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMtfsf : public Operation
	{
	public:
		OpMtfsf(CodeType code, uint64_t addr);
		uint8_t l;
		uint8_t fm;
		uint8_t w;
		uint8_t fb;
		uint8_t rc;
		uint32_t fsmask; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStfd : public Operation
	{
	public:
		OpStfd(CodeType code, uint64_t addr);
		uint8_t fs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStfdu : public Operation
	{
	public:
		OpStfdu(CodeType code, uint64_t addr);
		uint8_t fs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStfdux : public Operation
	{
	public:
		OpStfdux(CodeType code, uint64_t addr);
		uint8_t fs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStfdx : public Operation
	{
	public:
		OpStfdx(CodeType code, uint64_t addr);
		uint8_t fs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStfiwx : public Operation
	{
	public:
		OpStfiwx(CodeType code, uint64_t addr);
		uint8_t fs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStfs : public Operation
	{
	public:
		OpStfs(CodeType code, uint64_t addr);
		uint8_t fs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStfsu : public Operation
	{
	public:
		OpStfsu(CodeType code, uint64_t addr);
		uint8_t fs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStfsux : public Operation
	{
	public:
		OpStfsux(CodeType code, uint64_t addr);
		uint8_t fs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpStfsx : public Operation
	{
	public:
		OpStfsx(CodeType code, uint64_t addr);
		uint8_t fs;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMfspr : public Operation
	{
	public:
		OpMfspr(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t spr1;
		uint8_t spr0;
		unsigned n; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class OpMtspr : public Operation
	{
	public:
		OpMtspr(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t spr1;
		uint8_t spr0;
		unsigned n; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_0_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_0_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_0_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_0_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_2_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_2_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_2_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_2_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_3_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_3_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_3_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_3_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_4_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_4_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_4_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_4_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_5_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_5_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_5_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_5_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_6_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_6_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_6_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_6_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_7_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_7_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_7_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_7_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_8_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_8_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_8_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_8_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_9_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_9_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_9_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_9_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_a_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_a_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_a_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_a_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_b_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_b_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_b_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_b_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_c_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_c_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_c_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_c_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_d_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_d_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_d_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_d_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_e_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_e_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_e_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_e_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_f_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_f_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_f_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_f_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_10_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_10_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_10_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_10_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_11_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_11_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_11_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_11_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_12_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_12_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_12_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_12_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_13_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_13_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_13_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_13_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_14_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_14_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_14_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_14_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_15_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_15_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_15_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_15_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_16_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_16_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_16_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_16_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_17_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_17_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_17_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_17_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_18_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_18_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_18_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_18_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_19_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_19_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_19_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_19_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1a_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1a_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1a_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1a_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1b_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1b_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1b_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1b_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1c_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1c_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1c_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1c_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1d_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1d_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1d_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1d_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1e_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1e_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1e_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1e_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1f_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1f_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bcctr_bo_1f_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bcctr_bo_1f_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_0_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_0_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_0_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_0_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_0_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_0_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_0_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_0_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_2_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_2_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_2_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_2_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_2_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_2_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_2_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_2_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_3_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_3_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_3_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_3_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_3_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_3_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_3_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_3_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_4_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_4_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_4_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_4_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_4_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_4_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_4_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_4_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_5_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_5_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_5_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_5_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_5_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_5_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_5_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_5_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_6_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_6_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_6_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_6_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_6_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_6_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_6_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_6_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_7_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_7_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_7_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_7_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_7_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_7_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_7_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_7_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_8_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_8_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_8_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_8_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_8_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_8_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_8_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_8_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_9_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_9_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_9_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_9_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_9_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_9_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_9_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_9_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_a_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_a_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_a_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_a_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_a_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_a_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_a_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_a_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_b_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_b_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_b_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_b_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_b_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_b_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_b_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_b_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_c_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_c_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_c_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_c_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_c_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_c_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_c_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_c_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_d_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_d_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_d_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_d_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_d_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_d_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_d_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_d_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_e_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_e_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_e_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_e_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_e_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_e_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_e_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_e_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_f_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_f_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_f_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_f_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_f_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_f_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_f_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_f_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_10_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_10_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_10_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_10_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_10_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_10_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_10_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_10_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_11_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_11_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_11_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_11_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_11_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_11_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_11_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_11_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_12_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_12_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_12_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_12_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_12_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_12_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_12_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_12_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_13_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_13_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_13_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_13_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_13_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_13_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_13_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_13_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_14_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_14_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_14_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_14_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_14_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_14_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_14_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_14_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_15_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_15_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_15_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_15_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_15_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_15_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_15_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_15_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_16_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_16_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_16_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_16_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_16_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_16_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_16_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_16_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_17_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_17_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_17_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_17_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_17_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_17_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_17_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_17_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_18_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_18_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_18_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_18_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_18_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_18_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_18_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_18_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_19_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_19_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_19_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_19_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_19_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_19_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_19_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_19_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1a_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1a_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1a_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1a_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1a_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1a_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1a_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1a_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1b_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1b_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1b_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1b_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1b_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1b_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1b_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1b_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1c_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1c_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1c_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1c_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1c_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1c_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1c_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1c_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1d_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1d_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1d_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1d_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1d_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1d_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1d_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1d_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1e_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1e_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1e_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1e_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1e_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1e_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1e_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1e_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1f_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1f_aa_0_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1f_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1f_aa_0_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1f_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__bc_bo_1f_aa_1_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bc_bo_1f_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__bc_bo_1f_aa_1_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		int16_t bd14;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_0_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_0_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_0_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_0_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_1_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_1_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_2_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_2_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_2_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_2_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_3_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_3_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_3_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_3_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_4_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_4_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_4_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_4_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_5_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_5_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_5_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_5_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_6_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_6_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_6_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_6_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_7_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_7_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_7_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_7_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_8_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_8_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_8_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_8_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_9_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_9_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_9_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_9_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_a_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_a_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_a_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_a_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_b_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_b_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_b_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_b_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_c_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_c_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_c_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_c_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_d_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_d_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_d_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_d_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_e_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_e_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_e_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_e_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_f_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_f_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_f_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_f_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_10_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_10_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_10_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_10_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_11_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_11_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_11_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_11_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_12_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_12_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_12_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_12_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_13_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_13_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_13_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_13_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_14_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_14_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_14_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_14_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_15_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_15_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_15_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_15_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_16_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_16_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_16_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_16_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_17_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_17_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_17_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_17_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_18_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_18_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_18_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_18_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_19_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_19_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_19_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_19_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1a_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_1a_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1a_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_1a_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1b_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_1b_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1b_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_1b_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1c_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_1c_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1c_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_1c_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1d_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_1d_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1d_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_1d_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1e_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_1e_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1e_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_1e_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1f_aa_2_lk_0 : public Operation
	{
	public:
		Op__spec__bclr_bo_1f_aa_2_lk_0(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__bclr_bo_1f_aa_2_lk_1 : public Operation
	{
	public:
		Op__spec__bclr_bo_1f_aa_2_lk_1(CodeType code, uint64_t addr);
		uint8_t bo;
		uint8_t bi;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__b_aa_0_lk_0 : public Operation
	{
	public:
		Op__spec__b_aa_0_lk_0(CodeType code, uint64_t addr);
		int32_t li24;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__b_aa_0_lk_1 : public Operation
	{
	public:
		Op__spec__b_aa_0_lk_1(CodeType code, uint64_t addr);
		int32_t li24;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__b_aa_1_lk_0 : public Operation
	{
	public:
		Op__spec__b_aa_1_lk_0(CodeType code, uint64_t addr);
		int32_t li24;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__b_aa_1_lk_1 : public Operation
	{
	public:
		Op__spec__b_aa_1_lk_1(CodeType code, uint64_t addr);
		int32_t li24;
		uint8_t aa;
		uint8_t lk;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addc_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__addc_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addc_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__addc_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addc_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__addc_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addc_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__addc_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__adde_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__adde_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__adde_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__adde_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__adde_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__adde_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__adde_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__adde_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__add_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__add_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__add_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__add_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__add_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__add_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__add_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__add_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addme_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__addme_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addme_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__addme_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addme_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__addme_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addme_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__addme_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addze_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__addze_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addze_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__addze_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addze_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__addze_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__addze_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__addze_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__andc_rc_0 : public Operation
	{
	public:
		Op__spec__andc_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__andc_rc_1 : public Operation
	{
	public:
		Op__spec__andc_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__and_rc_0 : public Operation
	{
	public:
		Op__spec__and_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__and_rc_1 : public Operation
	{
	public:
		Op__spec__and_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmp_crfD_0 : public Operation
	{
	public:
		Op__spec__cmp_crfD_0(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmp_crfD_1 : public Operation
	{
	public:
		Op__spec__cmp_crfD_1(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmp_crfD_2 : public Operation
	{
	public:
		Op__spec__cmp_crfD_2(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmp_crfD_3 : public Operation
	{
	public:
		Op__spec__cmp_crfD_3(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmp_crfD_4 : public Operation
	{
	public:
		Op__spec__cmp_crfD_4(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmp_crfD_5 : public Operation
	{
	public:
		Op__spec__cmp_crfD_5(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmp_crfD_6 : public Operation
	{
	public:
		Op__spec__cmp_crfD_6(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmp_crfD_7 : public Operation
	{
	public:
		Op__spec__cmp_crfD_7(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpL_crfD_0 : public Operation
	{
	public:
		Op__spec__cmpL_crfD_0(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpL_crfD_1 : public Operation
	{
	public:
		Op__spec__cmpL_crfD_1(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpL_crfD_2 : public Operation
	{
	public:
		Op__spec__cmpL_crfD_2(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpL_crfD_3 : public Operation
	{
	public:
		Op__spec__cmpL_crfD_3(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpL_crfD_4 : public Operation
	{
	public:
		Op__spec__cmpL_crfD_4(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpL_crfD_5 : public Operation
	{
	public:
		Op__spec__cmpL_crfD_5(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpL_crfD_6 : public Operation
	{
	public:
		Op__spec__cmpL_crfD_6(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpL_crfD_7 : public Operation
	{
	public:
		Op__spec__cmpL_crfD_7(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpl_crfD_0 : public Operation
	{
	public:
		Op__spec__cmpl_crfD_0(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpl_crfD_1 : public Operation
	{
	public:
		Op__spec__cmpl_crfD_1(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpl_crfD_2 : public Operation
	{
	public:
		Op__spec__cmpl_crfD_2(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpl_crfD_3 : public Operation
	{
	public:
		Op__spec__cmpl_crfD_3(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpl_crfD_4 : public Operation
	{
	public:
		Op__spec__cmpl_crfD_4(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpl_crfD_5 : public Operation
	{
	public:
		Op__spec__cmpl_crfD_5(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpl_crfD_6 : public Operation
	{
	public:
		Op__spec__cmpl_crfD_6(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmpl_crfD_7 : public Operation
	{
	public:
		Op__spec__cmpl_crfD_7(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmplL_crfD_0 : public Operation
	{
	public:
		Op__spec__cmplL_crfD_0(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmplL_crfD_1 : public Operation
	{
	public:
		Op__spec__cmplL_crfD_1(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmplL_crfD_2 : public Operation
	{
	public:
		Op__spec__cmplL_crfD_2(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmplL_crfD_3 : public Operation
	{
	public:
		Op__spec__cmplL_crfD_3(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmplL_crfD_4 : public Operation
	{
	public:
		Op__spec__cmplL_crfD_4(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmplL_crfD_5 : public Operation
	{
	public:
		Op__spec__cmplL_crfD_5(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmplL_crfD_6 : public Operation
	{
	public:
		Op__spec__cmplL_crfD_6(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cmplL_crfD_7 : public Operation
	{
	public:
		Op__spec__cmplL_crfD_7(CodeType code, uint64_t addr);
		uint8_t crfD;
		uint8_t ra;
		uint8_t rb;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cntlzw_rc_0 : public Operation
	{
	public:
		Op__spec__cntlzw_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cntlzw_rc_1 : public Operation
	{
	public:
		Op__spec__cntlzw_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cntlzd_rc_0 : public Operation
	{
	public:
		Op__spec__cntlzd_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__cntlzd_rc_1 : public Operation
	{
	public:
		Op__spec__cntlzd_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divw_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__divw_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S32 operator () ( S32 a, S32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divw_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__divw_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S32 operator () ( S32 a, S32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divw_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__divw_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S32 operator () ( S32 a, S32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divw_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__divw_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S32 operator () ( S32 a, S32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divwu_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__divwu_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U32 operator () ( U32 a, U32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divwu_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__divwu_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U32 operator () ( U32 a, U32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divwu_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__divwu_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U32 operator () ( U32 a, U32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divwu_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__divwu_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U32 operator () ( U32 a, U32 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divd_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__divd_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S64 operator () ( S64 a, S64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divd_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__divd_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S64 operator () ( S64 a, S64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divd_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__divd_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S64 operator () ( S64 a, S64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divd_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__divd_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { S64 operator () ( S64 a, S64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divdu_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__divdu_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U64 operator () ( U64 a, U64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divdu_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__divdu_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U64 operator () ( U64 a, U64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divdu_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__divdu_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U64 operator () ( U64 a, U64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__divdu_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__divdu_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		struct { U64 operator () ( U64 a, U64 b ) { return a; /* Is QEMU Right ? */ } } DZResult; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__eqv_rc_0 : public Operation
	{
	public:
		Op__spec__eqv_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__eqv_rc_1 : public Operation
	{
	public:
		Op__spec__eqv_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__extsb_rc_0 : public Operation
	{
	public:
		Op__spec__extsb_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__extsb_rc_1 : public Operation
	{
	public:
		Op__spec__extsb_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__extsh_rc_0 : public Operation
	{
	public:
		Op__spec__extsh_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__extsh_rc_1 : public Operation
	{
	public:
		Op__spec__extsh_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__extsw_rc_0 : public Operation
	{
	public:
		Op__spec__extsw_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__extsw_rc_1 : public Operation
	{
	public:
		Op__spec__extsw_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mcrxr_crfD_0 : public Operation
	{
	public:
		Op__spec__mcrxr_crfD_0(CodeType code, uint64_t addr);
		uint8_t crfD;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mcrxr_crfD_1 : public Operation
	{
	public:
		Op__spec__mcrxr_crfD_1(CodeType code, uint64_t addr);
		uint8_t crfD;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mcrxr_crfD_2 : public Operation
	{
	public:
		Op__spec__mcrxr_crfD_2(CodeType code, uint64_t addr);
		uint8_t crfD;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mcrxr_crfD_3 : public Operation
	{
	public:
		Op__spec__mcrxr_crfD_3(CodeType code, uint64_t addr);
		uint8_t crfD;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mcrxr_crfD_4 : public Operation
	{
	public:
		Op__spec__mcrxr_crfD_4(CodeType code, uint64_t addr);
		uint8_t crfD;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mcrxr_crfD_5 : public Operation
	{
	public:
		Op__spec__mcrxr_crfD_5(CodeType code, uint64_t addr);
		uint8_t crfD;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mcrxr_crfD_6 : public Operation
	{
	public:
		Op__spec__mcrxr_crfD_6(CodeType code, uint64_t addr);
		uint8_t crfD;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mcrxr_crfD_7 : public Operation
	{
	public:
		Op__spec__mcrxr_crfD_7(CodeType code, uint64_t addr);
		uint8_t crfD;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulhw_rc_0 : public Operation
	{
	public:
		Op__spec__mulhw_rc_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulhw_rc_1 : public Operation
	{
	public:
		Op__spec__mulhw_rc_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulhwu_rc_0 : public Operation
	{
	public:
		Op__spec__mulhwu_rc_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulhwu_rc_1 : public Operation
	{
	public:
		Op__spec__mulhwu_rc_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mullw_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__mullw_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mullw_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__mullw_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mullw_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__mullw_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mullw_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__mullw_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulhd_rc_0 : public Operation
	{
	public:
		Op__spec__mulhd_rc_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulhd_rc_1 : public Operation
	{
	public:
		Op__spec__mulhd_rc_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulhdu_rc_0 : public Operation
	{
	public:
		Op__spec__mulhdu_rc_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulhdu_rc_1 : public Operation
	{
	public:
		Op__spec__mulhdu_rc_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulld_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__mulld_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulld_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__mulld_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulld_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__mulld_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mulld_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__mulld_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__nand_rc_0 : public Operation
	{
	public:
		Op__spec__nand_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__nand_rc_1 : public Operation
	{
	public:
		Op__spec__nand_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__neg_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__neg_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__neg_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__neg_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__neg_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__neg_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__neg_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__neg_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__nor_rc_0 : public Operation
	{
	public:
		Op__spec__nor_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__nor_rc_1 : public Operation
	{
	public:
		Op__spec__nor_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__orc_rc_0 : public Operation
	{
	public:
		Op__spec__orc_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__orc_rc_1 : public Operation
	{
	public:
		Op__spec__orc_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__or_rc_0 : public Operation
	{
	public:
		Op__spec__or_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__or_rc_1 : public Operation
	{
	public:
		Op__spec__or_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rlwimi_rc_0 : public Operation
	{
	public:
		Op__spec__rlwimi_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh;
		uint8_t mb;
		uint8_t me;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rlwimi_rc_1 : public Operation
	{
	public:
		Op__spec__rlwimi_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh;
		uint8_t mb;
		uint8_t me;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rlwinm_rc_0 : public Operation
	{
	public:
		Op__spec__rlwinm_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh;
		uint8_t mb;
		uint8_t me;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rlwinm_rc_1 : public Operation
	{
	public:
		Op__spec__rlwinm_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh;
		uint8_t mb;
		uint8_t me;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rlwnm_rc_0 : public Operation
	{
	public:
		Op__spec__rlwnm_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t mb;
		uint8_t me;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rlwnm_rc_1 : public Operation
	{
	public:
		Op__spec__rlwnm_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t mb;
		uint8_t me;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldicl_rc_0 : public Operation
	{
	public:
		Op__spec__rldicl_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t sh0;
		uint8_t rc;
		unsigned n;   uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldicl_rc_1 : public Operation
	{
	public:
		Op__spec__rldicl_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t sh0;
		uint8_t rc;
		unsigned n;   uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldicr_rc_0 : public Operation
	{
	public:
		Op__spec__rldicr_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t me1;
		uint8_t me0;
		uint8_t sh0;
		uint8_t rc;
		unsigned n;   uint8_t me; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldicr_rc_1 : public Operation
	{
	public:
		Op__spec__rldicr_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t me1;
		uint8_t me0;
		uint8_t sh0;
		uint8_t rc;
		unsigned n;   uint8_t me; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldic_rc_0 : public Operation
	{
	public:
		Op__spec__rldic_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t sh0;
		uint8_t rc;
		unsigned n;   uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldic_rc_1 : public Operation
	{
	public:
		Op__spec__rldic_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t sh0;
		uint8_t rc;
		unsigned n;   uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldcl_rc_0 : public Operation
	{
	public:
		Op__spec__rldcl_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t rc;
		uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldcl_rc_1 : public Operation
	{
	public:
		Op__spec__rldcl_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t rc;
		uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldcr_rc_0 : public Operation
	{
	public:
		Op__spec__rldcr_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t me1;
		uint8_t me0;
		uint8_t rc;
		uint8_t me; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldcr_rc_1 : public Operation
	{
	public:
		Op__spec__rldcr_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t me1;
		uint8_t me0;
		uint8_t rc;
		uint8_t me; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldimi_rc_0 : public Operation
	{
	public:
		Op__spec__rldimi_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t sh0;
		uint8_t rc;
		uint8_t sh;   uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__rldimi_rc_1 : public Operation
	{
	public:
		Op__spec__rldimi_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t mb1;
		uint8_t mb0;
		uint8_t sh0;
		uint8_t rc;
		uint8_t sh;   uint8_t mb; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__slw_rc_0 : public Operation
	{
	public:
		Op__spec__slw_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__slw_rc_1 : public Operation
	{
	public:
		Op__spec__slw_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__srawi_rc_0 : public Operation
	{
	public:
		Op__spec__srawi_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh;
		uint8_t rc;
		int32_t shifted_out; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__srawi_rc_1 : public Operation
	{
	public:
		Op__spec__srawi_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh;
		uint8_t rc;
		int32_t shifted_out; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__sraw_rc_0 : public Operation
	{
	public:
		Op__spec__sraw_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__sraw_rc_1 : public Operation
	{
	public:
		Op__spec__sraw_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__srw_rc_0 : public Operation
	{
	public:
		Op__spec__srw_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__srw_rc_1 : public Operation
	{
	public:
		Op__spec__srw_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__sld_rc_0 : public Operation
	{
	public:
		Op__spec__sld_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__sld_rc_1 : public Operation
	{
	public:
		Op__spec__sld_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__sradi_rc_0 : public Operation
	{
	public:
		Op__spec__sradi_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t sh0;
		uint8_t rc;
		unsigned sh; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__sradi_rc_1 : public Operation
	{
	public:
		Op__spec__sradi_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t sh1;
		uint8_t sh0;
		uint8_t rc;
		unsigned sh; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__srad_rc_0 : public Operation
	{
	public:
		Op__spec__srad_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__srad_rc_1 : public Operation
	{
	public:
		Op__spec__srad_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__srd_rc_0 : public Operation
	{
	public:
		Op__spec__srd_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__srd_rc_1 : public Operation
	{
	public:
		Op__spec__srd_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__stwu_rs_1_ra_1 : public Operation
	{
	public:
		Op__spec__stwu_rs_1_ra_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__stdu_rs_1_ra_1 : public Operation
	{
	public:
		Op__spec__stdu_rs_1_ra_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		int16_t d;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfc_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__subfc_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfc_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__subfc_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfc_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__subfc_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfc_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__subfc_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfe_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__subfe_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfe_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__subfe_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfe_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__subfe_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfe_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__subfe_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subf_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__subf_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subf_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__subf_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subf_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__subf_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subf_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__subf_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t rb;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfme_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__subfme_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfme_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__subfme_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfme_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__subfme_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfme_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__subfme_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfze_rc_0_oe_0 : public Operation
	{
	public:
		Op__spec__subfze_rc_0_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfze_rc_0_oe_1 : public Operation
	{
	public:
		Op__spec__subfze_rc_0_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfze_rc_1_oe_0 : public Operation
	{
	public:
		Op__spec__subfze_rc_1_oe_0(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__subfze_rc_1_oe_1 : public Operation
	{
	public:
		Op__spec__subfze_rc_1_oe_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t ra;
		uint8_t oe;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__xor_rc_0 : public Operation
	{
	public:
		Op__spec__xor_rc_0(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__xor_rc_1 : public Operation
	{
	public:
		Op__spec__xor_rc_1(CodeType code, uint64_t addr);
		uint8_t rs;
		uint8_t ra;
		uint8_t rb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fabs_rc_0 : public Operation
	{
	public:
		Op__spec__fabs_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fabs_rc_1 : public Operation
	{
	public:
		Op__spec__fabs_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fadd_rc_0 : public Operation
	{
	public:
		Op__spec__fadd_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fadd_rc_1 : public Operation
	{
	public:
		Op__spec__fadd_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fadds_rc_0 : public Operation
	{
	public:
		Op__spec__fadds_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fadds_rc_1 : public Operation
	{
	public:
		Op__spec__fadds_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fctiw_rc_0 : public Operation
	{
	public:
		Op__spec__fctiw_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fctiw_rc_1 : public Operation
	{
	public:
		Op__spec__fctiw_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fctiwz_rc_0 : public Operation
	{
	public:
		Op__spec__fctiwz_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fctiwz_rc_1 : public Operation
	{
	public:
		Op__spec__fctiwz_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fctid_rc_0 : public Operation
	{
	public:
		Op__spec__fctid_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fctid_rc_1 : public Operation
	{
	public:
		Op__spec__fctid_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fctidz_rc_0 : public Operation
	{
	public:
		Op__spec__fctidz_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fctidz_rc_1 : public Operation
	{
	public:
		Op__spec__fctidz_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fcfid_rc_0 : public Operation
	{
	public:
		Op__spec__fcfid_rc_0(CodeType code, uint64_t addr);
		uint8_t frt;
		uint8_t frb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fcfid_rc_1 : public Operation
	{
	public:
		Op__spec__fcfid_rc_1(CodeType code, uint64_t addr);
		uint8_t frt;
		uint8_t frb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fdiv_rc_0 : public Operation
	{
	public:
		Op__spec__fdiv_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fdiv_rc_1 : public Operation
	{
	public:
		Op__spec__fdiv_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fdivs_rc_0 : public Operation
	{
	public:
		Op__spec__fdivs_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fdivs_rc_1 : public Operation
	{
	public:
		Op__spec__fdivs_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmadd_rc_0 : public Operation
	{
	public:
		Op__spec__fmadd_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmadd_rc_1 : public Operation
	{
	public:
		Op__spec__fmadd_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmadds_rc_0 : public Operation
	{
	public:
		Op__spec__fmadds_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmadds_rc_1 : public Operation
	{
	public:
		Op__spec__fmadds_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmr_rc_0 : public Operation
	{
	public:
		Op__spec__fmr_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmr_rc_1 : public Operation
	{
	public:
		Op__spec__fmr_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmsub_rc_0 : public Operation
	{
	public:
		Op__spec__fmsub_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmsub_rc_1 : public Operation
	{
	public:
		Op__spec__fmsub_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmsubs_rc_0 : public Operation
	{
	public:
		Op__spec__fmsubs_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmsubs_rc_1 : public Operation
	{
	public:
		Op__spec__fmsubs_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmul_rc_0 : public Operation
	{
	public:
		Op__spec__fmul_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmul_rc_1 : public Operation
	{
	public:
		Op__spec__fmul_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmuls_rc_0 : public Operation
	{
	public:
		Op__spec__fmuls_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fmuls_rc_1 : public Operation
	{
	public:
		Op__spec__fmuls_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnabs_rc_0 : public Operation
	{
	public:
		Op__spec__fnabs_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnabs_rc_1 : public Operation
	{
	public:
		Op__spec__fnabs_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fneg_rc_0 : public Operation
	{
	public:
		Op__spec__fneg_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fneg_rc_1 : public Operation
	{
	public:
		Op__spec__fneg_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnmadd_rc_0 : public Operation
	{
	public:
		Op__spec__fnmadd_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnmadd_rc_1 : public Operation
	{
	public:
		Op__spec__fnmadd_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnmadds_rc_0 : public Operation
	{
	public:
		Op__spec__fnmadds_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnmadds_rc_1 : public Operation
	{
	public:
		Op__spec__fnmadds_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnmsub_rc_0 : public Operation
	{
	public:
		Op__spec__fnmsub_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnmsub_rc_1 : public Operation
	{
	public:
		Op__spec__fnmsub_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnmsubs_rc_0 : public Operation
	{
	public:
		Op__spec__fnmsubs_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fnmsubs_rc_1 : public Operation
	{
	public:
		Op__spec__fnmsubs_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__frsp_rc_0 : public Operation
	{
	public:
		Op__spec__frsp_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__frsp_rc_1 : public Operation
	{
	public:
		Op__spec__frsp_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fsel_rc_0 : public Operation
	{
	public:
		Op__spec__fsel_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fsel_rc_1 : public Operation
	{
	public:
		Op__spec__fsel_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t fc;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fsub_rc_0 : public Operation
	{
	public:
		Op__spec__fsub_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fsub_rc_1 : public Operation
	{
	public:
		Op__spec__fsub_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fsubs_rc_0 : public Operation
	{
	public:
		Op__spec__fsubs_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__fsubs_rc_1 : public Operation
	{
	public:
		Op__spec__fsubs_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t fa;
		uint8_t fb;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mffs_rc_0 : public Operation
	{
	public:
		Op__spec__mffs_rc_0(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mffs_rc_1 : public Operation
	{
	public:
		Op__spec__mffs_rc_1(CodeType code, uint64_t addr);
		uint8_t fd;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mtfsb0_rc_0 : public Operation
	{
	public:
		Op__spec__mtfsb0_rc_0(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mtfsb0_rc_1 : public Operation
	{
	public:
		Op__spec__mtfsb0_rc_1(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mtfsb1_rc_0 : public Operation
	{
	public:
		Op__spec__mtfsb1_rc_0(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mtfsb1_rc_1 : public Operation
	{
	public:
		Op__spec__mtfsb1_rc_1(CodeType code, uint64_t addr);
		uint8_t bt;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mtfsfi_rc_0 : public Operation
	{
	public:
		Op__spec__mtfsfi_rc_0(CodeType code, uint64_t addr);
		uint8_t bft;
		uint8_t w;
		uint8_t imm;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mtfsfi_rc_1 : public Operation
	{
	public:
		Op__spec__mtfsfi_rc_1(CodeType code, uint64_t addr);
		uint8_t bft;
		uint8_t w;
		uint8_t imm;
		uint8_t rc;
		virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mtfsf_rc_0 : public Operation
	{
	public:
		Op__spec__mtfsf_rc_0(CodeType code, uint64_t addr);
		uint8_t l;
		uint8_t fm;
		uint8_t w;
		uint8_t fb;
		uint8_t rc;
		uint32_t fsmask; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mtfsf_rc_1 : public Operation
	{
	public:
		Op__spec__mtfsf_rc_1(CodeType code, uint64_t addr);
		uint8_t l;
		uint8_t fm;
		uint8_t w;
		uint8_t fb;
		uint8_t rc;
		uint32_t fsmask; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mfspr_spr0_0_spr1_1 : public Operation
	{
	public:
		Op__spec__mfspr_spr0_0_spr1_1(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t spr1;
		uint8_t spr0;
		unsigned n; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mfspr_spr0_0_spr1_8 : public Operation
	{
	public:
		Op__spec__mfspr_spr0_0_spr1_8(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t spr1;
		uint8_t spr0;
		unsigned n; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	class Op__spec__mfspr_spr0_0_spr1_9 : public Operation
	{
	public:
		Op__spec__mfspr_spr0_0_spr1_9(CodeType code, uint64_t addr);
		uint8_t rd;
		uint8_t spr1;
		uint8_t spr0;
		unsigned n; virtual
		bool execute( Arch* cpu );
		virtual
		void disasm( std::ostream& os );
	private:
	};

	bool OpBcctr::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void OpBcctr::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOpBcctr(CodeType code, uint64_t addr)
	{
		return new OpBcctr(code, addr);
	}

	bool OpBc::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void OpBc::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOpBc(CodeType code, uint64_t addr)
	{
		return new OpBc(code, addr);
	}

	bool OpBclr::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void OpBclr::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOpBclr(CodeType code, uint64_t addr)
	{
		return new OpBclr(code, addr);
	}

	bool OpB::execute( Arch* cpu)
	{
		{
			UINT li( li24 );
			ADDRESS target_addr( aa ? li : cpu->GetCIA() + li );
			cpu->Branch(target_addr);
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );
			return true;
	}}
	void OpB::disasm( std::ostream& os)
	{
		{
			os << "b" << (lk ? "l" : "") << (aa ? "a" : "") << " "
			<< "0x" << std::hex << (aa ? li24 : GetAddr() + li24) << std::dec;
	}}

	static Operation *DecodeOpB(CodeType code, uint64_t addr)
	{
		return new OpB(code, addr);
	}

	bool OpCrandc::execute( Arch* cpu)
	{
		{
			// Read the input operands
			CR& cr = cpu->GetCR();
			U32 const mask(0x80000000 >> bt), source(cr);

			// Compute the result
			U32 result = (source & ~mask) | (mask & (((source << ba) & ~(source << bb)) >> bt));

			// Write back the result
			cr = result;

			return true;
	}}
	void OpCrandc::disasm( std::ostream& os)
	{
		{
			os << "crandc " << CRPrint(bt) << ", " << CRPrint(ba) << ", " << CRPrint(bb);
	}}

	static Operation *DecodeOpCrandc(CodeType code, uint64_t addr)
	{
		return new OpCrandc(code, addr);
	}

	bool OpCrand::execute( Arch* cpu)
	{
		{
			// Read the input operands
			CR& cr = cpu->GetCR();
			U32 const mask(0x80000000 >> bt), source(cr);

			// Compute the result
			U32 result = (source & ~mask) | (mask & (((source << ba) & (source << bb)) >> bt));

			// Write back the result
			cr = result;

			return true;
	}}
	void OpCrand::disasm( std::ostream& os)
	{
		{
			os << "crand " << CRPrint(bt) << ", " << CRPrint(ba) << ", " << CRPrint(bb);
	}}

	static Operation *DecodeOpCrand(CodeType code, uint64_t addr)
	{
		return new OpCrand(code, addr);
	}

	bool OpCreqv::execute( Arch* cpu)
	{
		{
			// Read the input operands
			CR& cr = cpu->GetCR();
			U32 const mask(0x80000000 >> bt), source(cr);

			// Compute the result
			U32 result = (source & ~mask) | (mask & ~(((source << ba) ^ (source << bb)) >> bt));

			// Write back the result
			cr = result;

			return true;
	}}
	void OpCreqv::disasm( std::ostream& os)
	{
		{
			os << "creqv " << CRPrint(bt) << ", " << CRPrint(ba) << ", " << CRPrint(bb);
	}}

	static Operation *DecodeOpCreqv(CodeType code, uint64_t addr)
	{
		return new OpCreqv(code, addr);
	}

	bool OpCrnand::execute( Arch* cpu)
	{
		{
			// Read the input operands
			CR& cr = cpu->GetCR();
			U32 const mask(0x80000000 >> bt), source(cr);

			// Compute the result
			U32 result = (source & ~mask) | (mask & ~(((source << ba) & (source << bb)) >> bt));

			// Write back the result
			cr = result;

			return true;
	}}
	void OpCrnand::disasm( std::ostream& os)
	{
		{
			os << "crnand " << CRPrint(bt) << ", " << CRPrint(ba) << ", " << CRPrint(bb);
	}}

	static Operation *DecodeOpCrnand(CodeType code, uint64_t addr)
	{
		return new OpCrnand(code, addr);
	}

	bool OpCrnor::execute( Arch* cpu)
	{
		{
			// Read the input operands
			CR& cr = cpu->GetCR();
			U32 const mask(0x80000000 >> bt), source(cr);

			// Compute the result
			U32 result = (source & ~mask) | (mask & ~(((source << ba) | (source << bb)) >> bt));

			// Write back the result
			cr = result;

			return true;
	}}
	void OpCrnor::disasm( std::ostream& os)
	{
		{
			os << "crnor " << CRPrint(bt) << ", " << CRPrint(ba) << ", " << CRPrint(bb);
	}}

	static Operation *DecodeOpCrnor(CodeType code, uint64_t addr)
	{
		return new OpCrnor(code, addr);
	}

	bool OpCrorc::execute( Arch* cpu)
	{
		{
			// Read the input operands
			CR& cr = cpu->GetCR();
			U32 const mask(0x80000000 >> bt), source(cr);

			// Compute the result
			U32 result = (source & ~mask) | (mask & (((source << ba) | ~(source << bb)) >> bt));

			// Write back the result
			cr = result;

			return true;
	}}
	void OpCrorc::disasm( std::ostream& os)
	{
		{
			os << "crorc " << CRPrint(bt) << ", " << CRPrint(ba) << ", " << CRPrint(bb);
	}}

	static Operation *DecodeOpCrorc(CodeType code, uint64_t addr)
	{
		return new OpCrorc(code, addr);
	}

	bool OpCror::execute( Arch* cpu)
	{
		{
			// Read the input operands
			CR& cr = cpu->GetCR();
			U32 const mask(0x80000000 >> bt), source(cr);

			// Compute the result
			U32 result = (source & ~mask) | (mask & (((source << ba) | (source << bb)) >> bt));

			// Write back the result
			cr = result;

			return true;
	}}
	void OpCror::disasm( std::ostream& os)
	{
		{
			os << "cror " << CRPrint(bt) << ", " << CRPrint(ba) << ", " << CRPrint(bb);
	}}

	static Operation *DecodeOpCror(CodeType code, uint64_t addr)
	{
		return new OpCror(code, addr);
	}

	bool OpCrxor::execute( Arch* cpu)
	{
		{
			// Read the input operands
			CR& cr = cpu->GetCR();
			U32 const mask(0x80000000 >> bt), source(cr);

			// Compute the result
			U32 result = (source & ~mask) | (mask & (((source << ba) ^ (source << bb)) >> bt));

			// Write back the result
			cr = result;

			return true;
	}}
	void OpCrxor::disasm( std::ostream& os)
	{
		{
			os << "crxor " << CRPrint(bt) << ", " << CRPrint(ba) << ", " << CRPrint(bb);
	}}

	static Operation *DecodeOpCrxor(CodeType code, uint64_t addr)
	{
		return new OpCrxor(code, addr);
	}

	bool OpMcrf::execute( Arch* cpu)
	{
		{
			// Read the input operands
			unsigned tsh = 4*bft, ash = 4*bfa;
			CR& cr = cpu->GetCR();
			U32 const mask(0xf0000000 >> tsh), source(cr);

			// Compute the result
			U32 result = (source & ~mask) | (mask & ((source << ash) >> tsh));

			// Write back the result
			cr = result;

			return true;
	}}
	void OpMcrf::disasm( std::ostream& os)
	{
		{
			os << "mcrf " << CRPrint(bft) << ", " << CRPrint(bfa);
	}}

	static Operation *DecodeOpMcrf(CodeType code, uint64_t addr)
	{
		return new OpMcrf(code, addr);
	}

	bool OpAddc::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | UINT( overflow));
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpAddc::disasm( std::ostream& os)
	{
		{
			os << "addc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpAddc(CodeType code, uint64_t addr)
	{
		return new OpAddc(code, addr);
	}

	bool OpAdde::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpAdde::disasm( std::ostream& os)
	{
		{
			os << "adde" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpAdde(CodeType code, uint64_t addr)
	{
		return new OpAdde(code, addr);
	}

	bool OpAddic_::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a( cpu->GetGPR(ra) ), b( simm );

			// Compute the result
			SINT result = a + b;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(a) > ~UINT(b));

			// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
			CR& cr = cpu->GetCR();
			cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
			cr.Set<CR::CR0::LT>(result < SINT(0));
			cr.Set<CR::CR0::GT>(result > SINT(0));
			cr.Set<CR::CR0::EQ>(result == SINT(0));

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpAddic_::disasm( std::ostream& os)
	{
		{
			os << "addic. " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << simm;
	}}

	static Operation *DecodeOpAddic_(CodeType code, uint64_t addr)
	{
		return new OpAddic_(code, addr);
	}

	bool OpAddic::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a( cpu->GetGPR(ra) ), b( simm );

			// Compute the result
			SINT result = a + b;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(a) > ~UINT(b));

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpAddic::disasm( std::ostream& os)
	{
		{
			os << "addic " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << int(simm);
	}}

	static Operation *DecodeOpAddic(CodeType code, uint64_t addr)
	{
		return new OpAddic(code, addr);
	}

	bool OpAddi::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT b = UINT(simm);

			// Compute the result
			UINT result = ra ? cpu->GetGPR(ra) + b : b;

			// Write back the result
			cpu->SetGPR(rd, result);

			return true;
	}}
	void OpAddi::disasm( std::ostream& os)
	{
		{
			if (ra == 0)
			os << "li " << GPRPrint(rd) << ", " << int(simm);
			else
			os << "addi " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << int(simm);
	}}

	static Operation *DecodeOpAddi(CodeType code, uint64_t addr)
	{
		return new OpAddi(code, addr);
	}

	bool OpAdd::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpAdd::disasm( std::ostream& os)
	{
		{
			os << "add" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpAdd(CodeType code, uint64_t addr)
	{
		return new OpAdd(code, addr);
	}

	bool OpAddis::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT b = UINT(simm) << 16;

			// Compute the result
			UINT result = ra ? cpu->GetGPR(ra) + b : b;

			// Write back the result
			cpu->SetGPR(rd, result);

			return true;
	}}
	void OpAddis::disasm( std::ostream& os)
	{
		{
			if(ra == 0)
			os << "lis " << GPRPrint(rd) << ", " << simm;
			else
			os << "addis " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << simm;
	}}

	static Operation *DecodeOpAddis(CodeType code, uint64_t addr)
	{
		return new OpAddis(code, addr);
	}

	bool OpAddme::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpAddme::disasm( std::ostream& os)
	{
		{
			os << "addme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOpAddme(CodeType code, uint64_t addr)
	{
		return new OpAddme(code, addr);
	}

	bool OpAddze::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpAddze::disasm( std::ostream& os)
	{
		{
			os << "addze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOpAddze(CodeType code, uint64_t addr)
	{
		return new OpAddze(code, addr);
	}

	bool OpAndc::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s & ~b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpAndc::disasm( std::ostream& os)
	{
		{
			os << "andc" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpAndc(CodeType code, uint64_t addr)
	{
		return new OpAndc(code, addr);
	}

	bool OpAndi_::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = UINT(uimm);

			// Compute the result
			UINT result = s & b;

			// Write back the result
			cpu->SetGPR(ra, result);

			// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
			CR& cr = cpu->GetCR();
			cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
			cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
			cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
			cr.Set<CR::CR0::EQ>(result == UINT(0));

			return true;
	}}
	void OpAndi_::disasm( std::ostream& os)
	{
		{
			os << "andi. " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << uimm;
	}}

	static Operation *DecodeOpAndi_(CodeType code, uint64_t addr)
	{
		return new OpAndi_(code, addr);
	}

	bool OpAnd::execute( Arch* cpu)
	{
		{
			// read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s & b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpAnd::disasm( std::ostream& os)
	{
		{
			os << "and" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpAnd(CodeType code, uint64_t addr)
	{
		return new OpAnd(code, addr);
	}

	bool OpAndis_::execute( Arch* cpu)
	{
		{
			// read the input operands
			UINT s = cpu->GetGPR(rs), b = UINT(uimm);

			// Compute the result
			UINT result = s & b;

			// Write back the result
			cpu->SetGPR(ra, result);

			// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
			CR& cr = cpu->GetCR();
			cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
			cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
			cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
			cr.Set<CR::CR0::EQ>(result == UINT(0));

			return true;
	}}
	void OpAndis_::disasm( std::ostream& os)
	{
		{
			os << "andis. " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << (uimm >> 16);
	}}

	static Operation *DecodeOpAndis_(CodeType code, uint64_t addr)
	{
		return new OpAndis_(code, addr);
	}

	bool OpCmp::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void OpCmp::disasm( std::ostream& os)
	{
		{
			os << "cmp " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpCmp(CodeType code, uint64_t addr)
	{
		return new OpCmp(code, addr);
	}

	bool OpCmpL::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void OpCmpL::disasm( std::ostream& os)
	{
		{
			os << "cmpd " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpCmpL(CodeType code, uint64_t addr)
	{
		return new OpCmpL(code, addr);
	}

	bool OpCmpi::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(simm);

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void OpCmpi::disasm( std::ostream& os)
	{
		{
			os << "cmpi " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << simm;
	}}

	static Operation *DecodeOpCmpi(CodeType code, uint64_t addr)
	{
		return new OpCmpi(code, addr);
	}

	bool OpCmpiL::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( simm );

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void OpCmpiL::disasm( std::ostream& os)
	{
		{
			os << "cmpdi " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << simm;
	}}

	static Operation *DecodeOpCmpiL(CodeType code, uint64_t addr)
	{
		return new OpCmpiL(code, addr);
	}

	bool OpCmpl::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void OpCmpl::disasm( std::ostream& os)
	{
		{
			os << "cmpl " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpCmpl(CodeType code, uint64_t addr)
	{
		return new OpCmpl(code, addr);
	}

	bool OpCmplL::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void OpCmplL::disasm( std::ostream& os)
	{
		{
			os << "cmpld " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpCmplL(CodeType code, uint64_t addr)
	{
		return new OpCmplL(code, addr);
	}

	bool OpCmpli::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(uimm);

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void OpCmpli::disasm( std::ostream& os)
	{
		{
			os << "cmpli " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << uimm;
	}}

	static Operation *DecodeOpCmpli(CodeType code, uint64_t addr)
	{
		return new OpCmpli(code, addr);
	}

	bool OpCmpliL::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(uimm);

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void OpCmpliL::disasm( std::ostream& os)
	{
		{
			os << "cmpldi " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << uimm;
	}}

	static Operation *DecodeOpCmpliL(CodeType code, uint64_t addr)
	{
		return new OpCmpliL(code, addr);
	}

	bool OpCntlzw::execute( Arch* cpu)
	{
		{
			// read the input operands
			U32 s = U32(cpu->GetGPR(rs));

			// Compute the result
			U32 result = ConditionalMove(s != U32(0), U32(31) - BitScanReverse(s), U32(32));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(false);
				cr.Set<CR::CR0::GT>(result > U32(0));
				cr.Set<CR::CR0::EQ>(result == U32(0));
			}

			return true;
	}}
	void OpCntlzw::disasm( std::ostream& os)
	{
		{
			os << "cntlzw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOpCntlzw(CodeType code, uint64_t addr)
	{
		return new OpCntlzw(code, addr);
	}

	bool OpCntlzd::execute( Arch* cpu)
	{
		{
			// read the input operands
			U64 s = U64(cpu->GetGPR(rs));

			// Compute the result
			U64 result = ConditionalMove(s != U64(0), U64(63) - BitScanReverse(s), U64(64));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpCntlzd::disasm( std::ostream& os)
	{
		{
			os << "cntlzd" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOpCntlzd(CodeType code, uint64_t addr)
	{
		return new OpCntlzd(code, addr);
	}

	bool OpDivw::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S32( 0x80000000) and b == S32( -1)) or b == S32(0)))
			{
				// Compute the result
				res32 = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void OpDivw::disasm( std::ostream& os)
	{
		{
			os << "divw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpDivw(CodeType code, uint64_t addr)
	{
		return new OpDivw(code, addr);
	}

	bool OpDivwu::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U32(0)))
			{
				// Compute the result
				res32 = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void OpDivwu::disasm( std::ostream& os)
	{
		{
			os << "divwu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpDivwu(CodeType code, uint64_t addr)
	{
		return new OpDivwu(code, addr);
	}

	bool OpDivd::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S64(0x8000000000000000ll) and b == S64(-1)) or b == S64(0)))
			{
				// Compute the result
				result = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void OpDivd::disasm( std::ostream& os)
	{
		{
			os << "divd" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpDivd(CodeType code, uint64_t addr)
	{
		return new OpDivd(code, addr);
	}

	bool OpDivdu::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U64(0)))
			{
				// Compute the result
				result = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b ;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpDivdu::disasm( std::ostream& os)
	{
		{
			os << "divdu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpDivdu(CodeType code, uint64_t addr)
	{
		return new OpDivdu(code, addr);
	}

	bool OpEqv::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ~(s ^ b);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpEqv::disasm( std::ostream& os)
	{
		{
			os << "eqv" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpEqv(CodeType code, uint64_t addr)
	{
		return new OpEqv(code, addr);
	}

	bool OpExtsb::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S8 s = S8(cpu->GetGPR(rs));

			// Compute the result
			SINT result = SINT(s);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void OpExtsb::disasm( std::ostream& os)
	{
		{
			os << "extsb" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOpExtsb(CodeType code, uint64_t addr)
	{
		return new OpExtsb(code, addr);
	}

	bool OpExtsh::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S16 s = S16( cpu->GetGPR(rs));

			// Compute the result
			SINT result = SINT(s);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void OpExtsh::disasm( std::ostream& os)
	{
		{
			os << "extsh" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOpExtsh(CodeType code, uint64_t addr)
	{
		return new OpExtsh(code, addr);
	}

	bool OpExtsw::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 s = S32( cpu->GetGPR(rs));

			// Compute the result
			SINT result = SINT(s);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void OpExtsw::disasm( std::ostream& os)
	{
		{
			os << "extsw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOpExtsw(CodeType code, uint64_t addr)
	{
		return new OpExtsw(code, addr);
	}

	bool OpIsel::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT a = ra ? cpu->GetGPR(ra) : UINT(0), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ConditionalMove(BOOL((U32(cpu->GetCR()) << bc) >> 31), a, b);

			// Write back the result
			cpu->SetGPR(rd, result);

			return true;
	}}
	void OpIsel::disasm( std::ostream& os)
	{
		{
			os << "isel " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb) << ", " << unsigned(bc);
	}}

	static Operation *DecodeOpIsel(CodeType code, uint64_t addr)
	{
		return new OpIsel(code, addr);
	}

	bool OpLbz::execute( Arch* cpu)
	{
		{
			// compute the effective address
			UINT disp( d );
			ADDRESS ea( ra ? cpu->GetGPR(ra) + disp : disp );
			// do the memory access
			return cpu->Int8Load(rd, ea);
	}}
	void OpLbz::disasm( std::ostream& os)
	{
		{
			os << "lbz " << GPRPrint(rd) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLbz(CodeType code, uint64_t addr)
	{
		return new OpLbz(code, addr);
	}

	bool OpLbzu::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea( cpu->GetGPR(ra) + UINT(d) );
			// do the memory access
			if(unlikely(not cpu->Int8Load(rd, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLbzu::disasm( std::ostream& os)
	{
		{
			os << "lbzu " << GPRPrint(rd) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLbzu(CodeType code, uint64_t addr)
	{
		return new OpLbzu(code, addr);
	}

	bool OpLbzux::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->Int8Load(rd, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLbzux::disasm( std::ostream& os)
	{
		{
			os << "lbzux " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLbzux(CodeType code, uint64_t addr)
	{
		return new OpLbzux(code, addr);
	}

	bool OpLbzx::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->Int8Load(rd, ea);
	}}
	void OpLbzx::disasm( std::ostream& os)
	{
		{
			os << "lbzx " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLbzx(CodeType code, uint64_t addr)
	{
		return new OpLbzx(code, addr);
	}

	bool OpLha::execute( Arch* cpu)
	{
		{
			// compute the effective address
			UINT disp( d );
			ADDRESS ea(ra ? cpu->GetGPR(ra) + disp : disp);
			// do the memory access
			return cpu->SInt16Load(rd, ea); // 16-bit load/no byte reverse/sign extend
	}}
	void OpLha::disasm( std::ostream& os)
	{
		{
			os << "lha " << GPRPrint(rd) << ',' << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLha(CodeType code, uint64_t addr)
	{
		return new OpLha(code, addr);
	}

	bool OpLhau::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea( cpu->GetGPR(ra) + UINT(d) );
			// do the memory access
			if(unlikely(not cpu->SInt16Load(rd, ea))) return false; // 16-bit load/no byte reverse/sign extend
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLhau::disasm( std::ostream& os)
	{
		{
			os << "lhau " << GPRPrint(rd) << ',' << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLhau(CodeType code, uint64_t addr)
	{
		return new OpLhau(code, addr);
	}

	bool OpLhaux::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->SInt16Load(rd, ea))) return false; // 16-bit load/no byte reverse/sign extend
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLhaux::disasm( std::ostream& os)
	{
		{
			os << "lhaux " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLhaux(CodeType code, uint64_t addr)
	{
		return new OpLhaux(code, addr);
	}

	bool OpLhax::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->SInt16Load(rd, ea); // 16-bit load/no byte reverse/sign extend
	}}
	void OpLhax::disasm( std::ostream& os)
	{
		{
			os << "lhax " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLhax(CodeType code, uint64_t addr)
	{
		return new OpLhax(code, addr);
	}

	bool OpLhz::execute( Arch* cpu)
	{
		{
			// compute the effective address
			UINT disp( d );
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + disp : disp);
			// do the memory access
			return cpu->Int16Load(rd, ea); // 16-bit load/no byte reverse/no sign extend
	}}
	void OpLhz::disasm( std::ostream& os)
	{
		{
			os << "lhz " << GPRPrint(rd) << ',' << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLhz(CodeType code, uint64_t addr)
	{
		return new OpLhz(code, addr);
	}

	bool OpLhzu::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea( cpu->GetGPR(ra) + UINT(d) );
			// do the memory access
			if(unlikely(not cpu->Int16Load(rd, ea))) return false; // 16-bit load/no byte reverse/no sign extend
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLhzu::disasm( std::ostream& os)
	{
		{
			os << "lhzu " << GPRPrint(rd) << ',' << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLhzu(CodeType code, uint64_t addr)
	{
		return new OpLhzu(code, addr);
	}

	bool OpLhzux::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->Int16Load(rd, ea))) return false; // 16-bit load/no byte reverse/no sign extend
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLhzux::disasm( std::ostream& os)
	{
		{
			os << "lhzux " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLhzux(CodeType code, uint64_t addr)
	{
		return new OpLhzux(code, addr);
	}

	bool OpLhzx::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->Int16Load(rd, ea); // 16-bit load/no byte reverse/no sign extend
	}}
	void OpLhzx::disasm( std::ostream& os)
	{
		{
			os << "lhzx " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLhzx(CodeType code, uint64_t addr)
	{
		return new OpLhzx(code, addr);
	}

	bool OpLwz::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS disp( d );
			ADDRESS ea( ra ? cpu->GetGPR(ra) + disp : disp );
			// do the memory access
			return cpu->Int32Load(rd, ea); // 32-bit load/no byte reverse/no sign extend
	}}
	void OpLwz::disasm( std::ostream& os)
	{
		{
			os << "lwz " << GPRPrint(rd) << ',' << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLwz(CodeType code, uint64_t addr)
	{
		return new OpLwz(code, addr);
	}

	bool OpLwzu::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea( cpu->GetGPR(ra) + UINT(d) );
			// do the memory access
			if(unlikely(not cpu->Int32Load(rd, ea))) return false; // 32-bit load/no byte reverse/no sign extend
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLwzu::disasm( std::ostream& os)
	{
		{
			os << "lwzu " << GPRPrint(rd) << ',' << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLwzu(CodeType code, uint64_t addr)
	{
		return new OpLwzu(code, addr);
	}

	bool OpLwzux::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->Int32Load(rd, ea))) return false; // 32-bit load/no byte reverse/no sign extend
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLwzux::disasm( std::ostream& os)
	{
		{
			os << "lwzux " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLwzux(CodeType code, uint64_t addr)
	{
		return new OpLwzux(code, addr);
	}

	bool OpLwzx::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->Int32Load(rd, ea); // 32-bit load/no byte reverse/no sign extend
	}}
	void OpLwzx::disasm( std::ostream& os)
	{
		{
			os << "lwzx " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLwzx(CodeType code, uint64_t addr)
	{
		return new OpLwzx(code, addr);
	}

	bool OpLwa::execute( Arch* cpu)
	{
		{
			// compute the effective address
			UINT disp( d );
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + disp : disp);
			// do the memory access
			return cpu->SInt32Load(rd, ea); // 32-bit load/no byte reverse/no sign extend
	}}
	void OpLwa::disasm( std::ostream& os)
	{
		{
			os << "lwa " << GPRPrint(rd) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLwa(CodeType code, uint64_t addr)
	{
		return new OpLwa(code, addr);
	}

	bool OpLwaux::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->SInt32Load(rd, ea))) return false; // 32-bit load/no byte reverse/no sign extend
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLwaux::disasm( std::ostream& os)
	{
		{
			os << "lwaux " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLwaux(CodeType code, uint64_t addr)
	{
		return new OpLwaux(code, addr);
	}

	bool OpLwax::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->SInt32Load(rd, ea); // 32-bit load/no byte reverse/no sign extend
	}}
	void OpLwax::disasm( std::ostream& os)
	{
		{
			os << "lwax " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLwax(CodeType code, uint64_t addr)
	{
		return new OpLwax(code, addr);
	}

	bool OpLd::execute( Arch* cpu)
	{
		{
			// compute the effective address
			UINT disp( d );
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + disp : disp);
			// do the memory access
			return cpu->Int64Load(rd, ea); // 64-bit load/no byte reverse/no sign extend
	}}
	void OpLd::disasm( std::ostream& os)
	{
		{
			os << "ld " << GPRPrint(rd) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLd(CodeType code, uint64_t addr)
	{
		return new OpLd(code, addr);
	}

	bool OpLdx::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->Int64Load(rd, ea); // 64-bit load/no byte reverse/no sign extend
	}}
	void OpLdx::disasm( std::ostream& os)
	{
		{
			os << "ldx " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLdx(CodeType code, uint64_t addr)
	{
		return new OpLdx(code, addr);
	}

	bool OpLdu::execute( Arch* cpu)
	{
		{
			if(unlikely(ra == 0 || ra == rd))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + UINT(SINT(d)));
			// do the memory access
			if(unlikely(not cpu->Int64Load(rd, ea))) return false; // 64-bit load/no byte reverse/no sign extend
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLdu::disasm( std::ostream& os)
	{
		{
			os << "ldu " << GPRPrint(rd) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLdu(CodeType code, uint64_t addr)
	{
		return new OpLdu(code, addr);
	}

	bool OpLdux::execute( Arch* cpu)
	{
		{
			if (unlikely((ra == 0) or (ra == rd)))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->Int64Load(rd, ea))) return false; // 64-bit load/no byte reverse/no sign extend
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLdux::disasm( std::ostream& os)
	{
		{
			os << "ldux " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLdux(CodeType code, uint64_t addr)
	{
		return new OpLdux(code, addr);
	}

	bool OpMcrxr::execute( Arch* cpu)
	{
		{
			XER& xer = cpu->GetXER();

			// Generate CR[crfD]: CR[crfD]=XER[0-3]
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(xer.Get<XER::_0_3>()); break;
				case 1: cr.Set<CR::CR1>(xer.Get<XER::_0_3>()); break;
				case 2: cr.Set<CR::CR2>(xer.Get<XER::_0_3>()); break;
				case 3: cr.Set<CR::CR3>(xer.Get<XER::_0_3>()); break;
				case 4: cr.Set<CR::CR4>(xer.Get<XER::_0_3>()); break;
				case 5: cr.Set<CR::CR5>(xer.Get<XER::_0_3>()); break;
				case 6: cr.Set<CR::CR6>(xer.Get<XER::_0_3>()); break;
				case 7: cr.Set<CR::CR7>(xer.Get<XER::_0_3>()); break;
			}
			// Reset XER[0-3]
			xer.Set<XER::_0_3>(0);

			return true;
	}}
	void OpMcrxr::disasm( std::ostream& os)
	{
		{
			os << "mcrxr " << CRPrint(crfD);
	}}

	static Operation *DecodeOpMcrxr(CodeType code, uint64_t addr)
	{
		return new OpMcrxr(code, addr);
	}

	bool OpMfcr::execute( Arch* cpu)
	{
		{
			// Move CR to destination GPR
			cpu->SetGPR(rd, UINT(U32(cpu->GetCR())));

			return true;
	}}
	void OpMfcr::disasm( std::ostream& os)
	{
		{
			os << "mfcr " << GPRPrint(rd);
	}}

	static Operation *DecodeOpMfcr(CodeType code, uint64_t addr)
	{
		return new OpMfcr(code, addr);
	}

	bool OpMtcrf::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 s( cpu->GetGPR(rs) ), mask(crmask);

			// Apply the bit mask
			CR& cr = cpu->GetCR();
			cr = (U32(cr) & ~mask) | (s & mask);

			return true;
	}}
	void OpMtcrf::disasm( std::ostream& os)
	{
		{
			if(crm == 0xff)
			os << "mtcr " << GPRPrint(rs);
			else
			os << "mtcrf " << unsigned(crm) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOpMtcrf(CodeType code, uint64_t addr)
	{
		return new OpMtcrf(code, addr);
	}

	bool OpMulli::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(simm);

			// Compute the result
			S64 result = a * b;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpMulli::disasm( std::ostream& os)
	{
		{
			os << "mulli " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << simm;
	}}

	static Operation *DecodeOpMulli(CodeType code, uint64_t addr)
	{
		return new OpMulli(code, addr);
	}

	bool OpMulhw::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(S32(cpu->GetGPR(ra))), b = S64(S32(cpu->GetGPR(rb)));

			// Compute the result
			S32 res32( a*b >> 32 );

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void OpMulhw::disasm( std::ostream& os)
	{
		{
			os << "mulhw" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpMulhw(CodeType code, uint64_t addr)
	{
		return new OpMulhw(code, addr);
	}

	bool OpMulhwu::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(U32(cpu->GetGPR(ra))), b = U64(U32(cpu->GetGPR(rb)));

			// Compute the result
			U32 res32( a*b >> 32 );

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void OpMulhwu::disasm( std::ostream& os)
	{
		{
			os << "mulhwu" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpMulhwu(CodeType code, uint64_t addr)
	{
		return new OpMulhwu(code, addr);
	}

	bool OpMullw::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(S32(cpu->GetGPR(ra))), b = S64(S32(cpu->GetGPR(rb)));

			// Compute the result
			S64 result64 = a*b;
			SINT result( result64 );

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 64-bits product cannot be
				* represented as a signed 32-bits result. */
				UINT overflow = UINT(result64 != S64(S32(result64)));
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void OpMullw::disasm( std::ostream& os)
	{
		{
			os << "mullw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpMullw(CodeType code, uint64_t addr)
	{
		return new OpMullw(code, addr);
	}

	bool OpMulhd::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			S64 result = SignedMultiplyHigh(a, b);

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void OpMulhd::disasm( std::ostream& os)
	{
		{
			os << "mulhd" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpMulhd(CodeType code, uint64_t addr)
	{
		return new OpMulhd(code, addr);
	}

	bool OpMulhdu::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			U64 result = UnsignedMultiplyHigh(a, b);

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpMulhdu::disasm( std::ostream& os)
	{
		{
			os << "mulhdu" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpMulhdu(CodeType code, uint64_t addr)
	{
		return new OpMulhdu(code, addr);
	}

	bool OpMulld::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			S64 result = a*b;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 128-bits product cannot be
				* represented as a signed 64-bits result.
				*/
				S64 high( SignedMultiplyHigh(a, b) );
				UINT overflow = UINT((result >> 63) != high);
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void OpMulld::disasm( std::ostream& os)
	{
		{
			os << "mulld" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpMulld(CodeType code, uint64_t addr)
	{
		return new OpMulld(code, addr);
	}

	bool OpNand::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs);
			UINT b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ~(s & b);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpNand::disasm( std::ostream& os)
	{
		{
			os << "nand" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpNand(CodeType code, uint64_t addr)
	{
		return new OpNand(code, addr);
	}

	bool OpNeg::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra));

			// Compute the result
			SINT result = -a; // 2's complement of a: (~a) + 1;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(oe))
			{
				XER& xer = cpu->GetXER();
				/* Overflow occur with the most negative number */
				SINT const mnn = SINT(~(UINT(-1) >> 1));
				if(unlikely(a == mnn))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(1);
					xer.Set<XER::SO>(1);
				}
				else
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(0);
				}
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(UINT(result) == UINT(0));
			}

			return true;
	}}
	void OpNeg::disasm( std::ostream& os)
	{
		{
			os << "neg" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOpNeg(CodeType code, uint64_t addr)
	{
		return new OpNeg(code, addr);
	}

	bool OpNor::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ~(s | b);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT( result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT( result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpNor::disasm( std::ostream& os)
	{
		{
			if(rs == rb)
			os << "not" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
			else
			os << "nor" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpNor(CodeType code, uint64_t addr)
	{
		return new OpNor(code, addr);
	}

	bool OpOrc::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s | ~b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpOrc::disasm( std::ostream& os)
	{
		{
			os << "orc" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpOrc(CodeType code, uint64_t addr)
	{
		return new OpOrc(code, addr);
	}

	bool OpOri::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = UINT(uimm);

			// Compute the result
			UINT result = s | b;

			// Write back the result
			cpu->SetGPR(ra, result);

			return true;
	}}
	void OpOri::disasm( std::ostream& os)
	{
		{
			if(rs == 0 and ra == 0 and uimm == 0)
			os << "nop";
			else
			os << "ori " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << uimm;
	}}

	static Operation *DecodeOpOri(CodeType code, uint64_t addr)
	{
		return new OpOri(code, addr);
	}

	bool OpOr::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s | b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpOr::disasm( std::ostream& os)
	{
		{
			if(rs == rb)
			os << "mr" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
			else
			os << "or" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpOr(CodeType code, uint64_t addr)
	{
		return new OpOr(code, addr);
	}

	bool OpOris::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = UINT(uimm);

			// Compute the result
			UINT result = s | b;

			// Write back the result
			cpu->SetGPR(ra, result);

			return true;
	}}
	void OpOris::disasm( std::ostream& os)
	{
		{
			os << "oris " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << (uimm >> 16);
	}}

	static Operation *DecodeOpOris(CodeType code, uint64_t addr)
	{
		return new OpOris(code, addr);
	}

	bool OpRlwimi::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s( cpu->GetGPR(rs) );
			UINT const m( Mask64(mb+32, me+32) ), a( cpu->GetGPR(ra) );

			// Compute the result
			UINT result = (RotL32(s, U8(sh)) & m) | (a & ~m);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpRlwimi::disasm( std::ostream& os)
	{
		{
			os << "rlwimi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh) << ", " << unsigned(mb) << ", " << unsigned(me);
	}}

	static Operation *DecodeOpRlwimi(CodeType code, uint64_t addr)
	{
		return new OpRlwimi(code, addr);
	}

	bool OpRlwinm::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s( cpu->GetGPR(rs) );
			UINT const m( Mask64(mb+32, me+32) );

			// Compute the result
			UINT result = RotL32(s, U8(sh)) & m;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpRlwinm::disasm( std::ostream& os)
	{
		{
			os << "rlwinm" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh) << ", " << unsigned(mb) << ", " << unsigned(me);
	}}

	static Operation *DecodeOpRlwinm(CodeType code, uint64_t addr)
	{
		return new OpRlwinm(code, addr);
	}

	bool OpRlwnm::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s( cpu->GetGPR(rs) );
			U8 n( cpu->GetGPR(rb) & UINT(0x1f) );
			UINT const m( Mask64(mb+32, me+32) );

			// Compute the result
			UINT result = RotL32(s, n) & m;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpRlwnm::disasm( std::ostream& os)
	{
		{
			os << "rlwnm" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb) << ", " << unsigned(mb) << ", " << unsigned(me);
	}}

	static Operation *DecodeOpRlwnm(CodeType code, uint64_t addr)
	{
		return new OpRlwnm(code, addr);
	}

	bool OpRldicl::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64(uint64_t(-1) >> mb);

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpRldicl::disasm( std::ostream& os)
	{
		{
			os << "rldicl" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << int(n) << ',' << int(mb);
	}}

	static Operation *DecodeOpRldicl(CodeType code, uint64_t addr)
	{
		return new OpRldicl(code, addr);
	}

	bool OpRldicr::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64(uint64_t(-1) << (me ^ 63));

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpRldicr::disasm( std::ostream& os)
	{
		{
			os << "rldicr" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << int(n) << ',' << int(me);
	}}

	static Operation *DecodeOpRldicr(CodeType code, uint64_t addr)
	{
		return new OpRldicr(code, addr);
	}

	bool OpRldic::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64( Mask64(mb, n^63) );

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpRldic::disasm( std::ostream& os)
	{
		{
			os << "rldic" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << int(n) << ',' << int(mb);
	}}

	static Operation *DecodeOpRldic(CodeType code, uint64_t addr)
	{
		return new OpRldic(code, addr);
	}

	bool OpRldcl::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );
			U8  n( cpu->GetGPR(rb) & U64(0x3f) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64(uint64_t(-1) >> mb);

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpRldcl::disasm( std::ostream& os)
	{
		{
			os << "rldcl" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << GPRPrint(rb) << ',' << int(mb);
	}}

	static Operation *DecodeOpRldcl(CodeType code, uint64_t addr)
	{
		return new OpRldcl(code, addr);
	}

	bool OpRldcr::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );
			U8  n( cpu->GetGPR(rb) & UINT(0x3f) );

			// Compute the result
			U64 result( RotateLeft(s, n) & U64(uint64_t(-1) << (me^63)) );

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpRldcr::disasm( std::ostream& os)
	{
		{
			os << "rldcr" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << GPRPrint(rb) << ',' << int(me);
	}}

	static Operation *DecodeOpRldcr(CodeType code, uint64_t addr)
	{
		return new OpRldcr(code, addr);
	}

	bool OpRldimi::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );
			U64 const m( Mask64(mb,sh^63) ),  a( cpu->GetGPR(ra) );

			// Compute the result
			U64 result( (RotateLeft(s, sh) & m) | (a & ~m) );

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpRldimi::disasm( std::ostream& os)
	{
		{
			os << "rldimi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh) << ", " << unsigned(mb);
	}}

	static Operation *DecodeOpRldimi(CodeType code, uint64_t addr)
	{
		return new OpRldimi(code, addr);
	}

	bool OpSlw::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 s = U32(cpu->GetGPR(rs));
			U8 b = U8(cpu->GetGPR(rb)) & U8(0x3f);

			// Compute the result
			U32 result = ConditionalMove(b > U8(0x1f), U32(0), (s << b));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result)  < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result)  > SINT(0));
				cr.Set<CR::CR0::EQ>(SINT(result) == SINT(0));
			}

			return true;
	}}
	void OpSlw::disasm( std::ostream& os)
	{
		{
			os << "slw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSlw(CodeType code, uint64_t addr)
	{
		return new OpSlw(code, addr);
	}

	bool OpSrawi::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 s = S32(  cpu->GetGPR(rs) );

			// Compute the result
			S32 result = s >> sh;

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S32(0)) and ((s & S32(shifted_out)) != S32(0)));
			//xer.Set<XER::CA>((s < S32(0)) and (s != (result << sh)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S32(0));
				cr.Set<CR::CR0::GT>(result > S32(0));
				cr.Set<CR::CR0::EQ>(result == S32(0));
			}

			return true;
	}}
	void OpSrawi::disasm( std::ostream& os)
	{
		{
			os << "srawi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh);
	}}

	static Operation *DecodeOpSrawi(CodeType code, uint64_t addr)
	{
		return new OpSrawi(code, addr);
	}

	bool OpSraw::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 s = S32(cpu->GetGPR(rs));
			U8 b = U8(cpu->GetGPR(rb)) & U8(0x3f);

			// Compute the result
			S32 result, shifted_out;
			if (unlikely(b > U8(0x1f)))
			{
				result = s >> 31;
				shifted_out = S32(-1);
			}
			else
			{
				result = s >> b;
				shifted_out = ((S32(1) << b) - S32( 1));
			}

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S32(0)) and ((s & shifted_out) != S32(0)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S32(0));
				cr.Set<CR::CR0::GT>(result > S32(0));
				cr.Set<CR::CR0::EQ>(result == S32(0));
			}

			return true;
	}}
	void OpSraw::disasm( std::ostream& os)
	{
		{
			os << "sraw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSraw(CodeType code, uint64_t addr)
	{
		return new OpSraw(code, addr);
	}

	bool OpSrw::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 s = U32(cpu->GetGPR(rs));
			U8  b = U8(cpu->GetGPR(rb)) & U8(0x3f);

			// Compute the result
			U32 result = ConditionalMove(b > U8(0x1f), U32(0), (s >> b));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result)  < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result)  > SINT(0));
				cr.Set<CR::CR0::EQ>(SINT(result) == SINT(0));
			}

			return true;
	}}
	void OpSrw::disasm( std::ostream& os)
	{
		{
			os << "srw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSrw(CodeType code, uint64_t addr)
	{
		return new OpSrw(code, addr);
	}

	bool OpSld::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s = U64(cpu->GetGPR(rs));
			U8 b = U8(cpu->GetGPR(rb)) & U8(0x7f);

			// Compute the result
			U64 result = unlikely(b > U8(0x3f)) ? U64(0) : (s << b);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpSld::disasm( std::ostream& os)
	{
		{
			os << "sld" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSld(CodeType code, uint64_t addr)
	{
		return new OpSld(code, addr);
	}

	bool OpSradi::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 s = S64( cpu->GetGPR(rs) );

			// Compute the result
			S64 result = s >> sh, shifted_out( (int64_t(1) << sh) - 1 );

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S64(0)) and ((s & shifted_out) != S64(0)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void OpSradi::disasm( std::ostream& os)
	{
		{
			os << "sradi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh);
	}}

	static Operation *DecodeOpSradi(CodeType code, uint64_t addr)
	{
		return new OpSradi(code, addr);
	}

	bool OpSrad::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 s = S64(cpu->GetGPR(rs));
			U8  b = U8(cpu->GetGPR(rb)) & U8(0x7f);

			// Compute the result
			S64 result, shifted_out;
			if (unlikely(b > U8(0x3f)))
			{
				result = s >> 63;
				shifted_out = S64(-1);
			}
			else
			{
				result = s >> b;
				shifted_out = ((S64(1) << b) - S64( 1));
			}

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S64(0)) and ((s & shifted_out) != S64(0)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void OpSrad::disasm( std::ostream& os)
	{
		{
			os << "srad" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSrad(CodeType code, uint64_t addr)
	{
		return new OpSrad(code, addr);
	}

	bool OpSrd::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s = U64(cpu->GetGPR(rs));
			U8  b = U8(cpu->GetGPR(rb)) & U8(0x7f);

			// Compute the result
			U64 result = unlikely(b > U8(0x3f)) ? U64(0) : (s >> b);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void OpSrd::disasm( std::ostream& os)
	{
		{
			os << "srd" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSrd(CodeType code, uint64_t addr)
	{
		return new OpSrd(code, addr);
	}

	bool OpStb::execute( Arch* cpu)
	{
		{
			// compute the effective address
			UINT disp( d );
			ADDRESS ea( ra ? cpu->GetGPR(ra) + disp : disp );

			// do the memory access
			return cpu->Int8Store(rs, ea);
	}}
	void OpStb::disasm( std::ostream& os)
	{
		{
			os << "stb " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStb(CodeType code, uint64_t addr)
	{
		return new OpStb(code, addr);
	}

	bool OpStbu::execute( Arch* cpu)
	{
		{
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea( cpu->GetGPR(ra) + UINT(d) );
			// do the memory access
			if(unlikely(not cpu->Int8Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStbu::disasm( std::ostream& os)
	{
		{
			os << "stbu " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStbu(CodeType code, uint64_t addr)
	{
		return new OpStbu(code, addr);
	}

	bool OpStbux::execute( Arch* cpu)
	{
		{
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->Int8Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStbux::disasm( std::ostream& os)
	{
		{
			os << "stbux " << GPRPrint(rs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStbux(CodeType code, uint64_t addr)
	{
		return new OpStbux(code, addr);
	}

	bool OpStbx::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->Int8Store(rs, ea);
	}}
	void OpStbx::disasm( std::ostream& os)
	{
		{
			os << "stbx " << GPRPrint(rs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStbx(CodeType code, uint64_t addr)
	{
		return new OpStbx(code, addr);
	}

	bool OpSth::execute( Arch* cpu)
	{
		{
			// compute the effective address
			UINT disp( d );
			ADDRESS ea( ra ? cpu->GetGPR(ra) + disp : disp );
			// do the memory access
			return cpu->Int16Store(rs, ea);
	}}
	void OpSth::disasm( std::ostream& os)
	{
		{
			os << "sth " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpSth(CodeType code, uint64_t addr)
	{
		return new OpSth(code, addr);
	}

	bool OpSthu::execute( Arch* cpu)
	{
		{
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea( cpu->GetGPR(ra) + UINT(d) );
			// do the memory access
			if(unlikely(not cpu->Int16Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpSthu::disasm( std::ostream& os)
	{
		{
			os << "sthu " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpSthu(CodeType code, uint64_t addr)
	{
		return new OpSthu(code, addr);
	}

	bool OpSthux::execute( Arch* cpu)
	{
		{
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->Int16Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpSthux::disasm( std::ostream& os)
	{
		{
			os << "sthux " << GPRPrint(rs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSthux(CodeType code, uint64_t addr)
	{
		return new OpSthux(code, addr);
	}

	bool OpSthx::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->Int16Store(rs, ea);
	}}
	void OpSthx::disasm( std::ostream& os)
	{
		{
			os << "sthx " << GPRPrint(rs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSthx(CodeType code, uint64_t addr)
	{
		return new OpSthx(code, addr);
	}

	bool OpStw::execute( Arch* cpu)
	{
		{
			// compute the effective address
			UINT disp( d );
			ADDRESS ea( ra ? cpu->GetGPR(ra) + disp : disp );
			// do the memory access
			return cpu->Int32Store(rs, ea);
	}}
	void OpStw::disasm( std::ostream& os)
	{
		{
			os << "stw " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStw(CodeType code, uint64_t addr)
	{
		return new OpStw(code, addr);
	}

	bool OpStwu::execute( Arch* cpu)
	{
		{
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea( cpu->GetGPR(ra) + UINT(d) );
			// do the memory access
			if(unlikely(not cpu->Int32Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStwu::disasm( std::ostream& os)
	{
		{
			os << "stwu " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStwu(CodeType code, uint64_t addr)
	{
		return new OpStwu(code, addr);
	}

	bool OpStwux::execute( Arch* cpu)
	{
		{
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->Int32Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStwux::disasm( std::ostream& os)
	{
		{
			os << "stwux " << GPRPrint(rs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStwux(CodeType code, uint64_t addr)
	{
		return new OpStwux(code, addr);
	}

	bool OpStwx::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->Int32Store(rs, ea);
	}}
	void OpStwx::disasm( std::ostream& os)
	{
		{
			os << "stwx " << GPRPrint(rs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStwx(CodeType code, uint64_t addr)
	{
		return new OpStwx(code, addr);
	}

	bool OpStd::execute( Arch* cpu)
	{
		{
			// compute the effective address
			UINT disp( d );
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + disp : disp);
			// do the memory access
			return cpu->Int64Store(rs, ea);
	}}
	void OpStd::disasm( std::ostream& os)
	{
		{
			os << "std " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStd(CodeType code, uint64_t addr)
	{
		return new OpStd(code, addr);
	}

	bool OpStdu::execute( Arch* cpu)
	{
		{
			if (unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + UINT(SINT(d)));
			// do the memory access
			if (unlikely(not cpu->Int64Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStdu::disasm( std::ostream& os)
	{
		{
			os << "stdu " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStdu(CodeType code, uint64_t addr)
	{
		return new OpStdu(code, addr);
	}

	bool OpStdux::execute( Arch* cpu)
	{
		{
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));
			// do the memory access
			if(unlikely(not cpu->Int64Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStdux::disasm( std::ostream& os)
	{
		{
			os << "stdux " << GPRPrint(rs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStdux(CodeType code, uint64_t addr)
	{
		return new OpStdux(code, addr);
	}

	bool OpStdx::execute( Arch* cpu)
	{
		{
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));
			// do the memory access
			return cpu->Int64Store(rs, ea);
	}}
	void OpStdx::disasm( std::ostream& os)
	{
		{
			os << "stdx " << GPRPrint(rs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStdx(CodeType code, uint64_t addr)
	{
		return new OpStdx(code, addr);
	}

	bool OpSubfc::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(b) >= UINT(a));

			if (unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpSubfc::disasm( std::ostream& os)
	{
		{
			os << "subfc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSubfc(CodeType code, uint64_t addr)
	{
		return new OpSubfc(code, addr);
	}

	bool OpSubfe::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			BOOL borrow = not BOOL(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(ConditionalMove(borrow, UINT(b) > UINT(a), UINT(b) >= UINT(a)));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT(ConditionalMove(borrow, b <= a, b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpSubfe::disasm( std::ostream& os)
	{
		{
			os << "subfe" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSubfe(CodeType code, uint64_t addr)
	{
		return new OpSubfe(code, addr);
	}

	bool OpSubfic::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a( cpu->GetGPR(ra) ), b( simm );

			// Compute the result
			SINT result = b - a;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(b) >= UINT(a));

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpSubfic::disasm( std::ostream& os)
	{
		{
			os << "subfic " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << simm;
	}}

	static Operation *DecodeOpSubfic(CodeType code, uint64_t addr)
	{
		return new OpSubfic(code, addr);
	}

	bool OpSubf::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpSubf::disasm( std::ostream& os)
	{
		{
			os << "subf" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpSubf(CodeType code, uint64_t addr)
	{
		return new OpSubf(code, addr);
	}

	bool OpSubfme::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpSubfme::disasm( std::ostream& os)
	{
		{
			os << "subfme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOpSubfme(CodeType code, uint64_t addr)
	{
		return new OpSubfme(code, addr);
	}

	bool OpSubfze::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void OpSubfze::disasm( std::ostream& os)
	{
		{
			os << "subfze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOpSubfze(CodeType code, uint64_t addr)
	{
		return new OpSubfze(code, addr);
	}

	bool OpXori::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = UINT(uimm);

			// Compute the result
			UINT result = s ^ b;

			// Write back the result
			cpu->SetGPR(ra, result);

			return true;
	}}
	void OpXori::disasm( std::ostream& os)
	{
		{
			os << "xori " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << uimm;
	}}

	static Operation *DecodeOpXori(CodeType code, uint64_t addr)
	{
		return new OpXori(code, addr);
	}

	bool OpXor::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s ^ b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT( result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT( result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void OpXor::disasm( std::ostream& os)
	{
		{
			os << "xor" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpXor(CodeType code, uint64_t addr)
	{
		return new OpXor(code, addr);
	}

	bool OpXoris::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = UINT(uimm);

			// Compute the result
			UINT result = s ^ b;

			// Write back the result
			cpu->SetGPR(ra, result);

			return true;
	}}
	void OpXoris::disasm( std::ostream& os)
	{
		{
			os << "xoris " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << (uimm >> 16);
	}}

	static Operation *DecodeOpXoris(CodeType code, uint64_t addr)
	{
		return new OpXoris(code, addr);
	}

	bool OpFabs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not BOOL(cpu->GetMSR().Get<CPU::MSR::FP>())))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			SoftDouble result( cpu->GetFPR(fb) );

			// Compute the result
			result.setPositive();

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFabs::disasm( std::ostream& os)
	{
		{
			os << "fabs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFabs(CodeType code, uint64_t addr)
	{
		return new OpFabs(code, addr);
	}

	bool OpFadd::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result = cpu->GetFPR(fa);
			const SoftDouble& b = cpu->GetFPR(fb);

			// Compute the result
			result.plusAssign(b, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFadd::disasm( std::ostream& os)
	{
		{
			os << "fadd" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFadd(CodeType code, uint64_t addr)
	{
		return new OpFadd(code, addr);
	}

	bool OpFadds::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& b(cpu->GetFPR(fb));

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.plusAssign(b, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFadds::disasm( std::ostream& os)
	{
		{
			os << "fadds" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFadds(CodeType code, uint64_t addr)
	{
		return new OpFadds(code, addr);
	}

	bool OpFcmpo::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble const& a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);

			// Do the floating point comparison
			U8 cmp = FPCompare(a, b);

			// Generate FPCC
			fpscr.Set<FPSCR::FPCC>(cmp);

			// Generate VXSNAN and VXVC
			if (unlikely(a.isQNaN() or b.isQNaN()))
			{
				if (unlikely(a.isSNaN() or b.isSNaN()))
				{
					fpscr.SetInvalid(FPSCR::VXSNAN());
					if (not cpu->CheckFloatingPointException())
					return false;
				}
				fpscr.SetException(FPSCR::VXVC());
			}

			if (not cpu->CheckFloatingPointException())
			return false;

			// CR[crfD] <- c
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(cmp); break;
				case 1: cr.Set<CR::CR1>(cmp); break;
				case 2: cr.Set<CR::CR2>(cmp); break;
				case 3: cr.Set<CR::CR3>(cmp); break;
				case 4: cr.Set<CR::CR4>(cmp); break;
				case 5: cr.Set<CR::CR5>(cmp); break;
				case 6: cr.Set<CR::CR6>(cmp); break;
				case 7: cr.Set<CR::CR7>(cmp); break;
			}

			return true;
	}}
	void OpFcmpo::disasm( std::ostream& os)
	{
		{
			os << "fcmpo " << CRPrint(crfD) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFcmpo(CodeType code, uint64_t addr)
	{
		return new OpFcmpo(code, addr);
	}

	bool OpFcmpu::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble const& a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);

			// Do the floating point comparison
			U8 cmp = FPCompare(a, b);

			// Generate FPCC
			fpscr.Set<FPSCR::FPCC>(cmp);

			// Generate VXSNAN
			if (unlikely(a.isSNaN() or b.isSNaN()))
			{
				fpscr.SetInvalid(FPSCR::VXSNAN());
			}

			if (not cpu->CheckFloatingPointException())
			return false;

			// CR[crfD] <- c
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(cmp); break;
				case 1: cr.Set<CR::CR1>(cmp); break;
				case 2: cr.Set<CR::CR2>(cmp); break;
				case 3: cr.Set<CR::CR3>(cmp); break;
				case 4: cr.Set<CR::CR4>(cmp); break;
				case 5: cr.Set<CR::CR5>(cmp); break;
				case 6: cr.Set<CR::CR6>(cmp); break;
				case 7: cr.Set<CR::CR7>(cmp); break;
			}

			return true;
	}}
	void OpFcmpu::disasm( std::ostream& os)
	{
		{
			os << "fcmpu " << CRPrint(crfD) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFcmpu(CodeType code, uint64_t addr)
	{
		return new OpFcmpu(code, addr);
	}

	bool OpFctiw::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			S32 res32 = b.queryS32( flags );

			U64 undef_high = (U64(0xfff80000) | U64(res32 == S32(0) and b.isNegative())) << 32;

			SoftDouble result(SoftDouble::FromRawBits, undef_high | U64(U32(res32)));

			// Generate VXSNAN, VXCVI, FR, FI, XX, FX, VX, FEX
			if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = fpscr;
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXCVI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, b, flags);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFctiw::disasm( std::ostream& os)
	{
		{
			os << "fctiw" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFctiw(CodeType code, uint64_t addr)
	{
		return new OpFctiw(code, addr);
	}

	bool OpFctiwz::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			Flags flags( Flags::RoundingMode(1) ); // ZeroRounding
			S32 res32 = b.queryS32( flags );

			U64 undef_high = (U64(0xfff80000) | U64(res32 == S32(0) and b.isNegative())) << 32;

			SoftDouble result(SoftDouble::FromRawBits, undef_high | U64(U32(res32)));

			// Generate VXSNAN, VXCVI, FR, FI, XX, FX, VX, FEX
			if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXCVI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, b, flags);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFctiwz::disasm( std::ostream& os)
	{
		{
			os << "fctiwz" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFctiwz(CodeType code, uint64_t addr)
	{
		return new OpFctiwz(code, addr);
	}

	bool OpFctid::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			S64 res64;

			if (unlikely(b.isNaN()))
			{
				if (unlikely(b.isSNaN()))
				{
					// Generate VXSNAN
					fpscr.SetInvalid(FPSCR::VXSNAN());
					if (unlikely(not cpu->CheckFloatingPointException()))
					return false;
				}

				res64 = S64(1ll<<63);
			}
			else
			{
				Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
				res64 = b.queryS64( flags );
				// Generate VXCVI, FR, FI, XX, FX, VX, FEX
				if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
				else                                fpscr.SetInvalid( FPSCR::VXCVI() );
				fpscr.Set<FPSCR::FR>( flags.hasIncrementFraction(res64 < S64(0)) );

				if (not cpu->CheckFloatingPointException())
				return false;
			}

			SoftDouble result(SoftDouble::FromRawBits, U64(res64));

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFctid::disasm( std::ostream& os)
	{
		{
			os << "fctid" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFctid(CodeType code, uint64_t addr)
	{
		return new OpFctid(code, addr);
	}

	bool OpFctidz::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			S64 res64;

			if (unlikely(b.isNaN()))
			{
				if (unlikely(b.isSNaN()))
				{
					// Generate VXSNAN
					fpscr.SetInvalid(FPSCR::VXSNAN());
					if (unlikely(not cpu->CheckFloatingPointException()))
					return false;
				}

				res64 = S64(1ll<<63);
			}
			else
			{
				Flags flags( Flags::RoundingMode(1) );
				res64 = b.queryS64( flags );
				// Generate VXCVI, FR, FI, XX, FX, VX, FEX
				if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
				else                                fpscr.SetInvalid( FPSCR::VXCVI() );
				fpscr.Set<FPSCR::FR>( flags.hasIncrementFraction(res64 < S64(0)) );

				if (not cpu->CheckFloatingPointException())
				return false;
			}

			SoftDouble result(SoftDouble::FromRawBits, U64(res64));

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFctidz::disasm( std::ostream& os)
	{
		{
			os << "fctidz" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFctidz(CodeType code, uint64_t addr)
	{
		return new OpFctidz(code, addr);
	}

	bool OpFcfid::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			S64 b( cpu->GetFPR(frb).queryRawBits() );

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result(b, flags);

			// Generate FPRF, FR, FI, XX, FX
			if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr(fpscr), old_fpscr = new_fpscr;
			GenFPSCR_FPRF<FPSCR>(new_fpscr, result);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(frt, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFcfid::disasm( std::ostream& os)
	{
		{
			os << "fcfid" << (rc ? "." : "") << " " << FPRPrint(frt) << ", " << FPRPrint(frb);
	}}

	static Operation *DecodeOpFcfid(CodeType code, uint64_t addr)
	{
		return new OpFcfid(code, addr);
	}

	bool OpFdiv::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			if (unlikely(b.isZero()))
			{
				if (unlikely(result.isZero())) { fpscr.SetInvalid(FPSCR::VXZDZ()); }
				else                           { fpscr.SetException(FPSCR::ZX()); }
			}
			else if (unlikely(b.isInfty() and result.isInfty()))
			{
				fpscr.SetInvalid(FPSCR::VXIDI());
			}

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.divAssign(b, flags);

			// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFdiv::disasm( std::ostream& os)
	{
		{
			os << "fdiv" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFdiv(CodeType code, uint64_t addr)
	{
		return new OpFdiv(code, addr);
	}

	bool OpFdivs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& b(cpu->GetFPR(fb));
			if (unlikely(b.isZero()))
			{
				if (unlikely(a.isZero())) { fpscr.SetInvalid(FPSCR::VXZDZ()); }
				else                      { fpscr.SetException(FPSCR::ZX()); }
			}
			else if (unlikely(b.isInfty() and a.isInfty()))
			{
				fpscr.SetInvalid(FPSCR::VXIDI());
			}

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.divAssign(b, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFdivs::disasm( std::ostream& os)
	{
		{
			os << "fdivs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFdivs(CodeType code, uint64_t addr)
	{
		return new OpFdivs(code, addr);
	}

	bool OpFmadd::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndAddAssign(c, b, flags);

			// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFmadd::disasm( std::ostream& os)
	{
		{
			os << "fmadd" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFmadd(CodeType code, uint64_t addr)
	{
		return new OpFmadd(code, addr);
	}

	bool OpFmadds::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndAddAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFmadds::disasm( std::ostream& os)
	{
		{
			os << "fmadds" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFmadds(CodeType code, uint64_t addr)
	{
		return new OpFmadds(code, addr);
	}

	bool OpFmr::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			cpu->SetFPR(fd, cpu->GetFPR(fb));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFmr::disasm( std::ostream& os)
	{
		{
			os << "fmr" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFmr(CodeType code, uint64_t addr)
	{
		return new OpFmr(code, addr);
	}

	bool OpFmsub::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndSubAssign(c, b, flags);

			// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFmsub::disasm( std::ostream& os)
	{
		{
			os << "fmsub" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFmsub(CodeType code, uint64_t addr)
	{
		return new OpFmsub(code, addr);
	}

	bool OpFmsubs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndSubAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFmsubs::disasm( std::ostream& os)
	{
		{
			os << "fmsubs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFmsubs(CodeType code, uint64_t addr)
	{
		return new OpFmsubs(code, addr);
	}

	bool OpFmul::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			result.multAssign(c, flags);

			// Generate OX, UX, VXSNAN, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFmul::disasm( std::ostream& os)
	{
		{
			os << "fmul" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc);
	}}

	static Operation *DecodeOpFmul(CodeType code, uint64_t addr)
	{
		return new OpFmul(code, addr);
	}

	bool OpFmuls::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& c(cpu->GetFPR(fc));

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAssign(c, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFmuls::disasm( std::ostream& os)
	{
		{
			os << "fmuls" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc);
	}}

	static Operation *DecodeOpFmuls(CodeType code, uint64_t addr)
	{
		return new OpFmuls(code, addr);
	}

	bool OpFnabs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			SoftDouble result( cpu->GetFPR(fb) );

			// Compute the result
			result.setNegative();

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFnabs::disasm( std::ostream& os)
	{
		{
			os << "fnabs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFnabs(CodeType code, uint64_t addr)
	{
		return new OpFnabs(code, addr);
	}

	bool OpFneg::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			SoftDouble result = cpu->GetFPR(fb);

			// Compute the result
			result.opposite();

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFneg::disasm( std::ostream& os)
	{
		{
			os << "fneg" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFneg(CodeType code, uint64_t addr)
	{
		return new OpFneg(code, addr);
	}

	bool OpFnmadd::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndAddAssign(c, b, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			if (likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFnmadd::disasm( std::ostream& os)
	{
		{
			os << "fnmadd" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFnmadd(CodeType code, uint64_t addr)
	{
		return new OpFnmadd(code, addr);
	}

	bool OpFnmadds::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding and opposite
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndAddAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			// Compute the final result
			if(likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFnmadds::disasm( std::ostream& os)
	{
		{
			os << "fnmadds" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFnmadds(CodeType code, uint64_t addr)
	{
		return new OpFnmadds(code, addr);
	}

	bool OpFnmsub::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndSubAssign(c, b, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			if (likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFnmsub::disasm( std::ostream& os)
	{
		{
			os << "fnmsub" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFnmsub(CodeType code, uint64_t addr)
	{
		return new OpFnmsub(code, addr);
	}

	bool OpFnmsubs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding and opposite
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndSubAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			// Compute the final result
			if(likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFnmsubs::disasm( std::ostream& os)
	{
		{
			os << "fnmsubs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFnmsubs(CodeType code, uint64_t addr)
	{
		return new OpFnmsubs(code, addr);
	}

	bool OpFrsp::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr(cpu->GetFPSCR());
			const SoftDouble& b = cpu->GetFPR(fb);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftFloat result(b, flags);

			// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr(fpscr), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFrsp::disasm( std::ostream& os)
	{
		{
			os << "frsp" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFrsp(CodeType code, uint64_t addr)
	{
		return new OpFrsp(code, addr);
	}

	bool OpFsel::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU or not CONFIG::HAS_FLOATING_POINT_GRAPHICS_INSTRUCTIONS)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			const SoftDouble& a = cpu->GetFPR(fa);
			const SoftDouble& b = cpu->GetFPR(fb);
			const SoftDouble& c = cpu->GetFPR(fc);

			// Compute and write the result
			cpu->SetFPR(fd, evenly((not a.isZero() and a.isNegative()) or a.isNaN()) ? b : c);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFsel::disasm( std::ostream& os)
	{
		{
			os << "fsel" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFsel(CodeType code, uint64_t addr)
	{
		return new OpFsel(code, addr);
	}

	bool OpFsub::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result = cpu->GetFPR(fa);
			const SoftDouble& b = cpu->GetFPR(fb);

			// Compute the result
			result.minusAssign(b, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFsub::disasm( std::ostream& os)
	{
		{
			os << "fsub" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFsub(CodeType code, uint64_t addr)
	{
		return new OpFsub(code, addr);
	}

	bool OpFsubs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& b(cpu->GetFPR(fb));

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.minusAssign(b, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpFsubs::disasm( std::ostream& os)
	{
		{
			os << "fsubs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpFsubs(CodeType code, uint64_t addr)
	{
		return new OpFsubs(code, addr);
	}

	bool OpLfd::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			UINT disp( d );
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + disp : disp);

			// do the memory access
			return cpu->Fp64Load(fd, ea);
	}}
	void OpLfd::disasm( std::ostream& os)
	{
		{
			os << "lfd " << FPRPrint(fd) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLfd(CodeType code, uint64_t addr)
	{
		return new OpLfd(code, addr);
	}

	bool OpLfdu::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea( cpu->GetGPR(ra) + UINT(d) );

			// do the memory access
			if (unlikely(not cpu->Fp64Load(fd, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLfdu::disasm( std::ostream& os)
	{
		{
			os << "lfdu " << FPRPrint(fd) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLfdu(CodeType code, uint64_t addr)
	{
		return new OpLfdu(code, addr);
	}

	bool OpLfdux::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));

			if(unlikely(not cpu->Fp64Load(fd, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLfdux::disasm( std::ostream& os)
	{
		{
			os << "lfdux " << FPRPrint(fd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLfdux(CodeType code, uint64_t addr)
	{
		return new OpLfdux(code, addr);
	}

	bool OpLfdx::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));

			// do the memory access
			return cpu->Fp64Load(fd, ea);
	}}
	void OpLfdx::disasm( std::ostream& os)
	{
		{
			os << "lfdx " << FPRPrint(fd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLfdx(CodeType code, uint64_t addr)
	{
		return new OpLfdx(code, addr);
	}

	bool OpLfs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			UINT disp( d );
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + disp : disp);

			// do the memory access
			return cpu->Fp32Load(fd, ea);
	}}
	void OpLfs::disasm( std::ostream& os)
	{
		{
			os << "lfs " << FPRPrint(fd) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLfs(CodeType code, uint64_t addr)
	{
		return new OpLfs(code, addr);
	}

	bool OpLfsu::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = cpu->GetGPR(ra) + UINT(SINT(d));

			// do the memory access
			if(unlikely(not cpu->Fp32Load(fd, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLfsu::disasm( std::ostream& os)
	{
		{
			os << "lfsu " << FPRPrint(fd) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpLfsu(CodeType code, uint64_t addr)
	{
		return new OpLfsu(code, addr);
	}

	bool OpLfsux::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + cpu->GetGPR(rb));

			// do the memory access
			if(unlikely(not cpu->Fp32Load(fd, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpLfsux::disasm( std::ostream& os)
	{
		{
			os << "lfsux " << FPRPrint(fd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLfsux(CodeType code, uint64_t addr)
	{
		return new OpLfsux(code, addr);
	}

	bool OpLfsx::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));

			// do the memory access
			return cpu->Fp32Load(fd, ea);
	}}
	void OpLfsx::disasm( std::ostream& os)
	{
		{
			os << "lfsx " << FPRPrint(fd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpLfsx(CodeType code, uint64_t addr)
	{
		return new OpLfsx(code, addr);
	}

	bool OpMcrfs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();

			// Extract FPSCR source 4-bit field
			UINT bits = ((UINT(fpscr) << 4*bfa) >> 28) & UINT(0xf);

			// Clear copied bits if they are exception bits or FX
			switch(bfa)
			{
			case 0:
				fpscr.Set<FPSCR::FX>(UINT(0));
				fpscr.Set<FPSCR::OX>(UINT(0));
				break;
			case 1:
				fpscr.Set<FPSCR::UX>(UINT(0));
				fpscr.Set<FPSCR::ZX>(UINT(0));
				fpscr.Set<FPSCR::XX>(UINT(0));
				fpscr.Set<FPSCR::VXSNAN>(UINT(0));
			case 2:
				fpscr.Set<FPSCR::VXISI>(UINT(0));
				fpscr.Set<FPSCR::VXIDI>(UINT(0));
				fpscr.Set<FPSCR::VXZDZ>(UINT(0));
				fpscr.Set<FPSCR::VXIMZ>(UINT(0));
				break;
			case 3:
				fpscr.Set<FPSCR::VXVC>(UINT(0));
				break;
			case 5:
				fpscr.Set<FPSCR::VXSOFT>(UINT(0));
				fpscr.Set<FPSCR::VXSQRT>(UINT(0));
				fpscr.Set<FPSCR::VXCVI>(UINT(0));
				break;
			}

			// Update VX, FEX
			UINT new_fpscr(fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			fpscr = new_fpscr;

			// Copy it into CR 4-bit destination field
			CR& cr = cpu->GetCR();
			switch(bft)
			{
				case 0: cr.Set<CR::CR0>(bits); break;
				case 1: cr.Set<CR::CR1>(bits); break;
				case 2: cr.Set<CR::CR2>(bits); break;
				case 3: cr.Set<CR::CR3>(bits); break;
				case 4: cr.Set<CR::CR4>(bits); break;
				case 5: cr.Set<CR::CR5>(bits); break;
				case 6: cr.Set<CR::CR6>(bits); break;
				case 7: cr.Set<CR::CR7>(bits); break;
			}

			return true;
	}}
	void OpMcrfs::disasm( std::ostream& os)
	{
		{
			os << "mcrfs " << CRPrint(bft) << ", " << CRPrint(bfa);
	}}

	static Operation *DecodeOpMcrfs(CodeType code, uint64_t addr)
	{
		return new OpMcrfs(code, addr);
	}

	bool OpMffs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Move FPSCR into destination FPR
			FPSCR& fpscr( cpu->GetFPSCR() );
			cpu->SetFPR(fd, SoftDouble(SoftDouble::FromRawBits, U64(fpscr) | U64(0xfff8000000000000ULL)));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpMffs::disasm( std::ostream& os)
	{
		{
			os << "mffs" << (rc ? "." : "") << " " << FPRPrint(fd);
	}}

	static Operation *DecodeOpMffs(CodeType code, uint64_t addr)
	{
		return new OpMffs(code, addr);
	}

	bool OpMtfsb0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();

			// Compute the result
			if (likely(bt != 1 && bt != 2))
			{
				// Clear bit BT
				UINT new_fpscr( fpscr );
				new_fpscr &= ~UINT(0x80000000 >> bt);

				// Update VX, FEX
				GenFPSCR_VX<FPSCR>(new_fpscr);
				GenFPSCR_FEX<FPSCR>(new_fpscr);

				fpscr = new_fpscr;
			}

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpMtfsb0::disasm( std::ostream& os)
	{
		{
			os << "mtfsb0" << (rc ? "." : "") << " " << CRPrint(bt);
	}}

	static Operation *DecodeOpMtfsb0(CodeType code, uint64_t addr)
	{
		return new OpMtfsb0(code, addr);
	}

	bool OpMtfsb1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();

			// Compute the result
			if (likely(bt != 1 && bt != 2))
			{
				// Set bit BT
				UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
				new_fpscr |= UINT(0x80000000 >> bt);

				// Update VX, FEX
				GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
				GenFPSCR_VX<FPSCR>(new_fpscr);
				GenFPSCR_FEX<FPSCR>(new_fpscr);

				fpscr = new_fpscr;
			}

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpMtfsb1::disasm( std::ostream& os)
	{
		{
			os << "mtfsb1" << (rc ? "." : "") << " " << CRPrint(bt);
	}}

	static Operation *DecodeOpMtfsb1(CodeType code, uint64_t addr)
	{
		return new OpMtfsb1(code, addr);
	}

	bool OpMtfsfi::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			unsigned pos = (4 * (7 - bft));
			uint32_t fsmask = 0xf << pos, fsbits = imm << pos;
			UINT mask(uint64_t(fsmask) << (w ? 32 : 0));
			UINT bits(uint64_t(fsbits) << (w ? 32 : 0));

			// Compute the result
			UINT new_fpscr( cpu->GetFPSCR() );
			new_fpscr = (new_fpscr & ~mask) | bits;

			// Update VX, FEX
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			fpscr = new_fpscr;

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpMtfsfi::disasm( std::ostream& os)
	{
		{
			os << "mtfsfi" << (rc ? "." : "") << " " << CRPrint(bft) << ", " << unsigned(imm);
	}}

	static Operation *DecodeOpMtfsfi(CodeType code, uint64_t addr)
	{
		return new OpMtfsfi(code, addr);
	}

	bool OpMtfsf::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			UINT rb( cpu->GetFPR(fb).queryRawBits() );
			UINT mask(l ? UINT(uint64_t(-1)) : UINT(uint64_t(fsmask) << (w ? 32 : 0)));

			// Compute the result
			UINT new_fpscr = ((UINT(fpscr) & ~mask) | (rb & mask));

			// Update VX, FEX
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			fpscr = new_fpscr;

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void OpMtfsf::disasm( std::ostream& os)
	{
		{
			os << "mtfsf" << (rc ? "." : "") << " " << unsigned(fm) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOpMtfsf(CodeType code, uint64_t addr)
	{
		return new OpMtfsf(code, addr);
	}

	bool OpStfd::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			UINT disp( d );
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + disp : disp);

			return cpu->Fp64Store(fs, ea);
	}}
	void OpStfd::disasm( std::ostream& os)
	{
		{
			os << "stfd " << FPRPrint(fs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStfd(CodeType code, uint64_t addr)
	{
		return new OpStfd(code, addr);
	}

	bool OpStfdu::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = cpu->GetGPR(ra) + UINT(SINT(d));

			if(unlikely(not cpu->Fp64Store(fs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStfdu::disasm( std::ostream& os)
	{
		{
			os << "stfdu " << FPRPrint(fs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStfdu(CodeType code, uint64_t addr)
	{
		return new OpStfdu(code, addr);
	}

	bool OpStfdux::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = cpu->GetGPR(ra) + cpu->GetGPR(rb);

			if(unlikely(not cpu->Fp64Store(fs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStfdux::disasm( std::ostream& os)
	{
		{
			os << "stfdux " << FPRPrint(fs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStfdux(CodeType code, uint64_t addr)
	{
		return new OpStfdux(code, addr);
	}

	bool OpStfdx::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb);

			return cpu->Fp64Store(fs, ea);
	}}
	void OpStfdx::disasm( std::ostream& os)
	{
		{
			os << "stfdx " << FPRPrint(fs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStfdx(CodeType code, uint64_t addr)
	{
		return new OpStfdx(code, addr);
	}

	bool OpStfiwx::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb));

			return cpu->FpStoreLSW(fs, ea);
	}}
	void OpStfiwx::disasm( std::ostream& os)
	{
		{
			os << "stfiwx " << FPRPrint(fs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStfiwx(CodeType code, uint64_t addr)
	{
		return new OpStfiwx(code, addr);
	}

	bool OpStfs::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}
			// compute the effective address
			UINT disp( d );
			ADDRESS ea = ra ? cpu->GetGPR(ra) + disp : disp;

			return cpu->Fp32Store(fs, ea);
	}}
	void OpStfs::disasm( std::ostream& os)
	{
		{
			os << "stfs " << FPRPrint(fs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStfs(CodeType code, uint64_t addr)
	{
		return new OpStfs(code, addr);
	}

	bool OpStfsu::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = cpu->GetGPR(ra) + UINT(SINT(d));

			if(unlikely(not cpu->Fp32Store(fs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStfsu::disasm( std::ostream& os)
	{
		{
			os << "stfsu " << FPRPrint(fs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOpStfsu(CodeType code, uint64_t addr)
	{
		return new OpStfsu(code, addr);
	}

	bool OpStfsux::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = cpu->GetGPR(ra) + cpu->GetGPR(rb);

			if(unlikely(not cpu->Fp32Store(fs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void OpStfsux::disasm( std::ostream& os)
	{
		{
			os << "stfsux " << FPRPrint(fs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStfsux(CodeType code, uint64_t addr)
	{
		return new OpStfsux(code, addr);
	}

	bool OpStfsx::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// compute the effective address
			ADDRESS ea = ra ? cpu->GetGPR(ra) + cpu->GetGPR(rb) : cpu->GetGPR(rb);

			return cpu->Fp32Store(fs, ea);
	}}
	void OpStfsx::disasm( std::ostream& os)
	{
		{
			os << "stfsx " << FPRPrint(fs) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOpStfsx(CodeType code, uint64_t addr)
	{
		return new OpStfsx(code, addr);
	}

	bool OpMfspr::execute( Arch* cpu)
	{
		{
			UINT result;
			switch(n)
			{
			case 0x001:
				result = cpu->GetXER();
				break;
			case 0x008:
				result = cpu->GetLR();
				break;
			case 0x009:
				result = cpu->GetCTR();
				break;
			default:
				if(unlikely(not cpu->MoveFromSPR(n, result))) return false;
				break;
			}

			cpu->SetGPR(rd, result);

			return true;
	}}
	void OpMfspr::disasm( std::ostream& os)
	{
		{
			switch(n)
			{
				case 1: os << "mfxer " << GPRPrint(rd); return;
				case 8: os << "mflr " << GPRPrint(rd); return;
				case 9: os << "mfctr " << GPRPrint(rd); return;
			}

			os << "mfspr " << GPRPrint(rd) << ", " << n;
	}}

	static Operation *DecodeOpMfspr(CodeType code, uint64_t addr)
	{
		return new OpMfspr(code, addr);
	}

	bool OpMtspr::execute( Arch* cpu)
	{
		{
			UINT value = cpu->GetGPR(rs);

			switch(n)
			{
			case 0x001:
				{
					XER& xer = cpu->GetXER();
					xer = value;
					break;
				}
			case 0x008:
				{
					LR& lr = cpu->GetLR();
					lr = value;
					break;
				}
			case 0x009:
				{
					CTR& ctr = cpu->GetCTR();
					ctr = value;
					break;
				}
			default:
				return cpu->MoveToSPR(n, value);
			}

			return true;
	}}
	void OpMtspr::disasm( std::ostream& os)
	{
		{
			switch(n)
			{
				case 1: os << "mtxer " << GPRPrint(rs); return;
				case 8: os << "mtlr " << GPRPrint(rs); return;
				case 9: os << "mtctr " << GPRPrint(rs); return;
			}

			os << "mtspr " << n << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOpMtspr(CodeType code, uint64_t addr)
	{
		return new OpMtspr(code, addr);
	}

	bool Op__spec__bcctr_bo_0_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_0_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_0_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_0_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_0_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_0_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_0_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_0_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_1_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_1_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_2_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_2_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_2_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_2_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_2_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_2_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_2_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_2_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_3_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_3_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_3_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_3_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_3_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_3_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_3_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_3_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_4_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_4_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_4_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_4_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_4_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_4_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_4_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_4_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_5_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_5_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_5_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_5_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_5_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_5_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_5_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_5_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_6_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_6_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_6_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_6_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_6_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_6_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_6_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_6_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_7_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_7_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_7_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_7_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_7_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_7_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_7_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_7_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_8_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_8_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_8_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_8_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_8_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_8_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_8_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_8_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_9_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_9_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_9_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_9_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_9_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_9_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_9_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_9_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_a_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_a_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_a_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_a_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_a_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_a_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_a_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_a_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_b_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_b_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_b_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_b_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_b_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_b_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_b_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_b_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_c_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_c_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_c_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_c_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_c_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_c_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_c_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_c_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_d_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_d_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_d_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_d_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_d_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_d_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_d_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_d_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_e_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_e_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_e_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_e_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_e_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_e_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_e_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_e_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_f_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_f_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_f_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_f_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_f_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_f_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_f_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_f_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_10_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_10_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_10_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_10_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_10_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_10_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_10_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_10_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_11_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_11_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_11_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_11_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_11_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_11_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_11_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_11_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_12_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_12_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_12_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_12_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_12_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_12_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_12_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_12_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_13_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_13_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_13_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_13_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_13_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_13_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_13_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_13_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_14_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_14_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_14_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_14_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_14_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_14_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_14_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_14_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_15_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_15_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_15_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_15_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_15_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_15_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_15_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_15_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_16_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_16_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_16_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_16_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_16_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_16_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_16_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_16_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_17_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_17_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_17_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_17_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_17_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_17_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_17_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_17_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_18_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_18_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_18_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_18_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_18_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_18_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_18_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_18_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_19_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_19_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_19_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_19_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_19_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_19_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_19_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_19_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_1a_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1a_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1a_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1a_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_1a_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1a_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1a_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1a_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_1b_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1b_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1b_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1b_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_1b_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1b_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1b_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1b_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_1c_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1c_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1c_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1c_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_1c_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1c_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1c_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1c_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_1d_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1d_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1d_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1d_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_1d_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1d_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1d_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1d_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_1e_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1e_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1e_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1e_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_1e_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1e_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1e_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1e_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bcctr_bo_1f_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1f_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1f_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1f_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bcctr_bo_1f_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			if(unlikely((bo & 4) == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}

			BOOL cond_ok = BOOL(true);

			if (((bo & 16) == 0)) {
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if (evenly(cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetCTR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bcctr_bo_1f_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << "<illegal>";
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "ctr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bcctr_bo_1f_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bcctr_bo_1f_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_0_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_0_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_0_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_0_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_0_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_0_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_0_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_0_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_0_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_0_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_0_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_0_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_0_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_0_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_0_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_0_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_2_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_2_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_2_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_2_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_2_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_2_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_2_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_2_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_2_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_2_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_2_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_2_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_2_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_2_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_2_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_2_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_3_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_3_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_3_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_3_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_3_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_3_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_3_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_3_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_3_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_3_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_3_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_3_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_3_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_3_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_3_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_3_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_4_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_4_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_4_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_4_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_4_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_4_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_4_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_4_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_4_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_4_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_4_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_4_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_4_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_4_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_4_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_4_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_5_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_5_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_5_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_5_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_5_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_5_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_5_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_5_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_5_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_5_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_5_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_5_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_5_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_5_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_5_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_5_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_6_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_6_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_6_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_6_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_6_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_6_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_6_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_6_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_6_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_6_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_6_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_6_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_6_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_6_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_6_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_6_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_7_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_7_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_7_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_7_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_7_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_7_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_7_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_7_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_7_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_7_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_7_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_7_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_7_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_7_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_7_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_7_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_8_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_8_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_8_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_8_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_8_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_8_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_8_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_8_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_8_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_8_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_8_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_8_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_8_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_8_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_8_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_8_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_9_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_9_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_9_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_9_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_9_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_9_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_9_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_9_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_9_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_9_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_9_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_9_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_9_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_9_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_9_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_9_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_a_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_a_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_a_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_a_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_a_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_a_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_a_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_a_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_a_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_a_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_a_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_a_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_a_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_a_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_a_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_a_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_b_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_b_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_b_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_b_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_b_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_b_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_b_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_b_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_b_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_b_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_b_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_b_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_b_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_b_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_b_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_b_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_c_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_c_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_c_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_c_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_c_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_c_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_c_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_c_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_c_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_c_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_c_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_c_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_c_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_c_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_c_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_c_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_d_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_d_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_d_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_d_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_d_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_d_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_d_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_d_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_d_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_d_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_d_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_d_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_d_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_d_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_d_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_d_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_e_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_e_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_e_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_e_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_e_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_e_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_e_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_e_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_e_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_e_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_e_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_e_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_e_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_e_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_e_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_e_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_f_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_f_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_f_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_f_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_f_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_f_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_f_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_f_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_f_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_f_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_f_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_f_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_f_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_f_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_f_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_f_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_10_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_10_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_10_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_10_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_10_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_10_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_10_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_10_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_10_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_10_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_10_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_10_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_10_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_10_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_10_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_10_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_11_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_11_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_11_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_11_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_11_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_11_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_11_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_11_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_11_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_11_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_11_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_11_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_11_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_11_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_11_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_11_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_12_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_12_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_12_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_12_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_12_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_12_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_12_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_12_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_12_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_12_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_12_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_12_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_12_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_12_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_12_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_12_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_13_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_13_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_13_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_13_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_13_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_13_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_13_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_13_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_13_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_13_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_13_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_13_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_13_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_13_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_13_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_13_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_14_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_14_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_14_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_14_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_14_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_14_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_14_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_14_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_14_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_14_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_14_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_14_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_14_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_14_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_14_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_14_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_15_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_15_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_15_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_15_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_15_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_15_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_15_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_15_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_15_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_15_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_15_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_15_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_15_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_15_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_15_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_15_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_16_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_16_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_16_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_16_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_16_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_16_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_16_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_16_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_16_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_16_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_16_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_16_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_16_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_16_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_16_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_16_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_17_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_17_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_17_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_17_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_17_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_17_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_17_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_17_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_17_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_17_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_17_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_17_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_17_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_17_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_17_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_17_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_18_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_18_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_18_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_18_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_18_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_18_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_18_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_18_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_18_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_18_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_18_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_18_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_18_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_18_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_18_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_18_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_19_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_19_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_19_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_19_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_19_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_19_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_19_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_19_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_19_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_19_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_19_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_19_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_19_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_19_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_19_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_19_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1a_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1a_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1a_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1a_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1a_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1a_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1a_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1a_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1a_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1a_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1a_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1a_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1a_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1a_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1a_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1a_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1b_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1b_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1b_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1b_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1b_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1b_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1b_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1b_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1b_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1b_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1b_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1b_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1b_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1b_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1b_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1b_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1c_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1c_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1c_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1c_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1c_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1c_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1c_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1c_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1c_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1c_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1c_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1c_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1c_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1c_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1c_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1c_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1d_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1d_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1d_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1d_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1d_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1d_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1d_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1d_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1d_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1d_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1d_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1d_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1d_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1d_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1d_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1d_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1e_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1e_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1e_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1e_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1e_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1e_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1e_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1e_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1e_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1e_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1e_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1e_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1e_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1e_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1e_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1e_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1f_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1f_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1f_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1f_aa_0_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1f_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1f_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1f_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1f_aa_0_lk_1(code, addr);
	}

	bool Op__spec__bc_bo_1f_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1f_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1f_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1f_aa_1_lk_0(code, addr);
	}

	bool Op__spec__bc_bo_1f_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				UINT bd( bd14 );
				ADDRESS target_addr( aa ? bd : cpu->GetCIA() + bd );
				cpu->Branch(target_addr);
			}

			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bc_bo_1f_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			if (aa) os << "a";
			os << " ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn) << ", "; }
			else if (dc) { os << unsigned(bi) << ", "; }
			else         { os << unsigned(bo) << ", " << unsigned(bi) << ", "; }
			os << "0x" << std::hex << (aa ? bd14 : GetAddr() + bd14) << std::dec;
	}}

	static Operation *DecodeOp__spec__bc_bo_1f_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bc_bo_1f_aa_1_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_0_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_0_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_0_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_0_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_0_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_0_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_0_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_0_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_1_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_1_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_2_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_2_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_2_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_2_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_2_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_2_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_2_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_2_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_3_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_3_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_3_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_3_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_3_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_3_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_3_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_3_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_4_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_4_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_4_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_4_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_4_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_4_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_4_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_4_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_5_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_5_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_5_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_5_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_5_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_5_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_5_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_5_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_6_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_6_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_6_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_6_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_6_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_6_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_6_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_6_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_7_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_7_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_7_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_7_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_7_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_7_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_7_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_7_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_8_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_8_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_8_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_8_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_8_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_8_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_8_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_8_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_9_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_9_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_9_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_9_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_9_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_9_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_9_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_9_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_a_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_a_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_a_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_a_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_a_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_a_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_a_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_a_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_b_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_b_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_b_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_b_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_b_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_b_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_b_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_b_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_c_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_c_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_c_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_c_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_c_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_c_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_c_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_c_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_d_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_d_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_d_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_d_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_d_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_d_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_d_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_d_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_e_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_e_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_e_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_e_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_e_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_e_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_e_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_e_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_f_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_f_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_f_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_f_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_f_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_f_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_f_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_f_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_10_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_10_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_10_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_10_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_10_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_10_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_10_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_10_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_11_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_11_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_11_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_11_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_11_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_11_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_11_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_11_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_12_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_12_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_12_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_12_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_12_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_12_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_12_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_12_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_13_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_13_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_13_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_13_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_13_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_13_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_13_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_13_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_14_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_14_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_14_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_14_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_14_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_14_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_14_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_14_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_15_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_15_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_15_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_15_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_15_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_15_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_15_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_15_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_16_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_16_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_16_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_16_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_16_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_16_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_16_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_16_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_17_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_17_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_17_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_17_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_17_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_17_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_17_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_17_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_18_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_18_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_18_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_18_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_18_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_18_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_18_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_18_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_19_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_19_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_19_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_19_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_19_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_19_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_19_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_19_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_1a_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1a_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1a_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1a_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_1a_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1a_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1a_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1a_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_1b_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1b_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1b_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1b_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_1b_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1b_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1b_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1b_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_1c_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1c_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1c_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1c_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_1c_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1c_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1c_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1c_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_1d_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1d_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1d_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1d_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_1d_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1d_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1d_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1d_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_1e_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1e_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1e_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1e_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_1e_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1e_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1e_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1e_aa_2_lk_1(code, addr);
	}

	bool Op__spec__bclr_bo_1f_aa_2_lk_0::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1f_aa_2_lk_0::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1f_aa_2_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1f_aa_2_lk_0(code, addr);
	}

	bool Op__spec__bclr_bo_1f_aa_2_lk_1::execute( Arch* cpu)
	{
		{
			BOOL ctr_ok = BOOL(true), cond_ok = BOOL(true);

			if (((bo & 16) == 0))
			{
				/* Conditional branch */
				if(bo & 8) {
					/* Branch if condition is true */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) != U32(0);
				}
				else {
					/* Branch if condition is false */
					cond_ok = ((U32(cpu->GetCR()) << bi) & U32(0x80000000)) == U32(0);
				}
			}

			if ((bo & 4) == 0)
			{
				/* Decrement CTR */
				CTR& ctr = cpu->GetCTR();
				ctr = UINT(ctr) - UINT(1);
				/* Test whether to branch if CTR is zero or not */
				if(bo & 2) {
					ctr_ok = UINT(cpu->GetCTR()) == UINT(0);
				}
				else {
					ctr_ok = UINT(cpu->GetCTR()) != UINT(0);
				}
			}

			if (evenly(ctr_ok and cond_ok)) {
				ADDRESS target_addr( UINT(cpu->GetLR()) & UINT(-4) );
				cpu->Branch(target_addr);
			}
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );

			return true;
	}}
	void Op__spec__bclr_bo_1f_aa_2_lk_1::disasm( std::ostream& os)
	{
		{
			bool cr = (bo & 16) == 0, dc = (bo & 4) == 0;
			os << "b";
			if (dc) os << ((bo & 2) ? "dz" : "dnz");
			if (cr) os << CondPrint(bi & 3,bo & 8);
			if (lk) os << "l";
			os << "lr ";
			if      (cr) { if (unsigned crn = bi >> 2) os << CRPrint(crn); }
			else if (dc) { os << unsigned(bi); }
			else         { os << unsigned(bo) << ", " << unsigned(bi); }
	}}

	static Operation *DecodeOp__spec__bclr_bo_1f_aa_2_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__bclr_bo_1f_aa_2_lk_1(code, addr);
	}

	bool Op__spec__b_aa_0_lk_0::execute( Arch* cpu)
	{
		{
			UINT li( li24 );
			ADDRESS target_addr( aa ? li : cpu->GetCIA() + li );
			cpu->Branch(target_addr);
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );
			return true;
	}}
	void Op__spec__b_aa_0_lk_0::disasm( std::ostream& os)
	{
		{
			os << "b" << (lk ? "l" : "") << (aa ? "a" : "") << " "
			<< "0x" << std::hex << (aa ? li24 : GetAddr() + li24) << std::dec;
	}}

	static Operation *DecodeOp__spec__b_aa_0_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__b_aa_0_lk_0(code, addr);
	}

	bool Op__spec__b_aa_0_lk_1::execute( Arch* cpu)
	{
		{
			UINT li( li24 );
			ADDRESS target_addr( aa ? li : cpu->GetCIA() + li );
			cpu->Branch(target_addr);
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );
			return true;
	}}
	void Op__spec__b_aa_0_lk_1::disasm( std::ostream& os)
	{
		{
			os << "b" << (lk ? "l" : "") << (aa ? "a" : "") << " "
			<< "0x" << std::hex << (aa ? li24 : GetAddr() + li24) << std::dec;
	}}

	static Operation *DecodeOp__spec__b_aa_0_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__b_aa_0_lk_1(code, addr);
	}

	bool Op__spec__b_aa_1_lk_0::execute( Arch* cpu)
	{
		{
			UINT li( li24 );
			ADDRESS target_addr( aa ? li : cpu->GetCIA() + li );
			cpu->Branch(target_addr);
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );
			return true;
	}}
	void Op__spec__b_aa_1_lk_0::disasm( std::ostream& os)
	{
		{
			os << "b" << (lk ? "l" : "") << (aa ? "a" : "") << " "
			<< "0x" << std::hex << (aa ? li24 : GetAddr() + li24) << std::dec;
	}}

	static Operation *DecodeOp__spec__b_aa_1_lk_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__b_aa_1_lk_0(code, addr);
	}

	bool Op__spec__b_aa_1_lk_1::execute( Arch* cpu)
	{
		{
			UINT li( li24 );
			ADDRESS target_addr( aa ? li : cpu->GetCIA() + li );
			cpu->Branch(target_addr);
			if (lk) cpu->GetLR() = ADDRESS( cpu->GetCIA() + UINT(4) );
			return true;
	}}
	void Op__spec__b_aa_1_lk_1::disasm( std::ostream& os)
	{
		{
			os << "b" << (lk ? "l" : "") << (aa ? "a" : "") << " "
			<< "0x" << std::hex << (aa ? li24 : GetAddr() + li24) << std::dec;
	}}

	static Operation *DecodeOp__spec__b_aa_1_lk_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__b_aa_1_lk_1(code, addr);
	}

	bool Op__spec__addc_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | UINT( overflow));
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addc_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "addc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__addc_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__addc_rc_0_oe_0(code, addr);
	}

	bool Op__spec__addc_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | UINT( overflow));
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addc_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "addc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__addc_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__addc_rc_0_oe_1(code, addr);
	}

	bool Op__spec__addc_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | UINT( overflow));
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addc_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "addc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__addc_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__addc_rc_1_oe_0(code, addr);
	}

	bool Op__spec__addc_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | UINT( overflow));
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addc_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "addc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__addc_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__addc_rc_1_oe_1(code, addr);
	}

	bool Op__spec__adde_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__adde_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "adde" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__adde_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__adde_rc_0_oe_0(code, addr);
	}

	bool Op__spec__adde_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__adde_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "adde" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__adde_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__adde_rc_0_oe_1(code, addr);
	}

	bool Op__spec__adde_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__adde_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "adde" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__adde_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__adde_rc_1_oe_0(code, addr);
	}

	bool Op__spec__adde_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__adde_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "adde" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__adde_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__adde_rc_1_oe_1(code, addr);
	}

	bool Op__spec__add_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__add_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "add" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__add_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__add_rc_0_oe_0(code, addr);
	}

	bool Op__spec__add_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__add_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "add" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__add_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__add_rc_0_oe_1(code, addr);
	}

	bool Op__spec__add_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__add_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "add" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__add_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__add_rc_1_oe_0(code, addr);
	}

	bool Op__spec__add_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = a + b;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((a <= SINT(~b)) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__add_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "add" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__add_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__add_rc_1_oe_1(code, addr);
	}

	bool Op__spec__addme_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addme_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "addme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__addme_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__addme_rc_0_oe_0(code, addr);
	}

	bool Op__spec__addme_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addme_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "addme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__addme_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__addme_rc_0_oe_1(code, addr);
	}

	bool Op__spec__addme_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addme_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "addme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__addme_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__addme_rc_1_oe_0(code, addr);
	}

	bool Op__spec__addme_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addme_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "addme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__addme_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__addme_rc_1_oe_1(code, addr);
	}

	bool Op__spec__addze_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addze_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "addze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__addze_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__addze_rc_0_oe_0(code, addr);
	}

	bool Op__spec__addze_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addze_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "addze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__addze_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__addze_rc_0_oe_1(code, addr);
	}

	bool Op__spec__addze_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addze_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "addze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__addze_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__addze_rc_1_oe_0(code, addr);
	}

	bool Op__spec__addze_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool carry = evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = a + b + SINT(carry);

			// Generate XER[CA]
			xer.Set<XER::CA>(carry ? UINT(a) >= ~UINT(b) : UINT(a) > ~UINT(b));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((carry ? a <  SINT(~b) : a <= SINT(~b)) xor (result < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__addze_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "addze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__addze_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__addze_rc_1_oe_1(code, addr);
	}

	bool Op__spec__andc_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s & ~b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__andc_rc_0::disasm( std::ostream& os)
	{
		{
			os << "andc" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__andc_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__andc_rc_0(code, addr);
	}

	bool Op__spec__andc_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s & ~b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__andc_rc_1::disasm( std::ostream& os)
	{
		{
			os << "andc" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__andc_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__andc_rc_1(code, addr);
	}

	bool Op__spec__and_rc_0::execute( Arch* cpu)
	{
		{
			// read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s & b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__and_rc_0::disasm( std::ostream& os)
	{
		{
			os << "and" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__and_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__and_rc_0(code, addr);
	}

	bool Op__spec__and_rc_1::execute( Arch* cpu)
	{
		{
			// read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s & b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__and_rc_1::disasm( std::ostream& os)
	{
		{
			os << "and" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__and_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__and_rc_1(code, addr);
	}

	bool Op__spec__cmp_crfD_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmp_crfD_0::disasm( std::ostream& os)
	{
		{
			os << "cmp " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmp_crfD_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmp_crfD_0(code, addr);
	}

	bool Op__spec__cmp_crfD_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmp_crfD_1::disasm( std::ostream& os)
	{
		{
			os << "cmp " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmp_crfD_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmp_crfD_1(code, addr);
	}

	bool Op__spec__cmp_crfD_2::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmp_crfD_2::disasm( std::ostream& os)
	{
		{
			os << "cmp " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmp_crfD_2(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmp_crfD_2(code, addr);
	}

	bool Op__spec__cmp_crfD_3::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmp_crfD_3::disasm( std::ostream& os)
	{
		{
			os << "cmp " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmp_crfD_3(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmp_crfD_3(code, addr);
	}

	bool Op__spec__cmp_crfD_4::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmp_crfD_4::disasm( std::ostream& os)
	{
		{
			os << "cmp " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmp_crfD_4(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmp_crfD_4(code, addr);
	}

	bool Op__spec__cmp_crfD_5::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmp_crfD_5::disasm( std::ostream& os)
	{
		{
			os << "cmp " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmp_crfD_5(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmp_crfD_5(code, addr);
	}

	bool Op__spec__cmp_crfD_6::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmp_crfD_6::disasm( std::ostream& os)
	{
		{
			os << "cmp " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmp_crfD_6(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmp_crfD_6(code, addr);
	}

	bool Op__spec__cmp_crfD_7::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a = S32(cpu->GetGPR(ra)), b = S32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmp_crfD_7::disasm( std::ostream& os)
	{
		{
			os << "cmp " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmp_crfD_7(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmp_crfD_7(code, addr);
	}

	bool Op__spec__cmpL_crfD_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpL_crfD_0::disasm( std::ostream& os)
	{
		{
			os << "cmpd " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpL_crfD_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpL_crfD_0(code, addr);
	}

	bool Op__spec__cmpL_crfD_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpL_crfD_1::disasm( std::ostream& os)
	{
		{
			os << "cmpd " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpL_crfD_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpL_crfD_1(code, addr);
	}

	bool Op__spec__cmpL_crfD_2::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpL_crfD_2::disasm( std::ostream& os)
	{
		{
			os << "cmpd " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpL_crfD_2(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpL_crfD_2(code, addr);
	}

	bool Op__spec__cmpL_crfD_3::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpL_crfD_3::disasm( std::ostream& os)
	{
		{
			os << "cmpd " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpL_crfD_3(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpL_crfD_3(code, addr);
	}

	bool Op__spec__cmpL_crfD_4::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpL_crfD_4::disasm( std::ostream& os)
	{
		{
			os << "cmpd " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpL_crfD_4(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpL_crfD_4(code, addr);
	}

	bool Op__spec__cmpL_crfD_5::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpL_crfD_5::disasm( std::ostream& os)
	{
		{
			os << "cmpd " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpL_crfD_5(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpL_crfD_5(code, addr);
	}

	bool Op__spec__cmpL_crfD_6::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpL_crfD_6::disasm( std::ostream& os)
	{
		{
			os << "cmpd " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpL_crfD_6(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpL_crfD_6(code, addr);
	}

	bool Op__spec__cmpL_crfD_7::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(cpu->GetGPR(ra)), b = S64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpL_crfD_7::disasm( std::ostream& os)
	{
		{
			os << "cmpd " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpL_crfD_7(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpL_crfD_7(code, addr);
	}

	bool Op__spec__cmpl_crfD_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpl_crfD_0::disasm( std::ostream& os)
	{
		{
			os << "cmpl " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpl_crfD_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpl_crfD_0(code, addr);
	}

	bool Op__spec__cmpl_crfD_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpl_crfD_1::disasm( std::ostream& os)
	{
		{
			os << "cmpl " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpl_crfD_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpl_crfD_1(code, addr);
	}

	bool Op__spec__cmpl_crfD_2::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpl_crfD_2::disasm( std::ostream& os)
	{
		{
			os << "cmpl " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpl_crfD_2(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpl_crfD_2(code, addr);
	}

	bool Op__spec__cmpl_crfD_3::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpl_crfD_3::disasm( std::ostream& os)
	{
		{
			os << "cmpl " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpl_crfD_3(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpl_crfD_3(code, addr);
	}

	bool Op__spec__cmpl_crfD_4::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpl_crfD_4::disasm( std::ostream& os)
	{
		{
			os << "cmpl " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpl_crfD_4(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpl_crfD_4(code, addr);
	}

	bool Op__spec__cmpl_crfD_5::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpl_crfD_5::disasm( std::ostream& os)
	{
		{
			os << "cmpl " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpl_crfD_5(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpl_crfD_5(code, addr);
	}

	bool Op__spec__cmpl_crfD_6::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpl_crfD_6::disasm( std::ostream& os)
	{
		{
			os << "cmpl " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpl_crfD_6(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpl_crfD_6(code, addr);
	}

	bool Op__spec__cmpl_crfD_7::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a = U32(cpu->GetGPR(ra)), b = U32(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmpl_crfD_7::disasm( std::ostream& os)
	{
		{
			os << "cmpl " << CRPrint(crfD) << ", 0, " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmpl_crfD_7(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmpl_crfD_7(code, addr);
	}

	bool Op__spec__cmplL_crfD_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmplL_crfD_0::disasm( std::ostream& os)
	{
		{
			os << "cmpld " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmplL_crfD_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmplL_crfD_0(code, addr);
	}

	bool Op__spec__cmplL_crfD_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmplL_crfD_1::disasm( std::ostream& os)
	{
		{
			os << "cmpld " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmplL_crfD_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmplL_crfD_1(code, addr);
	}

	bool Op__spec__cmplL_crfD_2::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmplL_crfD_2::disasm( std::ostream& os)
	{
		{
			os << "cmpld " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmplL_crfD_2(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmplL_crfD_2(code, addr);
	}

	bool Op__spec__cmplL_crfD_3::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmplL_crfD_3::disasm( std::ostream& os)
	{
		{
			os << "cmpld " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmplL_crfD_3(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmplL_crfD_3(code, addr);
	}

	bool Op__spec__cmplL_crfD_4::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmplL_crfD_4::disasm( std::ostream& os)
	{
		{
			os << "cmpld " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmplL_crfD_4(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmplL_crfD_4(code, addr);
	}

	bool Op__spec__cmplL_crfD_5::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmplL_crfD_5::disasm( std::ostream& os)
	{
		{
			os << "cmpld " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmplL_crfD_5(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmplL_crfD_5(code, addr);
	}

	bool Op__spec__cmplL_crfD_6::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmplL_crfD_6::disasm( std::ostream& os)
	{
		{
			os << "cmpld " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmplL_crfD_6(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmplL_crfD_6(code, addr);
	}

	bool Op__spec__cmplL_crfD_7::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(cpu->GetGPR(ra)), b = U64(cpu->GetGPR(rb));

			// Generate CR[crfD] bit field
			CR& cr = cpu->GetCR();
			XER& xer = cpu->GetXER();
			switch(crfD)
			{
			case 0:
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(a < b);
				cr.Set<CR::CR0::GT>(a > b);
				cr.Set<CR::CR0::EQ>(a == b);
				break;
			case 1:
				cr.Set<CR::CR1::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR1::LT>(a < b);
				cr.Set<CR::CR1::GT>(a > b);
				cr.Set<CR::CR1::EQ>(a == b);
				break;
			case 2:
				cr.Set<CR::CR2::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR2::LT>(a < b);
				cr.Set<CR::CR2::GT>(a > b);
				cr.Set<CR::CR2::EQ>(a == b);
				break;
			case 3:
				cr.Set<CR::CR3::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR3::LT>(a < b);
				cr.Set<CR::CR3::GT>(a > b);
				cr.Set<CR::CR3::EQ>(a == b);
				break;
			case 4:
				cr.Set<CR::CR4::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR4::LT>(a < b);
				cr.Set<CR::CR4::GT>(a > b);
				cr.Set<CR::CR4::EQ>(a == b);
				break;
			case 5:
				cr.Set<CR::CR5::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR5::LT>(a < b);
				cr.Set<CR::CR5::GT>(a > b);
				cr.Set<CR::CR5::EQ>(a == b);
				break;
			case 6:
				cr.Set<CR::CR6::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR6::LT>(a < b);
				cr.Set<CR::CR6::GT>(a > b);
				cr.Set<CR::CR6::EQ>(a == b);
				break;
			case 7:
				cr.Set<CR::CR7::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR7::LT>(a < b);
				cr.Set<CR::CR7::GT>(a > b);
				cr.Set<CR::CR7::EQ>(a == b);
				break;
			}

			return true;
	}}
	void Op__spec__cmplL_crfD_7::disasm( std::ostream& os)
	{
		{
			os << "cmpld " << CRPrint(crfD) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__cmplL_crfD_7(CodeType code, uint64_t addr)
	{
		return new Op__spec__cmplL_crfD_7(code, addr);
	}

	bool Op__spec__cntlzw_rc_0::execute( Arch* cpu)
	{
		{
			// read the input operands
			U32 s = U32(cpu->GetGPR(rs));

			// Compute the result
			U32 result = ConditionalMove(s != U32(0), U32(31) - BitScanReverse(s), U32(32));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(false);
				cr.Set<CR::CR0::GT>(result > U32(0));
				cr.Set<CR::CR0::EQ>(result == U32(0));
			}

			return true;
	}}
	void Op__spec__cntlzw_rc_0::disasm( std::ostream& os)
	{
		{
			os << "cntlzw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__cntlzw_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__cntlzw_rc_0(code, addr);
	}

	bool Op__spec__cntlzw_rc_1::execute( Arch* cpu)
	{
		{
			// read the input operands
			U32 s = U32(cpu->GetGPR(rs));

			// Compute the result
			U32 result = ConditionalMove(s != U32(0), U32(31) - BitScanReverse(s), U32(32));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(false);
				cr.Set<CR::CR0::GT>(result > U32(0));
				cr.Set<CR::CR0::EQ>(result == U32(0));
			}

			return true;
	}}
	void Op__spec__cntlzw_rc_1::disasm( std::ostream& os)
	{
		{
			os << "cntlzw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__cntlzw_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__cntlzw_rc_1(code, addr);
	}

	bool Op__spec__cntlzd_rc_0::execute( Arch* cpu)
	{
		{
			// read the input operands
			U64 s = U64(cpu->GetGPR(rs));

			// Compute the result
			U64 result = ConditionalMove(s != U64(0), U64(63) - BitScanReverse(s), U64(64));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__cntlzd_rc_0::disasm( std::ostream& os)
	{
		{
			os << "cntlzd" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__cntlzd_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__cntlzd_rc_0(code, addr);
	}

	bool Op__spec__cntlzd_rc_1::execute( Arch* cpu)
	{
		{
			// read the input operands
			U64 s = U64(cpu->GetGPR(rs));

			// Compute the result
			U64 result = ConditionalMove(s != U64(0), U64(63) - BitScanReverse(s), U64(64));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__cntlzd_rc_1::disasm( std::ostream& os)
	{
		{
			os << "cntlzd" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__cntlzd_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__cntlzd_rc_1(code, addr);
	}

	bool Op__spec__divw_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S32( 0x80000000) and b == S32( -1)) or b == S32(0)))
			{
				// Compute the result
				res32 = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__divw_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "divw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divw_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__divw_rc_0_oe_0(code, addr);
	}

	bool Op__spec__divw_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S32( 0x80000000) and b == S32( -1)) or b == S32(0)))
			{
				// Compute the result
				res32 = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__divw_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "divw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divw_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__divw_rc_0_oe_1(code, addr);
	}

	bool Op__spec__divw_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S32( 0x80000000) and b == S32( -1)) or b == S32(0)))
			{
				// Compute the result
				res32 = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__divw_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "divw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divw_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__divw_rc_1_oe_0(code, addr);
	}

	bool Op__spec__divw_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S32( 0x80000000) and b == S32( -1)) or b == S32(0)))
			{
				// Compute the result
				res32 = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__divw_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "divw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divw_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__divw_rc_1_oe_1(code, addr);
	}

	bool Op__spec__divwu_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U32(0)))
			{
				// Compute the result
				res32 = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__divwu_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "divwu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divwu_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__divwu_rc_0_oe_0(code, addr);
	}

	bool Op__spec__divwu_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U32(0)))
			{
				// Compute the result
				res32 = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__divwu_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "divwu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divwu_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__divwu_rc_0_oe_1(code, addr);
	}

	bool Op__spec__divwu_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U32(0)))
			{
				// Compute the result
				res32 = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__divwu_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "divwu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divwu_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__divwu_rc_1_oe_0(code, addr);
	}

	bool Op__spec__divwu_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), res32;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U32(0)))
			{
				// Compute the result
				res32 = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				res32 = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__divwu_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "divwu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divwu_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__divwu_rc_1_oe_1(code, addr);
	}

	bool Op__spec__divd_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S64(0x8000000000000000ll) and b == S64(-1)) or b == S64(0)))
			{
				// Compute the result
				result = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__divd_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "divd" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divd_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__divd_rc_0_oe_0(code, addr);
	}

	bool Op__spec__divd_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S64(0x8000000000000000ll) and b == S64(-1)) or b == S64(0)))
			{
				// Compute the result
				result = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__divd_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "divd" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divd_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__divd_rc_0_oe_1(code, addr);
	}

	bool Op__spec__divd_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S64(0x8000000000000000ll) and b == S64(-1)) or b == S64(0)))
			{
				// Compute the result
				result = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__divd_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "divd" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divd_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__divd_rc_1_oe_0(code, addr);
	}

	bool Op__spec__divd_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely((a == S64(0x8000000000000000ll) and b == S64(-1)) or b == S64(0)))
			{
				// Compute the result
				result = DZResult( a , b );

				if (unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__divd_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "divd" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divd_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__divd_rc_1_oe_1(code, addr);
	}

	bool Op__spec__divdu_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U64(0)))
			{
				// Compute the result
				result = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b ;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__divdu_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "divdu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divdu_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__divdu_rc_0_oe_0(code, addr);
	}

	bool Op__spec__divdu_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U64(0)))
			{
				// Compute the result
				result = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b ;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__divdu_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "divdu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divdu_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__divdu_rc_0_oe_1(code, addr);
	}

	bool Op__spec__divdu_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U64(0)))
			{
				// Compute the result
				result = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b ;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__divdu_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "divdu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divdu_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__divdu_rc_1_oe_0(code, addr);
	}

	bool Op__spec__divdu_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) ), result;
			XER& xer = cpu->GetXER();

			if(unlikely(b == U64(0)))
			{
				// Compute the result
				result = DZResult( a, b );

				if(unlikely(oe))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(UINT(1));
					xer.Set<XER::SO>(UINT(1));
				}
			}
			else
			{
				// Compute the result
				result = a / b ;

				if(unlikely(oe))
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(UINT(0));
				}
			}

			// Write back the result
			cpu->SetGPR(rd, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__divdu_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "divdu" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__divdu_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__divdu_rc_1_oe_1(code, addr);
	}

	bool Op__spec__eqv_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ~(s ^ b);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__eqv_rc_0::disasm( std::ostream& os)
	{
		{
			os << "eqv" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__eqv_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__eqv_rc_0(code, addr);
	}

	bool Op__spec__eqv_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ~(s ^ b);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__eqv_rc_1::disasm( std::ostream& os)
	{
		{
			os << "eqv" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__eqv_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__eqv_rc_1(code, addr);
	}

	bool Op__spec__extsb_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S8 s = S8(cpu->GetGPR(rs));

			// Compute the result
			SINT result = SINT(s);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__extsb_rc_0::disasm( std::ostream& os)
	{
		{
			os << "extsb" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__extsb_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__extsb_rc_0(code, addr);
	}

	bool Op__spec__extsb_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S8 s = S8(cpu->GetGPR(rs));

			// Compute the result
			SINT result = SINT(s);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__extsb_rc_1::disasm( std::ostream& os)
	{
		{
			os << "extsb" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__extsb_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__extsb_rc_1(code, addr);
	}

	bool Op__spec__extsh_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S16 s = S16( cpu->GetGPR(rs));

			// Compute the result
			SINT result = SINT(s);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__extsh_rc_0::disasm( std::ostream& os)
	{
		{
			os << "extsh" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__extsh_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__extsh_rc_0(code, addr);
	}

	bool Op__spec__extsh_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S16 s = S16( cpu->GetGPR(rs));

			// Compute the result
			SINT result = SINT(s);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__extsh_rc_1::disasm( std::ostream& os)
	{
		{
			os << "extsh" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__extsh_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__extsh_rc_1(code, addr);
	}

	bool Op__spec__extsw_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 s = S32( cpu->GetGPR(rs));

			// Compute the result
			SINT result = SINT(s);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__extsw_rc_0::disasm( std::ostream& os)
	{
		{
			os << "extsw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__extsw_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__extsw_rc_0(code, addr);
	}

	bool Op__spec__extsw_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 s = S32( cpu->GetGPR(rs));

			// Compute the result
			SINT result = SINT(s);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				XER& xer = cpu->GetXER();

				CR& cr = cpu->GetCR();

				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__extsw_rc_1::disasm( std::ostream& os)
	{
		{
			os << "extsw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
	}}

	static Operation *DecodeOp__spec__extsw_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__extsw_rc_1(code, addr);
	}

	bool Op__spec__mcrxr_crfD_0::execute( Arch* cpu)
	{
		{
			XER& xer = cpu->GetXER();

			// Generate CR[crfD]: CR[crfD]=XER[0-3]
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(xer.Get<XER::_0_3>()); break;
				case 1: cr.Set<CR::CR1>(xer.Get<XER::_0_3>()); break;
				case 2: cr.Set<CR::CR2>(xer.Get<XER::_0_3>()); break;
				case 3: cr.Set<CR::CR3>(xer.Get<XER::_0_3>()); break;
				case 4: cr.Set<CR::CR4>(xer.Get<XER::_0_3>()); break;
				case 5: cr.Set<CR::CR5>(xer.Get<XER::_0_3>()); break;
				case 6: cr.Set<CR::CR6>(xer.Get<XER::_0_3>()); break;
				case 7: cr.Set<CR::CR7>(xer.Get<XER::_0_3>()); break;
			}
			// Reset XER[0-3]
			xer.Set<XER::_0_3>(0);

			return true;
	}}
	void Op__spec__mcrxr_crfD_0::disasm( std::ostream& os)
	{
		{
			os << "mcrxr " << CRPrint(crfD);
	}}

	static Operation *DecodeOp__spec__mcrxr_crfD_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mcrxr_crfD_0(code, addr);
	}

	bool Op__spec__mcrxr_crfD_1::execute( Arch* cpu)
	{
		{
			XER& xer = cpu->GetXER();

			// Generate CR[crfD]: CR[crfD]=XER[0-3]
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(xer.Get<XER::_0_3>()); break;
				case 1: cr.Set<CR::CR1>(xer.Get<XER::_0_3>()); break;
				case 2: cr.Set<CR::CR2>(xer.Get<XER::_0_3>()); break;
				case 3: cr.Set<CR::CR3>(xer.Get<XER::_0_3>()); break;
				case 4: cr.Set<CR::CR4>(xer.Get<XER::_0_3>()); break;
				case 5: cr.Set<CR::CR5>(xer.Get<XER::_0_3>()); break;
				case 6: cr.Set<CR::CR6>(xer.Get<XER::_0_3>()); break;
				case 7: cr.Set<CR::CR7>(xer.Get<XER::_0_3>()); break;
			}
			// Reset XER[0-3]
			xer.Set<XER::_0_3>(0);

			return true;
	}}
	void Op__spec__mcrxr_crfD_1::disasm( std::ostream& os)
	{
		{
			os << "mcrxr " << CRPrint(crfD);
	}}

	static Operation *DecodeOp__spec__mcrxr_crfD_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mcrxr_crfD_1(code, addr);
	}

	bool Op__spec__mcrxr_crfD_2::execute( Arch* cpu)
	{
		{
			XER& xer = cpu->GetXER();

			// Generate CR[crfD]: CR[crfD]=XER[0-3]
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(xer.Get<XER::_0_3>()); break;
				case 1: cr.Set<CR::CR1>(xer.Get<XER::_0_3>()); break;
				case 2: cr.Set<CR::CR2>(xer.Get<XER::_0_3>()); break;
				case 3: cr.Set<CR::CR3>(xer.Get<XER::_0_3>()); break;
				case 4: cr.Set<CR::CR4>(xer.Get<XER::_0_3>()); break;
				case 5: cr.Set<CR::CR5>(xer.Get<XER::_0_3>()); break;
				case 6: cr.Set<CR::CR6>(xer.Get<XER::_0_3>()); break;
				case 7: cr.Set<CR::CR7>(xer.Get<XER::_0_3>()); break;
			}
			// Reset XER[0-3]
			xer.Set<XER::_0_3>(0);

			return true;
	}}
	void Op__spec__mcrxr_crfD_2::disasm( std::ostream& os)
	{
		{
			os << "mcrxr " << CRPrint(crfD);
	}}

	static Operation *DecodeOp__spec__mcrxr_crfD_2(CodeType code, uint64_t addr)
	{
		return new Op__spec__mcrxr_crfD_2(code, addr);
	}

	bool Op__spec__mcrxr_crfD_3::execute( Arch* cpu)
	{
		{
			XER& xer = cpu->GetXER();

			// Generate CR[crfD]: CR[crfD]=XER[0-3]
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(xer.Get<XER::_0_3>()); break;
				case 1: cr.Set<CR::CR1>(xer.Get<XER::_0_3>()); break;
				case 2: cr.Set<CR::CR2>(xer.Get<XER::_0_3>()); break;
				case 3: cr.Set<CR::CR3>(xer.Get<XER::_0_3>()); break;
				case 4: cr.Set<CR::CR4>(xer.Get<XER::_0_3>()); break;
				case 5: cr.Set<CR::CR5>(xer.Get<XER::_0_3>()); break;
				case 6: cr.Set<CR::CR6>(xer.Get<XER::_0_3>()); break;
				case 7: cr.Set<CR::CR7>(xer.Get<XER::_0_3>()); break;
			}
			// Reset XER[0-3]
			xer.Set<XER::_0_3>(0);

			return true;
	}}
	void Op__spec__mcrxr_crfD_3::disasm( std::ostream& os)
	{
		{
			os << "mcrxr " << CRPrint(crfD);
	}}

	static Operation *DecodeOp__spec__mcrxr_crfD_3(CodeType code, uint64_t addr)
	{
		return new Op__spec__mcrxr_crfD_3(code, addr);
	}

	bool Op__spec__mcrxr_crfD_4::execute( Arch* cpu)
	{
		{
			XER& xer = cpu->GetXER();

			// Generate CR[crfD]: CR[crfD]=XER[0-3]
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(xer.Get<XER::_0_3>()); break;
				case 1: cr.Set<CR::CR1>(xer.Get<XER::_0_3>()); break;
				case 2: cr.Set<CR::CR2>(xer.Get<XER::_0_3>()); break;
				case 3: cr.Set<CR::CR3>(xer.Get<XER::_0_3>()); break;
				case 4: cr.Set<CR::CR4>(xer.Get<XER::_0_3>()); break;
				case 5: cr.Set<CR::CR5>(xer.Get<XER::_0_3>()); break;
				case 6: cr.Set<CR::CR6>(xer.Get<XER::_0_3>()); break;
				case 7: cr.Set<CR::CR7>(xer.Get<XER::_0_3>()); break;
			}
			// Reset XER[0-3]
			xer.Set<XER::_0_3>(0);

			return true;
	}}
	void Op__spec__mcrxr_crfD_4::disasm( std::ostream& os)
	{
		{
			os << "mcrxr " << CRPrint(crfD);
	}}

	static Operation *DecodeOp__spec__mcrxr_crfD_4(CodeType code, uint64_t addr)
	{
		return new Op__spec__mcrxr_crfD_4(code, addr);
	}

	bool Op__spec__mcrxr_crfD_5::execute( Arch* cpu)
	{
		{
			XER& xer = cpu->GetXER();

			// Generate CR[crfD]: CR[crfD]=XER[0-3]
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(xer.Get<XER::_0_3>()); break;
				case 1: cr.Set<CR::CR1>(xer.Get<XER::_0_3>()); break;
				case 2: cr.Set<CR::CR2>(xer.Get<XER::_0_3>()); break;
				case 3: cr.Set<CR::CR3>(xer.Get<XER::_0_3>()); break;
				case 4: cr.Set<CR::CR4>(xer.Get<XER::_0_3>()); break;
				case 5: cr.Set<CR::CR5>(xer.Get<XER::_0_3>()); break;
				case 6: cr.Set<CR::CR6>(xer.Get<XER::_0_3>()); break;
				case 7: cr.Set<CR::CR7>(xer.Get<XER::_0_3>()); break;
			}
			// Reset XER[0-3]
			xer.Set<XER::_0_3>(0);

			return true;
	}}
	void Op__spec__mcrxr_crfD_5::disasm( std::ostream& os)
	{
		{
			os << "mcrxr " << CRPrint(crfD);
	}}

	static Operation *DecodeOp__spec__mcrxr_crfD_5(CodeType code, uint64_t addr)
	{
		return new Op__spec__mcrxr_crfD_5(code, addr);
	}

	bool Op__spec__mcrxr_crfD_6::execute( Arch* cpu)
	{
		{
			XER& xer = cpu->GetXER();

			// Generate CR[crfD]: CR[crfD]=XER[0-3]
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(xer.Get<XER::_0_3>()); break;
				case 1: cr.Set<CR::CR1>(xer.Get<XER::_0_3>()); break;
				case 2: cr.Set<CR::CR2>(xer.Get<XER::_0_3>()); break;
				case 3: cr.Set<CR::CR3>(xer.Get<XER::_0_3>()); break;
				case 4: cr.Set<CR::CR4>(xer.Get<XER::_0_3>()); break;
				case 5: cr.Set<CR::CR5>(xer.Get<XER::_0_3>()); break;
				case 6: cr.Set<CR::CR6>(xer.Get<XER::_0_3>()); break;
				case 7: cr.Set<CR::CR7>(xer.Get<XER::_0_3>()); break;
			}
			// Reset XER[0-3]
			xer.Set<XER::_0_3>(0);

			return true;
	}}
	void Op__spec__mcrxr_crfD_6::disasm( std::ostream& os)
	{
		{
			os << "mcrxr " << CRPrint(crfD);
	}}

	static Operation *DecodeOp__spec__mcrxr_crfD_6(CodeType code, uint64_t addr)
	{
		return new Op__spec__mcrxr_crfD_6(code, addr);
	}

	bool Op__spec__mcrxr_crfD_7::execute( Arch* cpu)
	{
		{
			XER& xer = cpu->GetXER();

			// Generate CR[crfD]: CR[crfD]=XER[0-3]
			CR& cr = cpu->GetCR();
			switch(crfD)
			{
				case 0: cr.Set<CR::CR0>(xer.Get<XER::_0_3>()); break;
				case 1: cr.Set<CR::CR1>(xer.Get<XER::_0_3>()); break;
				case 2: cr.Set<CR::CR2>(xer.Get<XER::_0_3>()); break;
				case 3: cr.Set<CR::CR3>(xer.Get<XER::_0_3>()); break;
				case 4: cr.Set<CR::CR4>(xer.Get<XER::_0_3>()); break;
				case 5: cr.Set<CR::CR5>(xer.Get<XER::_0_3>()); break;
				case 6: cr.Set<CR::CR6>(xer.Get<XER::_0_3>()); break;
				case 7: cr.Set<CR::CR7>(xer.Get<XER::_0_3>()); break;
			}
			// Reset XER[0-3]
			xer.Set<XER::_0_3>(0);

			return true;
	}}
	void Op__spec__mcrxr_crfD_7::disasm( std::ostream& os)
	{
		{
			os << "mcrxr " << CRPrint(crfD);
	}}

	static Operation *DecodeOp__spec__mcrxr_crfD_7(CodeType code, uint64_t addr)
	{
		return new Op__spec__mcrxr_crfD_7(code, addr);
	}

	bool Op__spec__mulhw_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(S32(cpu->GetGPR(ra))), b = S64(S32(cpu->GetGPR(rb)));

			// Compute the result
			S32 res32( a*b >> 32 );

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__mulhw_rc_0::disasm( std::ostream& os)
	{
		{
			os << "mulhw" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulhw_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulhw_rc_0(code, addr);
	}

	bool Op__spec__mulhw_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(S32(cpu->GetGPR(ra))), b = S64(S32(cpu->GetGPR(rb)));

			// Compute the result
			S32 res32( a*b >> 32 );

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__mulhw_rc_1::disasm( std::ostream& os)
	{
		{
			os << "mulhw" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulhw_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulhw_rc_1(code, addr);
	}

	bool Op__spec__mulhwu_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(U32(cpu->GetGPR(ra))), b = U64(U32(cpu->GetGPR(rb)));

			// Compute the result
			U32 res32( a*b >> 32 );

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__mulhwu_rc_0::disasm( std::ostream& os)
	{
		{
			os << "mulhwu" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulhwu_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulhwu_rc_0(code, addr);
	}

	bool Op__spec__mulhwu_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a = U64(U32(cpu->GetGPR(ra))), b = U64(U32(cpu->GetGPR(rb)));

			// Compute the result
			U32 res32( a*b >> 32 );

			// Write back the result
			SINT result = SINT( U32(res32) ); // TODO: upper bits (0..31) are undefined
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__mulhwu_rc_1::disasm( std::ostream& os)
	{
		{
			os << "mulhwu" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulhwu_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulhwu_rc_1(code, addr);
	}

	bool Op__spec__mullw_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(S32(cpu->GetGPR(ra))), b = S64(S32(cpu->GetGPR(rb)));

			// Compute the result
			S64 result64 = a*b;
			SINT result( result64 );

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 64-bits product cannot be
				* represented as a signed 32-bits result. */
				UINT overflow = UINT(result64 != S64(S32(result64)));
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__mullw_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "mullw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mullw_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mullw_rc_0_oe_0(code, addr);
	}

	bool Op__spec__mullw_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(S32(cpu->GetGPR(ra))), b = S64(S32(cpu->GetGPR(rb)));

			// Compute the result
			S64 result64 = a*b;
			SINT result( result64 );

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 64-bits product cannot be
				* represented as a signed 32-bits result. */
				UINT overflow = UINT(result64 != S64(S32(result64)));
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__mullw_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "mullw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mullw_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mullw_rc_0_oe_1(code, addr);
	}

	bool Op__spec__mullw_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(S32(cpu->GetGPR(ra))), b = S64(S32(cpu->GetGPR(rb)));

			// Compute the result
			S64 result64 = a*b;
			SINT result( result64 );

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 64-bits product cannot be
				* represented as a signed 32-bits result. */
				UINT overflow = UINT(result64 != S64(S32(result64)));
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__mullw_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "mullw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mullw_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mullw_rc_1_oe_0(code, addr);
	}

	bool Op__spec__mullw_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a = S64(S32(cpu->GetGPR(ra))), b = S64(S32(cpu->GetGPR(rb)));

			// Compute the result
			S64 result64 = a*b;
			SINT result( result64 );

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 64-bits product cannot be
				* represented as a signed 32-bits result. */
				UINT overflow = UINT(result64 != S64(S32(result64)));
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(result == SINT(0));
			}

			return true;
	}}
	void Op__spec__mullw_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "mullw" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mullw_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mullw_rc_1_oe_1(code, addr);
	}

	bool Op__spec__mulhd_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			S64 result = SignedMultiplyHigh(a, b);

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__mulhd_rc_0::disasm( std::ostream& os)
	{
		{
			os << "mulhd" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulhd_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulhd_rc_0(code, addr);
	}

	bool Op__spec__mulhd_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			S64 result = SignedMultiplyHigh(a, b);

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__mulhd_rc_1::disasm( std::ostream& os)
	{
		{
			os << "mulhd" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulhd_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulhd_rc_1(code, addr);
	}

	bool Op__spec__mulhdu_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			U64 result = UnsignedMultiplyHigh(a, b);

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__mulhdu_rc_0::disasm( std::ostream& os)
	{
		{
			os << "mulhdu" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulhdu_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulhdu_rc_0(code, addr);
	}

	bool Op__spec__mulhdu_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			U64 result = UnsignedMultiplyHigh(a, b);

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__mulhdu_rc_1::disasm( std::ostream& os)
	{
		{
			os << "mulhdu" << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulhdu_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulhdu_rc_1(code, addr);
	}

	bool Op__spec__mulld_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			S64 result = a*b;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 128-bits product cannot be
				* represented as a signed 64-bits result.
				*/
				S64 high( SignedMultiplyHigh(a, b) );
				UINT overflow = UINT((result >> 63) != high);
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__mulld_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "mulld" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulld_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulld_rc_0_oe_0(code, addr);
	}

	bool Op__spec__mulld_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			S64 result = a*b;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 128-bits product cannot be
				* represented as a signed 64-bits result.
				*/
				S64 high( SignedMultiplyHigh(a, b) );
				UINT overflow = UINT((result >> 63) != high);
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__mulld_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "mulld" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulld_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulld_rc_0_oe_1(code, addr);
	}

	bool Op__spec__mulld_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			S64 result = a*b;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 128-bits product cannot be
				* represented as a signed 64-bits result.
				*/
				S64 high( SignedMultiplyHigh(a, b) );
				UINT overflow = UINT((result >> 63) != high);
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__mulld_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "mulld" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulld_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulld_rc_1_oe_0(code, addr);
	}

	bool Op__spec__mulld_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 a( cpu->GetGPR(ra) ), b( cpu->GetGPR(rb) );

			// Compute the result
			S64 result = a*b;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(oe)
			{
				/* Overflow if the signed 128-bits product cannot be
				* represented as a signed 64-bits result.
				*/
				S64 high( SignedMultiplyHigh(a, b) );
				UINT overflow = UINT((result >> 63) != high);
				// Generate XER[OV] and XER[SO]: XER[OV]=overflow XER[SO]=1
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__mulld_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "mulld" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__mulld_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mulld_rc_1_oe_1(code, addr);
	}

	bool Op__spec__nand_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs);
			UINT b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ~(s & b);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__nand_rc_0::disasm( std::ostream& os)
	{
		{
			os << "nand" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__nand_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__nand_rc_0(code, addr);
	}

	bool Op__spec__nand_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs);
			UINT b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ~(s & b);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__nand_rc_1::disasm( std::ostream& os)
	{
		{
			os << "nand" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__nand_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__nand_rc_1(code, addr);
	}

	bool Op__spec__neg_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra));

			// Compute the result
			SINT result = -a; // 2's complement of a: (~a) + 1;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(oe))
			{
				XER& xer = cpu->GetXER();
				/* Overflow occur with the most negative number */
				SINT const mnn = SINT(~(UINT(-1) >> 1));
				if(unlikely(a == mnn))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(1);
					xer.Set<XER::SO>(1);
				}
				else
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(0);
				}
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(UINT(result) == UINT(0));
			}

			return true;
	}}
	void Op__spec__neg_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "neg" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__neg_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__neg_rc_0_oe_0(code, addr);
	}

	bool Op__spec__neg_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra));

			// Compute the result
			SINT result = -a; // 2's complement of a: (~a) + 1;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(oe))
			{
				XER& xer = cpu->GetXER();
				/* Overflow occur with the most negative number */
				SINT const mnn = SINT(~(UINT(-1) >> 1));
				if(unlikely(a == mnn))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(1);
					xer.Set<XER::SO>(1);
				}
				else
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(0);
				}
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(UINT(result) == UINT(0));
			}

			return true;
	}}
	void Op__spec__neg_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "neg" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__neg_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__neg_rc_0_oe_1(code, addr);
	}

	bool Op__spec__neg_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra));

			// Compute the result
			SINT result = -a; // 2's complement of a: (~a) + 1;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(oe))
			{
				XER& xer = cpu->GetXER();
				/* Overflow occur with the most negative number */
				SINT const mnn = SINT(~(UINT(-1) >> 1));
				if(unlikely(a == mnn))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(1);
					xer.Set<XER::SO>(1);
				}
				else
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(0);
				}
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(UINT(result) == UINT(0));
			}

			return true;
	}}
	void Op__spec__neg_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "neg" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__neg_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__neg_rc_1_oe_0(code, addr);
	}

	bool Op__spec__neg_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra));

			// Compute the result
			SINT result = -a; // 2's complement of a: (~a) + 1;

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			if(unlikely(oe))
			{
				XER& xer = cpu->GetXER();
				/* Overflow occur with the most negative number */
				SINT const mnn = SINT(~(UINT(-1) >> 1));
				if(unlikely(a == mnn))
				{
					// Generate XER[OV] and XER[SO]: XER[OV]=1 XER[SO]=1
					xer.Set<XER::OV>(1);
					xer.Set<XER::SO>(1);
				}
				else
				{
					// Generate XER[OV]: XER[OV]=0
					xer.Set<XER::OV>(0);
				}
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>(UINT(result) == UINT(0));
			}

			return true;
	}}
	void Op__spec__neg_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "neg" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__neg_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__neg_rc_1_oe_1(code, addr);
	}

	bool Op__spec__nor_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ~(s | b);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT( result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT( result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__nor_rc_0::disasm( std::ostream& os)
	{
		{
			if(rs == rb)
			os << "not" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
			else
			os << "nor" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__nor_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__nor_rc_0(code, addr);
	}

	bool Op__spec__nor_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = ~(s | b);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT( result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT( result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__nor_rc_1::disasm( std::ostream& os)
	{
		{
			if(rs == rb)
			os << "not" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
			else
			os << "nor" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__nor_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__nor_rc_1(code, addr);
	}

	bool Op__spec__orc_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s | ~b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__orc_rc_0::disasm( std::ostream& os)
	{
		{
			os << "orc" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__orc_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__orc_rc_0(code, addr);
	}

	bool Op__spec__orc_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s | ~b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__orc_rc_1::disasm( std::ostream& os)
	{
		{
			os << "orc" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__orc_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__orc_rc_1(code, addr);
	}

	bool Op__spec__or_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s | b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__or_rc_0::disasm( std::ostream& os)
	{
		{
			if(rs == rb)
			os << "mr" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
			else
			os << "or" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__or_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__or_rc_0(code, addr);
	}

	bool Op__spec__or_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s | b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__or_rc_1::disasm( std::ostream& os)
	{
		{
			if(rs == rb)
			os << "mr" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs);
			else
			os << "or" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__or_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__or_rc_1(code, addr);
	}

	bool Op__spec__rlwimi_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s( cpu->GetGPR(rs) );
			UINT const m( Mask64(mb+32, me+32) ), a( cpu->GetGPR(ra) );

			// Compute the result
			UINT result = (RotL32(s, U8(sh)) & m) | (a & ~m);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__rlwimi_rc_0::disasm( std::ostream& os)
	{
		{
			os << "rlwimi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh) << ", " << unsigned(mb) << ", " << unsigned(me);
	}}

	static Operation *DecodeOp__spec__rlwimi_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__rlwimi_rc_0(code, addr);
	}

	bool Op__spec__rlwimi_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s( cpu->GetGPR(rs) );
			UINT const m( Mask64(mb+32, me+32) ), a( cpu->GetGPR(ra) );

			// Compute the result
			UINT result = (RotL32(s, U8(sh)) & m) | (a & ~m);

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__rlwimi_rc_1::disasm( std::ostream& os)
	{
		{
			os << "rlwimi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh) << ", " << unsigned(mb) << ", " << unsigned(me);
	}}

	static Operation *DecodeOp__spec__rlwimi_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__rlwimi_rc_1(code, addr);
	}

	bool Op__spec__rlwinm_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s( cpu->GetGPR(rs) );
			UINT const m( Mask64(mb+32, me+32) );

			// Compute the result
			UINT result = RotL32(s, U8(sh)) & m;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__rlwinm_rc_0::disasm( std::ostream& os)
	{
		{
			os << "rlwinm" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh) << ", " << unsigned(mb) << ", " << unsigned(me);
	}}

	static Operation *DecodeOp__spec__rlwinm_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__rlwinm_rc_0(code, addr);
	}

	bool Op__spec__rlwinm_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s( cpu->GetGPR(rs) );
			UINT const m( Mask64(mb+32, me+32) );

			// Compute the result
			UINT result = RotL32(s, U8(sh)) & m;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__rlwinm_rc_1::disasm( std::ostream& os)
	{
		{
			os << "rlwinm" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh) << ", " << unsigned(mb) << ", " << unsigned(me);
	}}

	static Operation *DecodeOp__spec__rlwinm_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__rlwinm_rc_1(code, addr);
	}

	bool Op__spec__rlwnm_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s( cpu->GetGPR(rs) );
			U8 n( cpu->GetGPR(rb) & UINT(0x1f) );
			UINT const m( Mask64(mb+32, me+32) );

			// Compute the result
			UINT result = RotL32(s, n) & m;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__rlwnm_rc_0::disasm( std::ostream& os)
	{
		{
			os << "rlwnm" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb) << ", " << unsigned(mb) << ", " << unsigned(me);
	}}

	static Operation *DecodeOp__spec__rlwnm_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__rlwnm_rc_0(code, addr);
	}

	bool Op__spec__rlwnm_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s( cpu->GetGPR(rs) );
			U8 n( cpu->GetGPR(rb) & UINT(0x1f) );
			UINT const m( Mask64(mb+32, me+32) );

			// Compute the result
			UINT result = RotL32(s, n) & m;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__rlwnm_rc_1::disasm( std::ostream& os)
	{
		{
			os << "rlwnm" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb) << ", " << unsigned(mb) << ", " << unsigned(me);
	}}

	static Operation *DecodeOp__spec__rlwnm_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__rlwnm_rc_1(code, addr);
	}

	bool Op__spec__rldicl_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64(uint64_t(-1) >> mb);

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldicl_rc_0::disasm( std::ostream& os)
	{
		{
			os << "rldicl" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << int(n) << ',' << int(mb);
	}}

	static Operation *DecodeOp__spec__rldicl_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldicl_rc_0(code, addr);
	}

	bool Op__spec__rldicl_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64(uint64_t(-1) >> mb);

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldicl_rc_1::disasm( std::ostream& os)
	{
		{
			os << "rldicl" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << int(n) << ',' << int(mb);
	}}

	static Operation *DecodeOp__spec__rldicl_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldicl_rc_1(code, addr);
	}

	bool Op__spec__rldicr_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64(uint64_t(-1) << (me ^ 63));

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldicr_rc_0::disasm( std::ostream& os)
	{
		{
			os << "rldicr" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << int(n) << ',' << int(me);
	}}

	static Operation *DecodeOp__spec__rldicr_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldicr_rc_0(code, addr);
	}

	bool Op__spec__rldicr_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64(uint64_t(-1) << (me ^ 63));

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldicr_rc_1::disasm( std::ostream& os)
	{
		{
			os << "rldicr" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << int(n) << ',' << int(me);
	}}

	static Operation *DecodeOp__spec__rldicr_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldicr_rc_1(code, addr);
	}

	bool Op__spec__rldic_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64( Mask64(mb, n^63) );

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldic_rc_0::disasm( std::ostream& os)
	{
		{
			os << "rldic" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << int(n) << ',' << int(mb);
	}}

	static Operation *DecodeOp__spec__rldic_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldic_rc_0(code, addr);
	}

	bool Op__spec__rldic_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64( Mask64(mb, n^63) );

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldic_rc_1::disasm( std::ostream& os)
	{
		{
			os << "rldic" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << int(n) << ',' << int(mb);
	}}

	static Operation *DecodeOp__spec__rldic_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldic_rc_1(code, addr);
	}

	bool Op__spec__rldcl_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );
			U8  n( cpu->GetGPR(rb) & U64(0x3f) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64(uint64_t(-1) >> mb);

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldcl_rc_0::disasm( std::ostream& os)
	{
		{
			os << "rldcl" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << GPRPrint(rb) << ',' << int(mb);
	}}

	static Operation *DecodeOp__spec__rldcl_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldcl_rc_0(code, addr);
	}

	bool Op__spec__rldcl_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );
			U8  n( cpu->GetGPR(rb) & U64(0x3f) );

			// Compute the result
			U64 result = RotateLeft(s, n) & U64(uint64_t(-1) >> mb);

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldcl_rc_1::disasm( std::ostream& os)
	{
		{
			os << "rldcl" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << GPRPrint(rb) << ',' << int(mb);
	}}

	static Operation *DecodeOp__spec__rldcl_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldcl_rc_1(code, addr);
	}

	bool Op__spec__rldcr_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );
			U8  n( cpu->GetGPR(rb) & UINT(0x3f) );

			// Compute the result
			U64 result( RotateLeft(s, n) & U64(uint64_t(-1) << (me^63)) );

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldcr_rc_0::disasm( std::ostream& os)
	{
		{
			os << "rldcr" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << GPRPrint(rb) << ',' << int(me);
	}}

	static Operation *DecodeOp__spec__rldcr_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldcr_rc_0(code, addr);
	}

	bool Op__spec__rldcr_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );
			U8  n( cpu->GetGPR(rb) & UINT(0x3f) );

			// Compute the result
			U64 result( RotateLeft(s, n) & U64(uint64_t(-1) << (me^63)) );

			// Write back the result
			cpu->SetGPR(ra, result);

			if (unlikely(rc))
			{
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__rldcr_rc_1::disasm( std::ostream& os)
	{
		{
			os << "rldcr" << (rc ? "." : "") << ' ' << GPRPrint(ra) << ',' << GPRPrint(rs) << ',' << GPRPrint(rb) << ',' << int(me);
	}}

	static Operation *DecodeOp__spec__rldcr_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldcr_rc_1(code, addr);
	}

	bool Op__spec__rldimi_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );
			U64 const m( Mask64(mb,sh^63) ),  a( cpu->GetGPR(ra) );

			// Compute the result
			U64 result( (RotateLeft(s, sh) & m) | (a & ~m) );

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__rldimi_rc_0::disasm( std::ostream& os)
	{
		{
			os << "rldimi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh) << ", " << unsigned(mb);
	}}

	static Operation *DecodeOp__spec__rldimi_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldimi_rc_0(code, addr);
	}

	bool Op__spec__rldimi_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s( cpu->GetGPR(rs) );
			U64 const m( Mask64(mb,sh^63) ),  a( cpu->GetGPR(ra) );

			// Compute the result
			U64 result( (RotateLeft(s, sh) & m) | (a & ~m) );

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__rldimi_rc_1::disasm( std::ostream& os)
	{
		{
			os << "rldimi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh) << ", " << unsigned(mb);
	}}

	static Operation *DecodeOp__spec__rldimi_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__rldimi_rc_1(code, addr);
	}

	bool Op__spec__slw_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 s = U32(cpu->GetGPR(rs));
			U8 b = U8(cpu->GetGPR(rb)) & U8(0x3f);

			// Compute the result
			U32 result = ConditionalMove(b > U8(0x1f), U32(0), (s << b));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result)  < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result)  > SINT(0));
				cr.Set<CR::CR0::EQ>(SINT(result) == SINT(0));
			}

			return true;
	}}
	void Op__spec__slw_rc_0::disasm( std::ostream& os)
	{
		{
			os << "slw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__slw_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__slw_rc_0(code, addr);
	}

	bool Op__spec__slw_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 s = U32(cpu->GetGPR(rs));
			U8 b = U8(cpu->GetGPR(rb)) & U8(0x3f);

			// Compute the result
			U32 result = ConditionalMove(b > U8(0x1f), U32(0), (s << b));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result)  < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result)  > SINT(0));
				cr.Set<CR::CR0::EQ>(SINT(result) == SINT(0));
			}

			return true;
	}}
	void Op__spec__slw_rc_1::disasm( std::ostream& os)
	{
		{
			os << "slw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__slw_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__slw_rc_1(code, addr);
	}

	bool Op__spec__srawi_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 s = S32(  cpu->GetGPR(rs) );

			// Compute the result
			S32 result = s >> sh;

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S32(0)) and ((s & S32(shifted_out)) != S32(0)));
			//xer.Set<XER::CA>((s < S32(0)) and (s != (result << sh)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S32(0));
				cr.Set<CR::CR0::GT>(result > S32(0));
				cr.Set<CR::CR0::EQ>(result == S32(0));
			}

			return true;
	}}
	void Op__spec__srawi_rc_0::disasm( std::ostream& os)
	{
		{
			os << "srawi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh);
	}}

	static Operation *DecodeOp__spec__srawi_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__srawi_rc_0(code, addr);
	}

	bool Op__spec__srawi_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 s = S32(  cpu->GetGPR(rs) );

			// Compute the result
			S32 result = s >> sh;

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S32(0)) and ((s & S32(shifted_out)) != S32(0)));
			//xer.Set<XER::CA>((s < S32(0)) and (s != (result << sh)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S32(0));
				cr.Set<CR::CR0::GT>(result > S32(0));
				cr.Set<CR::CR0::EQ>(result == S32(0));
			}

			return true;
	}}
	void Op__spec__srawi_rc_1::disasm( std::ostream& os)
	{
		{
			os << "srawi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh);
	}}

	static Operation *DecodeOp__spec__srawi_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__srawi_rc_1(code, addr);
	}

	bool Op__spec__sraw_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 s = S32(cpu->GetGPR(rs));
			U8 b = U8(cpu->GetGPR(rb)) & U8(0x3f);

			// Compute the result
			S32 result, shifted_out;
			if (unlikely(b > U8(0x1f)))
			{
				result = s >> 31;
				shifted_out = S32(-1);
			}
			else
			{
				result = s >> b;
				shifted_out = ((S32(1) << b) - S32( 1));
			}

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S32(0)) and ((s & shifted_out) != S32(0)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S32(0));
				cr.Set<CR::CR0::GT>(result > S32(0));
				cr.Set<CR::CR0::EQ>(result == S32(0));
			}

			return true;
	}}
	void Op__spec__sraw_rc_0::disasm( std::ostream& os)
	{
		{
			os << "sraw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__sraw_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__sraw_rc_0(code, addr);
	}

	bool Op__spec__sraw_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S32 s = S32(cpu->GetGPR(rs));
			U8 b = U8(cpu->GetGPR(rb)) & U8(0x3f);

			// Compute the result
			S32 result, shifted_out;
			if (unlikely(b > U8(0x1f)))
			{
				result = s >> 31;
				shifted_out = S32(-1);
			}
			else
			{
				result = s >> b;
				shifted_out = ((S32(1) << b) - S32( 1));
			}

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S32(0)) and ((s & shifted_out) != S32(0)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S32(0));
				cr.Set<CR::CR0::GT>(result > S32(0));
				cr.Set<CR::CR0::EQ>(result == S32(0));
			}

			return true;
	}}
	void Op__spec__sraw_rc_1::disasm( std::ostream& os)
	{
		{
			os << "sraw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__sraw_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__sraw_rc_1(code, addr);
	}

	bool Op__spec__srw_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 s = U32(cpu->GetGPR(rs));
			U8  b = U8(cpu->GetGPR(rb)) & U8(0x3f);

			// Compute the result
			U32 result = ConditionalMove(b > U8(0x1f), U32(0), (s >> b));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result)  < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result)  > SINT(0));
				cr.Set<CR::CR0::EQ>(SINT(result) == SINT(0));
			}

			return true;
	}}
	void Op__spec__srw_rc_0::disasm( std::ostream& os)
	{
		{
			os << "srw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__srw_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__srw_rc_0(code, addr);
	}

	bool Op__spec__srw_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U32 s = U32(cpu->GetGPR(rs));
			U8  b = U8(cpu->GetGPR(rb)) & U8(0x3f);

			// Compute the result
			U32 result = ConditionalMove(b > U8(0x1f), U32(0), (s >> b));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT(result)  < SINT(0));
				cr.Set<CR::CR0::GT>(SINT(result)  > SINT(0));
				cr.Set<CR::CR0::EQ>(SINT(result) == SINT(0));
			}

			return true;
	}}
	void Op__spec__srw_rc_1::disasm( std::ostream& os)
	{
		{
			os << "srw" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__srw_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__srw_rc_1(code, addr);
	}

	bool Op__spec__sld_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s = U64(cpu->GetGPR(rs));
			U8 b = U8(cpu->GetGPR(rb)) & U8(0x7f);

			// Compute the result
			U64 result = unlikely(b > U8(0x3f)) ? U64(0) : (s << b);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__sld_rc_0::disasm( std::ostream& os)
	{
		{
			os << "sld" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__sld_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__sld_rc_0(code, addr);
	}

	bool Op__spec__sld_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s = U64(cpu->GetGPR(rs));
			U8 b = U8(cpu->GetGPR(rb)) & U8(0x7f);

			// Compute the result
			U64 result = unlikely(b > U8(0x3f)) ? U64(0) : (s << b);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__sld_rc_1::disasm( std::ostream& os)
	{
		{
			os << "sld" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__sld_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__sld_rc_1(code, addr);
	}

	bool Op__spec__sradi_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 s = S64( cpu->GetGPR(rs) );

			// Compute the result
			S64 result = s >> sh, shifted_out( (int64_t(1) << sh) - 1 );

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S64(0)) and ((s & shifted_out) != S64(0)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__sradi_rc_0::disasm( std::ostream& os)
	{
		{
			os << "sradi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh);
	}}

	static Operation *DecodeOp__spec__sradi_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__sradi_rc_0(code, addr);
	}

	bool Op__spec__sradi_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 s = S64( cpu->GetGPR(rs) );

			// Compute the result
			S64 result = s >> sh, shifted_out( (int64_t(1) << sh) - 1 );

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S64(0)) and ((s & shifted_out) != S64(0)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__sradi_rc_1::disasm( std::ostream& os)
	{
		{
			os << "sradi" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << unsigned(sh);
	}}

	static Operation *DecodeOp__spec__sradi_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__sradi_rc_1(code, addr);
	}

	bool Op__spec__srad_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 s = S64(cpu->GetGPR(rs));
			U8  b = U8(cpu->GetGPR(rb)) & U8(0x7f);

			// Compute the result
			S64 result, shifted_out;
			if (unlikely(b > U8(0x3f)))
			{
				result = s >> 63;
				shifted_out = S64(-1);
			}
			else
			{
				result = s >> b;
				shifted_out = ((S64(1) << b) - S64( 1));
			}

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S64(0)) and ((s & shifted_out) != S64(0)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__srad_rc_0::disasm( std::ostream& os)
	{
		{
			os << "srad" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__srad_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__srad_rc_0(code, addr);
	}

	bool Op__spec__srad_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			S64 s = S64(cpu->GetGPR(rs));
			U8  b = U8(cpu->GetGPR(rb)) & U8(0x7f);

			// Compute the result
			S64 result, shifted_out;
			if (unlikely(b > U8(0x3f)))
			{
				result = s >> 63;
				shifted_out = S64(-1);
			}
			else
			{
				result = s >> b;
				shifted_out = ((S64(1) << b) - S64( 1));
			}

			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>((s < S64(0)) and ((s & shifted_out) != S64(0)));

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < S64(0));
				cr.Set<CR::CR0::GT>(result > S64(0));
				cr.Set<CR::CR0::EQ>(result == S64(0));
			}

			return true;
	}}
	void Op__spec__srad_rc_1::disasm( std::ostream& os)
	{
		{
			os << "srad" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__srad_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__srad_rc_1(code, addr);
	}

	bool Op__spec__srd_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s = U64(cpu->GetGPR(rs));
			U8  b = U8(cpu->GetGPR(rb)) & U8(0x7f);

			// Compute the result
			U64 result = unlikely(b > U8(0x3f)) ? U64(0) : (s >> b);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__srd_rc_0::disasm( std::ostream& os)
	{
		{
			os << "srd" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__srd_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__srd_rc_0(code, addr);
	}

	bool Op__spec__srd_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			U64 s = U64(cpu->GetGPR(rs));
			U8  b = U8(cpu->GetGPR(rb)) & U8(0x7f);

			// Compute the result
			U64 result = unlikely(b > U8(0x3f)) ? U64(0) : (s >> b);

			// Write back the result
			cpu->SetGPR(ra, UINT(result));

			if(unlikely(rc))
			{
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(S64(result) < S64(0));
				cr.Set<CR::CR0::GT>(S64(result) > S64(0));
				cr.Set<CR::CR0::EQ>(result == U64(0));
			}

			return true;
	}}
	void Op__spec__srd_rc_1::disasm( std::ostream& os)
	{
		{
			os << "srd" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__srd_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__srd_rc_1(code, addr);
	}

	bool Op__spec__stwu_rs_1_ra_1::execute( Arch* cpu)
	{
		{
			if(unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea( cpu->GetGPR(ra) + UINT(d) );
			// do the memory access
			if(unlikely(not cpu->Int32Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void Op__spec__stwu_rs_1_ra_1::disasm( std::ostream& os)
	{
		{
			os << "stwu " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOp__spec__stwu_rs_1_ra_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__stwu_rs_1_ra_1(code, addr);
	}

	bool Op__spec__stdu_rs_1_ra_1::execute( Arch* cpu)
	{
		{
			if (unlikely(ra == 0))
			{
				cpu->ThrowException<CPU::ProgramInterrupt::IllegalInstruction>();
				return false;
			}
			// compute the effective address
			ADDRESS ea = (cpu->GetGPR(ra) + UINT(SINT(d)));
			// do the memory access
			if (unlikely(not cpu->Int64Store(rs, ea))) return false;
			// update the address register
			cpu->SetGPR(ra, ea);

			return true;
	}}
	void Op__spec__stdu_rs_1_ra_1::disasm( std::ostream& os)
	{
		{
			os << "stdu " << GPRPrint(rs) << ", " << EAPrint(d,ra);
	}}

	static Operation *DecodeOp__spec__stdu_rs_1_ra_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__stdu_rs_1_ra_1(code, addr);
	}

	bool Op__spec__subfc_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(b) >= UINT(a));

			if (unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfc_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subfc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subfc_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfc_rc_0_oe_0(code, addr);
	}

	bool Op__spec__subfc_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(b) >= UINT(a));

			if (unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfc_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subfc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subfc_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfc_rc_0_oe_1(code, addr);
	}

	bool Op__spec__subfc_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(b) >= UINT(a));

			if (unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfc_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subfc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subfc_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfc_rc_1_oe_0(code, addr);
	}

	bool Op__spec__subfc_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			// Generate XER[CA]
			XER& xer = cpu->GetXER();
			xer.Set<XER::CA>(UINT(b) >= UINT(a));

			if (unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if (unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfc_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subfc" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subfc_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfc_rc_1_oe_1(code, addr);
	}

	bool Op__spec__subfe_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			BOOL borrow = not BOOL(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(ConditionalMove(borrow, UINT(b) > UINT(a), UINT(b) >= UINT(a)));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT(ConditionalMove(borrow, b <= a, b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfe_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subfe" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subfe_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfe_rc_0_oe_0(code, addr);
	}

	bool Op__spec__subfe_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			BOOL borrow = not BOOL(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(ConditionalMove(borrow, UINT(b) > UINT(a), UINT(b) >= UINT(a)));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT(ConditionalMove(borrow, b <= a, b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfe_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subfe" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subfe_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfe_rc_0_oe_1(code, addr);
	}

	bool Op__spec__subfe_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			BOOL borrow = not BOOL(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(ConditionalMove(borrow, UINT(b) > UINT(a), UINT(b) >= UINT(a)));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT(ConditionalMove(borrow, b <= a, b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfe_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subfe" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subfe_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfe_rc_1_oe_0(code, addr);
	}

	bool Op__spec__subfe_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			BOOL borrow = not BOOL(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(ConditionalMove(borrow, UINT(b) > UINT(a), UINT(b) >= UINT(a)));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT(ConditionalMove(borrow, b <= a, b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfe_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subfe" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subfe_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfe_rc_1_oe_1(code, addr);
	}

	bool Op__spec__subf_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subf_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subf" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subf_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subf_rc_0_oe_0(code, addr);
	}

	bool Op__spec__subf_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subf_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subf" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subf_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subf_rc_0_oe_1(code, addr);
	}

	bool Op__spec__subf_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subf_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subf" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subf_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subf_rc_1_oe_0(code, addr);
	}

	bool Op__spec__subf_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(cpu->GetGPR(rb));

			// Compute the result
			SINT result = b - a;

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				XER& xer = cpu->GetXER();
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subf_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subf" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__subf_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subf_rc_1_oe_1(code, addr);
	}

	bool Op__spec__subfme_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfme_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subfme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__subfme_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfme_rc_0_oe_0(code, addr);
	}

	bool Op__spec__subfme_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfme_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subfme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__subfme_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfme_rc_0_oe_1(code, addr);
	}

	bool Op__spec__subfme_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfme_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subfme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__subfme_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfme_rc_1_oe_0(code, addr);
	}

	bool Op__spec__subfme_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(-1);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfme_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subfme" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__subfme_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfme_rc_1_oe_1(code, addr);
	}

	bool Op__spec__subfze_rc_0_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfze_rc_0_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subfze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__subfze_rc_0_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfze_rc_0_oe_0(code, addr);
	}

	bool Op__spec__subfze_rc_0_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfze_rc_0_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subfze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__subfze_rc_0_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfze_rc_0_oe_1(code, addr);
	}

	bool Op__spec__subfze_rc_1_oe_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfze_rc_1_oe_0::disasm( std::ostream& os)
	{
		{
			os << "subfze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__subfze_rc_1_oe_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfze_rc_1_oe_0(code, addr);
	}

	bool Op__spec__subfze_rc_1_oe_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			XER& xer = cpu->GetXER();
			bool borrow = not evenly(xer.Get<XER::CA>());
			SINT a = SINT(cpu->GetGPR(ra)), b = SINT(0);

			// Compute the result
			SINT result = b - a - SINT(borrow);

			// Generate XER[CA]
			xer.Set<XER::CA>(borrow ? UINT(b) > UINT(a) : UINT(b) >= UINT(a));

			if(unlikely(oe))
			{
				// Overflow: expected result sign and actual result sign differs
				UINT overflow = UINT((borrow ? b <= a : b < a) xor (SINT(result) < SINT(0)));

				// Generate XER[OV] and XER[SO]
				xer.Set<XER::OV>(overflow);
				xer.Set<XER::SO>(xer.Get<XER::SO>() | overflow);
			}

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(cpu->GetXER().Get<XER::SO>());
				cr.Set<CR::CR0::LT>(result < SINT(0));
				cr.Set<CR::CR0::GT>(result > SINT(0));
				cr.Set<CR::CR0::EQ>((UINT(result) == UINT(0)));
			}

			// Write back the result
			cpu->SetGPR(rd, UINT(result));

			return true;
	}}
	void Op__spec__subfze_rc_1_oe_1::disasm( std::ostream& os)
	{
		{
			os << "subfze" << (oe ? "o" : "") << (rc ? "." : "") << " " << GPRPrint(rd) << ", " << GPRPrint(ra);
	}}

	static Operation *DecodeOp__spec__subfze_rc_1_oe_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__subfze_rc_1_oe_1(code, addr);
	}

	bool Op__spec__xor_rc_0::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s ^ b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT( result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT( result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__xor_rc_0::disasm( std::ostream& os)
	{
		{
			os << "xor" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__xor_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__xor_rc_0(code, addr);
	}

	bool Op__spec__xor_rc_1::execute( Arch* cpu)
	{
		{
			// Read the input operands
			UINT s = cpu->GetGPR(rs), b = cpu->GetGPR(rb);

			// Compute the result
			UINT result = s ^ b;

			// Write back the result
			cpu->SetGPR(ra, result);

			if(unlikely(rc))
			{
				// Generate CR0: CR0[SO]=XER[SO] CR0[LT]=(result<0) CR0[GT]=(result>0) CR0[EQ]=(result==0)
				XER& xer = cpu->GetXER();
				CR& cr = cpu->GetCR();
				cr.Set<CR::CR0::SO>(xer.Get<XER::SO>());
				cr.Set<CR::CR0::LT>(SINT( result) < SINT(0));
				cr.Set<CR::CR0::GT>(SINT( result) > SINT(0));
				cr.Set<CR::CR0::EQ>(result == UINT(0));
			}

			return true;
	}}
	void Op__spec__xor_rc_1::disasm( std::ostream& os)
	{
		{
			os << "xor" << (rc ? "." : "") << " " << GPRPrint(ra) << ", " << GPRPrint(rs) << ", " << GPRPrint(rb);
	}}

	static Operation *DecodeOp__spec__xor_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__xor_rc_1(code, addr);
	}

	bool Op__spec__fabs_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not BOOL(cpu->GetMSR().Get<CPU::MSR::FP>())))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			SoftDouble result( cpu->GetFPR(fb) );

			// Compute the result
			result.setPositive();

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fabs_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fabs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fabs_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fabs_rc_0(code, addr);
	}

	bool Op__spec__fabs_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not BOOL(cpu->GetMSR().Get<CPU::MSR::FP>())))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			SoftDouble result( cpu->GetFPR(fb) );

			// Compute the result
			result.setPositive();

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fabs_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fabs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fabs_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fabs_rc_1(code, addr);
	}

	bool Op__spec__fadd_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result = cpu->GetFPR(fa);
			const SoftDouble& b = cpu->GetFPR(fb);

			// Compute the result
			result.plusAssign(b, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fadd_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fadd" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fadd_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fadd_rc_0(code, addr);
	}

	bool Op__spec__fadd_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result = cpu->GetFPR(fa);
			const SoftDouble& b = cpu->GetFPR(fb);

			// Compute the result
			result.plusAssign(b, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fadd_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fadd" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fadd_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fadd_rc_1(code, addr);
	}

	bool Op__spec__fadds_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& b(cpu->GetFPR(fb));

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.plusAssign(b, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fadds_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fadds" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fadds_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fadds_rc_0(code, addr);
	}

	bool Op__spec__fadds_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& b(cpu->GetFPR(fb));

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.plusAssign(b, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fadds_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fadds" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fadds_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fadds_rc_1(code, addr);
	}

	bool Op__spec__fctiw_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			S32 res32 = b.queryS32( flags );

			U64 undef_high = (U64(0xfff80000) | U64(res32 == S32(0) and b.isNegative())) << 32;

			SoftDouble result(SoftDouble::FromRawBits, undef_high | U64(U32(res32)));

			// Generate VXSNAN, VXCVI, FR, FI, XX, FX, VX, FEX
			if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = fpscr;
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXCVI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, b, flags);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fctiw_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fctiw" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fctiw_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fctiw_rc_0(code, addr);
	}

	bool Op__spec__fctiw_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			S32 res32 = b.queryS32( flags );

			U64 undef_high = (U64(0xfff80000) | U64(res32 == S32(0) and b.isNegative())) << 32;

			SoftDouble result(SoftDouble::FromRawBits, undef_high | U64(U32(res32)));

			// Generate VXSNAN, VXCVI, FR, FI, XX, FX, VX, FEX
			if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = fpscr;
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXCVI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, b, flags);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fctiw_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fctiw" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fctiw_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fctiw_rc_1(code, addr);
	}

	bool Op__spec__fctiwz_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			Flags flags( Flags::RoundingMode(1) ); // ZeroRounding
			S32 res32 = b.queryS32( flags );

			U64 undef_high = (U64(0xfff80000) | U64(res32 == S32(0) and b.isNegative())) << 32;

			SoftDouble result(SoftDouble::FromRawBits, undef_high | U64(U32(res32)));

			// Generate VXSNAN, VXCVI, FR, FI, XX, FX, VX, FEX
			if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXCVI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, b, flags);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fctiwz_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fctiwz" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fctiwz_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fctiwz_rc_0(code, addr);
	}

	bool Op__spec__fctiwz_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			Flags flags( Flags::RoundingMode(1) ); // ZeroRounding
			S32 res32 = b.queryS32( flags );

			U64 undef_high = (U64(0xfff80000) | U64(res32 == S32(0) and b.isNegative())) << 32;

			SoftDouble result(SoftDouble::FromRawBits, undef_high | U64(U32(res32)));

			// Generate VXSNAN, VXCVI, FR, FI, XX, FX, VX, FEX
			if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXCVI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, b, flags);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fctiwz_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fctiwz" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fctiwz_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fctiwz_rc_1(code, addr);
	}

	bool Op__spec__fctid_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			S64 res64;

			if (unlikely(b.isNaN()))
			{
				if (unlikely(b.isSNaN()))
				{
					// Generate VXSNAN
					fpscr.SetInvalid(FPSCR::VXSNAN());
					if (unlikely(not cpu->CheckFloatingPointException()))
					return false;
				}

				res64 = S64(1ll<<63);
			}
			else
			{
				Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
				res64 = b.queryS64( flags );
				// Generate VXCVI, FR, FI, XX, FX, VX, FEX
				if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
				else                                fpscr.SetInvalid( FPSCR::VXCVI() );
				fpscr.Set<FPSCR::FR>( flags.hasIncrementFraction(res64 < S64(0)) );

				if (not cpu->CheckFloatingPointException())
				return false;
			}

			SoftDouble result(SoftDouble::FromRawBits, U64(res64));

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fctid_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fctid" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fctid_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fctid_rc_0(code, addr);
	}

	bool Op__spec__fctid_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			S64 res64;

			if (unlikely(b.isNaN()))
			{
				if (unlikely(b.isSNaN()))
				{
					// Generate VXSNAN
					fpscr.SetInvalid(FPSCR::VXSNAN());
					if (unlikely(not cpu->CheckFloatingPointException()))
					return false;
				}

				res64 = S64(1ll<<63);
			}
			else
			{
				Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
				res64 = b.queryS64( flags );
				// Generate VXCVI, FR, FI, XX, FX, VX, FEX
				if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
				else                                fpscr.SetInvalid( FPSCR::VXCVI() );
				fpscr.Set<FPSCR::FR>( flags.hasIncrementFraction(res64 < S64(0)) );

				if (not cpu->CheckFloatingPointException())
				return false;
			}

			SoftDouble result(SoftDouble::FromRawBits, U64(res64));

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fctid_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fctid" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fctid_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fctid_rc_1(code, addr);
	}

	bool Op__spec__fctidz_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			S64 res64;

			if (unlikely(b.isNaN()))
			{
				if (unlikely(b.isSNaN()))
				{
					// Generate VXSNAN
					fpscr.SetInvalid(FPSCR::VXSNAN());
					if (unlikely(not cpu->CheckFloatingPointException()))
					return false;
				}

				res64 = S64(1ll<<63);
			}
			else
			{
				Flags flags( Flags::RoundingMode(1) );
				res64 = b.queryS64( flags );
				// Generate VXCVI, FR, FI, XX, FX, VX, FEX
				if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
				else                                fpscr.SetInvalid( FPSCR::VXCVI() );
				fpscr.Set<FPSCR::FR>( flags.hasIncrementFraction(res64 < S64(0)) );

				if (not cpu->CheckFloatingPointException())
				return false;
			}

			SoftDouble result(SoftDouble::FromRawBits, U64(res64));

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fctidz_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fctidz" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fctidz_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fctidz_rc_0(code, addr);
	}

	bool Op__spec__fctidz_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			SoftDouble b = cpu->GetFPR(fb);

			// Compute the result
			S64 res64;

			if (unlikely(b.isNaN()))
			{
				if (unlikely(b.isSNaN()))
				{
					// Generate VXSNAN
					fpscr.SetInvalid(FPSCR::VXSNAN());
					if (unlikely(not cpu->CheckFloatingPointException()))
					return false;
				}

				res64 = S64(1ll<<63);
			}
			else
			{
				Flags flags( Flags::RoundingMode(1) );
				res64 = b.queryS64( flags );
				// Generate VXCVI, FR, FI, XX, FX, VX, FEX
				if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
				else                                fpscr.SetInvalid( FPSCR::VXCVI() );
				fpscr.Set<FPSCR::FR>( flags.hasIncrementFraction(res64 < S64(0)) );

				if (not cpu->CheckFloatingPointException())
				return false;
			}

			SoftDouble result(SoftDouble::FromRawBits, U64(res64));

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fctidz_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fctidz" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fctidz_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fctidz_rc_1(code, addr);
	}

	bool Op__spec__fcfid_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			S64 b( cpu->GetFPR(frb).queryRawBits() );

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result(b, flags);

			// Generate FPRF, FR, FI, XX, FX
			if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr(fpscr), old_fpscr = new_fpscr;
			GenFPSCR_FPRF<FPSCR>(new_fpscr, result);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(frt, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fcfid_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fcfid" << (rc ? "." : "") << " " << FPRPrint(frt) << ", " << FPRPrint(frb);
	}}

	static Operation *DecodeOp__spec__fcfid_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fcfid_rc_0(code, addr);
	}

	bool Op__spec__fcfid_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr( cpu->GetFPSCR() );
			S64 b( cpu->GetFPR(frb).queryRawBits() );

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result(b, flags);

			// Generate FPRF, FR, FI, XX, FX
			if (likely(not flags.isOverflow())) fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr(fpscr), old_fpscr = new_fpscr;
			GenFPSCR_FPRF<FPSCR>(new_fpscr, result);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(frt, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fcfid_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fcfid" << (rc ? "." : "") << " " << FPRPrint(frt) << ", " << FPRPrint(frb);
	}}

	static Operation *DecodeOp__spec__fcfid_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fcfid_rc_1(code, addr);
	}

	bool Op__spec__fdiv_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			if (unlikely(b.isZero()))
			{
				if (unlikely(result.isZero())) { fpscr.SetInvalid(FPSCR::VXZDZ()); }
				else                           { fpscr.SetException(FPSCR::ZX()); }
			}
			else if (unlikely(b.isInfty() and result.isInfty()))
			{
				fpscr.SetInvalid(FPSCR::VXIDI());
			}

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.divAssign(b, flags);

			// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fdiv_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fdiv" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fdiv_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fdiv_rc_0(code, addr);
	}

	bool Op__spec__fdiv_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			if (unlikely(b.isZero()))
			{
				if (unlikely(result.isZero())) { fpscr.SetInvalid(FPSCR::VXZDZ()); }
				else                           { fpscr.SetException(FPSCR::ZX()); }
			}
			else if (unlikely(b.isInfty() and result.isInfty()))
			{
				fpscr.SetInvalid(FPSCR::VXIDI());
			}

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.divAssign(b, flags);

			// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fdiv_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fdiv" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fdiv_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fdiv_rc_1(code, addr);
	}

	bool Op__spec__fdivs_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& b(cpu->GetFPR(fb));
			if (unlikely(b.isZero()))
			{
				if (unlikely(a.isZero())) { fpscr.SetInvalid(FPSCR::VXZDZ()); }
				else                      { fpscr.SetException(FPSCR::ZX()); }
			}
			else if (unlikely(b.isInfty() and a.isInfty()))
			{
				fpscr.SetInvalid(FPSCR::VXIDI());
			}

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.divAssign(b, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fdivs_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fdivs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fdivs_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fdivs_rc_0(code, addr);
	}

	bool Op__spec__fdivs_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& b(cpu->GetFPR(fb));
			if (unlikely(b.isZero()))
			{
				if (unlikely(a.isZero())) { fpscr.SetInvalid(FPSCR::VXZDZ()); }
				else                      { fpscr.SetException(FPSCR::ZX()); }
			}
			else if (unlikely(b.isInfty() and a.isInfty()))
			{
				fpscr.SetInvalid(FPSCR::VXIDI());
			}

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.divAssign(b, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fdivs_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fdivs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fdivs_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fdivs_rc_1(code, addr);
	}

	bool Op__spec__fmadd_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndAddAssign(c, b, flags);

			// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmadd_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fmadd" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmadd_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmadd_rc_0(code, addr);
	}

	bool Op__spec__fmadd_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndAddAssign(c, b, flags);

			// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmadd_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fmadd" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmadd_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmadd_rc_1(code, addr);
	}

	bool Op__spec__fmadds_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndAddAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmadds_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fmadds" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmadds_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmadds_rc_0(code, addr);
	}

	bool Op__spec__fmadds_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndAddAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmadds_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fmadds" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmadds_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmadds_rc_1(code, addr);
	}

	bool Op__spec__fmr_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			cpu->SetFPR(fd, cpu->GetFPR(fb));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmr_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fmr" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmr_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmr_rc_0(code, addr);
	}

	bool Op__spec__fmr_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			cpu->SetFPR(fd, cpu->GetFPR(fb));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmr_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fmr" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmr_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmr_rc_1(code, addr);
	}

	bool Op__spec__fmsub_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndSubAssign(c, b, flags);

			// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmsub_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fmsub" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmsub_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmsub_rc_0(code, addr);
	}

	bool Op__spec__fmsub_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndSubAssign(c, b, flags);

			// Generate OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmsub_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fmsub" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmsub_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmsub_rc_1(code, addr);
	}

	bool Op__spec__fmsubs_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndSubAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmsubs_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fmsubs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmsubs_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmsubs_rc_0(code, addr);
	}

	bool Op__spec__fmsubs_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndSubAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmsubs_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fmsubs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fmsubs_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmsubs_rc_1(code, addr);
	}

	bool Op__spec__fmul_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			result.multAssign(c, flags);

			// Generate OX, UX, VXSNAN, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmul_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fmul" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc);
	}}

	static Operation *DecodeOp__spec__fmul_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmul_rc_0(code, addr);
	}

	bool Op__spec__fmul_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			result.multAssign(c, flags);

			// Generate OX, UX, VXSNAN, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmul_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fmul" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc);
	}}

	static Operation *DecodeOp__spec__fmul_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmul_rc_1(code, addr);
	}

	bool Op__spec__fmuls_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& c(cpu->GetFPR(fc));

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAssign(c, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmuls_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fmuls" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc);
	}}

	static Operation *DecodeOp__spec__fmuls_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmuls_rc_0(code, addr);
	}

	bool Op__spec__fmuls_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& c(cpu->GetFPR(fc));

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAssign(c, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fmuls_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fmuls" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc);
	}}

	static Operation *DecodeOp__spec__fmuls_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fmuls_rc_1(code, addr);
	}

	bool Op__spec__fnabs_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			SoftDouble result( cpu->GetFPR(fb) );

			// Compute the result
			result.setNegative();

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnabs_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fnabs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnabs_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnabs_rc_0(code, addr);
	}

	bool Op__spec__fnabs_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			SoftDouble result( cpu->GetFPR(fb) );

			// Compute the result
			result.setNegative();

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnabs_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fnabs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnabs_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnabs_rc_1(code, addr);
	}

	bool Op__spec__fneg_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			SoftDouble result = cpu->GetFPR(fb);

			// Compute the result
			result.opposite();

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fneg_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fneg" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fneg_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fneg_rc_0(code, addr);
	}

	bool Op__spec__fneg_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			SoftDouble result = cpu->GetFPR(fb);

			// Compute the result
			result.opposite();

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fneg_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fneg" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fneg_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fneg_rc_1(code, addr);
	}

	bool Op__spec__fnmadd_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndAddAssign(c, b, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			if (likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnmadd_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fnmadd" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnmadd_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnmadd_rc_0(code, addr);
	}

	bool Op__spec__fnmadd_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndAddAssign(c, b, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			if (likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnmadd_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fnmadd" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnmadd_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnmadd_rc_1(code, addr);
	}

	bool Op__spec__fnmadds_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding and opposite
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndAddAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			// Compute the final result
			if(likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnmadds_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fnmadds" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnmadds_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnmadds_rc_0(code, addr);
	}

	bool Op__spec__fnmadds_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding and opposite
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndAddAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			// Compute the final result
			if(likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnmadds_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fnmadds" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnmadds_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnmadds_rc_1(code, addr);
	}

	bool Op__spec__fnmsub_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndSubAssign(c, b, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			if (likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnmsub_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fnmsub" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnmsub_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnmsub_rc_0(code, addr);
	}

	bool Op__spec__fnmsub_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble result = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			result.multAndSubAssign(c, b, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			if (likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnmsub_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fnmsub" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnmsub_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnmsub_rc_1(code, addr);
	}

	bool Op__spec__fnmsubs_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding and opposite
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndSubAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			// Compute the final result
			if(likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnmsubs_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fnmsubs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnmsubs_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnmsubs_rc_0(code, addr);
	}

	bool Op__spec__fnmsubs_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a = cpu->GetFPR(fa);
			SoftDouble const& b = cpu->GetFPR(fb);
			SoftDouble const& c = cpu->GetFPR(fc);

			// Compute the intermediate result before rounding and opposite
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.multAndSubAssign(c, b, flags);

			// Round the result
			SoftFloat result(a, flags);
			BOOL fraction_rounded = flags.hasIncrementFraction(result.isNegative());

			// Compute the final result
			if(likely(not result.isQNaN())) result.opposite();

			// Generate FR, OX, UX, VXSNAN, VXISI, VXIMZ, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact( flags.isApproximate() );
			fpscr.Set<FPSCR::FR>(UINT(fraction_rounded));
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (unlikely(flags.isInftyMultZero())) fpscr.SetInvalid(FPSCR::VXIMZ());

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fnmsubs_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fnmsubs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fnmsubs_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fnmsubs_rc_1(code, addr);
	}

	bool Op__spec__frsp_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr(cpu->GetFPSCR());
			const SoftDouble& b = cpu->GetFPR(fb);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftFloat result(b, flags);

			// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr(fpscr), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__frsp_rc_0::disasm( std::ostream& os)
	{
		{
			os << "frsp" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__frsp_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__frsp_rc_0(code, addr);
	}

	bool Op__spec__frsp_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr(cpu->GetFPSCR());
			const SoftDouble& b = cpu->GetFPR(fb);

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftFloat result(b, flags);

			// Generate OX, UX, VXSNAN, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr(fpscr), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__frsp_rc_1::disasm( std::ostream& os)
	{
		{
			os << "frsp" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__frsp_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__frsp_rc_1(code, addr);
	}

	bool Op__spec__fsel_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU or not CONFIG::HAS_FLOATING_POINT_GRAPHICS_INSTRUCTIONS)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			const SoftDouble& a = cpu->GetFPR(fa);
			const SoftDouble& b = cpu->GetFPR(fb);
			const SoftDouble& c = cpu->GetFPR(fc);

			// Compute and write the result
			cpu->SetFPR(fd, evenly((not a.isZero() and a.isNegative()) or a.isNaN()) ? b : c);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fsel_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fsel" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fsel_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fsel_rc_0(code, addr);
	}

	bool Op__spec__fsel_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU or not CONFIG::HAS_FLOATING_POINT_GRAPHICS_INSTRUCTIONS)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			const SoftDouble& a = cpu->GetFPR(fa);
			const SoftDouble& b = cpu->GetFPR(fb);
			const SoftDouble& c = cpu->GetFPR(fc);

			// Compute and write the result
			cpu->SetFPR(fd, evenly((not a.isZero() and a.isNegative()) or a.isNaN()) ? b : c);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( cpu->GetFPSCR().Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fsel_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fsel" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fc) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fsel_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fsel_rc_1(code, addr);
	}

	bool Op__spec__fsub_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result = cpu->GetFPR(fa);
			const SoftDouble& b = cpu->GetFPR(fb);

			// Compute the result
			result.minusAssign(b, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fsub_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fsub" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fsub_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fsub_rc_0(code, addr);
	}

	bool Op__spec__fsub_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			SoftDouble result = cpu->GetFPR(fa);
			const SoftDouble& b = cpu->GetFPR(fb);

			// Compute the result
			result.minusAssign(b, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftDouble>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftDouble>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, result);

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fsub_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fsub" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fsub_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fsub_rc_1(code, addr);
	}

	bool Op__spec__fsubs_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& b(cpu->GetFPR(fb));

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.minusAssign(b, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fsubs_rc_0::disasm( std::ostream& os)
	{
		{
			os << "fsubs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fsubs_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__fsubs_rc_0(code, addr);
	}

	bool Op__spec__fsubs_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			SoftDouble a(cpu->GetFPR(fa));
			SoftDouble const& b(cpu->GetFPR(fb));

			// Compute the result
			Flags flags( Flags::RoundingMode(fpscr.Get<FPSCR::RN>()) );
			a.minusAssign(b, flags);
			SoftFloat result(a, flags);

			// Generate OX, UX, VXSNAN, VXISI, FR, FI, FPRF, XX, FX, VX, FEX
			fpscr.SetInexact(flags.isApproximate());
			UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
			GenFPSCR_OX<FPSCR>(new_fpscr, flags);
			GenFPSCR_UX<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXSNAN<FPSCR>(new_fpscr, flags);
			GenFPSCR_VXISI<FPSCR>(new_fpscr, flags);
			GenFPSCR_FR<FPSCR, SoftFloat>(new_fpscr, result, flags);
			GenFPSCR_FPRF<FPSCR, SoftFloat>(new_fpscr, result);
			GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			// Update FPSCR
			fpscr = new_fpscr;

			if (not cpu->CheckFloatingPointException())
			return false;

			// Write back the result
			cpu->SetFPR(fd, SoftDouble(result, flags));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__fsubs_rc_1::disasm( std::ostream& os)
	{
		{
			os << "fsubs" << (rc ? "." : "") << " " << FPRPrint(fd) << ", " << FPRPrint(fa) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__fsubs_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__fsubs_rc_1(code, addr);
	}

	bool Op__spec__mffs_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Move FPSCR into destination FPR
			FPSCR& fpscr( cpu->GetFPSCR() );
			cpu->SetFPR(fd, SoftDouble(SoftDouble::FromRawBits, U64(fpscr) | U64(0xfff8000000000000ULL)));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mffs_rc_0::disasm( std::ostream& os)
	{
		{
			os << "mffs" << (rc ? "." : "") << " " << FPRPrint(fd);
	}}

	static Operation *DecodeOp__spec__mffs_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mffs_rc_0(code, addr);
	}

	bool Op__spec__mffs_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Move FPSCR into destination FPR
			FPSCR& fpscr( cpu->GetFPSCR() );
			cpu->SetFPR(fd, SoftDouble(SoftDouble::FromRawBits, U64(fpscr) | U64(0xfff8000000000000ULL)));

			// Copy FX, FEX, VX, OX to CR1
			if(unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mffs_rc_1::disasm( std::ostream& os)
	{
		{
			os << "mffs" << (rc ? "." : "") << " " << FPRPrint(fd);
	}}

	static Operation *DecodeOp__spec__mffs_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mffs_rc_1(code, addr);
	}

	bool Op__spec__mtfsb0_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();

			// Compute the result
			if (likely(bt != 1 && bt != 2))
			{
				// Clear bit BT
				UINT new_fpscr( fpscr );
				new_fpscr &= ~UINT(0x80000000 >> bt);

				// Update VX, FEX
				GenFPSCR_VX<FPSCR>(new_fpscr);
				GenFPSCR_FEX<FPSCR>(new_fpscr);

				fpscr = new_fpscr;
			}

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mtfsb0_rc_0::disasm( std::ostream& os)
	{
		{
			os << "mtfsb0" << (rc ? "." : "") << " " << CRPrint(bt);
	}}

	static Operation *DecodeOp__spec__mtfsb0_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mtfsb0_rc_0(code, addr);
	}

	bool Op__spec__mtfsb0_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();

			// Compute the result
			if (likely(bt != 1 && bt != 2))
			{
				// Clear bit BT
				UINT new_fpscr( fpscr );
				new_fpscr &= ~UINT(0x80000000 >> bt);

				// Update VX, FEX
				GenFPSCR_VX<FPSCR>(new_fpscr);
				GenFPSCR_FEX<FPSCR>(new_fpscr);

				fpscr = new_fpscr;
			}

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mtfsb0_rc_1::disasm( std::ostream& os)
	{
		{
			os << "mtfsb0" << (rc ? "." : "") << " " << CRPrint(bt);
	}}

	static Operation *DecodeOp__spec__mtfsb0_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mtfsb0_rc_1(code, addr);
	}

	bool Op__spec__mtfsb1_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();

			// Compute the result
			if (likely(bt != 1 && bt != 2))
			{
				// Set bit BT
				UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
				new_fpscr |= UINT(0x80000000 >> bt);

				// Update VX, FEX
				GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
				GenFPSCR_VX<FPSCR>(new_fpscr);
				GenFPSCR_FEX<FPSCR>(new_fpscr);

				fpscr = new_fpscr;
			}

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mtfsb1_rc_0::disasm( std::ostream& os)
	{
		{
			os << "mtfsb1" << (rc ? "." : "") << " " << CRPrint(bt);
	}}

	static Operation *DecodeOp__spec__mtfsb1_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mtfsb1_rc_0(code, addr);
	}

	bool Op__spec__mtfsb1_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();

			// Compute the result
			if (likely(bt != 1 && bt != 2))
			{
				// Set bit BT
				UINT new_fpscr( fpscr ), old_fpscr = new_fpscr;
				new_fpscr |= UINT(0x80000000 >> bt);

				// Update VX, FEX
				GenFPSCR_FX<FPSCR>(new_fpscr, old_fpscr);
				GenFPSCR_VX<FPSCR>(new_fpscr);
				GenFPSCR_FEX<FPSCR>(new_fpscr);

				fpscr = new_fpscr;
			}

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mtfsb1_rc_1::disasm( std::ostream& os)
	{
		{
			os << "mtfsb1" << (rc ? "." : "") << " " << CRPrint(bt);
	}}

	static Operation *DecodeOp__spec__mtfsb1_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mtfsb1_rc_1(code, addr);
	}

	bool Op__spec__mtfsfi_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			unsigned pos = (4 * (7 - bft));
			uint32_t fsmask = 0xf << pos, fsbits = imm << pos;
			UINT mask(uint64_t(fsmask) << (w ? 32 : 0));
			UINT bits(uint64_t(fsbits) << (w ? 32 : 0));

			// Compute the result
			UINT new_fpscr( cpu->GetFPSCR() );
			new_fpscr = (new_fpscr & ~mask) | bits;

			// Update VX, FEX
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			fpscr = new_fpscr;

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mtfsfi_rc_0::disasm( std::ostream& os)
	{
		{
			os << "mtfsfi" << (rc ? "." : "") << " " << CRPrint(bft) << ", " << unsigned(imm);
	}}

	static Operation *DecodeOp__spec__mtfsfi_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mtfsfi_rc_0(code, addr);
	}

	bool Op__spec__mtfsfi_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			unsigned pos = (4 * (7 - bft));
			uint32_t fsmask = 0xf << pos, fsbits = imm << pos;
			UINT mask(uint64_t(fsmask) << (w ? 32 : 0));
			UINT bits(uint64_t(fsbits) << (w ? 32 : 0));

			// Compute the result
			UINT new_fpscr( cpu->GetFPSCR() );
			new_fpscr = (new_fpscr & ~mask) | bits;

			// Update VX, FEX
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			fpscr = new_fpscr;

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mtfsfi_rc_1::disasm( std::ostream& os)
	{
		{
			os << "mtfsfi" << (rc ? "." : "") << " " << CRPrint(bft) << ", " << unsigned(imm);
	}}

	static Operation *DecodeOp__spec__mtfsfi_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mtfsfi_rc_1(code, addr);
	}

	bool Op__spec__mtfsf_rc_0::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			UINT rb( cpu->GetFPR(fb).queryRawBits() );
			UINT mask(l ? UINT(uint64_t(-1)) : UINT(uint64_t(fsmask) << (w ? 32 : 0)));

			// Compute the result
			UINT new_fpscr = ((UINT(fpscr) & ~mask) | (rb & mask));

			// Update VX, FEX
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			fpscr = new_fpscr;

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mtfsf_rc_0::disasm( std::ostream& os)
	{
		{
			os << "mtfsf" << (rc ? "." : "") << " " << unsigned(fm) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__mtfsf_rc_0(CodeType code, uint64_t addr)
	{
		return new Op__spec__mtfsf_rc_0(code, addr);
	}

	bool Op__spec__mtfsf_rc_1::execute( Arch* cpu)
	{
		{
			if(not CONFIG::HAS_FPU)
			{
				cpu->ThrowException<CPU::ProgramInterrupt::UnimplementedInstruction>();
				return false;
			}
			if(unlikely(not cpu->GetMSR().Get<CPU::MSR::FP>()))
			{
				cpu->ThrowException<CPU::FloatingPointUnavailableInterrupt::FloatingPointUnavailable>();
				return false;
			}

			// Read the input operands
			FPSCR& fpscr = cpu->GetFPSCR();
			UINT rb( cpu->GetFPR(fb).queryRawBits() );
			UINT mask(l ? UINT(uint64_t(-1)) : UINT(uint64_t(fsmask) << (w ? 32 : 0)));

			// Compute the result
			UINT new_fpscr = ((UINT(fpscr) & ~mask) | (rb & mask));

			// Update VX, FEX
			GenFPSCR_VX<FPSCR>(new_fpscr);
			GenFPSCR_FEX<FPSCR>(new_fpscr);

			fpscr = new_fpscr;

			// Copy FX, FEX, VX, OX to CR1
			if (unlikely(rc)) { cpu->GetCR().Set<CR::CR1>( fpscr.Get<FPSCR::_0_3>() ); }

			return true;
	}}
	void Op__spec__mtfsf_rc_1::disasm( std::ostream& os)
	{
		{
			os << "mtfsf" << (rc ? "." : "") << " " << unsigned(fm) << ", " << FPRPrint(fb);
	}}

	static Operation *DecodeOp__spec__mtfsf_rc_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mtfsf_rc_1(code, addr);
	}

	bool Op__spec__mfspr_spr0_0_spr1_1::execute( Arch* cpu)
	{
		{
			UINT result;
			switch(n)
			{
			case 0x001:
				result = cpu->GetXER();
				break;
			case 0x008:
				result = cpu->GetLR();
				break;
			case 0x009:
				result = cpu->GetCTR();
				break;
			default:
				if(unlikely(not cpu->MoveFromSPR(n, result))) return false;
				break;
			}

			cpu->SetGPR(rd, result);

			return true;
	}}
	void Op__spec__mfspr_spr0_0_spr1_1::disasm( std::ostream& os)
	{
		{
			switch(n)
			{
				case 1: os << "mfxer " << GPRPrint(rd); return;
				case 8: os << "mflr " << GPRPrint(rd); return;
				case 9: os << "mfctr " << GPRPrint(rd); return;
			}

			os << "mfspr " << GPRPrint(rd) << ", " << n;
	}}

	static Operation *DecodeOp__spec__mfspr_spr0_0_spr1_1(CodeType code, uint64_t addr)
	{
		return new Op__spec__mfspr_spr0_0_spr1_1(code, addr);
	}

	bool Op__spec__mfspr_spr0_0_spr1_8::execute( Arch* cpu)
	{
		{
			UINT result;
			switch(n)
			{
			case 0x001:
				result = cpu->GetXER();
				break;
			case 0x008:
				result = cpu->GetLR();
				break;
			case 0x009:
				result = cpu->GetCTR();
				break;
			default:
				if(unlikely(not cpu->MoveFromSPR(n, result))) return false;
				break;
			}

			cpu->SetGPR(rd, result);

			return true;
	}}
	void Op__spec__mfspr_spr0_0_spr1_8::disasm( std::ostream& os)
	{
		{
			switch(n)
			{
				case 1: os << "mfxer " << GPRPrint(rd); return;
				case 8: os << "mflr " << GPRPrint(rd); return;
				case 9: os << "mfctr " << GPRPrint(rd); return;
			}

			os << "mfspr " << GPRPrint(rd) << ", " << n;
	}}

	static Operation *DecodeOp__spec__mfspr_spr0_0_spr1_8(CodeType code, uint64_t addr)
	{
		return new Op__spec__mfspr_spr0_0_spr1_8(code, addr);
	}

	bool Op__spec__mfspr_spr0_0_spr1_9::execute( Arch* cpu)
	{
		{
			UINT result;
			switch(n)
			{
			case 0x001:
				result = cpu->GetXER();
				break;
			case 0x008:
				result = cpu->GetLR();
				break;
			case 0x009:
				result = cpu->GetCTR();
				break;
			default:
				if(unlikely(not cpu->MoveFromSPR(n, result))) return false;
				break;
			}

			cpu->SetGPR(rd, result);

			return true;
	}}
	void Op__spec__mfspr_spr0_0_spr1_9::disasm( std::ostream& os)
	{
		{
			switch(n)
			{
				case 1: os << "mfxer " << GPRPrint(rd); return;
				case 8: os << "mflr " << GPRPrint(rd); return;
				case 9: os << "mfctr " << GPRPrint(rd); return;
			}

			os << "mfspr " << GPRPrint(rd) << ", " << n;
	}}

	static Operation *DecodeOp__spec__mfspr_spr0_0_spr1_9(CodeType code, uint64_t addr)
	{
		return new Op__spec__mfspr_spr0_0_spr1_9(code, addr);
	}

	OpBcctr::OpBcctr(CodeType code, uint64_t addr) : Operation(code, addr, "bcctr")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	OpBc::OpBc(CodeType code, uint64_t addr) : Operation(code, addr, "bc")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	OpBclr::OpBclr(CodeType code, uint64_t addr) : Operation(code, addr, "bclr")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	OpB::OpB(CodeType code, uint64_t addr) : Operation(code, addr, "b")
	{
		li24 = ((int32_t)(((code >> 2) & 0xffffff) << 8) >> 8) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	OpCrandc::OpCrandc(CodeType code, uint64_t addr) : Operation(code, addr, "crandc")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		ba = uint8_t((code >> 16) & 0x1f);
		bb = uint8_t((code >> 11) & 0x1f);
	}

	OpCrand::OpCrand(CodeType code, uint64_t addr) : Operation(code, addr, "crand")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		ba = uint8_t((code >> 16) & 0x1f);
		bb = uint8_t((code >> 11) & 0x1f);
	}

	OpCreqv::OpCreqv(CodeType code, uint64_t addr) : Operation(code, addr, "creqv")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		ba = uint8_t((code >> 16) & 0x1f);
		bb = uint8_t((code >> 11) & 0x1f);
	}

	OpCrnand::OpCrnand(CodeType code, uint64_t addr) : Operation(code, addr, "crnand")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		ba = uint8_t((code >> 16) & 0x1f);
		bb = uint8_t((code >> 11) & 0x1f);
	}

	OpCrnor::OpCrnor(CodeType code, uint64_t addr) : Operation(code, addr, "crnor")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		ba = uint8_t((code >> 16) & 0x1f);
		bb = uint8_t((code >> 11) & 0x1f);
	}

	OpCrorc::OpCrorc(CodeType code, uint64_t addr) : Operation(code, addr, "crorc")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		ba = uint8_t((code >> 16) & 0x1f);
		bb = uint8_t((code >> 11) & 0x1f);
	}

	OpCror::OpCror(CodeType code, uint64_t addr) : Operation(code, addr, "cror")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		ba = uint8_t((code >> 16) & 0x1f);
		bb = uint8_t((code >> 11) & 0x1f);
	}

	OpCrxor::OpCrxor(CodeType code, uint64_t addr) : Operation(code, addr, "crxor")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		ba = uint8_t((code >> 16) & 0x1f);
		bb = uint8_t((code >> 11) & 0x1f);
	}

	OpMcrf::OpMcrf(CodeType code, uint64_t addr) : Operation(code, addr, "mcrf")
	{
		bft = uint8_t((code >> 23) & 0x7);
		bfa = uint8_t((code >> 18) & 0x7);
	}

	OpAddc::OpAddc(CodeType code, uint64_t addr) : Operation(code, addr, "addc")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpAdde::OpAdde(CodeType code, uint64_t addr) : Operation(code, addr, "adde")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpAddic_::OpAddic_(CodeType code, uint64_t addr) : Operation(code, addr, "addic_")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		simm = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpAddic::OpAddic(CodeType code, uint64_t addr) : Operation(code, addr, "addic")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		simm = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpAddi::OpAddi(CodeType code, uint64_t addr) : Operation(code, addr, "addi")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		simm = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpAdd::OpAdd(CodeType code, uint64_t addr) : Operation(code, addr, "add")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpAddis::OpAddis(CodeType code, uint64_t addr) : Operation(code, addr, "addis")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		simm = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpAddme::OpAddme(CodeType code, uint64_t addr) : Operation(code, addr, "addme")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpAddze::OpAddze(CodeType code, uint64_t addr) : Operation(code, addr, "addze")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpAndc::OpAndc(CodeType code, uint64_t addr) : Operation(code, addr, "andc")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpAndi_::OpAndi_(CodeType code, uint64_t addr) : Operation(code, addr, "andi_")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		uimm = uint16_t(code & 0xffff);
	}

	OpAnd::OpAnd(CodeType code, uint64_t addr) : Operation(code, addr, "and")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpAndis_::OpAndis_(CodeType code, uint64_t addr) : Operation(code, addr, "andis_")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		uimm = uint32_t(code & 0xffff) << 16;
	}

	OpCmp::OpCmp(CodeType code, uint64_t addr) : Operation(code, addr, "cmp")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpCmpL::OpCmpL(CodeType code, uint64_t addr) : Operation(code, addr, "cmpL")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpCmpi::OpCmpi(CodeType code, uint64_t addr) : Operation(code, addr, "cmpi")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		simm = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpCmpiL::OpCmpiL(CodeType code, uint64_t addr) : Operation(code, addr, "cmpiL")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		simm = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpCmpl::OpCmpl(CodeType code, uint64_t addr) : Operation(code, addr, "cmpl")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpCmplL::OpCmplL(CodeType code, uint64_t addr) : Operation(code, addr, "cmplL")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpCmpli::OpCmpli(CodeType code, uint64_t addr) : Operation(code, addr, "cmpli")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		uimm = uint16_t(code & 0xffff);
	}

	OpCmpliL::OpCmpliL(CodeType code, uint64_t addr) : Operation(code, addr, "cmpliL")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		uimm = uint16_t(code & 0xffff);
	}

	OpCntlzw::OpCntlzw(CodeType code, uint64_t addr) : Operation(code, addr, "cntlzw")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpCntlzd::OpCntlzd(CodeType code, uint64_t addr) : Operation(code, addr, "cntlzd")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpDivw::OpDivw(CodeType code, uint64_t addr) : Operation(code, addr, "divw")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpDivwu::OpDivwu(CodeType code, uint64_t addr) : Operation(code, addr, "divwu")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpDivd::OpDivd(CodeType code, uint64_t addr) : Operation(code, addr, "divd")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpDivdu::OpDivdu(CodeType code, uint64_t addr) : Operation(code, addr, "divdu")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpEqv::OpEqv(CodeType code, uint64_t addr) : Operation(code, addr, "eqv")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpExtsb::OpExtsb(CodeType code, uint64_t addr) : Operation(code, addr, "extsb")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpExtsh::OpExtsh(CodeType code, uint64_t addr) : Operation(code, addr, "extsh")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpExtsw::OpExtsw(CodeType code, uint64_t addr) : Operation(code, addr, "extsw")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpIsel::OpIsel(CodeType code, uint64_t addr) : Operation(code, addr, "isel")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		bc = uint8_t((code >> 6) & 0x1f);
	}

	OpLbz::OpLbz(CodeType code, uint64_t addr) : Operation(code, addr, "lbz")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLbzu::OpLbzu(CodeType code, uint64_t addr) : Operation(code, addr, "lbzu")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLbzux::OpLbzux(CodeType code, uint64_t addr) : Operation(code, addr, "lbzux")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLbzx::OpLbzx(CodeType code, uint64_t addr) : Operation(code, addr, "lbzx")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLha::OpLha(CodeType code, uint64_t addr) : Operation(code, addr, "lha")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLhau::OpLhau(CodeType code, uint64_t addr) : Operation(code, addr, "lhau")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLhaux::OpLhaux(CodeType code, uint64_t addr) : Operation(code, addr, "lhaux")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLhax::OpLhax(CodeType code, uint64_t addr) : Operation(code, addr, "lhax")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLhz::OpLhz(CodeType code, uint64_t addr) : Operation(code, addr, "lhz")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLhzu::OpLhzu(CodeType code, uint64_t addr) : Operation(code, addr, "lhzu")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLhzux::OpLhzux(CodeType code, uint64_t addr) : Operation(code, addr, "lhzux")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLhzx::OpLhzx(CodeType code, uint64_t addr) : Operation(code, addr, "lhzx")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLwz::OpLwz(CodeType code, uint64_t addr) : Operation(code, addr, "lwz")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLwzu::OpLwzu(CodeType code, uint64_t addr) : Operation(code, addr, "lwzu")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLwzux::OpLwzux(CodeType code, uint64_t addr) : Operation(code, addr, "lwzux")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLwzx::OpLwzx(CodeType code, uint64_t addr) : Operation(code, addr, "lwzx")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLwa::OpLwa(CodeType code, uint64_t addr) : Operation(code, addr, "lwa")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
	}

	OpLwaux::OpLwaux(CodeType code, uint64_t addr) : Operation(code, addr, "lwaux")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLwax::OpLwax(CodeType code, uint64_t addr) : Operation(code, addr, "lwax")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLd::OpLd(CodeType code, uint64_t addr) : Operation(code, addr, "ld")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
	}

	OpLdx::OpLdx(CodeType code, uint64_t addr) : Operation(code, addr, "ldx")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLdu::OpLdu(CodeType code, uint64_t addr) : Operation(code, addr, "ldu")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
	}

	OpLdux::OpLdux(CodeType code, uint64_t addr) : Operation(code, addr, "ldux")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpMcrxr::OpMcrxr(CodeType code, uint64_t addr) : Operation(code, addr, "mcrxr")
	{
		crfD = uint8_t((code >> 23) & 0x7);
	}

	OpMfcr::OpMfcr(CodeType code, uint64_t addr) : Operation(code, addr, "mfcr")
	{
		rd = uint8_t((code >> 21) & 0x1f);
	}

	OpMtcrf::OpMtcrf(CodeType code, uint64_t addr) : Operation(code, addr, "mtcrf")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		crm = uint8_t((code >> 12) & 0xff);
		crmask = ((((crm&0x80) << 21)|((crm&0x40) << 18)|((crm&0x20) << 15)|((crm&0x10) << 12)|((crm&8) << 9)|((crm&4) << 6)|((crm&2) << 3)|((crm&1) << 0))&0x11111111)*0xf;
	}

	OpMulli::OpMulli(CodeType code, uint64_t addr) : Operation(code, addr, "mulli")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		simm = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpMulhw::OpMulhw(CodeType code, uint64_t addr) : Operation(code, addr, "mulhw")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpMulhwu::OpMulhwu(CodeType code, uint64_t addr) : Operation(code, addr, "mulhwu")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpMullw::OpMullw(CodeType code, uint64_t addr) : Operation(code, addr, "mullw")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpMulhd::OpMulhd(CodeType code, uint64_t addr) : Operation(code, addr, "mulhd")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpMulhdu::OpMulhdu(CodeType code, uint64_t addr) : Operation(code, addr, "mulhdu")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpMulld::OpMulld(CodeType code, uint64_t addr) : Operation(code, addr, "mulld")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpNand::OpNand(CodeType code, uint64_t addr) : Operation(code, addr, "nand")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpNeg::OpNeg(CodeType code, uint64_t addr) : Operation(code, addr, "neg")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpNor::OpNor(CodeType code, uint64_t addr) : Operation(code, addr, "nor")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpOrc::OpOrc(CodeType code, uint64_t addr) : Operation(code, addr, "orc")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpOri::OpOri(CodeType code, uint64_t addr) : Operation(code, addr, "ori")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		uimm = uint16_t(code & 0xffff);
	}

	OpOr::OpOr(CodeType code, uint64_t addr) : Operation(code, addr, "or")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpOris::OpOris(CodeType code, uint64_t addr) : Operation(code, addr, "oris")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		uimm = uint32_t(code & 0xffff) << 16;
	}

	OpRlwimi::OpRlwimi(CodeType code, uint64_t addr) : Operation(code, addr, "rlwimi")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh = uint8_t((code >> 11) & 0x1f);
		mb = uint8_t((code >> 6) & 0x1f);
		me = uint8_t((code >> 1) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpRlwinm::OpRlwinm(CodeType code, uint64_t addr) : Operation(code, addr, "rlwinm")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh = uint8_t((code >> 11) & 0x1f);
		mb = uint8_t((code >> 6) & 0x1f);
		me = uint8_t((code >> 1) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpRlwnm::OpRlwnm(CodeType code, uint64_t addr) : Operation(code, addr, "rlwnm")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		mb = uint8_t((code >> 6) & 0x1f);
		me = uint8_t((code >> 1) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpRldicl::OpRldicl(CodeType code, uint64_t addr) : Operation(code, addr, "rldicl")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		n = sh0|sh1;
		mb = mb0|mb1;
	}

	OpRldicr::OpRldicr(CodeType code, uint64_t addr) : Operation(code, addr, "rldicr")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		me1 = uint8_t((code >> 6) & 0x1f);
		me0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		n = sh0|sh1;
		me = me0|me1;
	}

	OpRldic::OpRldic(CodeType code, uint64_t addr) : Operation(code, addr, "rldic")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		n = sh0|sh1;
		mb = mb0|mb1;
	}

	OpRldcl::OpRldcl(CodeType code, uint64_t addr) : Operation(code, addr, "rldcl")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		mb = mb0|mb1;
	}

	OpRldcr::OpRldcr(CodeType code, uint64_t addr) : Operation(code, addr, "rldcr")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		me1 = uint8_t((code >> 6) & 0x1f);
		me0 = uint8_t((code >> 5) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		me = me0|me1;
	}

	OpRldimi::OpRldimi(CodeType code, uint64_t addr) : Operation(code, addr, "rldimi")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		sh = sh0|sh1;
		mb = mb0|mb1;
	}

	OpSlw::OpSlw(CodeType code, uint64_t addr) : Operation(code, addr, "slw")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpSrawi::OpSrawi(CodeType code, uint64_t addr) : Operation(code, addr, "srawi")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
		shifted_out = (1 << sh)-1;
	}

	OpSraw::OpSraw(CodeType code, uint64_t addr) : Operation(code, addr, "sraw")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpSrw::OpSrw(CodeType code, uint64_t addr) : Operation(code, addr, "srw")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpSld::OpSld(CodeType code, uint64_t addr) : Operation(code, addr, "sld")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpSradi::OpSradi(CodeType code, uint64_t addr) : Operation(code, addr, "sradi")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		sh = sh0|sh1;
	}

	OpSrad::OpSrad(CodeType code, uint64_t addr) : Operation(code, addr, "srad")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpSrd::OpSrd(CodeType code, uint64_t addr) : Operation(code, addr, "srd")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpStb::OpStb(CodeType code, uint64_t addr) : Operation(code, addr, "stb")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpStbu::OpStbu(CodeType code, uint64_t addr) : Operation(code, addr, "stbu")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpStbux::OpStbux(CodeType code, uint64_t addr) : Operation(code, addr, "stbux")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpStbx::OpStbx(CodeType code, uint64_t addr) : Operation(code, addr, "stbx")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpSth::OpSth(CodeType code, uint64_t addr) : Operation(code, addr, "sth")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpSthu::OpSthu(CodeType code, uint64_t addr) : Operation(code, addr, "sthu")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpSthux::OpSthux(CodeType code, uint64_t addr) : Operation(code, addr, "sthux")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpSthx::OpSthx(CodeType code, uint64_t addr) : Operation(code, addr, "sthx")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpStw::OpStw(CodeType code, uint64_t addr) : Operation(code, addr, "stw")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpStwu::OpStwu(CodeType code, uint64_t addr) : Operation(code, addr, "stwu")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpStwux::OpStwux(CodeType code, uint64_t addr) : Operation(code, addr, "stwux")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpStwx::OpStwx(CodeType code, uint64_t addr) : Operation(code, addr, "stwx")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpStd::OpStd(CodeType code, uint64_t addr) : Operation(code, addr, "std")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
	}

	OpStdu::OpStdu(CodeType code, uint64_t addr) : Operation(code, addr, "stdu")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
	}

	OpStdux::OpStdux(CodeType code, uint64_t addr) : Operation(code, addr, "stdux")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpStdx::OpStdx(CodeType code, uint64_t addr) : Operation(code, addr, "stdx")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpSubfc::OpSubfc(CodeType code, uint64_t addr) : Operation(code, addr, "subfc")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpSubfe::OpSubfe(CodeType code, uint64_t addr) : Operation(code, addr, "subfe")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpSubfic::OpSubfic(CodeType code, uint64_t addr) : Operation(code, addr, "subfic")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		simm = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpSubf::OpSubf(CodeType code, uint64_t addr) : Operation(code, addr, "subf")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpSubfme::OpSubfme(CodeType code, uint64_t addr) : Operation(code, addr, "subfme")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpSubfze::OpSubfze(CodeType code, uint64_t addr) : Operation(code, addr, "subfze")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	OpXori::OpXori(CodeType code, uint64_t addr) : Operation(code, addr, "xori")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		uimm = uint16_t(code & 0xffff);
	}

	OpXor::OpXor(CodeType code, uint64_t addr) : Operation(code, addr, "xor")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpXoris::OpXoris(CodeType code, uint64_t addr) : Operation(code, addr, "xoris")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		uimm = uint32_t(code & 0xffff) << 16;
	}

	OpFabs::OpFabs(CodeType code, uint64_t addr) : Operation(code, addr, "fabs")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFadd::OpFadd(CodeType code, uint64_t addr) : Operation(code, addr, "fadd")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFadds::OpFadds(CodeType code, uint64_t addr) : Operation(code, addr, "fadds")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFcmpo::OpFcmpo(CodeType code, uint64_t addr) : Operation(code, addr, "fcmpo")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
	}

	OpFcmpu::OpFcmpu(CodeType code, uint64_t addr) : Operation(code, addr, "fcmpu")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
	}

	OpFctiw::OpFctiw(CodeType code, uint64_t addr) : Operation(code, addr, "fctiw")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFctiwz::OpFctiwz(CodeType code, uint64_t addr) : Operation(code, addr, "fctiwz")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFctid::OpFctid(CodeType code, uint64_t addr) : Operation(code, addr, "fctid")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFctidz::OpFctidz(CodeType code, uint64_t addr) : Operation(code, addr, "fctidz")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFcfid::OpFcfid(CodeType code, uint64_t addr) : Operation(code, addr, "fcfid")
	{
		frt = uint8_t((code >> 21) & 0x1f);
		frb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFdiv::OpFdiv(CodeType code, uint64_t addr) : Operation(code, addr, "fdiv")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFdivs::OpFdivs(CodeType code, uint64_t addr) : Operation(code, addr, "fdivs")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFmadd::OpFmadd(CodeType code, uint64_t addr) : Operation(code, addr, "fmadd")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFmadds::OpFmadds(CodeType code, uint64_t addr) : Operation(code, addr, "fmadds")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFmr::OpFmr(CodeType code, uint64_t addr) : Operation(code, addr, "fmr")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFmsub::OpFmsub(CodeType code, uint64_t addr) : Operation(code, addr, "fmsub")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFmsubs::OpFmsubs(CodeType code, uint64_t addr) : Operation(code, addr, "fmsubs")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFmul::OpFmul(CodeType code, uint64_t addr) : Operation(code, addr, "fmul")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFmuls::OpFmuls(CodeType code, uint64_t addr) : Operation(code, addr, "fmuls")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFnabs::OpFnabs(CodeType code, uint64_t addr) : Operation(code, addr, "fnabs")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFneg::OpFneg(CodeType code, uint64_t addr) : Operation(code, addr, "fneg")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFnmadd::OpFnmadd(CodeType code, uint64_t addr) : Operation(code, addr, "fnmadd")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFnmadds::OpFnmadds(CodeType code, uint64_t addr) : Operation(code, addr, "fnmadds")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFnmsub::OpFnmsub(CodeType code, uint64_t addr) : Operation(code, addr, "fnmsub")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFnmsubs::OpFnmsubs(CodeType code, uint64_t addr) : Operation(code, addr, "fnmsubs")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFrsp::OpFrsp(CodeType code, uint64_t addr) : Operation(code, addr, "frsp")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFsel::OpFsel(CodeType code, uint64_t addr) : Operation(code, addr, "fsel")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFsub::OpFsub(CodeType code, uint64_t addr) : Operation(code, addr, "fsub")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpFsubs::OpFsubs(CodeType code, uint64_t addr) : Operation(code, addr, "fsubs")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpLfd::OpLfd(CodeType code, uint64_t addr) : Operation(code, addr, "lfd")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLfdu::OpLfdu(CodeType code, uint64_t addr) : Operation(code, addr, "lfdu")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLfdux::OpLfdux(CodeType code, uint64_t addr) : Operation(code, addr, "lfdux")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLfdx::OpLfdx(CodeType code, uint64_t addr) : Operation(code, addr, "lfdx")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLfs::OpLfs(CodeType code, uint64_t addr) : Operation(code, addr, "lfs")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLfsu::OpLfsu(CodeType code, uint64_t addr) : Operation(code, addr, "lfsu")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpLfsux::OpLfsux(CodeType code, uint64_t addr) : Operation(code, addr, "lfsux")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpLfsx::OpLfsx(CodeType code, uint64_t addr) : Operation(code, addr, "lfsx")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpMcrfs::OpMcrfs(CodeType code, uint64_t addr) : Operation(code, addr, "mcrfs")
	{
		bft = uint8_t((code >> 23) & 0x7);
		bfa = uint8_t((code >> 18) & 0x7);
	}

	OpMffs::OpMffs(CodeType code, uint64_t addr) : Operation(code, addr, "mffs")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpMtfsb0::OpMtfsb0(CodeType code, uint64_t addr) : Operation(code, addr, "mtfsb0")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpMtfsb1::OpMtfsb1(CodeType code, uint64_t addr) : Operation(code, addr, "mtfsb1")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	OpMtfsfi::OpMtfsfi(CodeType code, uint64_t addr) : Operation(code, addr, "mtfsfi")
	{
		bft = uint8_t((code >> 23) & 0x7);
		w = uint8_t((code >> 16) & 0x1);
		imm = uint8_t((code >> 12) & 0xf);
		rc = uint8_t(code & 0x1);
	}

	OpMtfsf::OpMtfsf(CodeType code, uint64_t addr) : Operation(code, addr, "mtfsf")
	{
		l = uint8_t((code >> 25) & 0x1);
		fm = uint8_t((code >> 17) & 0xff);
		w = uint8_t((code >> 16) & 0x1);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
		fsmask = (((fm&0x80) << 21)|((fm&0x40) << 18)|((fm&0x20) << 15)|((fm&0x10) << 12)|((fm&8) << 9)|((fm&4) << 6)|((fm&2) << 3)|((fm&1) << 0))*0xf;
	}

	OpStfd::OpStfd(CodeType code, uint64_t addr) : Operation(code, addr, "stfd")
	{
		fs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpStfdu::OpStfdu(CodeType code, uint64_t addr) : Operation(code, addr, "stfdu")
	{
		fs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpStfdux::OpStfdux(CodeType code, uint64_t addr) : Operation(code, addr, "stfdux")
	{
		fs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpStfdx::OpStfdx(CodeType code, uint64_t addr) : Operation(code, addr, "stfdx")
	{
		fs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpStfiwx::OpStfiwx(CodeType code, uint64_t addr) : Operation(code, addr, "stfiwx")
	{
		fs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpStfs::OpStfs(CodeType code, uint64_t addr) : Operation(code, addr, "stfs")
	{
		fs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpStfsu::OpStfsu(CodeType code, uint64_t addr) : Operation(code, addr, "stfsu")
	{
		fs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	OpStfsux::OpStfsux(CodeType code, uint64_t addr) : Operation(code, addr, "stfsux")
	{
		fs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpStfsx::OpStfsx(CodeType code, uint64_t addr) : Operation(code, addr, "stfsx")
	{
		fs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	OpMfspr::OpMfspr(CodeType code, uint64_t addr) : Operation(code, addr, "mfspr")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		spr1 = uint8_t((code >> 16) & 0x1f);
		spr0 = uint8_t((code >> 11) & 0x1f);
		n = spr0<<5 | spr1;
	}

	OpMtspr::OpMtspr(CodeType code, uint64_t addr) : Operation(code, addr, "mtspr")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		spr1 = uint8_t((code >> 16) & 0x1f);
		spr0 = uint8_t((code >> 11) & 0x1f);
		n = spr0<<5 | spr1;
	}

	Op__spec__bcctr_bo_0_aa_2_lk_0::Op__spec__bcctr_bo_0_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_0_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_0_aa_2_lk_1::Op__spec__bcctr_bo_0_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_0_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1_aa_2_lk_0::Op__spec__bcctr_bo_1_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1_aa_2_lk_1::Op__spec__bcctr_bo_1_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_2_aa_2_lk_0::Op__spec__bcctr_bo_2_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_2_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_2_aa_2_lk_1::Op__spec__bcctr_bo_2_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_2_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_3_aa_2_lk_0::Op__spec__bcctr_bo_3_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_3_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_3_aa_2_lk_1::Op__spec__bcctr_bo_3_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_3_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_4_aa_2_lk_0::Op__spec__bcctr_bo_4_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_4_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_4_aa_2_lk_1::Op__spec__bcctr_bo_4_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_4_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_5_aa_2_lk_0::Op__spec__bcctr_bo_5_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_5_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_5_aa_2_lk_1::Op__spec__bcctr_bo_5_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_5_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_6_aa_2_lk_0::Op__spec__bcctr_bo_6_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_6_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_6_aa_2_lk_1::Op__spec__bcctr_bo_6_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_6_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_7_aa_2_lk_0::Op__spec__bcctr_bo_7_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_7_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_7_aa_2_lk_1::Op__spec__bcctr_bo_7_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_7_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_8_aa_2_lk_0::Op__spec__bcctr_bo_8_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_8_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_8_aa_2_lk_1::Op__spec__bcctr_bo_8_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_8_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_9_aa_2_lk_0::Op__spec__bcctr_bo_9_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_9_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_9_aa_2_lk_1::Op__spec__bcctr_bo_9_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_9_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_a_aa_2_lk_0::Op__spec__bcctr_bo_a_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_a_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_a_aa_2_lk_1::Op__spec__bcctr_bo_a_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_a_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_b_aa_2_lk_0::Op__spec__bcctr_bo_b_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_b_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_b_aa_2_lk_1::Op__spec__bcctr_bo_b_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_b_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_c_aa_2_lk_0::Op__spec__bcctr_bo_c_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_c_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_c_aa_2_lk_1::Op__spec__bcctr_bo_c_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_c_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_d_aa_2_lk_0::Op__spec__bcctr_bo_d_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_d_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_d_aa_2_lk_1::Op__spec__bcctr_bo_d_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_d_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_e_aa_2_lk_0::Op__spec__bcctr_bo_e_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_e_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_e_aa_2_lk_1::Op__spec__bcctr_bo_e_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_e_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_f_aa_2_lk_0::Op__spec__bcctr_bo_f_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_f_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_f_aa_2_lk_1::Op__spec__bcctr_bo_f_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_f_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_10_aa_2_lk_0::Op__spec__bcctr_bo_10_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_10_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_10_aa_2_lk_1::Op__spec__bcctr_bo_10_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_10_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_11_aa_2_lk_0::Op__spec__bcctr_bo_11_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_11_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_11_aa_2_lk_1::Op__spec__bcctr_bo_11_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_11_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_12_aa_2_lk_0::Op__spec__bcctr_bo_12_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_12_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_12_aa_2_lk_1::Op__spec__bcctr_bo_12_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_12_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_13_aa_2_lk_0::Op__spec__bcctr_bo_13_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_13_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_13_aa_2_lk_1::Op__spec__bcctr_bo_13_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_13_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_14_aa_2_lk_0::Op__spec__bcctr_bo_14_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_14_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_14_aa_2_lk_1::Op__spec__bcctr_bo_14_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_14_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_15_aa_2_lk_0::Op__spec__bcctr_bo_15_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_15_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_15_aa_2_lk_1::Op__spec__bcctr_bo_15_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_15_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_16_aa_2_lk_0::Op__spec__bcctr_bo_16_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_16_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_16_aa_2_lk_1::Op__spec__bcctr_bo_16_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_16_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_17_aa_2_lk_0::Op__spec__bcctr_bo_17_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_17_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_17_aa_2_lk_1::Op__spec__bcctr_bo_17_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_17_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_18_aa_2_lk_0::Op__spec__bcctr_bo_18_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_18_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_18_aa_2_lk_1::Op__spec__bcctr_bo_18_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_18_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_19_aa_2_lk_0::Op__spec__bcctr_bo_19_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_19_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_19_aa_2_lk_1::Op__spec__bcctr_bo_19_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_19_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1a_aa_2_lk_0::Op__spec__bcctr_bo_1a_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1a_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1a_aa_2_lk_1::Op__spec__bcctr_bo_1a_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1a_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1b_aa_2_lk_0::Op__spec__bcctr_bo_1b_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1b_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1b_aa_2_lk_1::Op__spec__bcctr_bo_1b_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1b_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1c_aa_2_lk_0::Op__spec__bcctr_bo_1c_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1c_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1c_aa_2_lk_1::Op__spec__bcctr_bo_1c_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1c_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1d_aa_2_lk_0::Op__spec__bcctr_bo_1d_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1d_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1d_aa_2_lk_1::Op__spec__bcctr_bo_1d_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1d_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1e_aa_2_lk_0::Op__spec__bcctr_bo_1e_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1e_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1e_aa_2_lk_1::Op__spec__bcctr_bo_1e_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1e_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1f_aa_2_lk_0::Op__spec__bcctr_bo_1f_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1f_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bcctr_bo_1f_aa_2_lk_1::Op__spec__bcctr_bo_1f_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bcctr_bo_1f_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_0_aa_0_lk_0::Op__spec__bc_bo_0_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_0_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_0_aa_0_lk_1::Op__spec__bc_bo_0_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_0_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_0_aa_1_lk_0::Op__spec__bc_bo_0_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_0_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_0_aa_1_lk_1::Op__spec__bc_bo_0_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_0_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1_aa_0_lk_0::Op__spec__bc_bo_1_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1_aa_0_lk_1::Op__spec__bc_bo_1_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1_aa_1_lk_0::Op__spec__bc_bo_1_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1_aa_1_lk_1::Op__spec__bc_bo_1_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_2_aa_0_lk_0::Op__spec__bc_bo_2_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_2_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_2_aa_0_lk_1::Op__spec__bc_bo_2_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_2_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_2_aa_1_lk_0::Op__spec__bc_bo_2_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_2_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_2_aa_1_lk_1::Op__spec__bc_bo_2_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_2_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_3_aa_0_lk_0::Op__spec__bc_bo_3_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_3_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_3_aa_0_lk_1::Op__spec__bc_bo_3_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_3_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_3_aa_1_lk_0::Op__spec__bc_bo_3_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_3_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_3_aa_1_lk_1::Op__spec__bc_bo_3_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_3_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_4_aa_0_lk_0::Op__spec__bc_bo_4_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_4_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_4_aa_0_lk_1::Op__spec__bc_bo_4_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_4_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_4_aa_1_lk_0::Op__spec__bc_bo_4_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_4_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_4_aa_1_lk_1::Op__spec__bc_bo_4_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_4_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_5_aa_0_lk_0::Op__spec__bc_bo_5_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_5_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_5_aa_0_lk_1::Op__spec__bc_bo_5_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_5_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_5_aa_1_lk_0::Op__spec__bc_bo_5_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_5_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_5_aa_1_lk_1::Op__spec__bc_bo_5_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_5_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_6_aa_0_lk_0::Op__spec__bc_bo_6_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_6_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_6_aa_0_lk_1::Op__spec__bc_bo_6_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_6_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_6_aa_1_lk_0::Op__spec__bc_bo_6_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_6_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_6_aa_1_lk_1::Op__spec__bc_bo_6_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_6_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_7_aa_0_lk_0::Op__spec__bc_bo_7_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_7_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_7_aa_0_lk_1::Op__spec__bc_bo_7_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_7_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_7_aa_1_lk_0::Op__spec__bc_bo_7_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_7_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_7_aa_1_lk_1::Op__spec__bc_bo_7_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_7_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_8_aa_0_lk_0::Op__spec__bc_bo_8_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_8_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_8_aa_0_lk_1::Op__spec__bc_bo_8_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_8_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_8_aa_1_lk_0::Op__spec__bc_bo_8_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_8_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_8_aa_1_lk_1::Op__spec__bc_bo_8_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_8_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_9_aa_0_lk_0::Op__spec__bc_bo_9_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_9_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_9_aa_0_lk_1::Op__spec__bc_bo_9_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_9_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_9_aa_1_lk_0::Op__spec__bc_bo_9_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_9_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_9_aa_1_lk_1::Op__spec__bc_bo_9_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_9_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_a_aa_0_lk_0::Op__spec__bc_bo_a_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_a_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_a_aa_0_lk_1::Op__spec__bc_bo_a_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_a_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_a_aa_1_lk_0::Op__spec__bc_bo_a_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_a_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_a_aa_1_lk_1::Op__spec__bc_bo_a_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_a_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_b_aa_0_lk_0::Op__spec__bc_bo_b_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_b_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_b_aa_0_lk_1::Op__spec__bc_bo_b_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_b_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_b_aa_1_lk_0::Op__spec__bc_bo_b_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_b_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_b_aa_1_lk_1::Op__spec__bc_bo_b_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_b_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_c_aa_0_lk_0::Op__spec__bc_bo_c_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_c_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_c_aa_0_lk_1::Op__spec__bc_bo_c_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_c_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_c_aa_1_lk_0::Op__spec__bc_bo_c_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_c_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_c_aa_1_lk_1::Op__spec__bc_bo_c_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_c_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_d_aa_0_lk_0::Op__spec__bc_bo_d_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_d_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_d_aa_0_lk_1::Op__spec__bc_bo_d_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_d_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_d_aa_1_lk_0::Op__spec__bc_bo_d_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_d_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_d_aa_1_lk_1::Op__spec__bc_bo_d_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_d_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_e_aa_0_lk_0::Op__spec__bc_bo_e_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_e_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_e_aa_0_lk_1::Op__spec__bc_bo_e_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_e_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_e_aa_1_lk_0::Op__spec__bc_bo_e_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_e_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_e_aa_1_lk_1::Op__spec__bc_bo_e_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_e_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_f_aa_0_lk_0::Op__spec__bc_bo_f_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_f_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_f_aa_0_lk_1::Op__spec__bc_bo_f_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_f_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_f_aa_1_lk_0::Op__spec__bc_bo_f_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_f_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_f_aa_1_lk_1::Op__spec__bc_bo_f_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_f_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_10_aa_0_lk_0::Op__spec__bc_bo_10_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_10_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_10_aa_0_lk_1::Op__spec__bc_bo_10_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_10_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_10_aa_1_lk_0::Op__spec__bc_bo_10_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_10_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_10_aa_1_lk_1::Op__spec__bc_bo_10_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_10_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_11_aa_0_lk_0::Op__spec__bc_bo_11_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_11_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_11_aa_0_lk_1::Op__spec__bc_bo_11_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_11_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_11_aa_1_lk_0::Op__spec__bc_bo_11_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_11_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_11_aa_1_lk_1::Op__spec__bc_bo_11_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_11_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_12_aa_0_lk_0::Op__spec__bc_bo_12_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_12_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_12_aa_0_lk_1::Op__spec__bc_bo_12_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_12_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_12_aa_1_lk_0::Op__spec__bc_bo_12_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_12_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_12_aa_1_lk_1::Op__spec__bc_bo_12_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_12_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_13_aa_0_lk_0::Op__spec__bc_bo_13_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_13_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_13_aa_0_lk_1::Op__spec__bc_bo_13_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_13_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_13_aa_1_lk_0::Op__spec__bc_bo_13_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_13_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_13_aa_1_lk_1::Op__spec__bc_bo_13_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_13_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_14_aa_0_lk_0::Op__spec__bc_bo_14_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_14_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_14_aa_0_lk_1::Op__spec__bc_bo_14_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_14_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_14_aa_1_lk_0::Op__spec__bc_bo_14_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_14_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_14_aa_1_lk_1::Op__spec__bc_bo_14_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_14_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_15_aa_0_lk_0::Op__spec__bc_bo_15_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_15_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_15_aa_0_lk_1::Op__spec__bc_bo_15_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_15_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_15_aa_1_lk_0::Op__spec__bc_bo_15_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_15_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_15_aa_1_lk_1::Op__spec__bc_bo_15_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_15_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_16_aa_0_lk_0::Op__spec__bc_bo_16_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_16_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_16_aa_0_lk_1::Op__spec__bc_bo_16_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_16_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_16_aa_1_lk_0::Op__spec__bc_bo_16_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_16_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_16_aa_1_lk_1::Op__spec__bc_bo_16_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_16_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_17_aa_0_lk_0::Op__spec__bc_bo_17_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_17_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_17_aa_0_lk_1::Op__spec__bc_bo_17_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_17_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_17_aa_1_lk_0::Op__spec__bc_bo_17_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_17_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_17_aa_1_lk_1::Op__spec__bc_bo_17_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_17_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_18_aa_0_lk_0::Op__spec__bc_bo_18_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_18_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_18_aa_0_lk_1::Op__spec__bc_bo_18_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_18_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_18_aa_1_lk_0::Op__spec__bc_bo_18_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_18_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_18_aa_1_lk_1::Op__spec__bc_bo_18_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_18_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_19_aa_0_lk_0::Op__spec__bc_bo_19_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_19_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_19_aa_0_lk_1::Op__spec__bc_bo_19_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_19_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_19_aa_1_lk_0::Op__spec__bc_bo_19_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_19_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_19_aa_1_lk_1::Op__spec__bc_bo_19_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_19_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1a_aa_0_lk_0::Op__spec__bc_bo_1a_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1a_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1a_aa_0_lk_1::Op__spec__bc_bo_1a_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1a_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1a_aa_1_lk_0::Op__spec__bc_bo_1a_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1a_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1a_aa_1_lk_1::Op__spec__bc_bo_1a_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1a_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1b_aa_0_lk_0::Op__spec__bc_bo_1b_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1b_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1b_aa_0_lk_1::Op__spec__bc_bo_1b_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1b_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1b_aa_1_lk_0::Op__spec__bc_bo_1b_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1b_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1b_aa_1_lk_1::Op__spec__bc_bo_1b_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1b_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1c_aa_0_lk_0::Op__spec__bc_bo_1c_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1c_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1c_aa_0_lk_1::Op__spec__bc_bo_1c_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1c_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1c_aa_1_lk_0::Op__spec__bc_bo_1c_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1c_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1c_aa_1_lk_1::Op__spec__bc_bo_1c_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1c_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1d_aa_0_lk_0::Op__spec__bc_bo_1d_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1d_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1d_aa_0_lk_1::Op__spec__bc_bo_1d_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1d_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1d_aa_1_lk_0::Op__spec__bc_bo_1d_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1d_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1d_aa_1_lk_1::Op__spec__bc_bo_1d_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1d_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1e_aa_0_lk_0::Op__spec__bc_bo_1e_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1e_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1e_aa_0_lk_1::Op__spec__bc_bo_1e_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1e_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1e_aa_1_lk_0::Op__spec__bc_bo_1e_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1e_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1e_aa_1_lk_1::Op__spec__bc_bo_1e_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1e_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1f_aa_0_lk_0::Op__spec__bc_bo_1f_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1f_aa_0_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1f_aa_0_lk_1::Op__spec__bc_bo_1f_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1f_aa_0_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1f_aa_1_lk_0::Op__spec__bc_bo_1f_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1f_aa_1_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bc_bo_1f_aa_1_lk_1::Op__spec__bc_bo_1f_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bc_bo_1f_aa_1_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		bd14 = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_0_aa_2_lk_0::Op__spec__bclr_bo_0_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_0_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_0_aa_2_lk_1::Op__spec__bclr_bo_0_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_0_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1_aa_2_lk_0::Op__spec__bclr_bo_1_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1_aa_2_lk_1::Op__spec__bclr_bo_1_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_2_aa_2_lk_0::Op__spec__bclr_bo_2_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_2_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_2_aa_2_lk_1::Op__spec__bclr_bo_2_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_2_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_3_aa_2_lk_0::Op__spec__bclr_bo_3_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_3_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_3_aa_2_lk_1::Op__spec__bclr_bo_3_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_3_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_4_aa_2_lk_0::Op__spec__bclr_bo_4_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_4_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_4_aa_2_lk_1::Op__spec__bclr_bo_4_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_4_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_5_aa_2_lk_0::Op__spec__bclr_bo_5_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_5_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_5_aa_2_lk_1::Op__spec__bclr_bo_5_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_5_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_6_aa_2_lk_0::Op__spec__bclr_bo_6_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_6_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_6_aa_2_lk_1::Op__spec__bclr_bo_6_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_6_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_7_aa_2_lk_0::Op__spec__bclr_bo_7_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_7_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_7_aa_2_lk_1::Op__spec__bclr_bo_7_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_7_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_8_aa_2_lk_0::Op__spec__bclr_bo_8_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_8_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_8_aa_2_lk_1::Op__spec__bclr_bo_8_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_8_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_9_aa_2_lk_0::Op__spec__bclr_bo_9_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_9_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_9_aa_2_lk_1::Op__spec__bclr_bo_9_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_9_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_a_aa_2_lk_0::Op__spec__bclr_bo_a_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_a_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_a_aa_2_lk_1::Op__spec__bclr_bo_a_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_a_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_b_aa_2_lk_0::Op__spec__bclr_bo_b_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_b_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_b_aa_2_lk_1::Op__spec__bclr_bo_b_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_b_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_c_aa_2_lk_0::Op__spec__bclr_bo_c_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_c_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_c_aa_2_lk_1::Op__spec__bclr_bo_c_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_c_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_d_aa_2_lk_0::Op__spec__bclr_bo_d_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_d_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_d_aa_2_lk_1::Op__spec__bclr_bo_d_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_d_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_e_aa_2_lk_0::Op__spec__bclr_bo_e_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_e_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_e_aa_2_lk_1::Op__spec__bclr_bo_e_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_e_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_f_aa_2_lk_0::Op__spec__bclr_bo_f_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_f_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_f_aa_2_lk_1::Op__spec__bclr_bo_f_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_f_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_10_aa_2_lk_0::Op__spec__bclr_bo_10_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_10_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_10_aa_2_lk_1::Op__spec__bclr_bo_10_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_10_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_11_aa_2_lk_0::Op__spec__bclr_bo_11_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_11_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_11_aa_2_lk_1::Op__spec__bclr_bo_11_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_11_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_12_aa_2_lk_0::Op__spec__bclr_bo_12_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_12_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_12_aa_2_lk_1::Op__spec__bclr_bo_12_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_12_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_13_aa_2_lk_0::Op__spec__bclr_bo_13_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_13_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_13_aa_2_lk_1::Op__spec__bclr_bo_13_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_13_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_14_aa_2_lk_0::Op__spec__bclr_bo_14_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_14_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_14_aa_2_lk_1::Op__spec__bclr_bo_14_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_14_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_15_aa_2_lk_0::Op__spec__bclr_bo_15_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_15_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_15_aa_2_lk_1::Op__spec__bclr_bo_15_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_15_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_16_aa_2_lk_0::Op__spec__bclr_bo_16_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_16_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_16_aa_2_lk_1::Op__spec__bclr_bo_16_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_16_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_17_aa_2_lk_0::Op__spec__bclr_bo_17_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_17_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_17_aa_2_lk_1::Op__spec__bclr_bo_17_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_17_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_18_aa_2_lk_0::Op__spec__bclr_bo_18_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_18_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_18_aa_2_lk_1::Op__spec__bclr_bo_18_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_18_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_19_aa_2_lk_0::Op__spec__bclr_bo_19_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_19_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_19_aa_2_lk_1::Op__spec__bclr_bo_19_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_19_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1a_aa_2_lk_0::Op__spec__bclr_bo_1a_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1a_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1a_aa_2_lk_1::Op__spec__bclr_bo_1a_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1a_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1b_aa_2_lk_0::Op__spec__bclr_bo_1b_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1b_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1b_aa_2_lk_1::Op__spec__bclr_bo_1b_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1b_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1c_aa_2_lk_0::Op__spec__bclr_bo_1c_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1c_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1c_aa_2_lk_1::Op__spec__bclr_bo_1c_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1c_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1d_aa_2_lk_0::Op__spec__bclr_bo_1d_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1d_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1d_aa_2_lk_1::Op__spec__bclr_bo_1d_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1d_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1e_aa_2_lk_0::Op__spec__bclr_bo_1e_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1e_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1e_aa_2_lk_1::Op__spec__bclr_bo_1e_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1e_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1f_aa_2_lk_0::Op__spec__bclr_bo_1f_aa_2_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1f_aa_2_lk_0")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__bclr_bo_1f_aa_2_lk_1::Op__spec__bclr_bo_1f_aa_2_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__bclr_bo_1f_aa_2_lk_1")
	{
		bo = uint8_t((code >> 21) & 0x1f);
		bi = uint8_t((code >> 16) & 0x1f);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__b_aa_0_lk_0::Op__spec__b_aa_0_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__b_aa_0_lk_0")
	{
		li24 = ((int32_t)(((code >> 2) & 0xffffff) << 8) >> 8) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__b_aa_0_lk_1::Op__spec__b_aa_0_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__b_aa_0_lk_1")
	{
		li24 = ((int32_t)(((code >> 2) & 0xffffff) << 8) >> 8) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__b_aa_1_lk_0::Op__spec__b_aa_1_lk_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__b_aa_1_lk_0")
	{
		li24 = ((int32_t)(((code >> 2) & 0xffffff) << 8) >> 8) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__b_aa_1_lk_1::Op__spec__b_aa_1_lk_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__b_aa_1_lk_1")
	{
		li24 = ((int32_t)(((code >> 2) & 0xffffff) << 8) >> 8) << 2;
		aa = uint8_t((code >> 1) & 0x1);
		lk = uint8_t(code & 0x1);
	}

	Op__spec__addc_rc_0_oe_0::Op__spec__addc_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addc_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addc_rc_0_oe_1::Op__spec__addc_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addc_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addc_rc_1_oe_0::Op__spec__addc_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addc_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addc_rc_1_oe_1::Op__spec__addc_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addc_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__adde_rc_0_oe_0::Op__spec__adde_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__adde_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__adde_rc_0_oe_1::Op__spec__adde_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__adde_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__adde_rc_1_oe_0::Op__spec__adde_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__adde_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__adde_rc_1_oe_1::Op__spec__adde_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__adde_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__add_rc_0_oe_0::Op__spec__add_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__add_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__add_rc_0_oe_1::Op__spec__add_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__add_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__add_rc_1_oe_0::Op__spec__add_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__add_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__add_rc_1_oe_1::Op__spec__add_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__add_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addme_rc_0_oe_0::Op__spec__addme_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addme_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addme_rc_0_oe_1::Op__spec__addme_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addme_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addme_rc_1_oe_0::Op__spec__addme_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addme_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addme_rc_1_oe_1::Op__spec__addme_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addme_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addze_rc_0_oe_0::Op__spec__addze_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addze_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addze_rc_0_oe_1::Op__spec__addze_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addze_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addze_rc_1_oe_0::Op__spec__addze_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addze_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__addze_rc_1_oe_1::Op__spec__addze_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__addze_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__andc_rc_0::Op__spec__andc_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__andc_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__andc_rc_1::Op__spec__andc_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__andc_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__and_rc_0::Op__spec__and_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__and_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__and_rc_1::Op__spec__and_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__and_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__cmp_crfD_0::Op__spec__cmp_crfD_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmp_crfD_0")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmp_crfD_1::Op__spec__cmp_crfD_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmp_crfD_1")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmp_crfD_2::Op__spec__cmp_crfD_2(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmp_crfD_2")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmp_crfD_3::Op__spec__cmp_crfD_3(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmp_crfD_3")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmp_crfD_4::Op__spec__cmp_crfD_4(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmp_crfD_4")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmp_crfD_5::Op__spec__cmp_crfD_5(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmp_crfD_5")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmp_crfD_6::Op__spec__cmp_crfD_6(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmp_crfD_6")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmp_crfD_7::Op__spec__cmp_crfD_7(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmp_crfD_7")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpL_crfD_0::Op__spec__cmpL_crfD_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpL_crfD_0")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpL_crfD_1::Op__spec__cmpL_crfD_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpL_crfD_1")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpL_crfD_2::Op__spec__cmpL_crfD_2(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpL_crfD_2")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpL_crfD_3::Op__spec__cmpL_crfD_3(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpL_crfD_3")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpL_crfD_4::Op__spec__cmpL_crfD_4(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpL_crfD_4")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpL_crfD_5::Op__spec__cmpL_crfD_5(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpL_crfD_5")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpL_crfD_6::Op__spec__cmpL_crfD_6(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpL_crfD_6")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpL_crfD_7::Op__spec__cmpL_crfD_7(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpL_crfD_7")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpl_crfD_0::Op__spec__cmpl_crfD_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpl_crfD_0")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpl_crfD_1::Op__spec__cmpl_crfD_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpl_crfD_1")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpl_crfD_2::Op__spec__cmpl_crfD_2(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpl_crfD_2")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpl_crfD_3::Op__spec__cmpl_crfD_3(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpl_crfD_3")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpl_crfD_4::Op__spec__cmpl_crfD_4(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpl_crfD_4")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpl_crfD_5::Op__spec__cmpl_crfD_5(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpl_crfD_5")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpl_crfD_6::Op__spec__cmpl_crfD_6(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpl_crfD_6")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmpl_crfD_7::Op__spec__cmpl_crfD_7(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmpl_crfD_7")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmplL_crfD_0::Op__spec__cmplL_crfD_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmplL_crfD_0")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmplL_crfD_1::Op__spec__cmplL_crfD_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmplL_crfD_1")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmplL_crfD_2::Op__spec__cmplL_crfD_2(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmplL_crfD_2")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmplL_crfD_3::Op__spec__cmplL_crfD_3(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmplL_crfD_3")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmplL_crfD_4::Op__spec__cmplL_crfD_4(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmplL_crfD_4")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmplL_crfD_5::Op__spec__cmplL_crfD_5(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmplL_crfD_5")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmplL_crfD_6::Op__spec__cmplL_crfD_6(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmplL_crfD_6")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cmplL_crfD_7::Op__spec__cmplL_crfD_7(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cmplL_crfD_7")
	{
		crfD = uint8_t((code >> 23) & 0x7);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
	}

	Op__spec__cntlzw_rc_0::Op__spec__cntlzw_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cntlzw_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__cntlzw_rc_1::Op__spec__cntlzw_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cntlzw_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__cntlzd_rc_0::Op__spec__cntlzd_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cntlzd_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__cntlzd_rc_1::Op__spec__cntlzd_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__cntlzd_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divw_rc_0_oe_0::Op__spec__divw_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divw_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divw_rc_0_oe_1::Op__spec__divw_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divw_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divw_rc_1_oe_0::Op__spec__divw_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divw_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divw_rc_1_oe_1::Op__spec__divw_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divw_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divwu_rc_0_oe_0::Op__spec__divwu_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divwu_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divwu_rc_0_oe_1::Op__spec__divwu_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divwu_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divwu_rc_1_oe_0::Op__spec__divwu_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divwu_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divwu_rc_1_oe_1::Op__spec__divwu_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divwu_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divd_rc_0_oe_0::Op__spec__divd_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divd_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divd_rc_0_oe_1::Op__spec__divd_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divd_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divd_rc_1_oe_0::Op__spec__divd_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divd_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divd_rc_1_oe_1::Op__spec__divd_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divd_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divdu_rc_0_oe_0::Op__spec__divdu_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divdu_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divdu_rc_0_oe_1::Op__spec__divdu_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divdu_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divdu_rc_1_oe_0::Op__spec__divdu_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divdu_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__divdu_rc_1_oe_1::Op__spec__divdu_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__divdu_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__eqv_rc_0::Op__spec__eqv_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__eqv_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__eqv_rc_1::Op__spec__eqv_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__eqv_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__extsb_rc_0::Op__spec__extsb_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__extsb_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__extsb_rc_1::Op__spec__extsb_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__extsb_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__extsh_rc_0::Op__spec__extsh_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__extsh_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__extsh_rc_1::Op__spec__extsh_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__extsh_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__extsw_rc_0::Op__spec__extsw_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__extsw_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__extsw_rc_1::Op__spec__extsw_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__extsw_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mcrxr_crfD_0::Op__spec__mcrxr_crfD_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mcrxr_crfD_0")
	{
		crfD = uint8_t((code >> 23) & 0x7);
	}

	Op__spec__mcrxr_crfD_1::Op__spec__mcrxr_crfD_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mcrxr_crfD_1")
	{
		crfD = uint8_t((code >> 23) & 0x7);
	}

	Op__spec__mcrxr_crfD_2::Op__spec__mcrxr_crfD_2(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mcrxr_crfD_2")
	{
		crfD = uint8_t((code >> 23) & 0x7);
	}

	Op__spec__mcrxr_crfD_3::Op__spec__mcrxr_crfD_3(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mcrxr_crfD_3")
	{
		crfD = uint8_t((code >> 23) & 0x7);
	}

	Op__spec__mcrxr_crfD_4::Op__spec__mcrxr_crfD_4(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mcrxr_crfD_4")
	{
		crfD = uint8_t((code >> 23) & 0x7);
	}

	Op__spec__mcrxr_crfD_5::Op__spec__mcrxr_crfD_5(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mcrxr_crfD_5")
	{
		crfD = uint8_t((code >> 23) & 0x7);
	}

	Op__spec__mcrxr_crfD_6::Op__spec__mcrxr_crfD_6(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mcrxr_crfD_6")
	{
		crfD = uint8_t((code >> 23) & 0x7);
	}

	Op__spec__mcrxr_crfD_7::Op__spec__mcrxr_crfD_7(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mcrxr_crfD_7")
	{
		crfD = uint8_t((code >> 23) & 0x7);
	}

	Op__spec__mulhw_rc_0::Op__spec__mulhw_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulhw_rc_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulhw_rc_1::Op__spec__mulhw_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulhw_rc_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulhwu_rc_0::Op__spec__mulhwu_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulhwu_rc_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulhwu_rc_1::Op__spec__mulhwu_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulhwu_rc_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mullw_rc_0_oe_0::Op__spec__mullw_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mullw_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mullw_rc_0_oe_1::Op__spec__mullw_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mullw_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mullw_rc_1_oe_0::Op__spec__mullw_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mullw_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mullw_rc_1_oe_1::Op__spec__mullw_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mullw_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulhd_rc_0::Op__spec__mulhd_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulhd_rc_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulhd_rc_1::Op__spec__mulhd_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulhd_rc_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulhdu_rc_0::Op__spec__mulhdu_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulhdu_rc_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulhdu_rc_1::Op__spec__mulhdu_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulhdu_rc_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulld_rc_0_oe_0::Op__spec__mulld_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulld_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulld_rc_0_oe_1::Op__spec__mulld_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulld_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulld_rc_1_oe_0::Op__spec__mulld_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulld_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mulld_rc_1_oe_1::Op__spec__mulld_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mulld_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__nand_rc_0::Op__spec__nand_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__nand_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__nand_rc_1::Op__spec__nand_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__nand_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__neg_rc_0_oe_0::Op__spec__neg_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__neg_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__neg_rc_0_oe_1::Op__spec__neg_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__neg_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__neg_rc_1_oe_0::Op__spec__neg_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__neg_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__neg_rc_1_oe_1::Op__spec__neg_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__neg_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__nor_rc_0::Op__spec__nor_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__nor_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__nor_rc_1::Op__spec__nor_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__nor_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__orc_rc_0::Op__spec__orc_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__orc_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__orc_rc_1::Op__spec__orc_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__orc_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__or_rc_0::Op__spec__or_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__or_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__or_rc_1::Op__spec__or_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__or_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__rlwimi_rc_0::Op__spec__rlwimi_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rlwimi_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh = uint8_t((code >> 11) & 0x1f);
		mb = uint8_t((code >> 6) & 0x1f);
		me = uint8_t((code >> 1) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__rlwimi_rc_1::Op__spec__rlwimi_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rlwimi_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh = uint8_t((code >> 11) & 0x1f);
		mb = uint8_t((code >> 6) & 0x1f);
		me = uint8_t((code >> 1) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__rlwinm_rc_0::Op__spec__rlwinm_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rlwinm_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh = uint8_t((code >> 11) & 0x1f);
		mb = uint8_t((code >> 6) & 0x1f);
		me = uint8_t((code >> 1) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__rlwinm_rc_1::Op__spec__rlwinm_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rlwinm_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh = uint8_t((code >> 11) & 0x1f);
		mb = uint8_t((code >> 6) & 0x1f);
		me = uint8_t((code >> 1) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__rlwnm_rc_0::Op__spec__rlwnm_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rlwnm_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		mb = uint8_t((code >> 6) & 0x1f);
		me = uint8_t((code >> 1) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__rlwnm_rc_1::Op__spec__rlwnm_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rlwnm_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		mb = uint8_t((code >> 6) & 0x1f);
		me = uint8_t((code >> 1) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__rldicl_rc_0::Op__spec__rldicl_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldicl_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		n = sh0|sh1;
		mb = mb0|mb1;
	}

	Op__spec__rldicl_rc_1::Op__spec__rldicl_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldicl_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		n = sh0|sh1;
		mb = mb0|mb1;
	}

	Op__spec__rldicr_rc_0::Op__spec__rldicr_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldicr_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		me1 = uint8_t((code >> 6) & 0x1f);
		me0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		n = sh0|sh1;
		me = me0|me1;
	}

	Op__spec__rldicr_rc_1::Op__spec__rldicr_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldicr_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		me1 = uint8_t((code >> 6) & 0x1f);
		me0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		n = sh0|sh1;
		me = me0|me1;
	}

	Op__spec__rldic_rc_0::Op__spec__rldic_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldic_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		n = sh0|sh1;
		mb = mb0|mb1;
	}

	Op__spec__rldic_rc_1::Op__spec__rldic_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldic_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		n = sh0|sh1;
		mb = mb0|mb1;
	}

	Op__spec__rldcl_rc_0::Op__spec__rldcl_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldcl_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		mb = mb0|mb1;
	}

	Op__spec__rldcl_rc_1::Op__spec__rldcl_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldcl_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		mb = mb0|mb1;
	}

	Op__spec__rldcr_rc_0::Op__spec__rldcr_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldcr_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		me1 = uint8_t((code >> 6) & 0x1f);
		me0 = uint8_t((code >> 5) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		me = me0|me1;
	}

	Op__spec__rldcr_rc_1::Op__spec__rldcr_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldcr_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		me1 = uint8_t((code >> 6) & 0x1f);
		me0 = uint8_t((code >> 5) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		me = me0|me1;
	}

	Op__spec__rldimi_rc_0::Op__spec__rldimi_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldimi_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		sh = sh0|sh1;
		mb = mb0|mb1;
	}

	Op__spec__rldimi_rc_1::Op__spec__rldimi_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__rldimi_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		mb1 = uint8_t((code >> 6) & 0x1f);
		mb0 = uint8_t((code >> 5) & 0x1) << 5;
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		sh = sh0|sh1;
		mb = mb0|mb1;
	}

	Op__spec__slw_rc_0::Op__spec__slw_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__slw_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__slw_rc_1::Op__spec__slw_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__slw_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__srawi_rc_0::Op__spec__srawi_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__srawi_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
		shifted_out = (1 << sh)-1;
	}

	Op__spec__srawi_rc_1::Op__spec__srawi_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__srawi_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
		shifted_out = (1 << sh)-1;
	}

	Op__spec__sraw_rc_0::Op__spec__sraw_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__sraw_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__sraw_rc_1::Op__spec__sraw_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__sraw_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__srw_rc_0::Op__spec__srw_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__srw_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__srw_rc_1::Op__spec__srw_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__srw_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__sld_rc_0::Op__spec__sld_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__sld_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__sld_rc_1::Op__spec__sld_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__sld_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__sradi_rc_0::Op__spec__sradi_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__sradi_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		sh = sh0|sh1;
	}

	Op__spec__sradi_rc_1::Op__spec__sradi_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__sradi_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		sh1 = uint8_t((code >> 11) & 0x1f);
		sh0 = uint8_t((code >> 1) & 0x1) << 5;
		rc = uint8_t(code & 0x1);
		sh = sh0|sh1;
	}

	Op__spec__srad_rc_0::Op__spec__srad_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__srad_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__srad_rc_1::Op__spec__srad_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__srad_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__srd_rc_0::Op__spec__srd_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__srd_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__srd_rc_1::Op__spec__srd_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__srd_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__stwu_rs_1_ra_1::Op__spec__stwu_rs_1_ra_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__stwu_rs_1_ra_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)((code & 0xffff) << 0) >> 0);
	}

	Op__spec__stdu_rs_1_ra_1::Op__spec__stdu_rs_1_ra_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__stdu_rs_1_ra_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		d = ((int16_t)(((code >> 2) & 0x3fff) << 2) >> 2) << 2;
	}

	Op__spec__subfc_rc_0_oe_0::Op__spec__subfc_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfc_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfc_rc_0_oe_1::Op__spec__subfc_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfc_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfc_rc_1_oe_0::Op__spec__subfc_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfc_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfc_rc_1_oe_1::Op__spec__subfc_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfc_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfe_rc_0_oe_0::Op__spec__subfe_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfe_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfe_rc_0_oe_1::Op__spec__subfe_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfe_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfe_rc_1_oe_0::Op__spec__subfe_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfe_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfe_rc_1_oe_1::Op__spec__subfe_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfe_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subf_rc_0_oe_0::Op__spec__subf_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subf_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subf_rc_0_oe_1::Op__spec__subf_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subf_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subf_rc_1_oe_0::Op__spec__subf_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subf_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subf_rc_1_oe_1::Op__spec__subf_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subf_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfme_rc_0_oe_0::Op__spec__subfme_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfme_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfme_rc_0_oe_1::Op__spec__subfme_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfme_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfme_rc_1_oe_0::Op__spec__subfme_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfme_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfme_rc_1_oe_1::Op__spec__subfme_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfme_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfze_rc_0_oe_0::Op__spec__subfze_rc_0_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfze_rc_0_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfze_rc_0_oe_1::Op__spec__subfze_rc_0_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfze_rc_0_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfze_rc_1_oe_0::Op__spec__subfze_rc_1_oe_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfze_rc_1_oe_0")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__subfze_rc_1_oe_1::Op__spec__subfze_rc_1_oe_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__subfze_rc_1_oe_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		oe = uint8_t((code >> 10) & 0x1);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__xor_rc_0::Op__spec__xor_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__xor_rc_0")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__xor_rc_1::Op__spec__xor_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__xor_rc_1")
	{
		rs = uint8_t((code >> 21) & 0x1f);
		ra = uint8_t((code >> 16) & 0x1f);
		rb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fabs_rc_0::Op__spec__fabs_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fabs_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fabs_rc_1::Op__spec__fabs_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fabs_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fadd_rc_0::Op__spec__fadd_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fadd_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fadd_rc_1::Op__spec__fadd_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fadd_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fadds_rc_0::Op__spec__fadds_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fadds_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fadds_rc_1::Op__spec__fadds_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fadds_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fctiw_rc_0::Op__spec__fctiw_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fctiw_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fctiw_rc_1::Op__spec__fctiw_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fctiw_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fctiwz_rc_0::Op__spec__fctiwz_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fctiwz_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fctiwz_rc_1::Op__spec__fctiwz_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fctiwz_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fctid_rc_0::Op__spec__fctid_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fctid_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fctid_rc_1::Op__spec__fctid_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fctid_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fctidz_rc_0::Op__spec__fctidz_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fctidz_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fctidz_rc_1::Op__spec__fctidz_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fctidz_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fcfid_rc_0::Op__spec__fcfid_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fcfid_rc_0")
	{
		frt = uint8_t((code >> 21) & 0x1f);
		frb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fcfid_rc_1::Op__spec__fcfid_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fcfid_rc_1")
	{
		frt = uint8_t((code >> 21) & 0x1f);
		frb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fdiv_rc_0::Op__spec__fdiv_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fdiv_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fdiv_rc_1::Op__spec__fdiv_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fdiv_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fdivs_rc_0::Op__spec__fdivs_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fdivs_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fdivs_rc_1::Op__spec__fdivs_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fdivs_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmadd_rc_0::Op__spec__fmadd_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmadd_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmadd_rc_1::Op__spec__fmadd_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmadd_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmadds_rc_0::Op__spec__fmadds_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmadds_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmadds_rc_1::Op__spec__fmadds_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmadds_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmr_rc_0::Op__spec__fmr_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmr_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmr_rc_1::Op__spec__fmr_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmr_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmsub_rc_0::Op__spec__fmsub_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmsub_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmsub_rc_1::Op__spec__fmsub_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmsub_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmsubs_rc_0::Op__spec__fmsubs_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmsubs_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmsubs_rc_1::Op__spec__fmsubs_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmsubs_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmul_rc_0::Op__spec__fmul_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmul_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmul_rc_1::Op__spec__fmul_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmul_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmuls_rc_0::Op__spec__fmuls_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmuls_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fmuls_rc_1::Op__spec__fmuls_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fmuls_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnabs_rc_0::Op__spec__fnabs_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnabs_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnabs_rc_1::Op__spec__fnabs_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnabs_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fneg_rc_0::Op__spec__fneg_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fneg_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fneg_rc_1::Op__spec__fneg_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fneg_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnmadd_rc_0::Op__spec__fnmadd_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnmadd_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnmadd_rc_1::Op__spec__fnmadd_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnmadd_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnmadds_rc_0::Op__spec__fnmadds_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnmadds_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnmadds_rc_1::Op__spec__fnmadds_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnmadds_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnmsub_rc_0::Op__spec__fnmsub_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnmsub_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnmsub_rc_1::Op__spec__fnmsub_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnmsub_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnmsubs_rc_0::Op__spec__fnmsubs_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnmsubs_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fnmsubs_rc_1::Op__spec__fnmsubs_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fnmsubs_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__frsp_rc_0::Op__spec__frsp_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__frsp_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__frsp_rc_1::Op__spec__frsp_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__frsp_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fsel_rc_0::Op__spec__fsel_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fsel_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fsel_rc_1::Op__spec__fsel_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fsel_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		fc = uint8_t((code >> 6) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fsub_rc_0::Op__spec__fsub_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fsub_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fsub_rc_1::Op__spec__fsub_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fsub_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fsubs_rc_0::Op__spec__fsubs_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fsubs_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__fsubs_rc_1::Op__spec__fsubs_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__fsubs_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		fa = uint8_t((code >> 16) & 0x1f);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mffs_rc_0::Op__spec__mffs_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mffs_rc_0")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mffs_rc_1::Op__spec__mffs_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mffs_rc_1")
	{
		fd = uint8_t((code >> 21) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mtfsb0_rc_0::Op__spec__mtfsb0_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mtfsb0_rc_0")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mtfsb0_rc_1::Op__spec__mtfsb0_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mtfsb0_rc_1")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mtfsb1_rc_0::Op__spec__mtfsb1_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mtfsb1_rc_0")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mtfsb1_rc_1::Op__spec__mtfsb1_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mtfsb1_rc_1")
	{
		bt = uint8_t((code >> 21) & 0x1f);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mtfsfi_rc_0::Op__spec__mtfsfi_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mtfsfi_rc_0")
	{
		bft = uint8_t((code >> 23) & 0x7);
		w = uint8_t((code >> 16) & 0x1);
		imm = uint8_t((code >> 12) & 0xf);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mtfsfi_rc_1::Op__spec__mtfsfi_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mtfsfi_rc_1")
	{
		bft = uint8_t((code >> 23) & 0x7);
		w = uint8_t((code >> 16) & 0x1);
		imm = uint8_t((code >> 12) & 0xf);
		rc = uint8_t(code & 0x1);
	}

	Op__spec__mtfsf_rc_0::Op__spec__mtfsf_rc_0(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mtfsf_rc_0")
	{
		l = uint8_t((code >> 25) & 0x1);
		fm = uint8_t((code >> 17) & 0xff);
		w = uint8_t((code >> 16) & 0x1);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
		fsmask = (((fm&0x80) << 21)|((fm&0x40) << 18)|((fm&0x20) << 15)|((fm&0x10) << 12)|((fm&8) << 9)|((fm&4) << 6)|((fm&2) << 3)|((fm&1) << 0))*0xf;
	}

	Op__spec__mtfsf_rc_1::Op__spec__mtfsf_rc_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mtfsf_rc_1")
	{
		l = uint8_t((code >> 25) & 0x1);
		fm = uint8_t((code >> 17) & 0xff);
		w = uint8_t((code >> 16) & 0x1);
		fb = uint8_t((code >> 11) & 0x1f);
		rc = uint8_t(code & 0x1);
		fsmask = (((fm&0x80) << 21)|((fm&0x40) << 18)|((fm&0x20) << 15)|((fm&0x10) << 12)|((fm&8) << 9)|((fm&4) << 6)|((fm&2) << 3)|((fm&1) << 0))*0xf;
	}

	Op__spec__mfspr_spr0_0_spr1_1::Op__spec__mfspr_spr0_0_spr1_1(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mfspr_spr0_0_spr1_1")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		spr1 = uint8_t((code >> 16) & 0x1f);
		spr0 = uint8_t((code >> 11) & 0x1f);
		n = spr0<<5 | spr1;
	}

	Op__spec__mfspr_spr0_0_spr1_8::Op__spec__mfspr_spr0_0_spr1_8(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mfspr_spr0_0_spr1_8")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		spr1 = uint8_t((code >> 16) & 0x1f);
		spr0 = uint8_t((code >> 11) & 0x1f);
		n = spr0<<5 | spr1;
	}

	Op__spec__mfspr_spr0_0_spr1_9::Op__spec__mfspr_spr0_0_spr1_9(CodeType code, uint64_t addr) : Operation(code, addr, "__spec__mfspr_spr0_0_spr1_9")
	{
		rd = uint8_t((code >> 21) & 0x1f);
		spr1 = uint8_t((code >> 16) & 0x1f);
		spr0 = uint8_t((code >> 11) & 0x1f);
		n = spr0<<5 | spr1;
	}

	DecodeTableEntry::DecodeTableEntry(CodeType opcode, CodeType opcode_mask, Operation *(*decode)(CodeType, uint64_t))
	{
		this->opcode = opcode;
		this->opcode_mask = opcode_mask;
		this->decode = decode;
	}

	Decoder::Decoder()

	{
		decode_table.push_back(DecodeTableEntry(0x7c0902a6UL, 0xfc1ffffeUL, DecodeOp__spec__mfspr_spr0_0_spr1_9));
		decode_table.push_back(DecodeTableEntry(0x7c0802a6UL, 0xfc1ffffeUL, DecodeOp__spec__mfspr_spr0_0_spr1_8));
		decode_table.push_back(DecodeTableEntry(0x7c0102a6UL, 0xfc1ffffeUL, DecodeOp__spec__mfspr_spr0_0_spr1_1));
		decode_table.push_back(DecodeTableEntry(0xfc00058fUL, 0xfc0007ffUL, DecodeOp__spec__mtfsf_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00058eUL, 0xfc0007ffUL, DecodeOp__spec__mtfsf_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00010dUL, 0xfc0007ffUL, DecodeOp__spec__mtfsfi_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00010cUL, 0xfc0007ffUL, DecodeOp__spec__mtfsfi_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00004dUL, 0xfc0007ffUL, DecodeOp__spec__mtfsb1_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00004cUL, 0xfc0007ffUL, DecodeOp__spec__mtfsb1_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00008dUL, 0xfc0007ffUL, DecodeOp__spec__mtfsb0_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00008cUL, 0xfc0007ffUL, DecodeOp__spec__mtfsb0_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00048fUL, 0xfc0007ffUL, DecodeOp__spec__mffs_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00048eUL, 0xfc0007ffUL, DecodeOp__spec__mffs_rc_0));
		decode_table.push_back(DecodeTableEntry(0xec000029UL, 0xfc00003fUL, DecodeOp__spec__fsubs_rc_1));
		decode_table.push_back(DecodeTableEntry(0xec000028UL, 0xfc00003fUL, DecodeOp__spec__fsubs_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc000029UL, 0xfc00003fUL, DecodeOp__spec__fsub_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc000028UL, 0xfc00003fUL, DecodeOp__spec__fsub_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00002fUL, 0xfc00003fUL, DecodeOp__spec__fsel_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00002eUL, 0xfc00003fUL, DecodeOp__spec__fsel_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc000019UL, 0xfc0007ffUL, DecodeOp__spec__frsp_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc000018UL, 0xfc0007ffUL, DecodeOp__spec__frsp_rc_0));
		decode_table.push_back(DecodeTableEntry(0xec00003dUL, 0xfc00003fUL, DecodeOp__spec__fnmsubs_rc_1));
		decode_table.push_back(DecodeTableEntry(0xec00003cUL, 0xfc00003fUL, DecodeOp__spec__fnmsubs_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00003dUL, 0xfc00003fUL, DecodeOp__spec__fnmsub_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00003cUL, 0xfc00003fUL, DecodeOp__spec__fnmsub_rc_0));
		decode_table.push_back(DecodeTableEntry(0xec00003fUL, 0xfc00003fUL, DecodeOp__spec__fnmadds_rc_1));
		decode_table.push_back(DecodeTableEntry(0xec00003eUL, 0xfc00003fUL, DecodeOp__spec__fnmadds_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00003fUL, 0xfc00003fUL, DecodeOp__spec__fnmadd_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00003eUL, 0xfc00003fUL, DecodeOp__spec__fnmadd_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc000051UL, 0xfc0007ffUL, DecodeOp__spec__fneg_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc000050UL, 0xfc0007ffUL, DecodeOp__spec__fneg_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc000111UL, 0xfc0007ffUL, DecodeOp__spec__fnabs_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc000110UL, 0xfc0007ffUL, DecodeOp__spec__fnabs_rc_0));
		decode_table.push_back(DecodeTableEntry(0xec000033UL, 0xfc00003fUL, DecodeOp__spec__fmuls_rc_1));
		decode_table.push_back(DecodeTableEntry(0xec000032UL, 0xfc00003fUL, DecodeOp__spec__fmuls_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc000033UL, 0xfc00003fUL, DecodeOp__spec__fmul_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc000032UL, 0xfc00003fUL, DecodeOp__spec__fmul_rc_0));
		decode_table.push_back(DecodeTableEntry(0xec000039UL, 0xfc00003fUL, DecodeOp__spec__fmsubs_rc_1));
		decode_table.push_back(DecodeTableEntry(0xec000038UL, 0xfc00003fUL, DecodeOp__spec__fmsubs_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc000039UL, 0xfc00003fUL, DecodeOp__spec__fmsub_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc000038UL, 0xfc00003fUL, DecodeOp__spec__fmsub_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc000091UL, 0xfc0007ffUL, DecodeOp__spec__fmr_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc000090UL, 0xfc0007ffUL, DecodeOp__spec__fmr_rc_0));
		decode_table.push_back(DecodeTableEntry(0xec00003bUL, 0xfc00003fUL, DecodeOp__spec__fmadds_rc_1));
		decode_table.push_back(DecodeTableEntry(0xec00003aUL, 0xfc00003fUL, DecodeOp__spec__fmadds_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00003bUL, 0xfc00003fUL, DecodeOp__spec__fmadd_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00003aUL, 0xfc00003fUL, DecodeOp__spec__fmadd_rc_0));
		decode_table.push_back(DecodeTableEntry(0xec000025UL, 0xfc00003fUL, DecodeOp__spec__fdivs_rc_1));
		decode_table.push_back(DecodeTableEntry(0xec000024UL, 0xfc00003fUL, DecodeOp__spec__fdivs_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc000025UL, 0xfc00003fUL, DecodeOp__spec__fdiv_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc000024UL, 0xfc00003fUL, DecodeOp__spec__fdiv_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00069dUL, 0xfc0007ffUL, DecodeOp__spec__fcfid_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00069cUL, 0xfc0007ffUL, DecodeOp__spec__fcfid_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00065fUL, 0xfc0007ffUL, DecodeOp__spec__fctidz_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00065eUL, 0xfc0007ffUL, DecodeOp__spec__fctidz_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00065dUL, 0xfc0007ffUL, DecodeOp__spec__fctid_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00065cUL, 0xfc0007ffUL, DecodeOp__spec__fctid_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00001fUL, 0xfc0007ffUL, DecodeOp__spec__fctiwz_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00001eUL, 0xfc0007ffUL, DecodeOp__spec__fctiwz_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00001dUL, 0xfc0007ffUL, DecodeOp__spec__fctiw_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00001cUL, 0xfc0007ffUL, DecodeOp__spec__fctiw_rc_0));
		decode_table.push_back(DecodeTableEntry(0xec00002bUL, 0xfc00003fUL, DecodeOp__spec__fadds_rc_1));
		decode_table.push_back(DecodeTableEntry(0xec00002aUL, 0xfc00003fUL, DecodeOp__spec__fadds_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc00002bUL, 0xfc00003fUL, DecodeOp__spec__fadd_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc00002aUL, 0xfc00003fUL, DecodeOp__spec__fadd_rc_0));
		decode_table.push_back(DecodeTableEntry(0xfc000211UL, 0xfc0007ffUL, DecodeOp__spec__fabs_rc_1));
		decode_table.push_back(DecodeTableEntry(0xfc000210UL, 0xfc0007ffUL, DecodeOp__spec__fabs_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000279UL, 0xfc0007ffUL, DecodeOp__spec__xor_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000278UL, 0xfc0007ffUL, DecodeOp__spec__xor_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000591UL, 0xfc0007ffUL, DecodeOp__spec__subfze_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000191UL, 0xfc0007ffUL, DecodeOp__spec__subfze_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000590UL, 0xfc0007ffUL, DecodeOp__spec__subfze_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000190UL, 0xfc0007ffUL, DecodeOp__spec__subfze_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0005d1UL, 0xfc0007ffUL, DecodeOp__spec__subfme_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0001d1UL, 0xfc0007ffUL, DecodeOp__spec__subfme_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0005d0UL, 0xfc0007ffUL, DecodeOp__spec__subfme_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0001d0UL, 0xfc0007ffUL, DecodeOp__spec__subfme_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000451UL, 0xfc0007ffUL, DecodeOp__spec__subf_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000051UL, 0xfc0007ffUL, DecodeOp__spec__subf_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000450UL, 0xfc0007ffUL, DecodeOp__spec__subf_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000050UL, 0xfc0007ffUL, DecodeOp__spec__subf_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000511UL, 0xfc0007ffUL, DecodeOp__spec__subfe_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000111UL, 0xfc0007ffUL, DecodeOp__spec__subfe_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000510UL, 0xfc0007ffUL, DecodeOp__spec__subfe_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000110UL, 0xfc0007ffUL, DecodeOp__spec__subfe_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000411UL, 0xfc0007ffUL, DecodeOp__spec__subfc_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000011UL, 0xfc0007ffUL, DecodeOp__spec__subfc_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000410UL, 0xfc0007ffUL, DecodeOp__spec__subfc_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000010UL, 0xfc0007ffUL, DecodeOp__spec__subfc_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0xf8210001UL, 0xffff0003UL, DecodeOp__spec__stdu_rs_1_ra_1));
		decode_table.push_back(DecodeTableEntry(0x94210000UL, 0xffff0000UL, DecodeOp__spec__stwu_rs_1_ra_1));
		decode_table.push_back(DecodeTableEntry(0x7c000437UL, 0xfc0007ffUL, DecodeOp__spec__srd_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000436UL, 0xfc0007ffUL, DecodeOp__spec__srd_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000635UL, 0xfc0007ffUL, DecodeOp__spec__srad_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000634UL, 0xfc0007ffUL, DecodeOp__spec__srad_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000675UL, 0xfc0007fdUL, DecodeOp__spec__sradi_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000674UL, 0xfc0007fdUL, DecodeOp__spec__sradi_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000037UL, 0xfc0007ffUL, DecodeOp__spec__sld_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000036UL, 0xfc0007ffUL, DecodeOp__spec__sld_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000431UL, 0xfc0007ffUL, DecodeOp__spec__srw_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000430UL, 0xfc0007ffUL, DecodeOp__spec__srw_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000631UL, 0xfc0007ffUL, DecodeOp__spec__sraw_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000630UL, 0xfc0007ffUL, DecodeOp__spec__sraw_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000671UL, 0xfc0007ffUL, DecodeOp__spec__srawi_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000670UL, 0xfc0007ffUL, DecodeOp__spec__srawi_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000031UL, 0xfc0007ffUL, DecodeOp__spec__slw_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000030UL, 0xfc0007ffUL, DecodeOp__spec__slw_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7800000dUL, 0xfc00001dUL, DecodeOp__spec__rldimi_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7800000cUL, 0xfc00001dUL, DecodeOp__spec__rldimi_rc_0));
		decode_table.push_back(DecodeTableEntry(0x78000013UL, 0xfc00001fUL, DecodeOp__spec__rldcr_rc_1));
		decode_table.push_back(DecodeTableEntry(0x78000012UL, 0xfc00001fUL, DecodeOp__spec__rldcr_rc_0));
		decode_table.push_back(DecodeTableEntry(0x78000011UL, 0xfc00001fUL, DecodeOp__spec__rldcl_rc_1));
		decode_table.push_back(DecodeTableEntry(0x78000010UL, 0xfc00001fUL, DecodeOp__spec__rldcl_rc_0));
		decode_table.push_back(DecodeTableEntry(0x78000009UL, 0xfc00001dUL, DecodeOp__spec__rldic_rc_1));
		decode_table.push_back(DecodeTableEntry(0x78000008UL, 0xfc00001dUL, DecodeOp__spec__rldic_rc_0));
		decode_table.push_back(DecodeTableEntry(0x78000005UL, 0xfc00001dUL, DecodeOp__spec__rldicr_rc_1));
		decode_table.push_back(DecodeTableEntry(0x78000004UL, 0xfc00001dUL, DecodeOp__spec__rldicr_rc_0));
		decode_table.push_back(DecodeTableEntry(0x78000001UL, 0xfc00001dUL, DecodeOp__spec__rldicl_rc_1));
		decode_table.push_back(DecodeTableEntry(0x78000000UL, 0xfc00001dUL, DecodeOp__spec__rldicl_rc_0));
		decode_table.push_back(DecodeTableEntry(0x5c000001UL, 0xfc000001UL, DecodeOp__spec__rlwnm_rc_1));
		decode_table.push_back(DecodeTableEntry(0x5c000000UL, 0xfc000001UL, DecodeOp__spec__rlwnm_rc_0));
		decode_table.push_back(DecodeTableEntry(0x54000001UL, 0xfc000001UL, DecodeOp__spec__rlwinm_rc_1));
		decode_table.push_back(DecodeTableEntry(0x54000000UL, 0xfc000001UL, DecodeOp__spec__rlwinm_rc_0));
		decode_table.push_back(DecodeTableEntry(0x50000001UL, 0xfc000001UL, DecodeOp__spec__rlwimi_rc_1));
		decode_table.push_back(DecodeTableEntry(0x50000000UL, 0xfc000001UL, DecodeOp__spec__rlwimi_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000379UL, 0xfc0007ffUL, DecodeOp__spec__or_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000378UL, 0xfc0007ffUL, DecodeOp__spec__or_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000339UL, 0xfc0007ffUL, DecodeOp__spec__orc_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000338UL, 0xfc0007ffUL, DecodeOp__spec__orc_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c0000f9UL, 0xfc0007ffUL, DecodeOp__spec__nor_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c0000f8UL, 0xfc0007ffUL, DecodeOp__spec__nor_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c0004d1UL, 0xfc0007ffUL, DecodeOp__spec__neg_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0000d1UL, 0xfc0007ffUL, DecodeOp__spec__neg_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0004d0UL, 0xfc0007ffUL, DecodeOp__spec__neg_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0000d0UL, 0xfc0007ffUL, DecodeOp__spec__neg_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0003b9UL, 0xfc0007ffUL, DecodeOp__spec__nand_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c0003b8UL, 0xfc0007ffUL, DecodeOp__spec__nand_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c0005d3UL, 0xfc0007ffUL, DecodeOp__spec__mulld_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0001d3UL, 0xfc0007ffUL, DecodeOp__spec__mulld_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0005d2UL, 0xfc0007ffUL, DecodeOp__spec__mulld_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0001d2UL, 0xfc0007ffUL, DecodeOp__spec__mulld_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000013UL, 0xfc0003ffUL, DecodeOp__spec__mulhdu_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000012UL, 0xfc0003ffUL, DecodeOp__spec__mulhdu_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000093UL, 0xfc0003ffUL, DecodeOp__spec__mulhd_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000092UL, 0xfc0003ffUL, DecodeOp__spec__mulhd_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c0005d7UL, 0xfc0007ffUL, DecodeOp__spec__mullw_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0001d7UL, 0xfc0007ffUL, DecodeOp__spec__mullw_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0005d6UL, 0xfc0007ffUL, DecodeOp__spec__mullw_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0001d6UL, 0xfc0007ffUL, DecodeOp__spec__mullw_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000017UL, 0xfc0003ffUL, DecodeOp__spec__mulhwu_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000016UL, 0xfc0003ffUL, DecodeOp__spec__mulhwu_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000097UL, 0xfc0003ffUL, DecodeOp__spec__mulhw_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000096UL, 0xfc0003ffUL, DecodeOp__spec__mulhw_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7f800400UL, 0xff8007feUL, DecodeOp__spec__mcrxr_crfD_7));
		decode_table.push_back(DecodeTableEntry(0x7f000400UL, 0xff8007feUL, DecodeOp__spec__mcrxr_crfD_6));
		decode_table.push_back(DecodeTableEntry(0x7e800400UL, 0xff8007feUL, DecodeOp__spec__mcrxr_crfD_5));
		decode_table.push_back(DecodeTableEntry(0x7e000400UL, 0xff8007feUL, DecodeOp__spec__mcrxr_crfD_4));
		decode_table.push_back(DecodeTableEntry(0x7d800400UL, 0xff8007feUL, DecodeOp__spec__mcrxr_crfD_3));
		decode_table.push_back(DecodeTableEntry(0x7d000400UL, 0xff8007feUL, DecodeOp__spec__mcrxr_crfD_2));
		decode_table.push_back(DecodeTableEntry(0x7c800400UL, 0xff8007feUL, DecodeOp__spec__mcrxr_crfD_1));
		decode_table.push_back(DecodeTableEntry(0x7c000400UL, 0xff8007feUL, DecodeOp__spec__mcrxr_crfD_0));
		decode_table.push_back(DecodeTableEntry(0x7c0007b5UL, 0xfc0007ffUL, DecodeOp__spec__extsw_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c0007b4UL, 0xfc0007ffUL, DecodeOp__spec__extsw_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000735UL, 0xfc0007ffUL, DecodeOp__spec__extsh_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000734UL, 0xfc0007ffUL, DecodeOp__spec__extsh_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000775UL, 0xfc0007ffUL, DecodeOp__spec__extsb_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000774UL, 0xfc0007ffUL, DecodeOp__spec__extsb_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000239UL, 0xfc0007ffUL, DecodeOp__spec__eqv_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000238UL, 0xfc0007ffUL, DecodeOp__spec__eqv_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000793UL, 0xfc0007ffUL, DecodeOp__spec__divdu_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000393UL, 0xfc0007ffUL, DecodeOp__spec__divdu_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000792UL, 0xfc0007ffUL, DecodeOp__spec__divdu_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000392UL, 0xfc0007ffUL, DecodeOp__spec__divdu_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0007d3UL, 0xfc0007ffUL, DecodeOp__spec__divd_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0003d3UL, 0xfc0007ffUL, DecodeOp__spec__divd_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0007d2UL, 0xfc0007ffUL, DecodeOp__spec__divd_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0003d2UL, 0xfc0007ffUL, DecodeOp__spec__divd_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000797UL, 0xfc0007ffUL, DecodeOp__spec__divwu_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000397UL, 0xfc0007ffUL, DecodeOp__spec__divwu_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000796UL, 0xfc0007ffUL, DecodeOp__spec__divwu_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000396UL, 0xfc0007ffUL, DecodeOp__spec__divwu_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0007d7UL, 0xfc0007ffUL, DecodeOp__spec__divw_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0003d7UL, 0xfc0007ffUL, DecodeOp__spec__divw_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0007d6UL, 0xfc0007ffUL, DecodeOp__spec__divw_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0003d6UL, 0xfc0007ffUL, DecodeOp__spec__divw_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000075UL, 0xfc0007ffUL, DecodeOp__spec__cntlzd_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000074UL, 0xfc0007ffUL, DecodeOp__spec__cntlzd_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000035UL, 0xfc0007ffUL, DecodeOp__spec__cntlzw_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000034UL, 0xfc0007ffUL, DecodeOp__spec__cntlzw_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7fa00040UL, 0xffa007feUL, DecodeOp__spec__cmplL_crfD_7));
		decode_table.push_back(DecodeTableEntry(0x7f200040UL, 0xffa007feUL, DecodeOp__spec__cmplL_crfD_6));
		decode_table.push_back(DecodeTableEntry(0x7ea00040UL, 0xffa007feUL, DecodeOp__spec__cmplL_crfD_5));
		decode_table.push_back(DecodeTableEntry(0x7e200040UL, 0xffa007feUL, DecodeOp__spec__cmplL_crfD_4));
		decode_table.push_back(DecodeTableEntry(0x7da00040UL, 0xffa007feUL, DecodeOp__spec__cmplL_crfD_3));
		decode_table.push_back(DecodeTableEntry(0x7d200040UL, 0xffa007feUL, DecodeOp__spec__cmplL_crfD_2));
		decode_table.push_back(DecodeTableEntry(0x7ca00040UL, 0xffa007feUL, DecodeOp__spec__cmplL_crfD_1));
		decode_table.push_back(DecodeTableEntry(0x7c200040UL, 0xffa007feUL, DecodeOp__spec__cmplL_crfD_0));
		decode_table.push_back(DecodeTableEntry(0x7f800040UL, 0xffa007feUL, DecodeOp__spec__cmpl_crfD_7));
		decode_table.push_back(DecodeTableEntry(0x7f000040UL, 0xffa007feUL, DecodeOp__spec__cmpl_crfD_6));
		decode_table.push_back(DecodeTableEntry(0x7e800040UL, 0xffa007feUL, DecodeOp__spec__cmpl_crfD_5));
		decode_table.push_back(DecodeTableEntry(0x7e000040UL, 0xffa007feUL, DecodeOp__spec__cmpl_crfD_4));
		decode_table.push_back(DecodeTableEntry(0x7d800040UL, 0xffa007feUL, DecodeOp__spec__cmpl_crfD_3));
		decode_table.push_back(DecodeTableEntry(0x7d000040UL, 0xffa007feUL, DecodeOp__spec__cmpl_crfD_2));
		decode_table.push_back(DecodeTableEntry(0x7c800040UL, 0xffa007feUL, DecodeOp__spec__cmpl_crfD_1));
		decode_table.push_back(DecodeTableEntry(0x7c000040UL, 0xffa007feUL, DecodeOp__spec__cmpl_crfD_0));
		decode_table.push_back(DecodeTableEntry(0x7fa00000UL, 0xffa007feUL, DecodeOp__spec__cmpL_crfD_7));
		decode_table.push_back(DecodeTableEntry(0x7f200000UL, 0xffa007feUL, DecodeOp__spec__cmpL_crfD_6));
		decode_table.push_back(DecodeTableEntry(0x7ea00000UL, 0xffa007feUL, DecodeOp__spec__cmpL_crfD_5));
		decode_table.push_back(DecodeTableEntry(0x7e200000UL, 0xffa007feUL, DecodeOp__spec__cmpL_crfD_4));
		decode_table.push_back(DecodeTableEntry(0x7da00000UL, 0xffa007feUL, DecodeOp__spec__cmpL_crfD_3));
		decode_table.push_back(DecodeTableEntry(0x7d200000UL, 0xffa007feUL, DecodeOp__spec__cmpL_crfD_2));
		decode_table.push_back(DecodeTableEntry(0x7ca00000UL, 0xffa007feUL, DecodeOp__spec__cmpL_crfD_1));
		decode_table.push_back(DecodeTableEntry(0x7c200000UL, 0xffa007feUL, DecodeOp__spec__cmpL_crfD_0));
		decode_table.push_back(DecodeTableEntry(0x7f800000UL, 0xffa007feUL, DecodeOp__spec__cmp_crfD_7));
		decode_table.push_back(DecodeTableEntry(0x7f000000UL, 0xffa007feUL, DecodeOp__spec__cmp_crfD_6));
		decode_table.push_back(DecodeTableEntry(0x7e800000UL, 0xffa007feUL, DecodeOp__spec__cmp_crfD_5));
		decode_table.push_back(DecodeTableEntry(0x7e000000UL, 0xffa007feUL, DecodeOp__spec__cmp_crfD_4));
		decode_table.push_back(DecodeTableEntry(0x7d800000UL, 0xffa007feUL, DecodeOp__spec__cmp_crfD_3));
		decode_table.push_back(DecodeTableEntry(0x7d000000UL, 0xffa007feUL, DecodeOp__spec__cmp_crfD_2));
		decode_table.push_back(DecodeTableEntry(0x7c800000UL, 0xffa007feUL, DecodeOp__spec__cmp_crfD_1));
		decode_table.push_back(DecodeTableEntry(0x7c000000UL, 0xffa007feUL, DecodeOp__spec__cmp_crfD_0));
		decode_table.push_back(DecodeTableEntry(0x7c000039UL, 0xfc0007ffUL, DecodeOp__spec__and_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000038UL, 0xfc0007ffUL, DecodeOp__spec__and_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000079UL, 0xfc0007ffUL, DecodeOp__spec__andc_rc_1));
		decode_table.push_back(DecodeTableEntry(0x7c000078UL, 0xfc0007ffUL, DecodeOp__spec__andc_rc_0));
		decode_table.push_back(DecodeTableEntry(0x7c000595UL, 0xfc0007ffUL, DecodeOp__spec__addze_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000195UL, 0xfc0007ffUL, DecodeOp__spec__addze_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000594UL, 0xfc0007ffUL, DecodeOp__spec__addze_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000194UL, 0xfc0007ffUL, DecodeOp__spec__addze_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0005d5UL, 0xfc0007ffUL, DecodeOp__spec__addme_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0001d5UL, 0xfc0007ffUL, DecodeOp__spec__addme_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c0005d4UL, 0xfc0007ffUL, DecodeOp__spec__addme_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c0001d4UL, 0xfc0007ffUL, DecodeOp__spec__addme_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000615UL, 0xfc0007ffUL, DecodeOp__spec__add_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000215UL, 0xfc0007ffUL, DecodeOp__spec__add_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000614UL, 0xfc0007ffUL, DecodeOp__spec__add_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000214UL, 0xfc0007ffUL, DecodeOp__spec__add_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000515UL, 0xfc0007ffUL, DecodeOp__spec__adde_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000115UL, 0xfc0007ffUL, DecodeOp__spec__adde_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000514UL, 0xfc0007ffUL, DecodeOp__spec__adde_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000114UL, 0xfc0007ffUL, DecodeOp__spec__adde_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000415UL, 0xfc0007ffUL, DecodeOp__spec__addc_rc_1_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000015UL, 0xfc0007ffUL, DecodeOp__spec__addc_rc_1_oe_0));
		decode_table.push_back(DecodeTableEntry(0x7c000414UL, 0xfc0007ffUL, DecodeOp__spec__addc_rc_0_oe_1));
		decode_table.push_back(DecodeTableEntry(0x7c000014UL, 0xfc0007ffUL, DecodeOp__spec__addc_rc_0_oe_0));
		decode_table.push_back(DecodeTableEntry(0x48000003UL, 0xfc000003UL, DecodeOp__spec__b_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x48000002UL, 0xfc000003UL, DecodeOp__spec__b_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x48000001UL, 0xfc000003UL, DecodeOp__spec__b_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x48000000UL, 0xfc000003UL, DecodeOp__spec__b_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4fe00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1f_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4fe00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1f_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4fc00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1e_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4fc00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1e_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4fa00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1d_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4fa00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1d_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f800021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1c_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f800020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1c_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f600021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1b_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f600020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1b_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f400021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1a_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f400020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1a_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f200021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_19_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f200020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_19_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f000021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_18_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f000020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_18_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ee00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_17_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ee00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_17_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ec00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_16_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ec00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_16_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ea00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_15_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ea00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_15_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e800021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_14_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e800020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_14_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e600021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_13_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e600020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_13_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e400021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_12_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e400020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_12_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e200021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_11_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e200020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_11_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e000021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_10_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e000020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_10_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4de00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_f_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4de00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_f_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4dc00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_e_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4dc00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_e_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4da00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_d_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4da00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_d_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d800021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_c_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d800020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_c_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d600021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_b_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d600020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_b_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d400021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_a_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d400020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_a_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d200021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_9_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d200020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_9_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d000021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_8_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d000020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_8_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ce00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_7_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ce00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_7_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4cc00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_6_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4cc00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_6_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ca00021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_5_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ca00020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_5_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c800021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_4_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c800020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_4_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c600021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_3_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c600020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_3_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c400021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_2_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c400020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_2_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c200021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c200020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_1_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c000021UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_0_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c000020UL, 0xffe007ffUL, DecodeOp__spec__bclr_bo_0_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43e00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1f_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43e00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1f_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43e00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1f_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43e00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1f_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43c00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1e_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43c00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1e_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43c00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1e_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43c00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1e_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43a00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1d_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43a00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1d_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43a00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1d_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43a00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1d_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43800003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1c_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43800002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1c_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43800001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1c_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43800000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1c_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43600003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1b_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43600002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1b_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43600001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1b_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43600000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1b_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43400003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1a_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43400002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1a_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43400001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1a_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43400000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1a_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43200003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_19_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43200002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_19_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43200001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_19_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43200000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_19_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43000003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_18_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43000002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_18_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x43000001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_18_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x43000000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_18_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42e00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_17_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42e00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_17_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42e00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_17_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42e00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_17_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42c00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_16_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42c00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_16_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42c00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_16_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42c00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_16_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42a00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_15_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42a00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_15_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42a00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_15_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42a00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_15_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42800003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_14_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42800002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_14_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42800001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_14_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42800000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_14_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42600003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_13_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42600002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_13_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42600001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_13_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42600000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_13_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42400003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_12_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42400002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_12_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42400001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_12_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42400000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_12_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42200003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_11_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42200002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_11_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42200001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_11_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42200000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_11_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42000003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_10_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42000002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_10_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x42000001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_10_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x42000000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_10_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41e00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_f_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41e00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_f_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41e00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_f_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41e00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_f_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41c00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_e_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41c00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_e_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41c00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_e_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41c00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_e_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41a00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_d_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41a00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_d_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41a00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_d_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41a00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_d_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41800003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_c_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41800002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_c_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41800001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_c_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41800000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_c_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41600003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_b_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41600002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_b_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41600001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_b_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41600000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_b_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41400003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_a_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41400002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_a_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41400001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_a_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41400000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_a_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41200003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_9_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41200002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_9_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41200001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_9_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41200000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_9_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41000003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_8_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41000002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_8_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x41000001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_8_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x41000000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_8_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40e00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_7_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40e00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_7_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40e00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_7_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40e00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_7_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40c00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_6_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40c00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_6_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40c00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_6_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40c00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_6_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40a00003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_5_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40a00002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_5_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40a00001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_5_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40a00000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_5_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40800003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_4_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40800002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_4_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40800001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_4_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40800000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_4_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40600003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_3_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40600002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_3_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40600001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_3_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40600000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_3_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40400003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_2_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40400002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_2_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40400001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_2_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40400000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_2_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40200003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40200002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40200001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40200000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_1_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40000003UL, 0xffe00003UL, DecodeOp__spec__bc_bo_0_aa_1_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40000002UL, 0xffe00003UL, DecodeOp__spec__bc_bo_0_aa_1_lk_0));
		decode_table.push_back(DecodeTableEntry(0x40000001UL, 0xffe00003UL, DecodeOp__spec__bc_bo_0_aa_0_lk_1));
		decode_table.push_back(DecodeTableEntry(0x40000000UL, 0xffe00003UL, DecodeOp__spec__bc_bo_0_aa_0_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4fe00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1f_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4fe00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1f_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4fc00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1e_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4fc00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1e_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4fa00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1d_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4fa00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1d_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f800421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1c_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f800420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1c_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f600421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1b_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f600420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1b_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f400421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1a_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f400420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1a_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f200421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_19_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f200420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_19_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4f000421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_18_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4f000420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_18_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ee00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_17_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ee00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_17_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ec00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_16_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ec00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_16_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ea00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_15_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ea00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_15_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e800421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_14_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e800420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_14_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e600421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_13_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e600420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_13_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e400421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_12_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e400420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_12_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e200421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_11_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e200420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_11_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4e000421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_10_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4e000420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_10_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4de00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_f_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4de00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_f_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4dc00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_e_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4dc00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_e_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4da00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_d_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4da00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_d_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d800421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_c_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d800420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_c_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d600421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_b_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d600420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_b_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d400421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_a_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d400420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_a_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d200421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_9_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d200420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_9_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4d000421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_8_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4d000420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_8_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ce00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_7_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ce00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_7_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4cc00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_6_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4cc00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_6_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4ca00421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_5_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4ca00420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_5_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c800421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_4_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c800420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_4_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c600421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_3_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c600420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_3_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c400421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_2_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c400420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_2_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c200421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c200420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_1_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x4c000421UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_0_aa_2_lk_1));
		decode_table.push_back(DecodeTableEntry(0x4c000420UL, 0xffe007ffUL, DecodeOp__spec__bcctr_bo_0_aa_2_lk_0));
		decode_table.push_back(DecodeTableEntry(0x7c0003a6UL, 0xfc0007feUL, DecodeOpMtspr));
		decode_table.push_back(DecodeTableEntry(0x7c0002a6UL, 0xfc0007feUL, DecodeOpMfspr));
		decode_table.push_back(DecodeTableEntry(0x7c00052eUL, 0xfc0007feUL, DecodeOpStfsx));
		decode_table.push_back(DecodeTableEntry(0x7c00056eUL, 0xfc0007feUL, DecodeOpStfsux));
		decode_table.push_back(DecodeTableEntry(0xd4000000UL, 0xfc000000UL, DecodeOpStfsu));
		decode_table.push_back(DecodeTableEntry(0xd0000000UL, 0xfc000000UL, DecodeOpStfs));
		decode_table.push_back(DecodeTableEntry(0x7c0007aeUL, 0xfc0007feUL, DecodeOpStfiwx));
		decode_table.push_back(DecodeTableEntry(0x7c0005aeUL, 0xfc0007feUL, DecodeOpStfdx));
		decode_table.push_back(DecodeTableEntry(0x7c0005eeUL, 0xfc0007feUL, DecodeOpStfdux));
		decode_table.push_back(DecodeTableEntry(0xdc000000UL, 0xfc000000UL, DecodeOpStfdu));
		decode_table.push_back(DecodeTableEntry(0xd8000000UL, 0xfc000000UL, DecodeOpStfd));
		decode_table.push_back(DecodeTableEntry(0xfc00058eUL, 0xfc0007feUL, DecodeOpMtfsf));
		decode_table.push_back(DecodeTableEntry(0xfc00010cUL, 0xfc0007feUL, DecodeOpMtfsfi));
		decode_table.push_back(DecodeTableEntry(0xfc00004cUL, 0xfc0007feUL, DecodeOpMtfsb1));
		decode_table.push_back(DecodeTableEntry(0xfc00008cUL, 0xfc0007feUL, DecodeOpMtfsb0));
		decode_table.push_back(DecodeTableEntry(0xfc00048eUL, 0xfc0007feUL, DecodeOpMffs));
		decode_table.push_back(DecodeTableEntry(0xfc000080UL, 0xfc0007feUL, DecodeOpMcrfs));
		decode_table.push_back(DecodeTableEntry(0x7c00042eUL, 0xfc0007feUL, DecodeOpLfsx));
		decode_table.push_back(DecodeTableEntry(0x7c00046eUL, 0xfc0007feUL, DecodeOpLfsux));
		decode_table.push_back(DecodeTableEntry(0xc4000000UL, 0xfc000000UL, DecodeOpLfsu));
		decode_table.push_back(DecodeTableEntry(0xc0000000UL, 0xfc000000UL, DecodeOpLfs));
		decode_table.push_back(DecodeTableEntry(0x7c0004aeUL, 0xfc0007feUL, DecodeOpLfdx));
		decode_table.push_back(DecodeTableEntry(0x7c0004eeUL, 0xfc0007feUL, DecodeOpLfdux));
		decode_table.push_back(DecodeTableEntry(0xcc000000UL, 0xfc000000UL, DecodeOpLfdu));
		decode_table.push_back(DecodeTableEntry(0xc8000000UL, 0xfc000000UL, DecodeOpLfd));
		decode_table.push_back(DecodeTableEntry(0xec000028UL, 0xfc00003eUL, DecodeOpFsubs));
		decode_table.push_back(DecodeTableEntry(0xfc000028UL, 0xfc00003eUL, DecodeOpFsub));
		decode_table.push_back(DecodeTableEntry(0xfc00002eUL, 0xfc00003eUL, DecodeOpFsel));
		decode_table.push_back(DecodeTableEntry(0xfc000018UL, 0xfc0007feUL, DecodeOpFrsp));
		decode_table.push_back(DecodeTableEntry(0xec00003cUL, 0xfc00003eUL, DecodeOpFnmsubs));
		decode_table.push_back(DecodeTableEntry(0xfc00003cUL, 0xfc00003eUL, DecodeOpFnmsub));
		decode_table.push_back(DecodeTableEntry(0xec00003eUL, 0xfc00003eUL, DecodeOpFnmadds));
		decode_table.push_back(DecodeTableEntry(0xfc00003eUL, 0xfc00003eUL, DecodeOpFnmadd));
		decode_table.push_back(DecodeTableEntry(0xfc000050UL, 0xfc0007feUL, DecodeOpFneg));
		decode_table.push_back(DecodeTableEntry(0xfc000110UL, 0xfc0007feUL, DecodeOpFnabs));
		decode_table.push_back(DecodeTableEntry(0xec000032UL, 0xfc00003eUL, DecodeOpFmuls));
		decode_table.push_back(DecodeTableEntry(0xfc000032UL, 0xfc00003eUL, DecodeOpFmul));
		decode_table.push_back(DecodeTableEntry(0xec000038UL, 0xfc00003eUL, DecodeOpFmsubs));
		decode_table.push_back(DecodeTableEntry(0xfc000038UL, 0xfc00003eUL, DecodeOpFmsub));
		decode_table.push_back(DecodeTableEntry(0xfc000090UL, 0xfc0007feUL, DecodeOpFmr));
		decode_table.push_back(DecodeTableEntry(0xec00003aUL, 0xfc00003eUL, DecodeOpFmadds));
		decode_table.push_back(DecodeTableEntry(0xfc00003aUL, 0xfc00003eUL, DecodeOpFmadd));
		decode_table.push_back(DecodeTableEntry(0xec000024UL, 0xfc00003eUL, DecodeOpFdivs));
		decode_table.push_back(DecodeTableEntry(0xfc000024UL, 0xfc00003eUL, DecodeOpFdiv));
		decode_table.push_back(DecodeTableEntry(0xfc00069cUL, 0xfc0007feUL, DecodeOpFcfid));
		decode_table.push_back(DecodeTableEntry(0xfc00065eUL, 0xfc0007feUL, DecodeOpFctidz));
		decode_table.push_back(DecodeTableEntry(0xfc00065cUL, 0xfc0007feUL, DecodeOpFctid));
		decode_table.push_back(DecodeTableEntry(0xfc00001eUL, 0xfc0007feUL, DecodeOpFctiwz));
		decode_table.push_back(DecodeTableEntry(0xfc00001cUL, 0xfc0007feUL, DecodeOpFctiw));
		decode_table.push_back(DecodeTableEntry(0xfc000000UL, 0xfc0007feUL, DecodeOpFcmpu));
		decode_table.push_back(DecodeTableEntry(0xfc000040UL, 0xfc0007feUL, DecodeOpFcmpo));
		decode_table.push_back(DecodeTableEntry(0xec00002aUL, 0xfc00003eUL, DecodeOpFadds));
		decode_table.push_back(DecodeTableEntry(0xfc00002aUL, 0xfc00003eUL, DecodeOpFadd));
		decode_table.push_back(DecodeTableEntry(0xfc000210UL, 0xfc0007feUL, DecodeOpFabs));
		decode_table.push_back(DecodeTableEntry(0x6c000000UL, 0xfc000000UL, DecodeOpXoris));
		decode_table.push_back(DecodeTableEntry(0x7c000278UL, 0xfc0007feUL, DecodeOpXor));
		decode_table.push_back(DecodeTableEntry(0x68000000UL, 0xfc000000UL, DecodeOpXori));
		decode_table.push_back(DecodeTableEntry(0x7c000190UL, 0xfc0003feUL, DecodeOpSubfze));
		decode_table.push_back(DecodeTableEntry(0x7c0001d0UL, 0xfc0003feUL, DecodeOpSubfme));
		decode_table.push_back(DecodeTableEntry(0x7c000050UL, 0xfc0003feUL, DecodeOpSubf));
		decode_table.push_back(DecodeTableEntry(0x20000000UL, 0xfc000000UL, DecodeOpSubfic));
		decode_table.push_back(DecodeTableEntry(0x7c000110UL, 0xfc0003feUL, DecodeOpSubfe));
		decode_table.push_back(DecodeTableEntry(0x7c000010UL, 0xfc0003feUL, DecodeOpSubfc));
		decode_table.push_back(DecodeTableEntry(0x7c00012aUL, 0xfc0007feUL, DecodeOpStdx));
		decode_table.push_back(DecodeTableEntry(0x7c00016aUL, 0xfc0007feUL, DecodeOpStdux));
		decode_table.push_back(DecodeTableEntry(0xf8000001UL, 0xfc000003UL, DecodeOpStdu));
		decode_table.push_back(DecodeTableEntry(0xf8000000UL, 0xfc000003UL, DecodeOpStd));
		decode_table.push_back(DecodeTableEntry(0x7c00012eUL, 0xfc0007feUL, DecodeOpStwx));
		decode_table.push_back(DecodeTableEntry(0x7c00016eUL, 0xfc0007feUL, DecodeOpStwux));
		decode_table.push_back(DecodeTableEntry(0x94000000UL, 0xfc000000UL, DecodeOpStwu));
		decode_table.push_back(DecodeTableEntry(0x90000000UL, 0xfc000000UL, DecodeOpStw));
		decode_table.push_back(DecodeTableEntry(0x7c00032eUL, 0xfc0007feUL, DecodeOpSthx));
		decode_table.push_back(DecodeTableEntry(0x7c00036eUL, 0xfc0007feUL, DecodeOpSthux));
		decode_table.push_back(DecodeTableEntry(0xb4000000UL, 0xfc000000UL, DecodeOpSthu));
		decode_table.push_back(DecodeTableEntry(0xb0000000UL, 0xfc000000UL, DecodeOpSth));
		decode_table.push_back(DecodeTableEntry(0x7c0001aeUL, 0xfc0007feUL, DecodeOpStbx));
		decode_table.push_back(DecodeTableEntry(0x7c0001eeUL, 0xfc0007feUL, DecodeOpStbux));
		decode_table.push_back(DecodeTableEntry(0x9c000000UL, 0xfc000000UL, DecodeOpStbu));
		decode_table.push_back(DecodeTableEntry(0x98000000UL, 0xfc000000UL, DecodeOpStb));
		decode_table.push_back(DecodeTableEntry(0x7c000436UL, 0xfc0007feUL, DecodeOpSrd));
		decode_table.push_back(DecodeTableEntry(0x7c000634UL, 0xfc0007feUL, DecodeOpSrad));
		decode_table.push_back(DecodeTableEntry(0x7c000674UL, 0xfc0007fcUL, DecodeOpSradi));
		decode_table.push_back(DecodeTableEntry(0x7c000036UL, 0xfc0007feUL, DecodeOpSld));
		decode_table.push_back(DecodeTableEntry(0x7c000430UL, 0xfc0007feUL, DecodeOpSrw));
		decode_table.push_back(DecodeTableEntry(0x7c000630UL, 0xfc0007feUL, DecodeOpSraw));
		decode_table.push_back(DecodeTableEntry(0x7c000670UL, 0xfc0007feUL, DecodeOpSrawi));
		decode_table.push_back(DecodeTableEntry(0x7c000030UL, 0xfc0007feUL, DecodeOpSlw));
		decode_table.push_back(DecodeTableEntry(0x7800000cUL, 0xfc00001cUL, DecodeOpRldimi));
		decode_table.push_back(DecodeTableEntry(0x78000012UL, 0xfc00001eUL, DecodeOpRldcr));
		decode_table.push_back(DecodeTableEntry(0x78000010UL, 0xfc00001eUL, DecodeOpRldcl));
		decode_table.push_back(DecodeTableEntry(0x78000008UL, 0xfc00001cUL, DecodeOpRldic));
		decode_table.push_back(DecodeTableEntry(0x78000004UL, 0xfc00001cUL, DecodeOpRldicr));
		decode_table.push_back(DecodeTableEntry(0x78000000UL, 0xfc00001cUL, DecodeOpRldicl));
		decode_table.push_back(DecodeTableEntry(0x5c000000UL, 0xfc000000UL, DecodeOpRlwnm));
		decode_table.push_back(DecodeTableEntry(0x54000000UL, 0xfc000000UL, DecodeOpRlwinm));
		decode_table.push_back(DecodeTableEntry(0x50000000UL, 0xfc000000UL, DecodeOpRlwimi));
		decode_table.push_back(DecodeTableEntry(0x64000000UL, 0xfc000000UL, DecodeOpOris));
		decode_table.push_back(DecodeTableEntry(0x7c000378UL, 0xfc0007feUL, DecodeOpOr));
		decode_table.push_back(DecodeTableEntry(0x60000000UL, 0xfc000000UL, DecodeOpOri));
		decode_table.push_back(DecodeTableEntry(0x7c000338UL, 0xfc0007feUL, DecodeOpOrc));
		decode_table.push_back(DecodeTableEntry(0x7c0000f8UL, 0xfc0007feUL, DecodeOpNor));
		decode_table.push_back(DecodeTableEntry(0x7c0000d0UL, 0xfc0003feUL, DecodeOpNeg));
		decode_table.push_back(DecodeTableEntry(0x7c0003b8UL, 0xfc0007feUL, DecodeOpNand));
		decode_table.push_back(DecodeTableEntry(0x7c0001d2UL, 0xfc0003feUL, DecodeOpMulld));
		decode_table.push_back(DecodeTableEntry(0x7c000012UL, 0xfc0003feUL, DecodeOpMulhdu));
		decode_table.push_back(DecodeTableEntry(0x7c000092UL, 0xfc0003feUL, DecodeOpMulhd));
		decode_table.push_back(DecodeTableEntry(0x7c0001d6UL, 0xfc0003feUL, DecodeOpMullw));
		decode_table.push_back(DecodeTableEntry(0x7c000016UL, 0xfc0003feUL, DecodeOpMulhwu));
		decode_table.push_back(DecodeTableEntry(0x7c000096UL, 0xfc0003feUL, DecodeOpMulhw));
		decode_table.push_back(DecodeTableEntry(0x1c000000UL, 0xfc000000UL, DecodeOpMulli));
		decode_table.push_back(DecodeTableEntry(0x7c000120UL, 0xfc0007feUL, DecodeOpMtcrf));
		decode_table.push_back(DecodeTableEntry(0x7c000026UL, 0xfc0007feUL, DecodeOpMfcr));
		decode_table.push_back(DecodeTableEntry(0x7c000400UL, 0xfc0007feUL, DecodeOpMcrxr));
		decode_table.push_back(DecodeTableEntry(0x7c00006aUL, 0xfc0007feUL, DecodeOpLdux));
		decode_table.push_back(DecodeTableEntry(0xe8000001UL, 0xfc000003UL, DecodeOpLdu));
		decode_table.push_back(DecodeTableEntry(0x7c00002aUL, 0xfc0007feUL, DecodeOpLdx));
		decode_table.push_back(DecodeTableEntry(0xe8000000UL, 0xfc000003UL, DecodeOpLd));
		decode_table.push_back(DecodeTableEntry(0x7c0002aaUL, 0xfc0007feUL, DecodeOpLwax));
		decode_table.push_back(DecodeTableEntry(0x7c0002eaUL, 0xfc0007feUL, DecodeOpLwaux));
		decode_table.push_back(DecodeTableEntry(0xe8000002UL, 0xfc000003UL, DecodeOpLwa));
		decode_table.push_back(DecodeTableEntry(0x7c00002eUL, 0xfc0007feUL, DecodeOpLwzx));
		decode_table.push_back(DecodeTableEntry(0x7c00006eUL, 0xfc0007feUL, DecodeOpLwzux));
		decode_table.push_back(DecodeTableEntry(0x84000000UL, 0xfc000000UL, DecodeOpLwzu));
		decode_table.push_back(DecodeTableEntry(0x80000000UL, 0xfc000000UL, DecodeOpLwz));
		decode_table.push_back(DecodeTableEntry(0x7c00022eUL, 0xfc0007feUL, DecodeOpLhzx));
		decode_table.push_back(DecodeTableEntry(0x7c00026eUL, 0xfc0007feUL, DecodeOpLhzux));
		decode_table.push_back(DecodeTableEntry(0xa4000000UL, 0xfc000000UL, DecodeOpLhzu));
		decode_table.push_back(DecodeTableEntry(0xa0000000UL, 0xfc000000UL, DecodeOpLhz));
		decode_table.push_back(DecodeTableEntry(0x7c0002aeUL, 0xfc0007feUL, DecodeOpLhax));
		decode_table.push_back(DecodeTableEntry(0x7c0002eeUL, 0xfc0007feUL, DecodeOpLhaux));
		decode_table.push_back(DecodeTableEntry(0xac000000UL, 0xfc000000UL, DecodeOpLhau));
		decode_table.push_back(DecodeTableEntry(0xa8000000UL, 0xfc000000UL, DecodeOpLha));
		decode_table.push_back(DecodeTableEntry(0x7c0000aeUL, 0xfc0007feUL, DecodeOpLbzx));
		decode_table.push_back(DecodeTableEntry(0x7c0000eeUL, 0xfc0007feUL, DecodeOpLbzux));
		decode_table.push_back(DecodeTableEntry(0x8c000000UL, 0xfc000000UL, DecodeOpLbzu));
		decode_table.push_back(DecodeTableEntry(0x88000000UL, 0xfc000000UL, DecodeOpLbz));
		decode_table.push_back(DecodeTableEntry(0x7c00001eUL, 0xfc00003eUL, DecodeOpIsel));
		decode_table.push_back(DecodeTableEntry(0x7c0007b4UL, 0xfc0007feUL, DecodeOpExtsw));
		decode_table.push_back(DecodeTableEntry(0x7c000734UL, 0xfc0007feUL, DecodeOpExtsh));
		decode_table.push_back(DecodeTableEntry(0x7c000774UL, 0xfc0007feUL, DecodeOpExtsb));
		decode_table.push_back(DecodeTableEntry(0x7c000238UL, 0xfc0007feUL, DecodeOpEqv));
		decode_table.push_back(DecodeTableEntry(0x7c000392UL, 0xfc0003feUL, DecodeOpDivdu));
		decode_table.push_back(DecodeTableEntry(0x7c0003d2UL, 0xfc0003feUL, DecodeOpDivd));
		decode_table.push_back(DecodeTableEntry(0x7c000396UL, 0xfc0003feUL, DecodeOpDivwu));
		decode_table.push_back(DecodeTableEntry(0x7c0003d6UL, 0xfc0003feUL, DecodeOpDivw));
		decode_table.push_back(DecodeTableEntry(0x7c000074UL, 0xfc0007feUL, DecodeOpCntlzd));
		decode_table.push_back(DecodeTableEntry(0x7c000034UL, 0xfc0007feUL, DecodeOpCntlzw));
		decode_table.push_back(DecodeTableEntry(0x28200000UL, 0xfc200000UL, DecodeOpCmpliL));
		decode_table.push_back(DecodeTableEntry(0x28000000UL, 0xfc200000UL, DecodeOpCmpli));
		decode_table.push_back(DecodeTableEntry(0x7c200040UL, 0xfc2007feUL, DecodeOpCmplL));
		decode_table.push_back(DecodeTableEntry(0x7c000040UL, 0xfc2007feUL, DecodeOpCmpl));
		decode_table.push_back(DecodeTableEntry(0x2c200000UL, 0xfc200000UL, DecodeOpCmpiL));
		decode_table.push_back(DecodeTableEntry(0x2c000000UL, 0xfc200000UL, DecodeOpCmpi));
		decode_table.push_back(DecodeTableEntry(0x7c200000UL, 0xfc2007feUL, DecodeOpCmpL));
		decode_table.push_back(DecodeTableEntry(0x7c000000UL, 0xfc2007feUL, DecodeOpCmp));
		decode_table.push_back(DecodeTableEntry(0x74000000UL, 0xfc000000UL, DecodeOpAndis_));
		decode_table.push_back(DecodeTableEntry(0x7c000038UL, 0xfc0007feUL, DecodeOpAnd));
		decode_table.push_back(DecodeTableEntry(0x70000000UL, 0xfc000000UL, DecodeOpAndi_));
		decode_table.push_back(DecodeTableEntry(0x7c000078UL, 0xfc0007feUL, DecodeOpAndc));
		decode_table.push_back(DecodeTableEntry(0x7c000194UL, 0xfc0003feUL, DecodeOpAddze));
		decode_table.push_back(DecodeTableEntry(0x7c0001d4UL, 0xfc0003feUL, DecodeOpAddme));
		decode_table.push_back(DecodeTableEntry(0x3c000000UL, 0xfc000000UL, DecodeOpAddis));
		decode_table.push_back(DecodeTableEntry(0x7c000214UL, 0xfc0003feUL, DecodeOpAdd));
		decode_table.push_back(DecodeTableEntry(0x38000000UL, 0xfc000000UL, DecodeOpAddi));
		decode_table.push_back(DecodeTableEntry(0x30000000UL, 0xfc000000UL, DecodeOpAddic));
		decode_table.push_back(DecodeTableEntry(0x34000000UL, 0xfc000000UL, DecodeOpAddic_));
		decode_table.push_back(DecodeTableEntry(0x7c000114UL, 0xfc0003feUL, DecodeOpAdde));
		decode_table.push_back(DecodeTableEntry(0x7c000014UL, 0xfc0003feUL, DecodeOpAddc));
		decode_table.push_back(DecodeTableEntry(0x4c000000UL, 0xfc0007feUL, DecodeOpMcrf));
		decode_table.push_back(DecodeTableEntry(0x4c000182UL, 0xfc0007feUL, DecodeOpCrxor));
		decode_table.push_back(DecodeTableEntry(0x4c000382UL, 0xfc0007feUL, DecodeOpCror));
		decode_table.push_back(DecodeTableEntry(0x4c000342UL, 0xfc0007feUL, DecodeOpCrorc));
		decode_table.push_back(DecodeTableEntry(0x4c000042UL, 0xfc0007feUL, DecodeOpCrnor));
		decode_table.push_back(DecodeTableEntry(0x4c0001c2UL, 0xfc0007feUL, DecodeOpCrnand));
		decode_table.push_back(DecodeTableEntry(0x4c000242UL, 0xfc0007feUL, DecodeOpCreqv));
		decode_table.push_back(DecodeTableEntry(0x4c000202UL, 0xfc0007feUL, DecodeOpCrand));
		decode_table.push_back(DecodeTableEntry(0x4c000102UL, 0xfc0007feUL, DecodeOpCrandc));
		decode_table.push_back(DecodeTableEntry(0x48000000UL, 0xfc000000UL, DecodeOpB));
		decode_table.push_back(DecodeTableEntry(0x4c000020UL, 0xfc0007feUL, DecodeOpBclr));
		decode_table.push_back(DecodeTableEntry(0x40000000UL, 0xfc000000UL, DecodeOpBc));
		decode_table.push_back(DecodeTableEntry(0x4c000420UL, 0xfc0007feUL, DecodeOpBcctr));
	}

	Decoder::~Decoder()
	{
	}

	Operation *Decoder::NCDecode(uint64_t addr, CodeType code)
	{
		Operation *operation;
		unsigned int count = decode_table.size();
		unsigned int idx;
		for(idx = 0; idx < count; idx++)
		{
			if((code & decode_table[idx].opcode_mask) == decode_table[idx].opcode)
			{
				operation = decode_table[idx].decode(code, addr);
				return operation;
			}
		}
		operation = new Operation(code, addr, "???");
		return operation;
	}

	} }
