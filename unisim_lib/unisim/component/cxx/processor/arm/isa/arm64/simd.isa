/*
 *  Copyright (c) 2007-2021,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Yves Lhuillier (yves.lhuillier@cea.fr)
 *          Gilles Mouchard (gilles.mouchard@cea.fr)
 */

op abs_dd( 0b0101111011100000101110[22] : rn[5] : rd[5] );

abs_dd.disasm = {
  sink << "abs\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

abs_dd.execute = {
  cpu.SetVS64(rd, Abs(cpu, cpu.GetVS64(rn, 0)));
}

op abs_vbb( 0b0[1] : q[1] : 0b00111000100000101110[20] : rn[5] : rd[5] );

abs_vbb.disasm = {
  sink << "abs\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

abs_vbb.execute = {
  unsigned const elements = 8<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS8(rd, e, Abs(cpu, cpu.GetVS8(rn, e)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op abs_vhh( 0b0[1] : q[1] : 0b00111001100000101110[20] : rn[5] : rd[5] );

abs_vhh.disasm = {
  sink << "abs\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

abs_vhh.execute = {
  unsigned const elements = 4<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS16(rd, e, Abs(cpu, cpu.GetVS16(rn, e)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op abs_vss( 0b0[1] : q[1] : 0b00111010100000101110[20] : rn[5] : rd[5] );

abs_vss.disasm = {
  sink << "abs\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

abs_vss.execute = {
  unsigned const elements = 2<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS32(rd, e, Abs(cpu, cpu.GetVS32(rn, e)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op abs_v2d2d( 0b0100111011100000101110[22] : rn[5] : rd[5] );

abs_v2d2d.disasm = {
  sink << "abs\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3);
};

abs_v2d2d.execute = {
  unsigned const elements = 2;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS64(rd, e, Abs(cpu, cpu.GetVS64(rn, e)));
    }
}

/*******************************************************************
 * ADD
 *
 * Add
 */

op add_d( 0b01011110111[11] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

add_d.disasm = {
  sink << "add\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

add_d.execute = {
  cpu.SetVU64(rd, cpu.GetVU64(rn, 0) + cpu.GetVU64(rm, 0));
};

op add_vb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

add_vb.disasm = {
  sink << "add\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

add_vb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, cpu.GetVU8(rn, idx) + cpu.GetVU8(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op add_vh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

add_vh.disasm = {
  sink << "add\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

add_vh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, cpu.GetVU16(rn, idx) + cpu.GetVU16(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op add_vs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

add_vs.disasm = {
  sink << "add\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

add_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, cpu.GetVU32(rn, idx) + cpu.GetVU32(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op add_v2d( 0b01001110111[11] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

add_v2d.disasm = {
  sink << "add\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

add_v2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVU64(rd, idx, cpu.GetVU64(rn, idx) + cpu.GetVU64(rm, idx));
};

/*
 * end of ADD
 *******************************************************************/

op addhn2_v16bv8hv8h( 0b01001110001[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

addhn2_v16bv8hv8h.disasm = {
  sink << "addhn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

addhn2_v16bv8hv8h.execute = {
  typedef typename ARCH::U8 DST;
  for (unsigned idx = 0, end = 8; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx + end, DST((cpu.GetVU16(rn, idx) + cpu.GetVU16(rm, idx)) >> 8));
    }
}

op addhn2_v4sv2dv2d( 0b01001110101[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

addhn2_v4sv2dv2d.disasm = {
  sink << "addhn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

addhn2_v4sv2dv2d.execute = {
  typedef typename ARCH::U32 DST;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx + end, DST((cpu.GetVU64(rn, idx) + cpu.GetVU64(rm, idx)) >> 32));
    }
}

op addhn2_v8hv4sv4s( 0b01001110011[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

addhn2_v8hv4sv4s.disasm = {
  sink << "addhn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

addhn2_v8hv4sv4s.execute = {
  typedef typename ARCH::U16 DST;
  for (unsigned idx = 0, end = 4; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx + end, DST((cpu.GetVU32(rn, idx) + cpu.GetVU32(rm, idx)) >> 16));
    }
}

op addhn_v2sv2dv2d( 0b00001110101[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

addhn_v2sv2dv2d.disasm = {
  sink << "addhn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

addhn_v2sv2dv2d.execute = {
  typedef typename ARCH::U32 DST;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, DST((cpu.GetVU64(rn, idx) + cpu.GetVU64(rm, idx)) >> 32));
    }
  cpu.ClearHighV(rd, 8);
}

op addhn_v4hv4sv4s( 0b00001110011[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

addhn_v4hv4sv4s.disasm = {
  sink << "addhn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

addhn_v4hv4sv4s.execute = {
  typedef typename ARCH::U16 DST;
  for (unsigned idx = 0, end = 4; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, DST((cpu.GetVU32(rn, idx) + cpu.GetVU32(rm, idx)) >> 16));
    }
  cpu.ClearHighV(rd, 8);
}

op addhn_v8bv8hv8h( 0b00001110001[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

addhn_v8bv8hv8h.disasm = {
  sink << "addhn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

addhn_v8bv8hv8h.execute = {
  typedef typename ARCH::U8 DST;
  for (unsigned idx = 0, end = 8; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, DST((cpu.GetVU16(rn, idx) + cpu.GetVU16(rm, idx)) >> 8));
    }
  cpu.ClearHighV(rd, 8);
}

/*******************************************************************
 * ADDP
 *
 * Add pairwise
 */

op addp_d( 0b0101111011110001101110[22] : rn[5] : rd[5] );

addp_d.disasm = {
  sink << "addp\t" << DisasmD(rd) << ", " << DisasmTV(rn, 2, 3);
};

addp_d.execute = {
  cpu.SetVU64(rd, cpu.GetVU64(rn, 0) + cpu.GetVU64(rn, 1));
};

op addp_vb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b101111[6] : rn[5] : rd[5] );

addp_vb.disasm = {
  sink << "addp\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

addp_vb.execute = {
  unsigned const elements = 8<<q;
  typename ARCH::U8 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = cpu.GetVU8(rn, e) + cpu.GetVU8(rn, e+1);
      res[(elements+e)/2] = cpu.GetVU8(rm, e) + cpu.GetVU8(rm, e+1);
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU8(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

op addp_vh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b101111[6] : rn[5] : rd[5] );

addp_vh.disasm = {
  sink << "addp\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

addp_vh.execute = {
  unsigned const elements = 4<<q;
  typename ARCH::U16 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = cpu.GetVU16(rn, e) + cpu.GetVU16(rn, e+1);
      res[(elements+e)/2] = cpu.GetVU16(rm, e) + cpu.GetVU16(rm, e+1);
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU16(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

op addp_vs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b101111[6] : rn[5] : rd[5] );

addp_vs.disasm = {
  sink << "addp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

addp_vs.execute = {
  unsigned const elements = 2<<q;
  typename ARCH::U32 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = cpu.GetVU32(rn, e) + cpu.GetVU32(rn, e+1);
      res[(elements+e)/2] = cpu.GetVU32(rm, e) + cpu.GetVU32(rm, e+1);
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU32(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

op addp_v2d( 0b01001110111[11] : rm[5] : 0b101111[6] : rn[5] : rd[5] );

addp_v2d.disasm = {
  sink << "addp\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

addp_v2d.execute = {
  typename ARCH::U64 res[2];

  for (unsigned e=0; e < 1; e += 1)
    {
      res[e+0] = cpu.GetVU64(rn, 2*e) + cpu.GetVU64(rn, 2*e+1);
      res[e+1] = cpu.GetVU64(rm, 2*e) + cpu.GetVU64(rm, 2*e+1);
    }

  for (unsigned e=0; e < 2; e += 1)
    cpu.SetVU64(rd, e, res[e]);

  cpu.ClearHighV(rd, 16);
};

/*
 * end of ADDP (vector)
 *******************************************************************/

/*******************************************************************
 * ADDV
 *
 * Add across vector
 */

op addv_bvb( 0b0[1] : q[1] : 0b00111000110001101110[20] : rn[5] : rd[5] );

addv_bvb.disasm = {
  sink << "addv\t" << DisasmB(rd) << ", " << DisasmTV(rn, 8<<q, 0);
};

addv_bvb.execute = {
  typedef typename ARCH::U8 U8;

  U8 res(0);
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    res += cpu.GetVU8(rn, idx);
  cpu.SetVU8(rd, res);
};

op addv_hvh( 0b0[1] : q[1] : 0b00111001110001101110[20] : rn[5] : rd[5] );

addv_hvh.disasm = {
  sink << "addv\t" << DisasmH(rd) << ", " << DisasmTV(rn, 4<<q, 1);
};

addv_hvh.execute = {
  typedef typename ARCH::U16 U16;

  U16 res(0);
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    res += cpu.GetVU16(rn, idx);
  cpu.SetVU16(rd, res);
};

op addv_sv4s( 0b0100111010110001101110[22] : rn[5] : rd[5] );

addv_sv4s.disasm = {
  sink << "addv\t" << DisasmS(rd) << ", " << DisasmTV(rn, 4, 2);
};

addv_sv4s.execute = {
  typedef typename ARCH::U32 U32;

  U32 res(0);
  for (unsigned idx = 0, end = 2<<1; idx < end; ++idx)
    res += cpu.GetVU32(rn, idx);
  cpu.SetVU32(rd, res);
};

/*
 * end of ADDV
 *******************************************************************/

op aesd_v16b16b( 0b0100111000101000010110[22] : rn[5] : rd[5] );

aesd_v16b16b.disasm = {
  sink << "aesd\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 16, 0);
};

op aese_v16b16b( 0b0100111000101000010010[22] : rn[5] : rd[5] );

aese_v16b16b.disasm = {
  sink << "aese\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 16, 0);
};

op aesimc_v16b16b( 0b0100111000101000011110[22] : rn[5] : rd[5] );

aesimc_v16b16b.disasm = {
  sink << "aesimc\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 16, 0);
};

op aesmc_v16b16b( 0b0100111000101000011010[22] : rn[5] : rd[5] );

aesmc_v16b16b.disasm = {
  sink << "aesmc\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 16, 0);
};

/*******************************************************************
 * CMEQ (register)
 *
 * Compare bitwise equal two registers, setting destination vector
 * element to all ones if the condition holds, else zero
 */

op cmeq_d_reg( 0b01111110111[11] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmeq_d_reg.disasm = {
  sink << "cmeq\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

cmeq_d_reg.execute = {
  typedef typename ARCH::S64 S64;

  S64 op1 = cpu.GetVS64(rn, 0), op2 = cpu.GetVS64(rm, 0), res = -S64(op1 == op2);
  cpu.SetVS64(rd, res);
};

op cmeq_vb_reg( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmeq_vb_reg.disasm = {
  sink << "cmeq\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

cmeq_vb_reg.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned e=0, end = 8<<q; e < end; e += 1)
    {
      S8 op1 = cpu.GetVS8(rn, e), op2 = cpu.GetVS8(rm, e), res = -S8(op1 == op2);
      cpu.SetVS8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmeq_vh_reg( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmeq_vh_reg.disasm = {
  sink << "cmeq\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

cmeq_vh_reg.execute = {
  typedef typename ARCH::S16 S16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      S16 op1 = cpu.GetVS16(rn, e), op2 = cpu.GetVS16(rm, e), res = -S16(op1 == op2);
      cpu.SetVS16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmeq_vs_reg( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmeq_vs_reg.disasm = {
  sink << "cmeq\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

cmeq_vs_reg.execute = {
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      S32 op1 = cpu.GetVS32(rn, e), op2 = cpu.GetVS32(rm, e), res = -S32(op1 == op2);
      cpu.SetVS32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmeq_v2d_reg( 0b01101110111[11] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmeq_v2d_reg.disasm = {
  sink << "cmeq\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

cmeq_v2d_reg.execute = {
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      S64 op1 = cpu.GetVS64(rn, e), op2 = cpu.GetVS64(rm, e), res = -S64(op1 == op2);
      cpu.SetVS64(rd, e, res);
    }
};

/*
 * end of CMEQ (register)
 *******************************************************************/

/*******************************************************************
 * CMEQ (zero)
 *
 * Compare bitwise equal to zero (vector), setting destination vector
 * element to all ones if the condition holds, else zero
 */

op cmeq_d_zero( 0b0101111011100000100110[22] : rn[5] : rd[5] );

cmeq_d_zero.disasm = {
  sink << "cmeq\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0";
};

cmeq_d_zero.execute = {
  typedef typename ARCH::S64 S64;

  S64 op1 = cpu.GetVS64(rn, 0), op2( 0 ), res = -S64(op1 == op2);
  cpu.SetVS64(rd, res);
};

op cmeq_vb_zero( 0b0[1] : q[1] : 0b00111000100000100110[20] : rn[5] : rd[5] );

cmeq_vb_zero.disasm = {
  sink << "cmeq\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", #0";
};

cmeq_vb_zero.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned e=0, end=8<<q; e < end; e += 1)
    {
      S8 op1 = cpu.GetVS8(rn, e), op2( 0 ), res = -S8(op1 == op2);
      cpu.SetVS8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmeq_vh_zero( 0b0[1] : q[1] : 0b00111001100000100110[20] : rn[5] : rd[5] );

cmeq_vh_zero.disasm = {
  sink << "cmeq\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", #0";
};

cmeq_vh_zero.execute = {
  typedef typename ARCH::S16 S16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      S16 op1 = cpu.GetVS16(rn, e), op2( 0 ), res = -S16(op1 == op2);
      cpu.SetVS16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmeq_vs_zero( 0b0[1] : q[1] : 0b00111010100000100110[20] : rn[5] : rd[5] );

cmeq_vs_zero.disasm = {
  sink << "cmeq\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0";
};

cmeq_vs_zero.execute = {
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      S32 op1 = cpu.GetVS32(rn, e), op2( 0 ), res = -S32(op1 == op2);
      cpu.SetVS32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmeq_v2d_zero( 0b0100111011100000100110[22] : rn[5] : rd[5] );

cmeq_v2d_zero.disasm = {
  sink << "cmeq\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", #0";
};

cmeq_v2d_zero.execute = {
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      S64 op1 = cpu.GetVS64(rn, e), op2( 0 ), res = -S64(op1 == op2);
      cpu.SetVS64(rd, e, res);
    }
};

/*
 * end of CMEQ (zero)
 *******************************************************************/

/*******************************************************************
 * CMGE (register)
 *
 * Compare signed greater than or equal (vector)
 */

op cmge_d_reg( 0b01011110111[11] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmge_d_reg.disasm = {
  sink << "cmge\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

cmge_d_reg.execute = {
  typedef typename ARCH::S64 S64;

  S64 op1 = cpu.GetVS64(rn, 0), op2 = cpu.GetVS64(rm, 0), res = -S64(op1 >= op2);
  cpu.SetVS64(rd, res);
};

op cmge_vb_reg( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmge_vb_reg.disasm = {
  sink << "cmge\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

cmge_vb_reg.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned e=0, end=8<<q; e < end; e += 1)
    {
      S8 op1 = cpu.GetVS8(rn, e), op2 = cpu.GetVS8(rm, e), res = -S8(op1 >= op2);
      cpu.SetVS8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmge_vh_reg( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmge_vh_reg.disasm = {
  sink << "cmge\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

cmge_vh_reg.execute = {
  typedef typename ARCH::S16 S16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      S16 op1 = cpu.GetVS16(rn, e), op2 = cpu.GetVS16(rm, e), res = -S16(op1 >= op2);
      cpu.SetVS16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmge_vs_reg( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmge_vs_reg.disasm = {
  sink << "cmge\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

cmge_vs_reg.execute = {
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      S32 op1 = cpu.GetVS32(rn, e), op2 = cpu.GetVS32(rm, e), res = -S32(op1 >= op2);
      cpu.SetVS32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmge_v2d_reg( 0b01001110111[11] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmge_v2d_reg.disasm = {
  sink << "cmge\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

cmge_v2d_reg.execute = {
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      S64 op1 = cpu.GetVS64(rn, e), op2 = cpu.GetVS64(rm, e), res = -S64(op1 >= op2);
      cpu.SetVS64(rd, e, res);
    }
};

/*
 * end of CMGE (register)
 *******************************************************************/

/*******************************************************************
 * CMGE (zero)
 *
 * Compare signed greater than or equal to zero (vector), setting
 * destination vector element to all ones if the condition holds, else
 * zero
 */

op cmge_d_zero( 0b0111111011100000100010[22] : rn[5] : rd[5] );

cmge_d_zero.disasm = {
  sink << "cmge\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0";
};

cmge_d_zero.execute = {
  typedef typename ARCH::S64 S64;

  S64 op1 = cpu.GetVS64(rn, 0), op2( 0 ), res = -S64(op1 >= op2);
  cpu.SetVS64(rd, res);
};

op cmge_vb_zero( 0b0[1] : q[1] : 0b10111000100000100010[20] : rn[5] : rd[5] );

cmge_vb_zero.disasm = {
  sink << "cmge\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", #0";
};

cmge_vb_zero.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned e=0, end=8<<q; e < end; e += 1)
    {
      S8 op1 = cpu.GetVS8(rn, e), op2( 0 ), res = -S8(op1 >= op2);
      cpu.SetVS8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmge_vh_zero( 0b0[1] : q[1] : 0b10111001100000100010[20] : rn[5] : rd[5] );

cmge_vh_zero.disasm = {
  sink << "cmge\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", #0";
};

cmge_vh_zero.execute = {
  typedef typename ARCH::S16 S16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      S16 op1 = cpu.GetVS16(rn, e), op2( 0 ), res = -S16(op1 >= op2);
      cpu.SetVS16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmge_vs_zero( 0b0[1] : q[1] : 0b10111010100000100010[20] : rn[5] : rd[5] );

cmge_vs_zero.disasm = {
  sink << "cmge\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0";
};

cmge_vs_zero.execute = {
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      S32 op1 = cpu.GetVS32(rn, e), op2( 0 ), res = -S32(op1 >= op2);
      cpu.SetVS32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmge_v2d_zero( 0b0110111011100000100010[22] : rn[5] : rd[5] );

cmge_v2d_zero.disasm = {
  sink << "cmge\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", #0";
};

cmge_v2d_zero.execute = {
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      S64 op1 = cpu.GetVS64(rn, e), op2( 0 ), res = -S64(op1 >= op2);
      cpu.SetVS64(rd, e, res);
    }
};

/*
 * end of CMGE (zero)
 *******************************************************************/

/*******************************************************************
 * CMGT (register)
 *
 * Compare signed greater than (vector), setting destination vector
 * element to all ones if the condition holds, else zero
 */

op cmgt_d_reg( 0b01011110111[11] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmgt_d_reg.disasm = {
  sink << "cmgt\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

cmgt_d_reg.execute = {
  typedef typename ARCH::S64 S64;

  S64 op1 = cpu.GetVS64(rn, 0), op2 = cpu.GetVS64(rm, 0), res = -S64(op1 > op2);
  cpu.SetVS64(rd, res);
};

op cmgt_vb_reg( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmgt_vb_reg.disasm = {
  sink << "cmgt\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

cmgt_vb_reg.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned e=0, end=8<<q; e < end; e += 1)
    {
      S8 op1 = cpu.GetVS8(rn, e), op2 = cpu.GetVS8(rm, e), res = -S8(op1 > op2);
      cpu.SetVS8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmgt_vh_reg( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmgt_vh_reg.disasm = {
  sink << "cmgt\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

cmgt_vh_reg.execute = {
  typedef typename ARCH::S16 S16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      S16 op1 = cpu.GetVS16(rn, e), op2 = cpu.GetVS16(rm, e), res = -S16(op1 > op2);
      cpu.SetVS16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmgt_vs_reg( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmgt_vs_reg.disasm = {
  sink << "cmgt\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

cmgt_vs_reg.execute = {
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      S32 op1 = cpu.GetVS32(rn, e), op2 = cpu.GetVS32(rm, e), res = -S32(op1 > op2);
      cpu.SetVS32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmgt_v2d_reg( 0b01001110111[11] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmgt_v2d_reg.disasm = {
  sink << "cmgt\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

cmgt_v2d_reg.execute = {
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      S64 op1 = cpu.GetVS64(rn, e), op2 = cpu.GetVS64(rm, e), res = -S64(op1 > op2);
      cpu.SetVS64(rd, e, res);
    }
};

/*
 * end of CMGT (register)
 *******************************************************************/

/*******************************************************************
 * CMGT (zero)
 *
 * Compare signed greater than zero (vector), setting destination
 * vector element to all ones if the condition holds, else zero
 */

op cmgt_d_zero( 0b0101111011100000100010[22] : rn[5] : rd[5] );

cmgt_d_zero.disasm = {
  sink << "cmgt\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0";
};

cmgt_d_zero.execute = {
  typedef typename ARCH::S64 S64;

  S64 op1 = cpu.GetVS64(rn, 0), op2( 0 ), res = -S64(op1 > op2);
  cpu.SetVS64(rd, res);
};

op cmgt_vb_zero( 0b0[1] : q[1] : 0b00111000100000100010[20] : rn[5] : rd[5] );

cmgt_vb_zero.disasm = {
  sink << "cmgt\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", #0";
};

cmgt_vb_zero.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned e=0, end=8<<q; e < end; e += 1)
    {
      S8 op1 = cpu.GetVS8(rn, e), op2( 0 ), res = -S8(op1 > op2);
      cpu.SetVS8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmgt_vh_zero( 0b0[1] : q[1] : 0b00111001100000100010[20] : rn[5] : rd[5] );

cmgt_vh_zero.disasm = {
  sink << "cmgt\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", #0";
};

cmgt_vh_zero.execute = {
  typedef typename ARCH::S16 S16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      S16 op1 = cpu.GetVS16(rn, e), op2( 0 ), res = -S16(op1 > op2);
      cpu.SetVS16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmgt_vs_zero( 0b0[1] : q[1] : 0b00111010100000100010[20] : rn[5] : rd[5] );

cmgt_vs_zero.disasm = {
  sink << "cmgt\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0";
};

cmgt_vs_zero.execute = {
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      S32 op1 = cpu.GetVS32(rn, e), op2( 0 ), res = -S32(op1 > op2);
      cpu.SetVS32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmgt_v2d_zero( 0b0100111011100000100010[22] : rn[5] : rd[5] );

cmgt_v2d_zero.disasm = {
  sink << "cmgt\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", #0";
};

cmgt_v2d_zero.execute = {
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      S64 op1 = cpu.GetVS64(rn, e), op2( 0 ), res = -S64(op1 > op2);
      cpu.SetVS64(rd, e, res);
    }
};

/*
 * end of CMGT (zero)
 *******************************************************************/

/*******************************************************************
 * CMHI (register)
 *
 * Compare unsigned higher (vector), setting destination vector
 * element to all ones if the condition holds, else zero
 */

op cmhi_d_reg( 0b01111110111[11] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmhi_d_reg.disasm = {
  sink << "cmhi\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

cmhi_d_reg.execute = {
  typedef typename ARCH::U64 U64;

  U64 op1 = cpu.GetVU64(rn, 0), op2 = cpu.GetVU64(rm, 0), res = -U64(op1 > op2);
  cpu.SetVU64(rd, res);
};

op cmhi_vb_reg( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmhi_vb_reg.disasm = {
  sink << "cmhi\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

cmhi_vb_reg.execute = {
  typedef typename ARCH::U8 U8;

  for (unsigned e=0, end=8<<q; e < end; e += 1)
    {
      U8 op1 = cpu.GetVU8(rn, e), op2 = cpu.GetVU8(rm, e), res = -U8(op1 > op2);
      cpu.SetVU8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmhi_vh_reg( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmhi_vh_reg.disasm = {
  sink << "cmhi\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

cmhi_vh_reg.execute = {
  typedef typename ARCH::U16 U16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      U16 op1 = cpu.GetVU16(rn, e), op2 = cpu.GetVU16(rm, e), res = -U16(op1 > op2);
      cpu.SetVU16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmhi_vs_reg( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmhi_vs_reg.disasm = {
  sink << "cmhi\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

cmhi_vs_reg.execute = {
  typedef typename ARCH::U32 U32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      U32 op1 = cpu.GetVU32(rn, e), op2 = cpu.GetVU32(rm, e), res = -U32(op1 > op2);
      cpu.SetVU32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmhi_v2d_reg( 0b01101110111[11] : rm[5] : 0b001101[6] : rn[5] : rd[5] );

cmhi_v2d_reg.disasm = {
  sink << "cmhi\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

cmhi_v2d_reg.execute = {
  typedef typename ARCH::U64 U64;

  for (unsigned e=0; e < 2; e += 1)
    {
      U64 op1 = cpu.GetVU64(rn, e), op2 = cpu.GetVU64(rm, e), res = -U64(op1 > op2);
      cpu.SetVU64(rd, e, res);
    }
};

/*
 * end of CMHI (register)
 *******************************************************************/

/*******************************************************************
 * CMHS (register)
 *
 * Compare unsigned higher or same (vector), setting destination
 * vector element to all ones if the condition holds, else zero
 */

op cmhs_d_reg( 0b01111110111[11] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmhs_d_reg.disasm = {
  sink << "cmhs\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

cmhs_d_reg.execute = {
  typedef typename ARCH::U64 U64;

  U64 op1 = cpu.GetVU64(rn, 0), op2 = cpu.GetVU64(rm, 0), res = -U64(op1 >= op2);
  cpu.SetVU64(rd, res);
};

op cmhs_vb_reg( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmhs_vb_reg.disasm = {
  sink << "cmhs\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

cmhs_vb_reg.execute = {
  typedef typename ARCH::U8 U8;

  for (unsigned e=0, end=8<<q; e < end; e += 1)
    {
      U8 op1 = cpu.GetVU8(rn, e), op2 = cpu.GetVU8(rm, e), res = -U8(op1 >= op2);
      cpu.SetVU8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmhs_vh_reg( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmhs_vh_reg.disasm = {
  sink << "cmhs\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

cmhs_vh_reg.execute = {
  typedef typename ARCH::U16 U16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      U16 op1 = cpu.GetVU16(rn, e), op2 = cpu.GetVU16(rm, e), res = -U16(op1 >= op2);
      cpu.SetVU16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmhs_vs_reg( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmhs_vs_reg.disasm = {
  sink << "cmhs\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

cmhs_vs_reg.execute = {
  typedef typename ARCH::U32 U32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      U32 op1 = cpu.GetVU32(rn, e), op2 = cpu.GetVU32(rm, e), res = -U32(op1 >= op2);
      cpu.SetVU32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmhs_v2d_reg( 0b01101110111[11] : rm[5] : 0b001111[6] : rn[5] : rd[5] );

cmhs_v2d_reg.disasm = {
  sink << "cmhs\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

cmhs_v2d_reg.execute = {
  typedef typename ARCH::U64 U64;

  for (unsigned e=0; e < 2; e += 1)
    {
      U64 op1 = cpu.GetVU64(rn, e), op2 = cpu.GetVU64(rm, e), res = -U64(op1 >= op2);
      cpu.SetVU64(rd, e, res);
    }
};

/*
 * end of CMHS (register)
 *******************************************************************/

/*******************************************************************
 * CMLE (zero)
 *
 * Compare signed less than or equal to zero (vector), setting
 * destination vector element to all ones if the condition holds, else
 * zero
 */

op cmle_d_zero( 0b0111111011100000100110[22] : rn[5] : rd[5] );

cmle_d_zero.disasm = {
  sink << "cmle\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0";
};

cmle_d_zero.execute = {
  typedef typename ARCH::S64 S64;

  S64 op1 = cpu.GetVS64(rn, 0), op2( 0 ), res = -S64(op1 <= op2);
  cpu.SetVS64(rd, res);
};

op cmle_vb_zero( 0b0[1] : q[1] : 0b10111000100000100110[20] : rn[5] : rd[5] );

cmle_vb_zero.disasm = {
  sink << "cmle\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", #0";
};

cmle_vb_zero.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned e=0, end=8<<q; e < end; e += 1)
    {
      S8 op1 = cpu.GetVS8(rn, e), op2( 0 ), res = -S8(op1 <= op2);
      cpu.SetVS8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmle_vh_zero( 0b0[1] : q[1] : 0b10111001100000100110[20] : rn[5] : rd[5] );

cmle_vh_zero.disasm = {
  sink << "cmle\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", #0";
};

cmle_vh_zero.execute = {
  typedef typename ARCH::S16 S16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      S16 op1 = cpu.GetVS16(rn, e), op2( 0 ), res = -S16(op1 <= op2);
      cpu.SetVS16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmle_vs_zero( 0b0[1] : q[1] : 0b10111010100000100110[20] : rn[5] : rd[5] );

cmle_vs_zero.disasm = {
  sink << "cmle\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0";
};

cmle_vs_zero.execute = {
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      S32 op1 = cpu.GetVS32(rn, e), op2( 0 ), res = -S32(op1 <= op2);
      cpu.SetVS32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmle_v2d_zero( 0b0110111011100000100110[22] : rn[5] : rd[5] );

cmle_v2d_zero.disasm = {
  sink << "cmle\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", #0";
};

cmle_v2d_zero.execute = {
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      S64 op1 = cpu.GetVS64(rn, e), op2( 0 ), res = -S64(op1 <= op2);
      cpu.SetVS64(rd, e, res);
    }
};

/*
 * end of CMLE (zero)
 *******************************************************************/

/*******************************************************************
 * CMLT (zero)
 *
 * Compare signed less than zero (vector), setting destination vector
 * element to all ones if the condition holds, else zero
 */

op cmlt_d_zero( 0b0101111011100000101010[22] : rn[5] : rd[5] );

cmlt_d_zero.disasm = {
  sink << "cmlt\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", #0";
};

cmlt_d_zero.execute = {
  typedef typename ARCH::S64 S64;

  S64 op1 = cpu.GetVS64(rn, 0), op2( 0 ), res = -S64(op1 < op2);
  cpu.SetVS64(rd, res);
};

op cmlt_vb_zero( 0b0[1] : q[1] : 0b00111000100000101010[20] : rn[5] : rd[5] );

cmlt_vb_zero.disasm = {
  sink << "cmlt\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", #0";
};

cmlt_vb_zero.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned e=0, end=8<<q; e < end; e += 1)
    {
      S8 op1 = cpu.GetVS8(rn, e), op2( 0 ), res = -S8(op1 < op2);
      cpu.SetVS8(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmlt_vh_zero( 0b0[1] : q[1] : 0b00111001100000101010[20] : rn[5] : rd[5] );

cmlt_vh_zero.disasm = {
  sink << "cmlt\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", #0";
};

cmlt_vh_zero.execute = {
  typedef typename ARCH::S16 S16;

  for (unsigned e=0, end=4<<q; e < end; e += 1)
    {
      S16 op1 = cpu.GetVS16(rn, e), op2( 0 ), res = -S16(op1 < op2);
      cpu.SetVS16(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmlt_vs_zero( 0b0[1] : q[1] : 0b00111010100000101010[20] : rn[5] : rd[5] );

cmlt_vs_zero.disasm = {
  sink << "cmlt\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", #0";
};

cmlt_vs_zero.execute = {
  typedef typename ARCH::S32 S32;

  for (unsigned e=0, end=2<<q; e < end; e += 1)
    {
      S32 op1 = cpu.GetVS32(rn, e), op2( 0 ), res = -S32(op1 < op2);
      cpu.SetVS32(rd, e, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op cmlt_v2d_zero( 0b0100111011100000101010[22] : rn[5] : rd[5] );

cmlt_v2d_zero.disasm = {
  sink << "cmlt\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", #0";
};

cmlt_v2d_zero.execute = {
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < 2; e += 1)
    {
      S64 op1 = cpu.GetVS64(rn, e), op2( 0 ), res = -S64(op1 < op2);
      cpu.SetVS64(rd, e, res);
    }
};

/*
 * end of CMLT (zero)
 *******************************************************************/

op cmtst_ddd( 0b01011110111[11] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmtst_ddd.disasm = {
  sink << "cmtst\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

cmtst_ddd.execute = {
  typedef typename ARCH::U64 U64;

  U64 val( cpu.GetVU64(rn, 0) & cpu.GetVU64(rm, 0) );
  cpu.SetVU64(rd, cpu.Test(val != U64(0)) ? ~U64(0) : U64(0));
}

op cmtst_v2dv2dv2d( 0b01001110111[11] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmtst_v2dv2dv2d.disasm = {
  sink << "cmtst\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

cmtst_v2dv2dv2d.execute = {
  typedef typename ARCH::U64 U64;

  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      U64 val( cpu.GetVU64(rn, idx) & cpu.GetVU64(rm, idx) );
      cpu.SetVU64(rd, idx, cpu.Test(val != U64(0)) ? ~U64(0) : U64(0));
    }
}

/*******************************************************************
 * LDP (SIMD&FP)
 *
 * Load pair of SIMD&FP registers
 */

op ldp_so( 0b0010110[7] : am[2] : 1[1] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldp_so.var reject : {Reject} = {rt == rt2};

ldp_so.disasm = {
  sink << "ld" << (am ? "" : "n") << "p\t" << DisasmS(rt) << ", " << DisasmS(rt2) << ", " << DisasmMemoryRI(rn, imm, am);
};

ldp_so.execute = {
  /* TODO: catch Non-temporal hint (am == 0) */
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetVU32(rt,  data0);
  cpu.SetVU32(rt2, data1);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op ldp_do( 0b0110110[7] : am[2] : 1[1] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldp_do.var reject : {Reject} = {rt == rt2};

ldp_do.disasm = {
  sink << "ld" << (am ? "" : "n") << "p\t" << DisasmD(rt) << ", " << DisasmD(rt2) << ", " << DisasmMemoryRI(rn, imm, am);
};

ldp_do.execute = {
  /* TODO: catch Non-temporal hint (am == 0) */
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U64 data0( cpu.MemRead64( addr + U64(0) ) ),
      data1( cpu.MemRead64( addr + U64(8) ) );
  cpu.SetVU64(rt,  data0);
  cpu.SetVU64(rt2, data1);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op ldp_qo( 0b1010110[7] : am[2] : 1[1] : shl<4> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldp_qo.var reject : {Reject} = {rt == rt2};

ldp_qo.disasm = {
  sink << "ld" << (am ? "" : "n") << "p\t" << DisasmQ(rt) << ", " << DisasmQ(rt2) << ", " << DisasmMemoryRI(rn, imm, am);
};

ldp_qo.execute = {
  /* TODO: catch Non-temporal hint (am == 0) */
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U64 data0( cpu.MemRead64( addr + U64( 0) ) ),
      data1( cpu.MemRead64( addr + U64( 8) ) ),
      data2( cpu.MemRead64( addr + U64(16) ) ),
      data3( cpu.MemRead64( addr + U64(24) ) );
  cpu.SetVU64(rt,  0, data0);
  cpu.SetVU64(rt,  1, data1);
  cpu.SetVU64(rt2, 0, data2);
  cpu.SetVU64(rt2, 1, data3);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

/*
 * end of LDP (SIMD&FP)
 *******************************************************************/

/*******************************************************************
 * LDR (immediate, SIMD&FP)
 *
 * Load SIMD&FP register (immediate offset)
 */

op ldr_bxi( 0b00111100010[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
ldr_bxi.var reject : {Reject} = {am == 2};

ldr_bxi.disasm = {
  sink << "ld" << (am ? "" : "u") << "r\t" << DisasmB(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

ldr_bxi.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U8 data( cpu.MemRead8(addr) );
  cpu.SetVU8(rt, data);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op ldr_buo( 0b0011110101[10] : imm[12] : rn[5] : rt[5] );

ldr_buo.disasm = {
  sink << "ldr\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

ldr_buo.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U8 data( cpu.MemRead8(addr) );
  cpu.SetVU8(rt, data);
};

op ldr_hxi( 0b01111100010[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
ldr_hxi.var reject : {Reject} = {am == 2};

ldr_hxi.disasm = {
  sink << "ld" << (am ? "" : "u") << "r\t" << DisasmH(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

ldr_hxi.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U16 data( cpu.MemRead16(addr) );
  cpu.SetVU16(rt, data);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op ldr_huo( 0b0111110101[10] : shl<1> imm[12] : rn[5] : rt[5] );

ldr_huo.disasm = {
  sink << "ldr\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

ldr_huo.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U16 data( cpu.MemRead16(addr) );
  cpu.SetVU16(rt, data);
};

op ldr_sxi( 0b10111100010[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
ldr_sxi.var reject : {Reject} = {am == 2};

ldr_sxi.disasm = {
  sink << "ld" << (am ? "" : "u") << "r\t" << DisasmS(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

ldr_sxi.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U32 data( cpu.MemRead32(addr) );
  cpu.SetVU32(rt, data);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op ldr_suo( 0b1011110101[10] : shl<2> imm[12] : rn[5] : rt[5] );

ldr_suo.disasm = {
  sink << "ldr\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

ldr_suo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U32 data( cpu.MemRead32(addr) );
  cpu.SetVU32(rt, data);
};

op ldr_dxi( 0b11111100010[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
ldr_dxi.var reject : {Reject} = {am == 2};

ldr_dxi.disasm = {
  sink << "ld" << (am ? "" : "u") << "r\t" << DisasmD(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

ldr_dxi.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U64 data( cpu.MemRead64(addr) );
  cpu.SetVU64(rt, data);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op ldr_duo( 0b1111110101[10] : shl<3> imm[12] : rn[5] : rt[5] );

ldr_duo.disasm = {
  sink << "ldr\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

ldr_duo.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U64 data( cpu.MemRead64(addr) );
  cpu.SetVU64(rt, data);
};

op ldr_qxi( 0b00111100110[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
ldr_qxi.var reject : {Reject} = {am == 2};

ldr_qxi.disasm = {
  sink << "ld" << (am ? "" : "u") << "r\t" << DisasmQ(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

ldr_qxi.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U64 data0( cpu.MemRead64(addr) ), data1( cpu.MemRead64(addr+U64(8)) );
  cpu.SetVU64(rt, 0, data0);
  cpu.SetVU64(rt, 1, data1);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op ldr_quo( 0b0011110111[10] : shl<4> imm[12] : rn[5] : rt[5] );

ldr_quo.disasm = {
  sink << "ldr\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

ldr_quo.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U64 data0( cpu.MemRead64(addr) ), data1( cpu.MemRead64(addr+U64(8)) );
  cpu.SetVU64(rt, 0, data0);
  cpu.SetVU64(rt, 1, data1);
};

/*
 * end of LDR (immediate, SIMD&FP)
 *******************************************************************/

/*******************************************************************
 * LDR (literal, SIMD&FP)
 *
 * Load SIMD&FP register (PC-relative literal)
 */

op ldr_slit( 0b00011100[8] : shl<2> sext imm[19] : rt[5] );

ldr_slit.disasm = {
  sink << "ldr\t" << DisasmS(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

ldr_slit.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetPC() + U64(imm) );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetVU32(rt, data);
};

op ldr_dlit( 0b01011100[8] : shl<2> sext imm[19] : rt[5] );

ldr_dlit.disasm = {
  sink << "ldr\t" << DisasmD(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

ldr_dlit.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetPC() + U64(imm) );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetVU64(rt, data);
};

op ldr_qlit( 0b10011100[8] : shl<2> sext imm[19] : rt[5] );

ldr_qlit.disasm = {
  sink << "ldr\t" << DisasmQ(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

ldr_qlit.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetPC() + U64(imm) );
  U64 data0( cpu.MemRead64(addr) ), data1( cpu.MemRead64(addr + U64(8)) );
  cpu.SetVU64(rt, 0, data0);
  cpu.SetVU64(rt, 1, data1);
}

/*
 * end of LDR (literal, SIMD&FP)
 *******************************************************************/

/*******************************************************************
 * LDR (register, SIMD&FP)
 *
 * Load SIMD&FP register (register offset)
 */

op ldr_bxwu( 0b00111100011[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_bxwu.var shift : {uint8_t} = {s*0};

ldr_bxwu.disasm = {
  sink << "ldr\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_bxwu.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U8 data( cpu.MemRead8(addr) );
  cpu.SetVU8(rt, data);
};

op ldr_bxxu( 0b00111100011[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_bxxu.var shift : {uint8_t} = {s*0};

ldr_bxxu.disasm = {
  sink << "ldr\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

ldr_bxxu.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U8 data( cpu.MemRead8(addr) );
  cpu.SetVU8(rt, data);
};

op ldr_bxws( 0b00111100011[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_bxws.var shift : {uint8_t} = {s*0};

ldr_bxws.disasm = {
  sink << "ldr\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_bxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U8  U8;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U8 data( cpu.MemRead8(addr) );
  cpu.SetVU8(rt, data);
};

op ldr_bxxs( 0b00111100011[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_bxxs.var shift : {uint8_t} = {s*0};

ldr_bxxs.disasm = {
  sink << "ldr\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

ldr_bxxs.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U8 data( cpu.MemRead8(addr) );
  cpu.SetVU8(rt, data);
};

op ldr_hxwu( 0b01111100011[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_hxwu.var shift : {uint8_t} = {s*1};

ldr_hxwu.disasm = {
  sink << "ldr\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_hxwu.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U16 data( cpu.MemRead16(addr) );
  cpu.SetVU16(rt, data);
};

op ldr_hxxu( 0b01111100011[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_hxxu.var shift : {uint8_t} = {s*1};

ldr_hxxu.disasm = {
  sink << "ldr\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

ldr_hxxu.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U16 data( cpu.MemRead16(addr) );
  cpu.SetVU16(rt, data);
};

op ldr_hxws( 0b01111100011[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_hxws.var shift : {uint8_t} = {s*1};

ldr_hxws.disasm = {
  sink << "ldr\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_hxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U16 data( cpu.MemRead16(addr) );
  cpu.SetVU16(rt, data);
};

op ldr_hxxs( 0b01111100011[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_hxxs.var shift : {uint8_t} = {s*1};

ldr_hxxs.disasm = {
  sink << "ldr\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

ldr_hxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U16 data( cpu.MemRead16(addr) );
  cpu.SetVU16(rt, data);
};

op ldr_sxwu( 0b10111100011[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_sxwu.var shift : {uint8_t} = {s*2};

ldr_sxwu.disasm = {
  sink << "ldr\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_sxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U32 data( cpu.MemRead32(addr) );
  cpu.SetVU32(rt, data);
};

op ldr_sxxu( 0b10111100011[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_sxxu.var shift : {uint8_t} = {s*2};

ldr_sxxu.disasm = {
  sink << "ldr\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

ldr_sxxu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U32 data( cpu.MemRead32(addr) );
  cpu.SetVU32(rt, data);
};

op ldr_sxws( 0b10111100011[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_sxws.var shift : {uint8_t} = {s*2};

ldr_sxws.disasm = {
  sink << "ldr\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_sxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U32 data( cpu.MemRead32(addr) );
  cpu.SetVU32(rt, data);
};

op ldr_sxxs( 0b10111100011[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_sxxs.var shift : {uint8_t} = {s*2};

ldr_sxxs.disasm = {
  sink << "ldr\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

ldr_sxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U32 data( cpu.MemRead32(addr) );
  cpu.SetVU32(rt, data);
};

op ldr_dxwu( 0b11111100011[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_dxwu.var shift : {uint8_t} = {s*3};

ldr_dxwu.disasm = {
  sink << "ldr\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_dxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data( cpu.MemRead64(addr) );
  cpu.SetVU64(rt, data);
};

op ldr_dxxu( 0b11111100011[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_dxxu.var shift : {uint8_t} = {s*3};

ldr_dxxu.disasm = {
  sink << "ldr\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

ldr_dxxu.execute = {
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data( cpu.MemRead64(addr) );
  cpu.SetVU64(rt, data);
};

op ldr_dxws( 0b11111100011[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_dxws.var shift : {uint8_t} = {s*3};

ldr_dxws.disasm = {
  sink << "ldr\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_dxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data( cpu.MemRead64(addr) );
  cpu.SetVU64(rt, data);
};

op ldr_dxxs( 0b11111100011[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_dxxs.var shift : {uint8_t} = {s*3};

ldr_dxxs.disasm = {
  sink << "ldr\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

ldr_dxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data( cpu.MemRead64(addr) );
  cpu.SetVU64(rt, data);
};

op ldr_qxwu( 0b00111100111[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_qxwu.var shift : {uint8_t} = {s*4};

ldr_qxwu.disasm = {
  sink << "ldr\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_qxwu.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data0( cpu.MemRead64(addr) ), data1( cpu.MemRead64(addr + U64(8)) );
  cpu.SetVU64(rt, 0, data0);
  cpu.SetVU64(rt, 1, data1);
};

op ldr_qxxu( 0b00111100111[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_qxxu.var shift : {uint8_t} = {s*4};

ldr_qxxu.disasm = {
  sink << "ldr\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

ldr_qxxu.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data0( cpu.MemRead64(addr) ), data1( cpu.MemRead64(addr + U64(8)) );
  cpu.SetVU64(rt, 0, data0);
  cpu.SetVU64(rt, 1, data1);
};

op ldr_qxws( 0b00111100111[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_qxws.var shift : {uint8_t} = {s*4};

ldr_qxws.disasm = {
  sink << "ldr\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_qxws.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data0( cpu.MemRead64(addr) ), data1( cpu.MemRead64(addr + U64(8)) );
  cpu.SetVU64(rt, 0, data0);
  cpu.SetVU64(rt, 1, data1);
};

op ldr_qxxs( 0b00111100111[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_qxxs.var shift : {uint8_t} = {s*4};

ldr_qxxs.disasm = {
  sink << "ldr\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

ldr_qxxs.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data0( cpu.MemRead64(addr) ), data1( cpu.MemRead64(addr + U64(8)) );
  cpu.SetVU64(rt, 0, data0);
  cpu.SetVU64(rt, 1, data1);
};

/*
 * end of LDR (register, SIMD&FP)
 *******************************************************************/

/*******************************************************************
 * Mov
 */

op mov_vbii( 0b01101110000[11] : index1[4] : 0b10[2] : index2[4] : 0b1[1] : rn[5] : rd[5] );

mov_vbii.disasm = {
  sink << "mov\t" << DisasmTV(rd, 0, 0) << DisasmSubscript(index1) << ", " << DisasmTV(rn, 0, 0) << DisasmSubscript(index2);
};

mov_vbii.execute = {
  cpu.SetVU8(rd, index1, cpu.GetVU8(rn, index2));
};

op mov_vhii( 0b01101110000[11] : index1[3] : 0b100[3] : index2[3] : ?[1] : 0b1[1] : rn[5] : rd[5] );

mov_vhii.disasm = {
  sink << "mov\t" << DisasmTV(rd, 0, 1) << DisasmSubscript(index1) << ", " << DisasmTV(rn, 0, 1) << DisasmSubscript(index2);
};

mov_vhii.execute = {
  cpu.SetVU16(rd, index1, cpu.GetVU16(rn, index2));
};

op mov_vsii( 0b01101110000[11] : index1[2] : 0b1000[4] : index2[2] : ?[2] : 0b1[1] : rn[5] : rd[5] );

mov_vsii.disasm = {
  sink << "mov\t" << DisasmTV(rd, 0, 2) << DisasmSubscript(index1) << ", " << DisasmTV(rn, 0, 2) << DisasmSubscript(index2);
};

mov_vsii.execute = {
  cpu.SetVU32(rd, index1, cpu.GetVU32(rn, index2));
};

op mov_vdii( 0b01101110000[11] : index1[1] : 0b10000[5] : index2[1] : ?[3] : 0b1[1] : rn[5] : rd[5] );

mov_vdii.disasm = {
  sink << "mov\t" << DisasmTV(rd, 0, 3) << DisasmSubscript(index1) << ", " << DisasmTV(rn, 0, 3) << DisasmSubscript(index2);
};

mov_vdii.execute = {
  cpu.SetVU64(rd, index1, cpu.GetVU64(rn, index2));
};

/*******************************************************************
 * INS (general)
 *
 * Insert vector element from general-purpose register
 */

op ins_vbw( 0b01001110000[11] : index[4] : 0b1000111[7] : rn[5] : rd[5] );

ins_vbw.disasm = {
  sink << "ins\t" << DisasmTV(rd, 0, 0) << DisasmSubscript(index) << ", " << DisasmGZWR(rn);
};

ins_vbw.execute = {
  cpu.SetVU8(rd, index, typename ARCH::U8(cpu.GetGZR(rn)));
};

op ins_vhw( 0b01001110000[11] : index[3] : 0b10000111[8] : rn[5] : rd[5] );

ins_vhw.disasm = {
  sink << "ins\t" << DisasmTV(rd, 0, 1) << DisasmSubscript(index) << ", " << DisasmGZWR(rn);
};

ins_vhw.execute = {
  cpu.SetVU16(rd, index, typename ARCH::U16(cpu.GetGZR(rn)));
};

op ins_vsw( 0b01001110000[11] : index[2] : 0b100000111[9] : rn[5] : rd[5] );

ins_vsw.disasm = {
  sink << "ins\t" << DisasmTV(rd, 0, 2) << DisasmSubscript(index) << ", " << DisasmGZWR(rn);
};

ins_vsw.execute = {
  cpu.SetVU32(rd, index, typename ARCH::U32(cpu.GetGZR(rn)));
};

op ins_vdx( 0b01001110000[11] : index[1] : 0b1000000111[10] : rn[5] : rd[5] );

ins_vdx.disasm = {
  sink << "ins\t" << DisasmTV(rd, 0, 3) << DisasmSubscript(index) << ", " << DisasmGZXR(rn);
};

ins_vdx.execute = {
  cpu.SetVU64(rd, index, cpu.GetGZR(rn));
};

/*
 * end of INS (general)
 *******************************************************************/

op pmull( 0b00001110111[11] : rm[5] : 0b111000[6] : rn[5] : rd[5] );

pmull.disasm = {
  sink << "pmull\t" << DisasmTV(rd, 1, 4) << ", " << DisasmTV(rn, 1, 3) << ", " << DisasmTV(rm, 1, 3);
};

op pmull2( 0b01001110111[11] : rm[5] : 0b111000[6] : rn[5] : rd[5] );

pmull2.disasm = {
  sink << "pmull2\t" << DisasmTV(rd, 1, 4) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

op pmull2_v8hv16bv16b( 0b01001110001[11] : rm[5] : 0b111000[6] : rn[5] : rd[5] );

pmull2_v8hv16bv16b.disasm = {
  sink << "pmull2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

pmull2_v8hv16bv16b.execute = {
  typedef typename ARCH::U16 U16;

  for (unsigned idx = 0, end=8; idx < end; ++idx)
    {
      U16 op1(cpu.GetVU8(rn, end + idx)), op2(cpu.GetVU8(rm, end + idx)), res(0);
      for (unsigned bit = 0; bit < 8; ++bit)
        res = res ^ (op2*(op1 & U16(1<<bit)));
      cpu.SetVU16(rd, idx, res);
    }
};

op pmull_v8hv8bv8b( 0b00001110001[11] : rm[5] : 0b111000[6] : rn[5] : rd[5] );

pmull_v8hv8bv8b.disasm = {
  sink << "pmull\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

pmull_v8hv8bv8b.execute = {
  typedef typename ARCH::U16 U16;

  for (unsigned idx = 0, end=8; idx < end; ++idx)
    {
      U16 op1(cpu.GetVU8(rn, idx)), op2(cpu.GetVU8(rm, idx)), res(0);
      for (unsigned bit = 0; bit < 8; ++bit)
        res = res ^ (op2*(op1 & U16(1<<bit)));
      cpu.SetVU16(rd, idx, res);
    }
};

op raddhn2_v16bv8hv8h( 0b01101110001[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

raddhn2_v16bv8hv8h.disasm = {
  sink << "raddhn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

raddhn2_v16bv8hv8h.execute = {
  typedef typename ARCH::U8 DST;
  typedef typename ARCH::U16 SRC;
  for (unsigned idx = 0, end = 8; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx + end, DST((cpu.GetVU16(rn, idx) + cpu.GetVU16(rm, idx) + (SRC(1) << 7)) >> 8));
    }
}

op raddhn2_v4sv2dv2d( 0b01101110101[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

raddhn2_v4sv2dv2d.disasm = {
  sink << "raddhn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

raddhn2_v4sv2dv2d.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U64 SRC;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx + end, DST((cpu.GetVU64(rn, idx) + cpu.GetVU64(rm, idx) + (SRC(1) << 31)) >> 32));
    }
}

op raddhn2_v8hv4sv4s( 0b01101110011[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

raddhn2_v8hv4sv4s.disasm = {
  sink << "raddhn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

raddhn2_v8hv4sv4s.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U32 SRC;
  for (unsigned idx = 0, end = 4; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx + end, DST((cpu.GetVU32(rn, idx) + cpu.GetVU32(rm, idx) + (SRC(1) << 15)) >> 16));
    }
}

op raddhn_v2sv2dv2d( 0b00101110101[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

raddhn_v2sv2dv2d.disasm = {
  sink << "raddhn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

raddhn_v2sv2dv2d.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U64 SRC;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, DST((cpu.GetVU64(rn, idx) + cpu.GetVU64(rm, idx) + (SRC(1) << 31)) >> 32));
    }
  cpu.ClearHighV(rd, 8);
}

op raddhn_v4hv4sv4s( 0b00101110011[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

raddhn_v4hv4sv4s.disasm = {
  sink << "raddhn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

raddhn_v4hv4sv4s.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U32 SRC;
  for (unsigned idx = 0, end = 4; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, DST((cpu.GetVU32(rn, idx) + cpu.GetVU32(rm, idx) + (SRC(1) << 15)) >> 16));
    }
  cpu.ClearHighV(rd, 8);
}

op raddhn_v8bv8hv8h( 0b00101110001[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

raddhn_v8bv8hv8h.disasm = {
  sink << "raddhn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

raddhn_v8bv8hv8h.execute = {
  typedef typename ARCH::U8 DST;
  typedef typename ARCH::U16 SRC;
  for (unsigned idx = 0, end = 8; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, DST((cpu.GetVU16(rn, idx) + cpu.GetVU16(rm, idx) + (SRC(1) << 7)) >> 8));
    }
  cpu.ClearHighV(rd, 8);
}

op rshrn2_v16b8hi( 0b0100111100001[13] : lro[3] : 0b100011[6] : rn[5] : rd[5] );
rshrn2_v16b8hi.var shift : {unsigned} = {8 - lro}, round : {uint32_t} = { uint32_t(1) << (shift - 1)};

rshrn2_v16b8hi.disasm = {
  sink << "rshrn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

rshrn2_v16b8hi.execute = {
  typedef typename ARCH::U8 DST;
  typedef typename ARCH::U16 SRC;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST((cpu.GetVU16(rn, idx) + SRC(round)) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, elements + idx, res[idx]);
    }
}

op rshrn2_v4s2di( 0b01001111001[11] : lro[5] : 0b100011[6] : rn[5] : rd[5] );
rshrn2_v4s2di.var shift : {unsigned} = {32 - lro}, round : {uint64_t} = { uint64_t(1) << (shift - 1)};

rshrn2_v4s2di.disasm = {
  sink << "rshrn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

rshrn2_v4s2di.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U64 SRC;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST((cpu.GetVU64(rn, idx) + SRC(round)) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, elements + idx, res[idx]);
    }
}

op rshrn2_v8h4si( 0b010011110001[12] : lro[4] : 0b100011[6] : rn[5] : rd[5] );
rshrn2_v8h4si.var shift : {unsigned} = {16 - lro}, round : {uint32_t} = { uint32_t(1) << (shift - 1)};

rshrn2_v8h4si.disasm = {
  sink << "rshrn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

rshrn2_v8h4si.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U32 SRC;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST((cpu.GetVU32(rn, idx) + SRC(round)) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, elements + idx, res[idx]);
    }
}

op rshrn_v2s2di( 0b00001111001[11] : lro[5] : 0b100011[6] : rn[5] : rd[5] );
rshrn_v2s2di.var shift : {unsigned} = {32 - lro}, round : {uint64_t} = { uint64_t(1) << (shift - 1)};

rshrn_v2s2di.disasm = {
  sink << "rshrn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

rshrn_v2s2di.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U64 SRC;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST((cpu.GetVU64(rn, idx) + SRC(round)) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op rshrn_v4h4si( 0b000011110001[12] : lro[4] : 0b100011[6] : rn[5] : rd[5] );
rshrn_v4h4si.var shift : {unsigned} = {16 - lro}, round : {uint32_t} = { uint32_t(1) << (shift - 1)};

rshrn_v4h4si.disasm = {
  sink << "rshrn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

rshrn_v4h4si.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U32 SRC;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST((cpu.GetVU32(rn, idx) + SRC(round)) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op rshrn_v8b8hi( 0b0000111100001[13] : lro[3] : 0b100011[6] : rn[5] : rd[5] );
rshrn_v8b8hi.var shift : {unsigned} = {8 - lro}, round : {uint16_t} = { uint16_t(1) << (shift - 1)};

rshrn_v8b8hi.disasm = {
  sink << "rshrn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

rshrn_v8b8hi.execute = {
  typedef typename ARCH::U8 DST;
  typedef typename ARCH::U16 SRC;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST((cpu.GetVU16(rn, idx) + SRC(round)) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op rsubhn2_v16bv8hv8h( 0b01101110001[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

rsubhn2_v16bv8hv8h.disasm = {
  sink << "rsubhn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

rsubhn2_v16bv8hv8h.execute = {
  typedef typename ARCH::U8 DST;
  typedef typename ARCH::U16 SRC;
  for (unsigned idx = 0, end = 8; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx + end, DST((cpu.GetVU16(rn, idx) - cpu.GetVU16(rm, idx) + (SRC(1) << 7)) >> 8));
    }
}

op rsubhn2_v4sv2dv2d( 0b01101110101[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

rsubhn2_v4sv2dv2d.disasm = {
  sink << "rsubhn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

rsubhn2_v4sv2dv2d.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U64 SRC;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx + end, DST((cpu.GetVU64(rn, idx) - cpu.GetVU64(rm, idx) + (SRC(1) << 31)) >> 32));
    }
}

op rsubhn2_v8hv4sv4s( 0b01101110011[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

rsubhn2_v8hv4sv4s.disasm = {
  sink << "rsubhn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

rsubhn2_v8hv4sv4s.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U32 SRC;
  for (unsigned idx = 0, end = 4; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx + end, DST((cpu.GetVU32(rn, idx) - cpu.GetVU32(rm, idx) + (SRC(1) << 15)) >> 16));
    }
}

op rsubhn_v2sv2dv2d( 0b00101110101[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

rsubhn_v2sv2dv2d.disasm = {
  sink << "rsubhn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

rsubhn_v2sv2dv2d.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U64 SRC;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, DST((cpu.GetVU64(rn, idx) - cpu.GetVU64(rm, idx) + (SRC(1) << 31)) >> 32));
    }
  cpu.ClearHighV(rd, 8);
}

op rsubhn_v4hv4sv4s( 0b00101110011[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

rsubhn_v4hv4sv4s.disasm = {
  sink << "rsubhn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

rsubhn_v4hv4sv4s.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U32 SRC;
  for (unsigned idx = 0, end = 4; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, DST((cpu.GetVU32(rn, idx) - cpu.GetVU32(rm, idx) + (SRC(1) << 15)) >> 16));
    }
  cpu.ClearHighV(rd, 8);
}

op rsubhn_v8bv8hv8h( 0b00101110001[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

rsubhn_v8bv8hv8h.disasm = {
  sink << "rsubhn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

rsubhn_v8bv8hv8h.execute = {
  typedef typename ARCH::U8 DST;
  typedef typename ARCH::U16 SRC;
  for (unsigned idx = 0, end = 8; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, DST((cpu.GetVU16(rn, idx) - cpu.GetVU16(rm, idx) + (SRC(1) << 7)) >> 8));
    }
  cpu.ClearHighV(rd, 8);
}

op sabal2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

sabal2_v2dv4sv4s.disasm = {
  sink << "sabal2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

sabal2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) + S64(Abs(cpu, S64(cpu.GetVS32(rn, elements + idx)) - S64(cpu.GetVS32(rm, elements + idx))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sabal2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

sabal2_v4sv8hv8h.disasm = {
  sink << "sabal2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

sabal2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) + S32(Abs(cpu, S32(cpu.GetVS16(rn, elements + idx)) - S32(cpu.GetVS16(rm, elements + idx))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sabal2_v8hv16bv16b( 0b01001110001[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

sabal2_v8hv16bv16b.disasm = {
  sink << "sabal2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

sabal2_v8hv16bv16b.execute = {
  typedef typename ARCH::S16 DST;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rd, idx) + S16(Abs(cpu, S16(cpu.GetVS8(rn, elements + idx)) - S16(cpu.GetVS8(rm, elements + idx))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op sabal_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

sabal_v2dv2sv2s.disasm = {
  sink << "sabal\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

sabal_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 S64;
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVS64(rd, idx, cpu.GetVS64(rd, idx) + Abs(cpu, S64(cpu.GetVS32(rn, idx)) - S64(cpu.GetVS32(rm, idx))));
    }
}

op sabal_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

sabal_v4sv4hv4h.disasm = {
  sink << "sabal\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

sabal_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 S32;
  for (unsigned idx = 0; idx < 4; ++idx)
    {
      cpu.SetVS32(rd, idx, cpu.GetVS32(rd, idx) + Abs(cpu, S32(cpu.GetVS16(rn, idx)) - S32(cpu.GetVS16(rm, idx))));
    }
}

op sabal_v8hv8bv8b( 0b00001110001[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

sabal_v8hv8bv8b.disasm = {
  sink << "sabal\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

sabal_v8hv8bv8b.execute = {
  typedef typename ARCH::S16 S16;
  for (unsigned idx = 0; idx < 8; ++idx)
    {
      cpu.SetVS16(rd, idx, cpu.GetVS16(rd, idx) + Abs(cpu, S16(cpu.GetVS8(rn, idx)) - S16(cpu.GetVS8(rm, idx))));
    }
}

op sabdl2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

sabdl2_v2dv4sv4s.disasm = {
  sink << "sabdl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

sabdl2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = S64(Abs(cpu, S64(cpu.GetVS32(rn, elements + idx)) - S64(cpu.GetVS32(rm, elements + idx))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sabdl2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

sabdl2_v4sv8hv8h.disasm = {
  sink << "sabdl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

sabdl2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = S32(Abs(cpu, S32(cpu.GetVS16(rn, elements + idx)) - S32(cpu.GetVS16(rm, elements + idx))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sabdl2_v8hv16bv16b( 0b01001110001[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

sabdl2_v8hv16bv16b.disasm = {
  sink << "sabdl2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

sabdl2_v8hv16bv16b.execute = {
  typedef typename ARCH::S16 DST;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = S16(Abs(cpu, S16(cpu.GetVS8(rn, elements + idx)) - S16(cpu.GetVS8(rm, elements + idx))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op sabdl_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

sabdl_v2dv2sv2s.disasm = {
  sink << "sabdl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

sabdl_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 S64;
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVS64(rd, idx, Abs(cpu, S64(cpu.GetVS32(rn, idx)) - S64(cpu.GetVS32(rm, idx))));
    }
}

op sabdl_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

sabdl_v4sv4hv4h.disasm = {
  sink << "sabdl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

sabdl_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 S32;
  for (unsigned idx = 0; idx < 4; ++idx)
    {
      cpu.SetVS32(rd, idx, Abs(cpu, S32(cpu.GetVS16(rn, idx)) - S32(cpu.GetVS16(rm, idx))));
    }
}

op sabdl_v8hv8bv8b( 0b00001110001[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

sabdl_v8hv8bv8b.disasm = {
  sink << "sabdl\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

sabdl_v8hv8bv8b.execute = {
  typedef typename ARCH::S16 S16;
  for (unsigned idx = 0; idx < 8; ++idx)
    {
      cpu.SetVS16(rd, idx, Abs(cpu, S16(cpu.GetVS8(rn, idx)) - S16(cpu.GetVS8(rm, idx))));
    }
}

op saddl2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

saddl2_v2dv4sv4s.disasm = {
  sink << "saddl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

saddl2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = S64(cpu.GetVS32(rn, elements + idx)) + S64(cpu.GetVS32(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op saddl2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

saddl2_v4sv8hv8h.disasm = {
  sink << "saddl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

saddl2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = S32(cpu.GetVS16(rn, elements + idx)) + S32(cpu.GetVS16(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op saddl2_v8hv16bv16b( 0b01001110001[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

saddl2_v8hv16bv16b.disasm = {
  sink << "saddl2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

saddl2_v8hv16bv16b.execute = {
  typedef typename ARCH::S16 DST;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = S16(cpu.GetVS8(rn, elements + idx)) + S16(cpu.GetVS8(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op saddl_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

saddl_v2dv2sv2s.disasm = {
  sink << "saddl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

saddl_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 S64;
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVS64(rd, idx, S64(cpu.GetVS32(rn, idx)) + S64(cpu.GetVS32(rm, idx)));
    }
}

op saddl_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

saddl_v4sv4hv4h.disasm = {
  sink << "saddl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

saddl_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 S32;
  for (unsigned idx = 0; idx < 4; ++idx)
    {
      cpu.SetVS32(rd, idx, S32(cpu.GetVS16(rn, idx)) + S32(cpu.GetVS16(rm, idx)));
    }
}

op saddl_v8hv8bv8b( 0b00001110001[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

saddl_v8hv8bv8b.disasm = {
  sink << "saddl\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

saddl_v8hv8bv8b.execute = {
  typedef typename ARCH::S16 S16;
  for (unsigned idx = 0; idx < 8; ++idx)
    {
      cpu.SetVS16(rd, idx, S16(cpu.GetVS8(rn, idx)) + S16(cpu.GetVS8(rm, idx)));
    }
}

op saddlv_dv4s( 0b0100111010110000001110[22] : rn[5] : rd[5] );

saddlv_dv4s.disasm = {
  sink << "saddlv\t" << DisasmD(rd) << ", " << DisasmTV(rn, 4, 2);
};

saddlv_dv4s.execute = {
  unsigned const elements = 4;
  typedef typename ARCH::S64 S64;

  S64 sum = S64(cpu.GetVS32(rn, 0));
  for (unsigned e=1; e < elements; e += 1)
    {
      sum += S64(cpu.GetVS32(rn, e));
    }

  cpu.SetVS64(rd, sum);
}

op saddw2_v2dv2dv4s( 0b01001110101[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

saddw2_v2dv2dv4s.disasm = {
  sink << "saddw2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 4, 2);
};

saddw2_v2dv2dv4s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rn, idx) + DST(cpu.GetVS32(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op saddw2_v4sv4sv8h( 0b01001110011[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

saddw2_v4sv4sv8h.disasm = {
  sink << "saddw2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 8, 1);
};

saddw2_v4sv4sv8h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rn, idx) + DST(cpu.GetVS16(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op saddw2_v8hv8hv16b( 0b01001110001[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

saddw2_v8hv8hv16b.disasm = {
  sink << "saddw2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 16, 0);
};

saddw2_v8hv8hv16b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rn, idx) + DST(cpu.GetVS8(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op saddw_v2dv2dv2s( 0b00001110101[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

saddw_v2dv2dv2s.disasm = {
  sink << "saddw\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 2);
};

saddw_v2dv2dv2s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rn, idx) + DST(cpu.GetVS32(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op saddw_v4sv4sv4h( 0b00001110011[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

saddw_v4sv4sv4h.disasm = {
  sink << "saddw\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 1);
};

saddw_v4sv4sv4h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rn, idx) + DST(cpu.GetVS16(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op saddw_v8hv8hv8b( 0b00001110001[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

saddw_v8hv8hv8b.disasm = {
  sink << "saddw\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 0);
};

saddw_v8hv8hv8b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rn, idx) + DST(cpu.GetVS8(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op sha1c( 0b01011110000[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

sha1c.disasm = {
  sink << "sha1c\t" << DisasmQ(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm, 4, 2);
};

op sha1h_ss( 0b0101111000101000000010[22] : rn[5] : rd[5] );

sha1h_ss.disasm = {
  sink << "sha1h\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

op sha1m( 0b01011110000[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

sha1m.disasm = {
  sink << "sha1m\t" << DisasmQ(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm, 4, 2);
};

op sha1p( 0b01011110000[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

sha1p.disasm = {
  sink << "sha1p\t" << DisasmQ(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm, 4, 2);
};

op sha1su0_v4sv4sv4s( 0b01011110000[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

sha1su0_v4sv4sv4s.disasm = {
  sink << "sha1su0\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

op sha1su1_v4s4s( 0b0101111000101000000110[22] : rn[5] : rd[5] );

sha1su1_v4s4s.disasm = {
  sink << "sha1su1\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2);
};

op sha256h( 0b01011110000[11] : rm[5] : 0b010000[6] : rn[5] : rd[5] );

sha256h.disasm = {
  sink << "sha256h\t" << DisasmQ(rd) << ", " << DisasmQ(rn) << ", " << DisasmTV(rm, 4, 2);
};

op sha256h2( 0b01011110000[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

sha256h2.disasm = {
  sink << "sha256h2\t" << DisasmQ(rd) << ", " << DisasmQ(rn) << ", " << DisasmTV(rm, 4, 2);
};

op sha256su0_v4s4s( 0b0101111000101000001010[22] : rn[5] : rd[5] );

sha256su0_v4s4s.disasm = {
  sink << "sha256su0\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2);
};

op sha256su1_v4sv4sv4s( 0b01011110000[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

sha256su1_v4sv4sv4s.disasm = {
  sink << "sha256su1\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

/*******************************************************************
 * SHLL
 *
 * Shift Left Long (by element size)
 */

op shll_v8h( 0b0[1] : q[1] : 0b10111000100001001110[20] : rn[5] : rd[5] );

shll_v8h.disasm = {
  sink << "shll" << (q ? "2" : "") << '\t' << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8<<q, 0) << ", #8";
};

shll_v8h.execute = {
  typedef typename ARCH::U16 DST;

  unsigned const elements = 8, srcidx = elements*q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU8(rn, srcidx + idx)) << 8;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
};

op shll_v4s( 0b0[1] : q[1] : 0b10111001100001001110[20] : rn[5] : rd[5] );

shll_v4s.disasm = {
  sink << "shll" << (q ? "2" : "") << '\t' << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4<<q, 1) << ", #16";
};

shll_v4s.execute = {
  typedef typename ARCH::U32 DST;

  unsigned const elements = 4, srcidx = elements*q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rn, srcidx + idx)) << 16;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
};

op shll_v2d( 0b0[1] : q[1] : 0b10111010100001001110[20] : rn[5] : rd[5] );

shll_v2d.disasm = {
  sink << "shll" << (q ? "2" : "") << '\t' << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2<<q, 2) << ", #32";
};

shll_v2d.execute = {
  typedef typename ARCH::U64 DST;

  unsigned const elements = 2, srcidx = elements*q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rn, srcidx + idx)) << 32;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
};

/*
 * end of SHLL
 *******************************************************************/

op shrn2_v16b8hi( 0b0100111100001[13] : lro[3] : 0b100001[6] : rn[5] : rd[5] );
shrn2_v16b8hi.var shift : {unsigned} = {8 - lro};

shrn2_v16b8hi.disasm = {
  sink << "shrn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

shrn2_v16b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rn, idx) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, elements + idx, res[idx]);
    }
}

op shrn2_v4s2di( 0b01001111001[11] : lro[5] : 0b100001[6] : rn[5] : rd[5] );
shrn2_v4s2di.var shift : {unsigned} = {32 - lro};

shrn2_v4s2di.disasm = {
  sink << "shrn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

shrn2_v4s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU64(rn, idx) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, elements + idx, res[idx]);
    }
}

op shrn2_v8h4si( 0b010011110001[12] : lro[4] : 0b100001[6] : rn[5] : rd[5] );
shrn2_v8h4si.var shift : {unsigned} = {16 - lro};

shrn2_v8h4si.disasm = {
  sink << "shrn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

shrn2_v8h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rn, idx) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, elements + idx, res[idx]);
    }
}

op shrn_v2s2di( 0b00001111001[11] : lro[5] : 0b100001[6] : rn[5] : rd[5] );
shrn_v2s2di.var shift : {unsigned} = {32 - lro};

shrn_v2s2di.disasm = {
  sink << "shrn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

shrn_v2s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU64(rn, idx) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op shrn_v4h4si( 0b000011110001[12] : lro[4] : 0b100001[6] : rn[5] : rd[5] );
shrn_v4h4si.var shift : {unsigned} = {16 - lro};

shrn_v4h4si.disasm = {
  sink << "shrn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

shrn_v4h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rn, idx) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op shrn_v8b8hi( 0b0000111100001[13] : lro[3] : 0b100001[6] : rn[5] : rd[5] );
shrn_v8b8hi.var shift : {unsigned} = {8 - lro};

shrn_v8b8hi.disasm = {
  sink << "shrn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

shrn_v8b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rn, idx) >> shift);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

/*******************************************************************
 * SMAXV
 *
 * Signed maximum across vector
 */

op smaxv_bvb( 0b0[1] : q[1] : 0b00111000110000101010[20] : rn[5] : rd[5] );

smaxv_bvb.disasm = {
  sink << "smaxv\t" << DisasmB(rd) << ", " << DisasmTV(rn, 8<<q, 0);
};

smaxv_bvb.execute = {
  typedef typename ARCH::S8 S8;

  S8 res = cpu.GetVS8(rn, 0);
  for (unsigned idx = 1, end=8<<q; idx < end; ++idx)
    {
      S8 elem = cpu.GetVS8(rn, idx);
      if (cpu.Test(res < elem)) res = elem;
    }
  cpu.SetVS8(rd, res);
};

op smaxv_hvh( 0b0[1] : q[1] : 0b00111001110000101010[20] : rn[5] : rd[5] );

smaxv_hvh.disasm = {
  sink << "smaxv\t" << DisasmH(rd) << ", " << DisasmTV(rn, 4<<q, 1);
};

smaxv_hvh.execute = {
  typedef typename ARCH::S16 S16;

  S16 res = cpu.GetVS16(rn, 0);
  for (unsigned idx = 1, end=4<<q; idx < end; ++idx)
    {
      S16 elem = cpu.GetVS16(rn, idx);
      if (cpu.Test(res < elem)) res = elem;
    }
  cpu.SetVS16(rd, res);
};

op smaxv_sv4s( 0b0100111010110000101010[22] : rn[5] : rd[5] );

smaxv_sv4s.disasm = {
  sink << "smaxv\t" << DisasmS(rd) << ", " << DisasmTV(rn, 4, 2);
};

smaxv_sv4s.execute = {
  typedef typename ARCH::S32 S32;

  S32 res = cpu.GetVS32(rn, 0);
  for (unsigned idx = 1, end=2<<1; idx < end; ++idx)
    {
      S32 elem = cpu.GetVS32(rn, idx);
      if (cpu.Test(res < elem)) res = elem;
    }
  cpu.SetVS32(rd, res);
};

/*
 * end of SMAXV
 *******************************************************************/

/*******************************************************************
 * SMINV
 *
 * Signed minimum across vector
 */

op sminv_bvb( 0b0[1] : q[1] : 0b00111000110001101010[20] : rn[5] : rd[5] );

sminv_bvb.disasm = {
  sink << "sminv\t" << DisasmB(rd) << ", " << DisasmTV(rn, 8<<q, 0);
};

sminv_bvb.execute = {
  typedef typename ARCH::S8 S8;

  S8 res = cpu.GetVS8(rn, 0);
  for (unsigned idx = 1, end=8<<q; idx < end; ++idx)
    {
      S8 elem = cpu.GetVS8(rn, idx);
      if (cpu.Test(res > elem)) res = elem;
    }
  cpu.SetVS8(rd, res);
};

op sminv_hvh( 0b0[1] : q[1] : 0b00111001110001101010[20] : rn[5] : rd[5] );

sminv_hvh.disasm = {
  sink << "sminv\t" << DisasmH(rd) << ", " << DisasmTV(rn, 4<<q, 1);
};

sminv_hvh.execute = {
  typedef typename ARCH::S16 S16;

  S16 res = cpu.GetVS16(rn, 0);
  for (unsigned idx = 1, end=4<<q; idx < end; ++idx)
    {
      S16 elem = cpu.GetVS16(rn, idx);
      if (cpu.Test(res > elem)) res = elem;
    }
  cpu.SetVS16(rd, res);
};

op sminv_sv4s( 0b0100111010110001101010[22] : rn[5] : rd[5] );

sminv_sv4s.disasm = {
  sink << "sminv\t" << DisasmS(rd) << ", " << DisasmTV(rn, 4, 2);
};

sminv_sv4s.execute = {
  typedef typename ARCH::S32 S32;

  S32 res = cpu.GetVS32(rn, 0);
  for (unsigned idx = 1, end=2<<1; idx < end; ++idx)
    {
      S32 elem = cpu.GetVS32(rn, idx);
      if (cpu.Test(res > elem)) res = elem;
    }
  cpu.SetVS32(rd, res);
};

/*
 * end of SMINV
 *******************************************************************/

/*******************************************************************
 * UMAXV
 *
 * Unsigned maximum across vector
 */

op umaxv_bvb( 0b0[1] : q[1] : 0b10111000110000101010[20] : rn[5] : rd[5] );

umaxv_bvb.disasm = {
  sink << "umaxv\t" << DisasmB(rd) << ", " << DisasmTV(rn, 8<<q, 0);
};

umaxv_bvb.execute = {
  typedef typename ARCH::U8 U8;

  U8 res = cpu.GetVU8(rn, 0);
  for (unsigned idx = 1, end=8<<q; idx < end; ++idx)
    {
      U8 elem = cpu.GetVU8(rn, idx);
      if (cpu.Test(res < elem)) res = elem;
    }
  cpu.SetVU8(rd, res);
};

op umaxv_hvh( 0b0[1] : q[1] : 0b10111001110000101010[20] : rn[5] : rd[5] );

umaxv_hvh.disasm = {
  sink << "umaxv\t" << DisasmH(rd) << ", " << DisasmTV(rn, 4<<q, 1);
};

umaxv_hvh.execute = {
  typedef typename ARCH::U16 U16;

  U16 res = cpu.GetVU16(rn, 0);
  for (unsigned idx = 1, end=4<<q; idx < end; ++idx)
    {
      U16 elem = cpu.GetVU16(rn, idx);
      if (cpu.Test(res < elem)) res = elem;
    }
  cpu.SetVU16(rd, res);
};

op umaxv_sv4s( 0b0110111010110000101010[22] : rn[5] : rd[5] );

umaxv_sv4s.disasm = {
  sink << "umaxv\t" << DisasmS(rd) << ", " << DisasmTV(rn, 4, 2);
};

umaxv_sv4s.execute = {
  typedef typename ARCH::U32 U32;

  U32 res = cpu.GetVU32(rn, 0);
  for (unsigned idx = 1, end=2<<1; idx < end; ++idx)
    {
      U32 elem = cpu.GetVU32(rn, idx);
      if (cpu.Test(res < elem)) res = elem;
    }
  cpu.SetVU32(rd, res);
};

/*
 * end of UMAXV
 *******************************************************************/

/*******************************************************************
 * UMINV
 *
 * Unsigned minimum across vector
 */

op uminv_bvb( 0b0[1] : q[1] : 0b10111000110001101010[20] : rn[5] : rd[5] );

uminv_bvb.disasm = {
  sink << "uminv\t" << DisasmB(rd) << ", " << DisasmTV(rn, 8<<q, 0);
};

uminv_bvb.execute = {
  typedef typename ARCH::U8 U8;

  U8 res = cpu.GetVU8(rn, 0);
  for (unsigned idx = 1, end=8<<q; idx < end; ++idx)
    {
      U8 elem = cpu.GetVU8(rn, idx);
      if (cpu.Test(res > elem)) res = elem;
    }
  cpu.SetVU8(rd, res);
};

op uminv_hvh( 0b0[1] : q[1] : 0b10111001110001101010[20] : rn[5] : rd[5] );

uminv_hvh.disasm = {
  sink << "uminv\t" << DisasmH(rd) << ", " << DisasmTV(rn, 4<<q, 1);
};

uminv_hvh.execute = {
  typedef typename ARCH::U16 U16;

  U16 res = cpu.GetVU16(rn, 0);
  for (unsigned idx = 1, end=4<<q; idx < end; ++idx)
    {
      U16 elem = cpu.GetVU16(rn, idx);
      if (cpu.Test(res > elem)) res = elem;
    }
  cpu.SetVU16(rd, res);
};

op uminv_sv4s( 0b0110111010110001101010[22] : rn[5] : rd[5] );

uminv_sv4s.disasm = {
  sink << "uminv\t" << DisasmS(rd) << ", " << DisasmTV(rn, 4, 2);
};

uminv_sv4s.execute = {
  typedef typename ARCH::U32 U32;

  U32 res = cpu.GetVU32(rn, 0);
  for (unsigned idx = 1, end=2<<1; idx < end; ++idx)
    {
      U32 elem = cpu.GetVU32(rn, idx);
      if (cpu.Test(res > elem)) res = elem;
    }
  cpu.SetVU32(rd, res);
};

/*
 * end of UMINV
 *******************************************************************/

op smlal2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

smlal2_v2dv4sv4s.disasm = {
  sink << "smlal2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

smlal2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) + (DST(cpu.GetVS32(rn, elements + idx)) * DST(cpu.GetVS32(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smlal2_v2dv4svsi( 0b0100111110[10] : index0[1] : rm[5] : 0b0010[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
smlal2_v2dv4svsi.var index : {unsigned} = {index1|index0};

smlal2_v2dv4svsi.disasm = {
  sink << "smlal2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

smlal2_v2dv4svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) + (DST(cpu.GetVS32(rn, elements + idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smlal2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

smlal2_v4sv8hv8h.disasm = {
  sink << "smlal2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

smlal2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) + (DST(cpu.GetVS16(rn, elements + idx)) * DST(cpu.GetVS16(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smlal2_v4sv8hvhi( 0b0100111101[10] : index0[2] : rm[4] : 0b0010[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
smlal2_v4sv8hvhi.var index : {unsigned} = {index1|index0};

smlal2_v4sv8hvhi.disasm = {
  sink << "smlal2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

smlal2_v4sv8hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) + (DST(cpu.GetVS16(rn, elements + idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smlal2_v8hv16bv16b( 0b01001110001[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

smlal2_v8hv16bv16b.disasm = {
  sink << "smlal2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

smlal2_v8hv16bv16b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rd, idx) + (DST(cpu.GetVS8(rn, elements + idx)) * DST(cpu.GetVS8(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op smlal_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

smlal_v2dv2sv2s.disasm = {
  sink << "smlal\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

smlal_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) + (DST(cpu.GetVS32(rn, idx)) * DST(cpu.GetVS32(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smlal_v2dv2svsi( 0b0000111110[10] : index0[1] : rm[5] : 0b0010[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
smlal_v2dv2svsi.var index : {unsigned} = {index1|index0};

smlal_v2dv2svsi.disasm = {
  sink << "smlal\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

smlal_v2dv2svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) + (DST(cpu.GetVS32(rn, idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smlal_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

smlal_v4sv4hv4h.disasm = {
  sink << "smlal\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

smlal_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) + (DST(cpu.GetVS16(rn, idx)) * DST(cpu.GetVS16(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smlal_v4sv4hvhi( 0b0000111101[10] : index0[2] : rm[4] : 0b0010[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
smlal_v4sv4hvhi.var index : {unsigned} = {index1|index0};

smlal_v4sv4hvhi.disasm = {
  sink << "smlal\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

smlal_v4sv4hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) + (DST(cpu.GetVS16(rn, idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smlal_v8hv8bv8b( 0b00001110001[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

smlal_v8hv8bv8b.disasm = {
  sink << "smlal\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

smlal_v8hv8bv8b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rd, idx) + (DST(cpu.GetVS8(rn, idx)) * DST(cpu.GetVS8(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op smlsl2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

smlsl2_v2dv4sv4s.disasm = {
  sink << "smlsl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

smlsl2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) - (DST(cpu.GetVS32(rn, elements + idx)) * DST(cpu.GetVS32(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smlsl2_v2dv4svsi( 0b0100111110[10] : index0[1] : rm[5] : 0b0110[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
smlsl2_v2dv4svsi.var index : {unsigned} = {index1|index0};

smlsl2_v2dv4svsi.disasm = {
  sink << "smlsl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

smlsl2_v2dv4svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) - (DST(cpu.GetVS32(rn, elements + idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smlsl2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

smlsl2_v4sv8hv8h.disasm = {
  sink << "smlsl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

smlsl2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) - (DST(cpu.GetVS16(rn, elements + idx)) * DST(cpu.GetVS16(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smlsl2_v4sv8hvhi( 0b0100111101[10] : index0[2] : rm[4] : 0b0110[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
smlsl2_v4sv8hvhi.var index : {unsigned} = {index1|index0};

smlsl2_v4sv8hvhi.disasm = {
  sink << "smlsl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

smlsl2_v4sv8hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) - (DST(cpu.GetVS16(rn, elements + idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smlsl2_v8hv16bv16b( 0b01001110001[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

smlsl2_v8hv16bv16b.disasm = {
  sink << "smlsl2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

smlsl2_v8hv16bv16b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rd, idx) - (DST(cpu.GetVS8(rn, elements + idx)) * DST(cpu.GetVS8(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op smlsl_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

smlsl_v2dv2sv2s.disasm = {
  sink << "smlsl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

smlsl_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) - (DST(cpu.GetVS32(rn, idx)) * DST(cpu.GetVS32(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smlsl_v2dv2svsi( 0b0000111110[10] : index0[1] : rm[5] : 0b0110[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
smlsl_v2dv2svsi.var index : {unsigned} = {index1|index0};

smlsl_v2dv2svsi.disasm = {
  sink << "smlsl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

smlsl_v2dv2svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) - (DST(cpu.GetVS32(rn, idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smlsl_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

smlsl_v4sv4hv4h.disasm = {
  sink << "smlsl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

smlsl_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) - (DST(cpu.GetVS16(rn, idx)) * DST(cpu.GetVS16(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smlsl_v4sv4hvhi( 0b0000111101[10] : index0[2] : rm[4] : 0b0110[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
smlsl_v4sv4hvhi.var index : {unsigned} = {index1|index0};

smlsl_v4sv4hvhi.disasm = {
  sink << "smlsl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

smlsl_v4sv4hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) - (DST(cpu.GetVS16(rn, idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smlsl_v8hv8bv8b( 0b00001110001[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

smlsl_v8hv8bv8b.disasm = {
  sink << "smlsl\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

smlsl_v8hv8bv8b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rd, idx) - (DST(cpu.GetVS8(rn, idx)) * DST(cpu.GetVS8(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

/*******************************************************************
 * SMOV
 *
 * Signed move vector element to general-purpose register
 */

op smov_wvb( 0b00001110000[11] : index[4] : 0b1001011[7] : rn[5] : rd[5] );

smov_wvb.disasm = {
  sink << "smov\t" << DisasmGZWR(rd) << ", " << DisasmTV(rn, 0, 0) << DisasmSubscript(index);
};

smov_wvb.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;

  cpu.SetGZR(rd, U32(S32(cpu.GetVS8(rn, index))));
};

op smov_wvh( 0b00001110000[11] : index[3] : 0b10001011[8] : rn[5] : rd[5] );

smov_wvh.disasm = {
  sink << "smov\t" << DisasmGZWR(rd) << ", " << DisasmTV(rn, 0, 1) << DisasmSubscript(index);
};

smov_wvh.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;

  cpu.SetGZR(rd, U32(S32(cpu.GetVS16(rn, index))));
};

op smov_xvb( 0b01001110000[11] : index[4] : 0b1001011[7] : rn[5] : rd[5] );

smov_xvb.disasm = {
  sink << "smov\t" << DisasmGZXR(rd) << ", " << DisasmTV(rn, 0, 0) << DisasmSubscript(index);
};

smov_xvb.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;

  cpu.SetGZR(rd, U64(S64(cpu.GetVS8(rn, index))));
};

op smov_xvh( 0b01001110000[11] : index[3] : 0b10001011[8] : rn[5] : rd[5] );

smov_xvh.disasm = {
  sink << "smov\t" << DisasmGZXR(rd) << ", " << DisasmTV(rn, 0, 1) << DisasmSubscript(index);
};

smov_xvh.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;

  cpu.SetGZR(rd, U64(S64(cpu.GetVS16(rn, index))));
};

op smov_xvs( 0b01001110000[11] : index[2] : 0b100001011[9] : rn[5] : rd[5] );

smov_xvs.disasm = {
  sink << "smov\t" << DisasmGZXR(rd) << ", " << DisasmTV(rn, 0, 2) << DisasmSubscript(index);
};

smov_xvs.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;

  cpu.SetGZR(rd, U64(S64(cpu.GetVS32(rn, index))));
};

/*
 * end of SMOV
 *******************************************************************/

op smull2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

smull2_v2dv4sv4s.disasm = {
  sink << "smull2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

smull2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS32(rm, elements + idx)) * DST(cpu.GetVS32(rn, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smull2_v2dv4svsi( 0b0100111110[10] : index0[1] : rm[5] : 0b1010[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
smull2_v2dv4svsi.var index : {unsigned} = {index1|index0};

smull2_v2dv4svsi.disasm = {
  sink << "smull2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

smull2_v2dv4svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS32(rn, elements + idx)) * element;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smull2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

smull2_v4sv8hv8h.disasm = {
  sink << "smull2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

smull2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS16(rm, elements + idx)) * DST(cpu.GetVS16(rn, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smull2_v4sv8hvhi( 0b0100111101[10] : index0[2] : rm[4] : 0b1010[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
smull2_v4sv8hvhi.var index : {unsigned} = {index1|index0};

smull2_v4sv8hvhi.disasm = {
  sink << "smull2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

smull2_v4sv8hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS16(rn, elements + idx)) * element;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smull2_v8hv16bv16b( 0b01001110001[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

smull2_v8hv16bv16b.disasm = {
  sink << "smull2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

smull2_v8hv16bv16b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS8(rm, elements + idx)) * DST(cpu.GetVS8(rn, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op smull_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

smull_v2dv2sv2s.disasm = {
  sink << "smull\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

smull_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS32(rm, idx)) * DST(cpu.GetVS32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smull_v2dv2svsi( 0b0000111110[10] : index0[1] : rm[5] : 0b1010[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
smull_v2dv2svsi.var index : {unsigned} = {index1|index0};

smull_v2dv2svsi.disasm = {
  sink << "smull\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

smull_v2dv2svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS32(rn, idx)) * element;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op smull_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

smull_v4sv4hv4h.disasm = {
  sink << "smull\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

smull_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS16(rm, idx)) * DST(cpu.GetVS16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smull_v4sv4hvhi( 0b0000111101[10] : index0[2] : rm[4] : 0b1010[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
smull_v4sv4hvhi.var index : {unsigned} = {index1|index0};

smull_v4sv4hvhi.disasm = {
  sink << "smull\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

smull_v4sv4hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS16(rn, idx)) * element;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op smull_v8hv8bv8b( 0b00001110001[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

smull_v8hv8bv8b.disasm = {
  sink << "smull\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

smull_v8hv8bv8b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS8(rm, idx)) * DST(cpu.GetVS8(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op sqabs_bb( 0b0101111000100000011110[22] : rn[5] : rd[5] );

sqabs_bb.disasm = {
  sink << "sqabs\t" << DisasmB(rd) << ", " << DisasmB(rn);
};

sqabs_bb.execute = {
  cpu.SetVS8(rd, Abs(cpu, cpu.GetVS8(rn, 0), /* sat */ true));
}

op sqabs_dd( 0b0101111011100000011110[22] : rn[5] : rd[5] );

sqabs_dd.disasm = {
  sink << "sqabs\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

sqabs_dd.execute = {
  cpu.SetVS64(rd, Abs(cpu, cpu.GetVS64(rn, 0), /* sat */ true));
}

op sqabs_hh( 0b0101111001100000011110[22] : rn[5] : rd[5] );

sqabs_hh.disasm = {
  sink << "sqabs\t" << DisasmH(rd) << ", " << DisasmH(rn);
};

sqabs_hh.execute = {
  cpu.SetVS16(rd, Abs(cpu, cpu.GetVS16(rn, 0), /* sat */ true));
}

op sqabs_ss( 0b0101111010100000011110[22] : rn[5] : rd[5] );

sqabs_ss.disasm = {
  sink << "sqabs\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

sqabs_ss.execute = {
  cpu.SetVS32(rd, Abs(cpu, cpu.GetVS32(rn, 0), /* sat */ true));
}

op sqabs_v2d2d( 0b0100111011100000011110[22] : rn[5] : rd[5] );

sqabs_v2d2d.disasm = {
  sink << "sqabs\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3);
};

sqabs_v2d2d.execute = {
  unsigned const elements = 2;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS64(rd, e, Abs(cpu, cpu.GetVS64(rn, e), /* sat */ true));
    }
}

op sqadd_bbb( 0b01011110001[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

sqadd_bbb.disasm = {
  sink << "sqadd\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmB(rm);
};

sqadd_bbb.execute = {
  cpu.SetVS8(rd, SatAdd(cpu, cpu.GetVS8(rn, 0), cpu.GetVS8(rm, 0)));
}

op sqadd_ddd( 0b01011110111[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

sqadd_ddd.disasm = {
  sink << "sqadd\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

sqadd_ddd.execute = {
  cpu.SetVS64(rd, SatAdd(cpu, cpu.GetVS64(rn, 0), cpu.GetVS64(rm, 0)));
}

op sqadd_hhh( 0b01011110011[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

sqadd_hhh.disasm = {
  sink << "sqadd\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

sqadd_hhh.execute = {
  cpu.SetVS16(rd, SatAdd(cpu, cpu.GetVS16(rn, 0), cpu.GetVS16(rm, 0)));
}

op sqadd_sss( 0b01011110101[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

sqadd_sss.disasm = {
  sink << "sqadd\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

sqadd_sss.execute = {
  cpu.SetVS32(rd, SatAdd(cpu, cpu.GetVS32(rn, 0), cpu.GetVS32(rm, 0)));
}

op sqadd_v2dv2dv2d( 0b01001110111[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

sqadd_v2dv2dv2d.disasm = {
  sink << "sqadd\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

sqadd_v2dv2dv2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVS64(rd, idx, SatAdd(cpu, cpu.GetVS64(rn, idx), cpu.GetVS64(rm, idx)));
    }
};

op sqdmlal2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b100100[6] : rn[5] : rd[5] );

sqdmlal2_v2dv4sv4s.disasm = {
  sink << "sqdmlal2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

sqdmlal2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatAdd(cpu, cpu.GetVS64(rd, idx), NeonSHL(cpu, DST(cpu.GetVS32(rn, elements + idx)) * DST(cpu.GetVS32(rm, elements + idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmlal2_v2dv4svsi( 0b0100111110[10] : index0[1] : rm[5] : 0b0011[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlal2_v2dv4svsi.var index : {unsigned} = {index1|index0};

sqdmlal2_v2dv4svsi.disasm = {
  sink << "sqdmlal2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmlal2_v2dv4svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatAdd(cpu, cpu.GetVS64(rd, idx), NeonSHL(cpu, DST(cpu.GetVS32(rn, elements + idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmlal2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b100100[6] : rn[5] : rd[5] );

sqdmlal2_v4sv8hv8h.disasm = {
  sink << "sqdmlal2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

sqdmlal2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatAdd(cpu, cpu.GetVS32(rd, idx), NeonSHL(cpu, DST(cpu.GetVS16(rn, elements + idx)) * DST(cpu.GetVS16(rm, elements + idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmlal2_v4sv8hvhi( 0b0100111101[10] : index0[2] : rm[4] : 0b0011[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlal2_v4sv8hvhi.var index : {unsigned} = {index1|index0};

sqdmlal2_v4sv8hvhi.disasm = {
  sink << "sqdmlal2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmlal2_v4sv8hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatAdd(cpu, cpu.GetVS32(rd, idx), NeonSHL(cpu, DST(cpu.GetVS16(rn, elements + idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmlal_dss( 0b01011110101[11] : rm[5] : 0b100100[6] : rn[5] : rd[5] );

sqdmlal_dss.disasm = {
  sink << "sqdmlal\t" << DisasmD(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

sqdmlal_dss.execute = {
  typedef typename ARCH::S64 S64;
  cpu.SetVS64(rd, SatAdd(cpu, cpu.GetVS64(rd, 0), NeonSHL(cpu, S64(cpu.GetVS32(rn, 0)) * S64(cpu.GetVS32(rm, 0)), typename ARCH::S8(1), /* round */ false, /* sat */ true)));
}

op sqdmlal_dsvsi( 0b0101111110[10] : index0[1] : rm[5] : 0b0011[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlal_dsvsi.var index : {unsigned} = {index1|index0};

sqdmlal_dsvsi.disasm = {
  sink << "sqdmlal\t" << DisasmD(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmlal_dsvsi.execute = {
  typedef typename ARCH::S64 S64;
  cpu.SetVS64(rd, SatAdd(cpu, cpu.GetVS64(rd, 0), NeonSHL(cpu, S64(cpu.GetVS32(rn, 0)) * S64(cpu.GetVS32(rm, index)), typename ARCH::S8(1), /* round */ false, /* sat */ true)));
}

op sqdmlal_shh( 0b01011110011[11] : rm[5] : 0b100100[6] : rn[5] : rd[5] );

sqdmlal_shh.disasm = {
  sink << "sqdmlal\t" << DisasmS(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

sqdmlal_shh.execute = {
  typedef typename ARCH::S32 S32;
  cpu.SetVS32(rd, SatAdd(cpu, cpu.GetVS32(rd, 0), NeonSHL(cpu, S32(cpu.GetVS16(rn, 0)) * S32(cpu.GetVS16(rm, 0)), typename ARCH::S8(1), /* round */ false, /* sat */ true)));
}

op sqdmlal_shvhi( 0b0101111101[10] : index0[2] : rm[4] : 0b0011[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlal_shvhi.var index : {unsigned} = {index1|index0};

sqdmlal_shvhi.disasm = {
  sink << "sqdmlal\t" << DisasmS(rd) << ", " << DisasmH(rn) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmlal_shvhi.execute = {
  typedef typename ARCH::S32 S32;
  cpu.SetVS32(rd, SatAdd(cpu, cpu.GetVS32(rd, 0), NeonSHL(cpu, S32(cpu.GetVS16(rn, 0)) * S32(cpu.GetVS16(rm, index)), typename ARCH::S8(1), /* round */ false, /* sat */ true)));
}

op sqdmlal_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b100100[6] : rn[5] : rd[5] );

sqdmlal_v2dv2sv2s.disasm = {
  sink << "sqdmlal\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

sqdmlal_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatAdd(cpu, cpu.GetVS64(rd, idx), NeonSHL(cpu, DST(cpu.GetVS32(rn, idx)) * DST(cpu.GetVS32(rm, idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmlal_v2dv2svsi( 0b0000111110[10] : index0[1] : rm[5] : 0b0011[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlal_v2dv2svsi.var index : {unsigned} = {index1|index0};

sqdmlal_v2dv2svsi.disasm = {
  sink << "sqdmlal\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmlal_v2dv2svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatAdd(cpu, cpu.GetVS64(rd, idx), NeonSHL(cpu, DST(cpu.GetVS32(rn, idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmlal_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b100100[6] : rn[5] : rd[5] );

sqdmlal_v4sv4hv4h.disasm = {
  sink << "sqdmlal\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

sqdmlal_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatAdd(cpu, cpu.GetVS32(rd, idx), NeonSHL(cpu, DST(cpu.GetVS16(rn, idx)) * DST(cpu.GetVS16(rm, idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmlal_v4sv4hvhi( 0b0000111101[10] : index0[2] : rm[4] : 0b0011[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlal_v4sv4hvhi.var index : {unsigned} = {index1|index0};

sqdmlal_v4sv4hvhi.disasm = {
  sink << "sqdmlal\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmlal_v4sv4hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatAdd(cpu, cpu.GetVS32(rd, idx), NeonSHL(cpu, DST(cpu.GetVS16(rn, idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmlsl2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b101100[6] : rn[5] : rd[5] );

sqdmlsl2_v2dv4sv4s.disasm = {
  sink << "sqdmlsl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

sqdmlsl2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatSub(cpu, cpu.GetVS64(rd, idx), NeonSHL(cpu, DST(cpu.GetVS32(rn, elements + idx)) * DST(cpu.GetVS32(rm, elements + idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmlsl2_v2dv4svsi( 0b0100111110[10] : index0[1] : rm[5] : 0b0111[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlsl2_v2dv4svsi.var index : {unsigned} = {index1|index0};

sqdmlsl2_v2dv4svsi.disasm = {
  sink << "sqdmlsl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmlsl2_v2dv4svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatSub(cpu, cpu.GetVS64(rd, idx), NeonSHL(cpu, DST(cpu.GetVS32(rn, elements + idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmlsl2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b101100[6] : rn[5] : rd[5] );

sqdmlsl2_v4sv8hv8h.disasm = {
  sink << "sqdmlsl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

sqdmlsl2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatSub(cpu, cpu.GetVS32(rd, idx), NeonSHL(cpu, DST(cpu.GetVS16(rn, elements + idx)) * DST(cpu.GetVS16(rm, elements + idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmlsl2_v4sv8hvhi( 0b0100111101[10] : index0[2] : rm[4] : 0b0111[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlsl2_v4sv8hvhi.var index : {unsigned} = {index1|index0};

sqdmlsl2_v4sv8hvhi.disasm = {
  sink << "sqdmlsl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmlsl2_v4sv8hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatSub(cpu, cpu.GetVS32(rd, idx), NeonSHL(cpu, DST(cpu.GetVS16(rn, elements + idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmlsl_dss( 0b01011110101[11] : rm[5] : 0b101100[6] : rn[5] : rd[5] );

sqdmlsl_dss.disasm = {
  sink << "sqdmlsl\t" << DisasmD(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

sqdmlsl_dss.execute = {
  typedef typename ARCH::S64 S64;
  cpu.SetVS64(rd, SatSub(cpu, cpu.GetVS64(rd, 0), NeonSHL(cpu, S64(cpu.GetVS32(rn, 0)) * S64(cpu.GetVS32(rm, 0)), typename ARCH::S8(1), /* round */ false, /* sat */ true)));
}

op sqdmlsl_dsvsi( 0b0101111110[10] : index0[1] : rm[5] : 0b0111[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlsl_dsvsi.var index : {unsigned} = {index1|index0};

sqdmlsl_dsvsi.disasm = {
  sink << "sqdmlsl\t" << DisasmD(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmlsl_dsvsi.execute = {
  typedef typename ARCH::S64 S64;
  cpu.SetVS64(rd, SatSub(cpu, cpu.GetVS64(rd, 0), NeonSHL(cpu, S64(cpu.GetVS32(rn, 0)) * S64(cpu.GetVS32(rm, index)), typename ARCH::S8(1), /* round */ false, /* sat */ true)));
}

op sqdmlsl_shh( 0b01011110011[11] : rm[5] : 0b101100[6] : rn[5] : rd[5] );

sqdmlsl_shh.disasm = {
  sink << "sqdmlsl\t" << DisasmS(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

sqdmlsl_shh.execute = {
  typedef typename ARCH::S32 S32;
  cpu.SetVS32(rd, SatSub(cpu, cpu.GetVS32(rd, 0), NeonSHL(cpu, S32(cpu.GetVS16(rn, 0)) * S32(cpu.GetVS16(rm, 0)), typename ARCH::S8(1), /* round */ false, /* sat */ true)));
}

op sqdmlsl_shvhi( 0b0101111101[10] : index0[2] : rm[4] : 0b0111[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlsl_shvhi.var index : {unsigned} = {index1|index0};

sqdmlsl_shvhi.disasm = {
  sink << "sqdmlsl\t" << DisasmS(rd) << ", " << DisasmH(rn) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmlsl_shvhi.execute = {
  typedef typename ARCH::S32 S32;
  cpu.SetVS32(rd, SatSub(cpu, cpu.GetVS32(rd, 0), NeonSHL(cpu, S32(cpu.GetVS16(rn, 0)) * S32(cpu.GetVS16(rm, index)), typename ARCH::S8(1), /* round */ false, /* sat */ true)));
}

op sqdmlsl_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b101100[6] : rn[5] : rd[5] );

sqdmlsl_v2dv2sv2s.disasm = {
  sink << "sqdmlsl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

sqdmlsl_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatSub(cpu, cpu.GetVS64(rd, idx), NeonSHL(cpu, DST(cpu.GetVS32(rn, idx)) * DST(cpu.GetVS32(rm, idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmlsl_v2dv2svsi( 0b0000111110[10] : index0[1] : rm[5] : 0b0111[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlsl_v2dv2svsi.var index : {unsigned} = {index1|index0};

sqdmlsl_v2dv2svsi.disasm = {
  sink << "sqdmlsl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmlsl_v2dv2svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatSub(cpu, cpu.GetVS64(rd, idx), NeonSHL(cpu, DST(cpu.GetVS32(rn, idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmlsl_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b101100[6] : rn[5] : rd[5] );

sqdmlsl_v4sv4hv4h.disasm = {
  sink << "sqdmlsl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

sqdmlsl_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatSub(cpu, cpu.GetVS32(rd, idx), NeonSHL(cpu, DST(cpu.GetVS16(rn, idx)) * DST(cpu.GetVS16(rm, idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmlsl_v4sv4hvhi( 0b0000111101[10] : index0[2] : rm[4] : 0b0111[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmlsl_v4sv4hvhi.var index : {unsigned} = {index1|index0};

sqdmlsl_v4sv4hvhi.disasm = {
  sink << "sqdmlsl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmlsl_v4sv4hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatSub(cpu, cpu.GetVS32(rd, idx), NeonSHL(cpu, DST(cpu.GetVS16(rn, idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmulh_hhh( 0b01011110011[11] : rm[5] : 0b101101[6] : rn[5] : rd[5] );

sqdmulh_hhh.disasm = {
  sink << "sqdmulh\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

sqdmulh_hhh.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  cpu.SetVS16(rd, SatNarrow<S16>(cpu, NeonSHL(cpu, S32(cpu.GetVS16(rm, 0)) * S32(cpu.GetVS16(rn, 0)), typename ARCH::S8(-15), /* round */ false, /* sat */ false)));
}

op sqdmulh_hhvhi( 0b0101111101[10] : index0[2] : rm[4] : 0b1100[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmulh_hhvhi.var index : {unsigned} = {index1|index0};

sqdmulh_hhvhi.disasm = {
  sink << "sqdmulh\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmulh_hhvhi.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S16 S16;
  cpu.SetVS16(rd, SatNarrow<S16>(cpu, NeonSHL(cpu, S32(cpu.GetVS16(rn, 0)) * S32(cpu.GetVS16(rm, index)), typename ARCH::S8(-15), /* round */ false, /* sat */ false)));
}

op sqdmulh_sss( 0b01011110101[11] : rm[5] : 0b101101[6] : rn[5] : rd[5] );

sqdmulh_sss.disasm = {
  sink << "sqdmulh\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

sqdmulh_sss.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  cpu.SetVS32(rd, SatNarrow<S32>(cpu, NeonSHL(cpu, S64(cpu.GetVS32(rm, 0)) * S64(cpu.GetVS32(rn, 0)), typename ARCH::S8(-31), /* round */ false, /* sat */ false)));
}

op sqdmulh_ssvsi( 0b0101111110[10] : index0[1] : rm[5] : 0b1100[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmulh_ssvsi.var index : {unsigned} = {index1|index0};

sqdmulh_ssvsi.disasm = {
  sink << "sqdmulh\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmulh_ssvsi.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S32 S32;
  cpu.SetVS32(rd, SatNarrow<S32>(cpu, NeonSHL(cpu, S64(cpu.GetVS32(rn, 0)) * S64(cpu.GetVS32(rm, index)), typename ARCH::S8(-31), /* round */ false, /* sat */ false)));
}

op sqdmull2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b110100[6] : rn[5] : rd[5] );

sqdmull2_v2dv4sv4s.disasm = {
  sink << "sqdmull2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

sqdmull2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = NeonSHL(cpu, DST(cpu.GetVS32(rm, elements + idx)) * DST(cpu.GetVS32(rn, elements + idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmull2_v2dv4svsi( 0b0100111110[10] : index0[1] : rm[5] : 0b1011[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmull2_v2dv4svsi.var index : {unsigned} = {index1|index0};

sqdmull2_v2dv4svsi.disasm = {
  sink << "sqdmull2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmull2_v2dv4svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = NeonSHL(cpu, DST(cpu.GetVS32(rn, elements + idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmull2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b110100[6] : rn[5] : rd[5] );

sqdmull2_v4sv8hv8h.disasm = {
  sink << "sqdmull2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

sqdmull2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = NeonSHL(cpu, DST(cpu.GetVS16(rm, elements + idx)) * DST(cpu.GetVS16(rn, elements + idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmull2_v4sv8hvhi( 0b0100111101[10] : index0[2] : rm[4] : 0b1011[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmull2_v4sv8hvhi.var index : {unsigned} = {index1|index0};

sqdmull2_v4sv8hvhi.disasm = {
  sink << "sqdmull2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmull2_v4sv8hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = NeonSHL(cpu, DST(cpu.GetVS16(rn, elements + idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmull_dss( 0b01011110101[11] : rm[5] : 0b110100[6] : rn[5] : rd[5] );

sqdmull_dss.disasm = {
  sink << "sqdmull\t" << DisasmD(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

sqdmull_dss.execute = {
  typedef typename ARCH::S64 S64;
  cpu.SetVS64(rd, NeonSHL(cpu, S64(cpu.GetVS32(rn, 0)) * S64(cpu.GetVS32(rm, 0)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
}

op sqdmull_dsvsi( 0b0101111110[10] : index0[1] : rm[5] : 0b1011[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmull_dsvsi.var index : {unsigned} = {index1|index0};

sqdmull_dsvsi.disasm = {
  sink << "sqdmull\t" << DisasmD(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmull_dsvsi.execute = {
  typedef typename ARCH::S64 S64;
  cpu.SetVS64(rd, NeonSHL(cpu, S64(cpu.GetVS32(rn, 0)) * S64(cpu.GetVS32(rm, index)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
}

op sqdmull_shh( 0b01011110011[11] : rm[5] : 0b110100[6] : rn[5] : rd[5] );

sqdmull_shh.disasm = {
  sink << "sqdmull\t" << DisasmS(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

sqdmull_shh.execute = {
  typedef typename ARCH::S32 S32;
  cpu.SetVS32(rd, NeonSHL(cpu, S32(cpu.GetVS16(rn, 0)) * S32(cpu.GetVS16(rm, 0)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
}

op sqdmull_shvhi( 0b0101111101[10] : index0[2] : rm[4] : 0b1011[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmull_shvhi.var index : {unsigned} = {index1|index0};

sqdmull_shvhi.disasm = {
  sink << "sqdmull\t" << DisasmS(rd) << ", " << DisasmH(rn) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmull_shvhi.execute = {
  typedef typename ARCH::S32 S32;
  cpu.SetVS32(rd, NeonSHL(cpu, S32(cpu.GetVS16(rn, 0)) * S32(cpu.GetVS16(rm, index)), typename ARCH::S8(1), /* round */ false, /* sat */ true));
}

op sqdmull_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b110100[6] : rn[5] : rd[5] );

sqdmull_v2dv2sv2s.disasm = {
  sink << "sqdmull\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

sqdmull_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = NeonSHL(cpu, DST(cpu.GetVS32(rm, idx)) * DST(cpu.GetVS32(rn, idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmull_v2dv2svsi( 0b0000111110[10] : index0[1] : rm[5] : 0b1011[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmull_v2dv2svsi.var index : {unsigned} = {index1|index0};

sqdmull_v2dv2svsi.disasm = {
  sink << "sqdmull\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmull_v2dv2svsi.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = NeonSHL(cpu, DST(cpu.GetVS32(rn, idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op sqdmull_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b110100[6] : rn[5] : rd[5] );

sqdmull_v4sv4hv4h.disasm = {
  sink << "sqdmull\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

sqdmull_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = NeonSHL(cpu, DST(cpu.GetVS16(rm, idx)) * DST(cpu.GetVS16(rn, idx)), typename ARCH::S8(1), /* round */ false, /* sat */ true);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqdmull_v4sv4hvhi( 0b0000111101[10] : index0[2] : rm[4] : 0b1011[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmull_v4sv4hvhi.var index : {unsigned} = {index1|index0};

sqdmull_v4sv4hvhi.disasm = {
  sink << "sqdmull\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmull_v4sv4hvhi.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = NeonSHL(cpu, DST(cpu.GetVS16(rn, idx)) * element, typename ARCH::S8(1), /* round */ false, /* sat */ true);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op sqneg_bb( 0b0111111000100000011110[22] : rn[5] : rd[5] );

sqneg_bb.disasm = {
  sink << "sqneg\t" << DisasmB(rd) << ", " << DisasmB(rn);
};

sqneg_bb.execute = {
  cpu.SetVS8(rd, Neg(cpu, cpu.GetVS8(rn, 0), /* sat */ true));
};

op sqneg_dd( 0b0111111011100000011110[22] : rn[5] : rd[5] );

sqneg_dd.disasm = {
  sink << "sqneg\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

sqneg_dd.execute = {
  cpu.SetVS64(rd, Neg(cpu, cpu.GetVS64(rn, 0), /* sat */ true));
};

op sqneg_hh( 0b0111111001100000011110[22] : rn[5] : rd[5] );

sqneg_hh.disasm = {
  sink << "sqneg\t" << DisasmH(rd) << ", " << DisasmH(rn);
};

sqneg_hh.execute = {
  cpu.SetVS16(rd, Neg(cpu, cpu.GetVS16(rn, 0), /* sat */ true));
};

op sqneg_ss( 0b0111111010100000011110[22] : rn[5] : rd[5] );

sqneg_ss.disasm = {
  sink << "sqneg\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

sqneg_ss.execute = {
  cpu.SetVS32(rd, Neg(cpu, cpu.GetVS32(rn, 0), /* sat */ true));
};

op sqneg_v2dv2d( 0b0110111011100000011110[22] : rn[5] : rd[5] );

sqneg_v2dv2d.disasm = {
  sink << "sqneg\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3);
};

sqneg_v2dv2d.execute = {
  unsigned const elements = 2;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS64(rd, e, Neg(cpu, cpu.GetVS64(rn, e), /* sat */ true));
    }
};

op sqrdmulh_hhh( 0b01111110011[11] : rm[5] : 0b101101[6] : rn[5] : rd[5] );

sqrdmulh_hhh.disasm = {
  sink << "sqrdmulh\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

sqrdmulh_hhh.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  cpu.SetVS16(rd, SatNarrow<S16>(cpu, NeonSHL(cpu, S32(cpu.GetVS16(rm, 0)) * S32(cpu.GetVS16(rn, 0)), typename ARCH::S8(-15), /* round */ true, /* sat */ false)));
}

op sqrdmulh_hhvhi( 0b0101111101[10] : index0[2] : rm[4] : 0b1101[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqrdmulh_hhvhi.var index : {unsigned} = {index1|index0};

sqrdmulh_hhvhi.disasm = {
  sink << "sqrdmulh\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqrdmulh_hhvhi.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S16 S16;
  cpu.SetVS16(rd, SatNarrow<S16>(cpu, NeonSHL(cpu, S32(cpu.GetVS16(rn, 0)) * S32(cpu.GetVS16(rm, index)), typename ARCH::S8(-15), /* round */ true, /* sat */ false)));
}

op sqrdmulh_sss( 0b01111110101[11] : rm[5] : 0b101101[6] : rn[5] : rd[5] );

sqrdmulh_sss.disasm = {
  sink << "sqrdmulh\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

sqrdmulh_sss.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  cpu.SetVS32(rd, SatNarrow<S32>(cpu, NeonSHL(cpu, S64(cpu.GetVS32(rm, 0)) * S64(cpu.GetVS32(rn, 0)), typename ARCH::S8(-31), /* round */ true, /* sat */ false)));
}

op sqrdmulh_ssvsi( 0b0101111110[10] : index0[1] : rm[5] : 0b1101[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqrdmulh_ssvsi.var index : {unsigned} = {index1|index0};

sqrdmulh_ssvsi.disasm = {
  sink << "sqrdmulh\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqrdmulh_ssvsi.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S32 S32;
  cpu.SetVS32(rd, SatNarrow<S32>(cpu, NeonSHL(cpu, S64(cpu.GetVS32(rn, 0)) * S64(cpu.GetVS32(rm, index)), typename ARCH::S8(-31), /* round */ true, /* sat */ false)));
}

op sqrshl_bbb( 0b01011110001[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

sqrshl_bbb.disasm = {
  sink << "sqrshl\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmB(rm);
};

sqrshl_bbb.execute = {
  typedef typename ARCH::S8 S8;
  cpu.SetVS8(rd, NeonSHL(cpu, cpu.GetVS8(rn, 0), S8(cpu.GetVS8(rm, 0)), /* round */ true, /* sat */ true));
}

op sqrshl_ddd( 0b01011110111[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

sqrshl_ddd.disasm = {
  sink << "sqrshl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

sqrshl_ddd.execute = {
  typedef typename ARCH::S8 S8;
  cpu.SetVS64(rd, NeonSHL(cpu, cpu.GetVS64(rn, 0), S8(cpu.GetVS64(rm, 0)), /* round */ true, /* sat */ true));
}

op sqrshl_hhh( 0b01011110011[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

sqrshl_hhh.disasm = {
  sink << "sqrshl\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

sqrshl_hhh.execute = {
  typedef typename ARCH::S8 S8;
  cpu.SetVS16(rd, NeonSHL(cpu, cpu.GetVS16(rn, 0), S8(cpu.GetVS8(rm, 0)), /* round */ true, /* sat */ true));
}

op sqrshl_sss( 0b01011110101[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

sqrshl_sss.disasm = {
  sink << "sqrshl\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

sqrshl_sss.execute = {
  typedef typename ARCH::S8 S8;
  cpu.SetVS32(rd, NeonSHL(cpu, cpu.GetVS32(rn, 0), S8(cpu.GetVS8(rm, 0)), /* round */ true, /* sat */ true));
}

op sqrshl_v2dv2dv2d( 0b01001110111[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

sqrshl_v2dv2dv2d.disasm = {
  sink << "sqrshl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

sqrshl_v2dv2dv2d.execute = {
  typedef typename ARCH::S8 S8;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVS64(rd, idx, NeonSHL(cpu, cpu.GetVS64(rn, idx), S8(cpu.GetVS64(rm, idx)), /* round */ true, /* sat */ true));
    }
}

op sqrshrn2_v16b8hi( 0b0100111100001[13] : lro[3] : 0b100111[6] : rn[5] : rd[5] );
sqrshrn2_v16b8hi.var shift : {unsigned} = {8 - lro};

sqrshrn2_v16b8hi.disasm = {
  sink << "sqrshrn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

sqrshrn2_v16b8hi.execute = {
  typedef typename ARCH::S8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS8(rd, elements + idx, res[idx]);
    }
}

op sqrshrn2_v4s2di( 0b01001111001[11] : lro[5] : 0b100111[6] : rn[5] : rd[5] );
sqrshrn2_v4s2di.var shift : {unsigned} = {32 - lro};

sqrshrn2_v4s2di.disasm = {
  sink << "sqrshrn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sqrshrn2_v4s2di.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, elements + idx, res[idx]);
    }
}

op sqrshrn2_v8h4si( 0b010011110001[12] : lro[4] : 0b100111[6] : rn[5] : rd[5] );
sqrshrn2_v8h4si.var shift : {unsigned} = {16 - lro};

sqrshrn2_v8h4si.disasm = {
  sink << "sqrshrn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

sqrshrn2_v8h4si.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, elements + idx, res[idx]);
    }
}

op sqrshrn_bhi( 0b0101111100001[13] : lro[3] : 0b100111[6] : rn[5] : rd[5] );
sqrshrn_bhi.var shift : {unsigned} = {8 - lro};

sqrshrn_bhi.disasm = {
  sink << "sqrshrn\t" << DisasmB(rd) << ", " << DisasmH(rn) << ", " << DisasmI(shift);
};

sqrshrn_bhi.execute = {
  cpu.SetVS8(rd, SatNarrow<typename ARCH::S8>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ true)));
}

op sqrshrn_hsi( 0b010111110001[12] : lro[4] : 0b100111[6] : rn[5] : rd[5] );
sqrshrn_hsi.var shift : {unsigned} = {16 - lro};

sqrshrn_hsi.disasm = {
  sink << "sqrshrn\t" << DisasmH(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

sqrshrn_hsi.execute = {
  cpu.SetVS16(rd, SatNarrow<typename ARCH::S16>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ true)));
}

op sqrshrn_sdi( 0b01011111001[11] : lro[5] : 0b100111[6] : rn[5] : rd[5] );
sqrshrn_sdi.var shift : {unsigned} = {32 - lro};

sqrshrn_sdi.disasm = {
  sink << "sqrshrn\t" << DisasmS(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

sqrshrn_sdi.execute = {
  cpu.SetVS32(rd, SatNarrow<typename ARCH::S32>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ true)));
}

op sqrshrn_v2s2di( 0b00001111001[11] : lro[5] : 0b100111[6] : rn[5] : rd[5] );
sqrshrn_v2s2di.var shift : {unsigned} = {32 - lro};

sqrshrn_v2s2di.disasm = {
  sink << "sqrshrn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sqrshrn_v2s2di.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqrshrn_v4h4si( 0b000011110001[12] : lro[4] : 0b100111[6] : rn[5] : rd[5] );
sqrshrn_v4h4si.var shift : {unsigned} = {16 - lro};

sqrshrn_v4h4si.disasm = {
  sink << "sqrshrn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

sqrshrn_v4h4si.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqrshrn_v8b8hi( 0b0000111100001[13] : lro[3] : 0b100111[6] : rn[5] : rd[5] );
sqrshrn_v8b8hi.var shift : {unsigned} = {8 - lro};

sqrshrn_v8b8hi.disasm = {
  sink << "sqrshrn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

sqrshrn_v8b8hi.execute = {
  typedef typename ARCH::S8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqrshrun2_v16b8hi( 0b0110111100001[13] : lro[3] : 0b100011[6] : rn[5] : rd[5] );
sqrshrun2_v16b8hi.var shift : {unsigned} = {8 - lro};

sqrshrun2_v16b8hi.disasm = {
  sink << "sqrshrun2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

sqrshrun2_v16b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, elements + idx, res[idx]);
    }
}

op sqrshrun2_v4s2di( 0b01101111001[11] : lro[5] : 0b100011[6] : rn[5] : rd[5] );
sqrshrun2_v4s2di.var shift : {unsigned} = {32 - lro};

sqrshrun2_v4s2di.disasm = {
  sink << "sqrshrun2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sqrshrun2_v4s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, elements + idx, res[idx]);
    }
}

op sqrshrun2_v8h4si( 0b011011110001[12] : lro[4] : 0b100011[6] : rn[5] : rd[5] );
sqrshrun2_v8h4si.var shift : {unsigned} = {16 - lro};

sqrshrun2_v8h4si.disasm = {
  sink << "sqrshrun2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

sqrshrun2_v8h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, elements + idx, res[idx]);
    }
}

op sqrshrun_bhi( 0b0111111100001[13] : lro[3] : 0b100011[6] : rn[5] : rd[5] );
sqrshrun_bhi.var shift : {unsigned} = {8 - lro};

sqrshrun_bhi.disasm = {
  sink << "sqrshrun\t" << DisasmB(rd) << ", " << DisasmH(rn) << ", " << DisasmI(shift);
};

sqrshrun_bhi.execute = {
  cpu.SetVU8(rd, SatNarrow<typename ARCH::U8>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ true)));
}

op sqrshrun_hsi( 0b011111110001[12] : lro[4] : 0b100011[6] : rn[5] : rd[5] );
sqrshrun_hsi.var shift : {unsigned} = {16 - lro};

sqrshrun_hsi.disasm = {
  sink << "sqrshrun\t" << DisasmH(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

sqrshrun_hsi.execute = {
  cpu.SetVU16(rd, SatNarrow<typename ARCH::U16>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ true)));
}

op sqrshrun_sdi( 0b01111111001[11] : lro[5] : 0b100011[6] : rn[5] : rd[5] );
sqrshrun_sdi.var shift : {unsigned} = {32 - lro};

sqrshrun_sdi.disasm = {
  sink << "sqrshrun\t" << DisasmS(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

sqrshrun_sdi.execute = {
  cpu.SetVU32(rd, SatNarrow<typename ARCH::U32>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ true)));
}

op sqrshrun_v2s2di( 0b00101111001[11] : lro[5] : 0b100011[6] : rn[5] : rd[5] );
sqrshrun_v2s2di.var shift : {unsigned} = {32 - lro};

sqrshrun_v2s2di.disasm = {
  sink << "sqrshrun\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sqrshrun_v2s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqrshrun_v4h4si( 0b001011110001[12] : lro[4] : 0b100011[6] : rn[5] : rd[5] );
sqrshrun_v4h4si.var shift : {unsigned} = {16 - lro};

sqrshrun_v4h4si.disasm = {
  sink << "sqrshrun\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

sqrshrun_v4h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqrshrun_v8b8hi( 0b0010111100001[13] : lro[3] : 0b100011[6] : rn[5] : rd[5] );
sqrshrun_v8b8hi.var shift : {unsigned} = {8 - lro};

sqrshrun_v8b8hi.disasm = {
  sink << "sqrshrun\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

sqrshrun_v8b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqshl_bbb( 0b01011110001[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

sqshl_bbb.disasm = {
  sink << "sqshl\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmB(rm);
};

sqshl_bbb.execute = {
  cpu.SetVS8(rd, NeonSHL(cpu, cpu.GetVS8(rn, 0), typename ARCH::S8(cpu.GetVU8(rm, 0)), /* round */ false, /* sat */ true));
}

op sqshl_bbi( 0b0101111100001[13] : shift[3] : 0b011101[6] : rn[5] : rd[5] );

sqshl_bbi.disasm = {
  sink << "sqshl\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmI(shift);
};

sqshl_bbi.execute = {
  cpu.SetVS8(rd, NeonSHL(cpu, cpu.GetVS8(rn, 0), typename ARCH::S8(shift), /* round */ false, /* sat */ true));
}

op sqshl_ddd( 0b01011110111[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

sqshl_ddd.disasm = {
  sink << "sqshl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

sqshl_ddd.execute = {
  cpu.SetVS64(rd, NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(cpu.GetVU8(rm, 0)), /* round */ false, /* sat */ true));
}

op sqshl_ddi( 0b0101111101[10] : shift[6] : 0b011101[6] : rn[5] : rd[5] );

sqshl_ddi.disasm = {
  sink << "sqshl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

sqshl_ddi.execute = {
  cpu.SetVS64(rd, NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(shift), /* round */ false, /* sat */ true));
}

op sqshl_hhh( 0b01011110011[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

sqshl_hhh.disasm = {
  sink << "sqshl\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

sqshl_hhh.execute = {
  cpu.SetVS16(rd, NeonSHL(cpu, cpu.GetVS16(rn, 0), typename ARCH::S8(cpu.GetVU8(rm, 0)), /* round */ false, /* sat */ true));
}

op sqshl_hhi( 0b010111110001[12] : shift[4] : 0b011101[6] : rn[5] : rd[5] );

sqshl_hhi.disasm = {
  sink << "sqshl\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmI(shift);
};

sqshl_hhi.execute = {
  cpu.SetVS16(rd, NeonSHL(cpu, cpu.GetVS16(rn, 0), typename ARCH::S8(shift), /* round */ false, /* sat */ true));
}

op sqshl_ssi( 0b01011111001[11] : shift[5] : 0b011101[6] : rn[5] : rd[5] );

sqshl_ssi.disasm = {
  sink << "sqshl\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

sqshl_ssi.execute = {
  cpu.SetVS32(rd, NeonSHL(cpu, cpu.GetVS32(rn, 0), typename ARCH::S8(shift), /* round */ false, /* sat */ true));
}

op sqshl_sss( 0b01011110101[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

sqshl_sss.disasm = {
  sink << "sqshl\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

sqshl_sss.execute = {
  cpu.SetVS32(rd, NeonSHL(cpu, cpu.GetVS32(rn, 0), typename ARCH::S8(cpu.GetVU8(rm, 0)), /* round */ false, /* sat */ true));
}

op sqshl_v2d2di( 0b0100111101[10] : imm[6] : 0b011101[6] : rn[5] : rd[5] );

sqshl_v2d2di.disasm = {
  sink << "sqshl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(imm);
};

sqshl_v2d2di.execute = {
  typedef typename ARCH::S8 S8;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVS64(rd, idx, NeonSHL(cpu, cpu.GetVS64(rn, idx), S8(imm), /* round */ false, /* sat */ true));
    }
}

op sqshl_v2dv2dv2d( 0b01001110111[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

sqshl_v2dv2dv2d.disasm = {
  sink << "sqshl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

sqshl_v2dv2dv2d.execute = {
  typedef typename ARCH::S8 S8;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVS64(rd, idx, NeonSHL(cpu, cpu.GetVS64(rn, idx), S8(cpu.GetVS64(rm, idx)), /* round */ false, /* sat */ true));
    }
}

op sqshlu_bbi( 0b0111111100001[13] : shift[3] : 0b011001[6] : rn[5] : rd[5] );

sqshlu_bbi.disasm = {
  sink << "sqshlu\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmI(shift);
};

sqshlu_bbi.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U8 U8;

  S8 op = cpu.GetVS8(rn, 0);
  U8 res(0);
  if (cpu.Test(op < S8(0)))
    {
      cpu.SetQC();
    }
  else
    {
      res = NeonSHL(cpu, U8(op), S8(shift), /* round */ false, /* sat */ true);
    }

  cpu.SetVU8(rd, res);
}

op sqshlu_ddi( 0b0111111101[10] : shift[6] : 0b011001[6] : rn[5] : rd[5] );

sqshlu_ddi.disasm = {
  sink << "sqshlu\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

sqshlu_ddi.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S8 S8;

  S64 op = cpu.GetVS64(rn, 0);
  U64 res(0);
  if (cpu.Test(op < S64(0)))
    {
      cpu.SetQC();
    }
  else
    {
      res = NeonSHL(cpu, U64(op), S8(shift), /* round */ false, /* sat */ true);
    }

  cpu.SetVU64(rd, res);
}

op sqshlu_hhi( 0b011111110001[12] : shift[4] : 0b011001[6] : rn[5] : rd[5] );

sqshlu_hhi.disasm = {
  sink << "sqshlu\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmI(shift);
};

sqshlu_hhi.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::S8 S8;

  S16 op = cpu.GetVS16(rn, 0);
  U16 res(0);
  if (cpu.Test(op < S16(0)))
    {
      cpu.SetQC();
    }
  else
    {
      res = NeonSHL(cpu, U16(op), S8(shift), /* round */ false, /* sat */ true);
    }

  cpu.SetVU16(rd, res);
}

op sqshlu_ssi( 0b01111111001[11] : shift[5] : 0b011001[6] : rn[5] : rd[5] );

sqshlu_ssi.disasm = {
  sink << "sqshlu\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

sqshlu_ssi.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S8 S8;

  S32 op = cpu.GetVS32(rn, 0);
  U32 res(0);
  if (cpu.Test(op < S32(0)))
    {
      cpu.SetQC();
    }
  else
    {
      res = NeonSHL(cpu, U32(op), S8(shift), /* round */ false, /* sat */ true);
    }

  cpu.SetVU32(rd, res);
}

op sqshlu_v2d2di( 0b0110111101[10] : shift[6] : 0b011001[6] : rn[5] : rd[5] );

sqshlu_v2d2di.disasm = {
  sink << "sqshlu\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sqshlu_v2d2di.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S8 S8;
  
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      S64 op = cpu.GetVS64(rn, idx);
      U64 res(0);
      if (cpu.Test(op < S64(0)))
        {
          cpu.SetQC();
        }
      else
        {
          res = NeonSHL(cpu, U64(op), S8(shift), /* round */ false, /* sat */ true);
        }

      cpu.SetVU64(rd, idx, res);
    }
}

op sqshrn2_v16b8hi( 0b0100111100001[13] : lro[3] : 0b100101[6] : rn[5] : rd[5] );
sqshrn2_v16b8hi.var shift : {unsigned} = {8 - lro};

sqshrn2_v16b8hi.disasm = {
  sink << "sqshrn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

sqshrn2_v16b8hi.execute = {
  typedef typename ARCH::S8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS8(rd, elements + idx, res[idx]);
    }
}

op sqshrn2_v4s2di( 0b01001111001[11] : lro[5] : 0b100101[6] : rn[5] : rd[5] );
sqshrn2_v4s2di.var shift : {unsigned} = {32 - lro};

sqshrn2_v4s2di.disasm = {
  sink << "sqshrn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sqshrn2_v4s2di.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, elements + idx, res[idx]);
    }
}

op sqshrn2_v8h4si( 0b010011110001[12] : lro[4] : 0b100101[6] : rn[5] : rd[5] );
sqshrn2_v8h4si.var shift : {unsigned} = {16 - lro};

sqshrn2_v8h4si.disasm = {
  sink << "sqshrn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

sqshrn2_v8h4si.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, elements + idx, res[idx]);
    }
}

op sqshrn_bhi( 0b0101111100001[13] : lro[3] : 0b100101[6] : rn[5] : rd[5] );
sqshrn_bhi.var shift : {unsigned} = {8 - lro};

sqshrn_bhi.disasm = {
  sink << "sqshrn\t" << DisasmB(rd) << ", " << DisasmH(rn) << ", " << DisasmI(shift);
};

sqshrn_bhi.execute = {
  cpu.SetVS8(rd, SatNarrow<typename ARCH::S8>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, 0), typename ARCH::S8(-shift), /* round */ false, /* sat */ true)));
}

op sqshrn_hsi( 0b010111110001[12] : lro[4] : 0b100101[6] : rn[5] : rd[5] );
sqshrn_hsi.var shift : {unsigned} = {16 - lro};

sqshrn_hsi.disasm = {
  sink << "sqshrn\t" << DisasmH(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

sqshrn_hsi.execute = {
  cpu.SetVS16(rd, SatNarrow<typename ARCH::S16>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, 0), typename ARCH::S8(-shift), /* round */ false, /* sat */ true)));
}

op sqshrn_sdi( 0b01011111001[11] : lro[5] : 0b100101[6] : rn[5] : rd[5] );
sqshrn_sdi.var shift : {unsigned} = {32 - lro};

sqshrn_sdi.disasm = {
  sink << "sqshrn\t" << DisasmS(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

sqshrn_sdi.execute = {
  cpu.SetVS32(rd, SatNarrow<typename ARCH::S32>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(-shift), /* round */ false, /* sat */ true)));
}

op sqshrn_v2s2di( 0b00001111001[11] : lro[5] : 0b100101[6] : rn[5] : rd[5] );
sqshrn_v2s2di.var shift : {unsigned} = {32 - lro};

sqshrn_v2s2di.disasm = {
  sink << "sqshrn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sqshrn_v2s2di.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqshrn_v4h4si( 0b000011110001[12] : lro[4] : 0b100101[6] : rn[5] : rd[5] );
sqshrn_v4h4si.var shift : {unsigned} = {16 - lro};

sqshrn_v4h4si.disasm = {
  sink << "sqshrn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

sqshrn_v4h4si.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqshrn_v8b8hi( 0b0000111100001[13] : lro[3] : 0b100101[6] : rn[5] : rd[5] );
sqshrn_v8b8hi.var shift : {unsigned} = {8 - lro};

sqshrn_v8b8hi.disasm = {
  sink << "sqshrn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

sqshrn_v8b8hi.execute = {
  typedef typename ARCH::S8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqshrun2_v16b8hi( 0b0110111100001[13] : lro[3] : 0b100001[6] : rn[5] : rd[5] );
sqshrun2_v16b8hi.var shift : {unsigned} = {8 - lro};

sqshrun2_v16b8hi.disasm = {
  sink << "sqshrun2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

sqshrun2_v16b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, elements + idx, res[idx]);
    }
}

op sqshrun2_v4s2di( 0b01101111001[11] : lro[5] : 0b100001[6] : rn[5] : rd[5] );
sqshrun2_v4s2di.var shift : {unsigned} = {32 - lro};

sqshrun2_v4s2di.disasm = {
  sink << "sqshrun2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sqshrun2_v4s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, elements + idx, res[idx]);
    }
}

op sqshrun2_v8h4si( 0b011011110001[12] : lro[4] : 0b100001[6] : rn[5] : rd[5] );
sqshrun2_v8h4si.var shift : {unsigned} = {16 - lro};

sqshrun2_v8h4si.disasm = {
  sink << "sqshrun2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

sqshrun2_v8h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, elements + idx, res[idx]);
    }
}

op sqshrun_bhi( 0b0111111100001[13] : lro[3] : 0b100001[6] : rn[5] : rd[5] );
sqshrun_bhi.var shift : {unsigned} = {8 - lro};

sqshrun_bhi.disasm = {
  sink << "sqshrun\t" << DisasmB(rd) << ", " << DisasmH(rn) << ", " << DisasmI(shift);
};

sqshrun_bhi.execute = {
  cpu.SetVU8(rd, SatNarrow<typename ARCH::U8>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, 0), typename ARCH::S8(-shift), /* round */ false, /* sat */ true)));
}

op sqshrun_hsi( 0b011111110001[12] : lro[4] : 0b100001[6] : rn[5] : rd[5] );
sqshrun_hsi.var shift : {unsigned} = {16 - lro};

sqshrun_hsi.disasm = {
  sink << "sqshrun\t" << DisasmH(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

sqshrun_hsi.execute = {
  cpu.SetVU16(rd, SatNarrow<typename ARCH::U16>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, 0), typename ARCH::S8(-shift), /* round */ false, /* sat */ true)));
}

op sqshrun_sdi( 0b01111111001[11] : lro[5] : 0b100001[6] : rn[5] : rd[5] );
sqshrun_sdi.var shift : {unsigned} = {32 - lro};

sqshrun_sdi.disasm = {
  sink << "sqshrun\t" << DisasmS(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

sqshrun_sdi.execute = {
  cpu.SetVU32(rd, SatNarrow<typename ARCH::U32>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(-shift), /* round */ false, /* sat */ true)));
}

op sqshrun_v2s2di( 0b00101111001[11] : lro[5] : 0b100001[6] : rn[5] : rd[5] );
sqshrun_v2s2di.var shift : {unsigned} = {32 - lro};

sqshrun_v2s2di.disasm = {
  sink << "sqshrun\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sqshrun_v2s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS64(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqshrun_v4h4si( 0b001011110001[12] : lro[4] : 0b100001[6] : rn[5] : rd[5] );
sqshrun_v4h4si.var shift : {unsigned} = {16 - lro};

sqshrun_v4h4si.disasm = {
  sink << "sqshrun\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

sqshrun_v4h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqshrun_v8b8hi( 0b0010111100001[13] : lro[3] : 0b100001[6] : rn[5] : rd[5] );
sqshrun_v8b8hi.var shift : {unsigned} = {8 - lro};

sqshrun_v8b8hi.disasm = {
  sink << "sqshrun\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

sqshrun_v8b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqsub_bbb( 0b01011110001[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

sqsub_bbb.disasm = {
  sink << "sqsub\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmB(rm);
};

sqsub_bbb.execute = {
  cpu.SetVS8(rd, SatSub(cpu, cpu.GetVS8(rn, 0), cpu.GetVS8(rm, 0)));
}

op sqsub_ddd( 0b01011110111[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

sqsub_ddd.disasm = {
  sink << "sqsub\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

sqsub_ddd.execute = {
  cpu.SetVS64(rd, SatSub(cpu, cpu.GetVS64(rn, 0), cpu.GetVS64(rm, 0)));
}

op sqsub_hhh( 0b01011110011[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

sqsub_hhh.disasm = {
  sink << "sqsub\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

sqsub_hhh.execute = {
  cpu.SetVS16(rd, SatSub(cpu, cpu.GetVS16(rn, 0), cpu.GetVS16(rm, 0)));
}

op sqsub_sss( 0b01011110101[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

sqsub_sss.disasm = {
  sink << "sqsub\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

sqsub_sss.execute = {
  cpu.SetVS32(rd, SatSub(cpu, cpu.GetVS32(rn, 0), cpu.GetVS32(rm, 0)));
}

op sqsub_v2dv2dv2d( 0b01001110111[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

sqsub_v2dv2dv2d.disasm = {
  sink << "sqsub\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

sqsub_v2dv2dv2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVS64(rd, idx, SatSub(cpu, cpu.GetVS64(rn, idx), cpu.GetVS64(rm, idx)));
    }
};

op sqxtn2_v16b8h( 0b0100111000100001010010[22] : rn[5] : rd[5] );

sqxtn2_v16b8h.disasm = {
  sink << "sqxtn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1);
};

sqxtn2_v16b8h.execute = {
  typedef typename ARCH::S8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS8(rd, elements + idx, res[idx]);
    }
}

op sqxtn2_v4s2d( 0b0100111010100001010010[22] : rn[5] : rd[5] );

sqxtn2_v4s2d.disasm = {
  sink << "sqxtn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3);
};

sqxtn2_v4s2d.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu , cpu.GetVS64(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, elements + idx, res[idx]);
    }
}

op sqxtn2_v8h4s( 0b0100111001100001010010[22] : rn[5] : rd[5] );

sqxtn2_v8h4s.disasm = {
  sink << "sqxtn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2);
};

sqxtn2_v8h4s.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, elements + idx, res[idx]);
    }
}

op sqxtn_bh( 0b0101111000100001010010[22] : rn[5] : rd[5] );

sqxtn_bh.disasm = {
  sink << "sqxtn\t" << DisasmB(rd) << ", " << DisasmH(rn);
};

sqxtn_bh.execute = {
  cpu.SetVS8(rd, SatNarrow<typename ARCH::S8>(cpu, cpu.GetVS16(rn, 0)));
}

op sqxtn_hs( 0b0101111001100001010010[22] : rn[5] : rd[5] );

sqxtn_hs.disasm = {
  sink << "sqxtn\t" << DisasmH(rd) << ", " << DisasmS(rn);
};

sqxtn_hs.execute = {
  cpu.SetVS16(rd, SatNarrow<typename ARCH::S16>(cpu, cpu.GetVS32(rn, 0)));
}

op sqxtn_sd( 0b0101111010100001010010[22] : rn[5] : rd[5] );

sqxtn_sd.disasm = {
  sink << "sqxtn\t" << DisasmS(rd) << ", " << DisasmD(rn);
};

sqxtn_sd.execute = {
  cpu.SetVS32(rd, SatNarrow<typename ARCH::S32>(cpu, cpu.GetVS64(rn, 0)));
}

op sqxtn_v2s2d( 0b0000111010100001010010[22] : rn[5] : rd[5] );

sqxtn_v2s2d.disasm = {
  sink << "sqxtn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3);
};

sqxtn_v2s2d.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS64(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqxtn_v4h4s( 0b0000111001100001010010[22] : rn[5] : rd[5] );

sqxtn_v4h4s.disasm = {
  sink << "sqxtn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2);
};

sqxtn_v4h4s.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqxtn_v8b8h( 0b0000111000100001010010[22] : rn[5] : rd[5] );

sqxtn_v8b8h.disasm = {
  sink << "sqxtn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1);
};

sqxtn_v8b8h.execute = {
  typedef typename ARCH::S8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqxtun2_v16b8h( 0b0110111000100001001010[22] : rn[5] : rd[5] );

sqxtun2_v16b8h.disasm = {
  sink << "sqxtun2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1);
};

sqxtun2_v16b8h.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, elements + idx, res[idx]);
    }
}

op sqxtun2_v4s2d( 0b0110111010100001001010[22] : rn[5] : rd[5] );

sqxtun2_v4s2d.disasm = {
  sink << "sqxtun2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3);
};

sqxtun2_v4s2d.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu , cpu.GetVS64(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, elements + idx, res[idx]);
    }
}

op sqxtun2_v8h4s( 0b0110111001100001001010[22] : rn[5] : rd[5] );

sqxtun2_v8h4s.disasm = {
  sink << "sqxtun2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2);
};

sqxtun2_v8h4s.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, elements + idx, res[idx]);
    }
}

op sqxtun_bh( 0b0111111000100001001010[22] : rn[5] : rd[5] );

sqxtun_bh.disasm = {
  sink << "sqxtun\t" << DisasmB(rd) << ", " << DisasmH(rn);
};

sqxtun_bh.execute = {
  cpu.SetVU8(rd, SatNarrow<typename ARCH::U8>(cpu, cpu.GetVS16(rn, 0)));
}

op sqxtun_hs( 0b0111111001100001001010[22] : rn[5] : rd[5] );

sqxtun_hs.disasm = {
  sink << "sqxtun\t" << DisasmH(rd) << ", " << DisasmS(rn);
};

sqxtun_hs.execute = {
  cpu.SetVU16(rd, SatNarrow<typename ARCH::U16>(cpu, cpu.GetVS32(rn, 0)));
}

op sqxtun_sd( 0b0111111010100001001010[22] : rn[5] : rd[5] );

sqxtun_sd.disasm = {
  sink << "sqxtun\t" << DisasmS(rd) << ", " << DisasmD(rn);
};

sqxtun_sd.execute = {
  cpu.SetVU32(rd, SatNarrow<typename ARCH::U32>(cpu, cpu.GetVS64(rn, 0)));
}

op sqxtun_v2s2d( 0b0010111010100001001010[22] : rn[5] : rd[5] );

sqxtun_v2s2d.disasm = {
  sink << "sqxtun\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3);
};

sqxtun_v2s2d.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS64(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqxtun_v4h4s( 0b0010111001100001001010[22] : rn[5] : rd[5] );

sqxtun_v4h4s.disasm = {
  sink << "sqxtun\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2);
};

sqxtun_v4h4s.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sqxtun_v8b8h( 0b0010111000100001001010[22] : rn[5] : rd[5] );

sqxtun_v8b8h.disasm = {
  sink << "sqxtun\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1);
};

sqxtun_v8b8h.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVS16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op sri_ddi( 0b0111111101[10] : lro[6] : 0b010001[6] : rn[5] : rd[5] );
sri_ddi.var shift : {unsigned} = {64 - lro};

sri_ddi.disasm = {
  sink << "sri\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

sri_ddi.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S8 S8;

  U64 mask(~NeonSHL(cpu, U64(~U64(0)), -S8(shift)));
  U64 op1(cpu.GetVU64(rd, 0)), op2(cpu.GetVU64(rn, 0)), res(U64(op1 & mask) | NeonSHL(cpu, op2, -S8(shift)));
  cpu.SetVU64(rd, res);
}

op sri_v2d2di( 0b0110111101[10] : lro[6] : 0b010001[6] : rn[5] : rd[5] );
sri_v2d2di.var shift : {unsigned} = {64 - lro};

sri_v2d2di.disasm = {
  sink << "sri\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sri_v2d2di.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S8 S8;

  unsigned const elements = 2;
  U64 mask(~NeonSHL(cpu, ~U64(0), -S8(shift)));

  for (unsigned idx = 0; idx < elements; ++idx)
    {
      U64 op1(cpu.GetVU64(rd, idx)), op2(cpu.GetVU64(rn, idx)), res((op1 & mask) | NeonSHL(cpu, op2, -S8(shift)));
      cpu.SetVU64(rd, idx, res);
    }
}

op srshl_ddd( 0b01011110111[11] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

srshl_ddd.disasm = {
  sink << "srshl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

srshl_ddd.execute = {
  typedef typename ARCH::S8 S8;
  cpu.SetVS64(rd, NeonSHL(cpu, cpu.GetVS64(rn, 0), S8(cpu.GetVS64(rm, 0)), /* round */ true, /* sat */ false));
}

op srshl_v2dv2dv2d( 0b01001110111[11] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

srshl_v2dv2dv2d.disasm = {
  sink << "srshl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

srshl_v2dv2dv2d.execute = {
  typedef typename ARCH::S8 S8;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVS64(rd, idx, NeonSHL(cpu, cpu.GetVS64(rn, idx), S8(cpu.GetVS64(rm, idx)), /* round */ true, /* sat */ false));
    }
}

op srshr_ddi( 0b0101111101[10] : lro[6] : 0b001001[6] : rn[5] : rd[5] );
srshr_ddi.var shift : {unsigned} = {64 - lro};

srshr_ddi.disasm = {
  sink << "srshr\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

srshr_ddi.execute = {
  cpu.SetVS64(rd, NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ false));
}

op srsra_ddi( 0b0101111101[10] : lro[6] : 0b001101[6] : rn[5] : rd[5] );
srsra_ddi.var shift : {unsigned} = {64 - lro};

srsra_ddi.disasm = {
  sink << "srsra\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

srsra_ddi.execute = {
  cpu.SetVS64(rd, cpu.GetVS64(rd, 0) + NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ false));
}

op sshl_ddd( 0b01011110111[11] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

sshl_ddd.disasm = {
  sink << "sshl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

sshl_ddd.execute = {
  cpu.SetVS64(rd, NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(cpu.GetVU8(rm, 0))));
}

op sshl_v2dv2dv2d( 0b01001110111[11] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

sshl_v2dv2dv2d.disasm = {
  sink << "sshl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

sshl_v2dv2dv2d.execute = {
  unsigned const elements = 2;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS64(rd, e, NeonSHL(cpu, cpu.GetVS64(rn, e), typename ARCH::S8(cpu.GetVS64(rm, e))));
    }
};

/*******************************************************************
 * SSHLL
 *
 * Signed Shift Left Long (immediate).
 */

op sshll_v8h( 0b0[1] : q[1] : 0b00111100001[11] : imm[3] : 0b101001[6] : rn[5] : rd[5] );

sshll_v8h.disasm = {
  sink << (imm ? "sshll" : "sxtl") << (q ? "2" : "") << '\t' << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8<<q, 0);
  if (imm) { sink << ", " << DisasmI(imm); }
};

sshll_v8h.execute = {
  typedef typename ARCH::U16 DST;

  unsigned const elements = 8, srcidx = elements*q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS8(rn, srcidx + idx)) << imm;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
};

op sshll_v4s( 0b0[1] : q[1] : 0b0011110001[10] : imm[4] : 0b101001[6] : rn[5] : rd[5] );

sshll_v4s.disasm = {
  sink << (imm ? "sshll" : "sxtl") << (q ? "2" : "") << '\t' << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4<<q, 1);
  if (imm) { sink << ", " << DisasmI(imm); }
};

sshll_v4s.execute = {
  typedef typename ARCH::U32 DST;

  unsigned const elements = 4, srcidx = elements*q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS16(rn, srcidx + idx)) << imm;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
};

op sshll_v2d( 0b0[1] : q[1] : 0b001111001[9] : imm[5] : 0b101001[6] : rn[5] : rd[5] );

sshll_v2d.disasm = {
  sink << (imm ? "sshll" : "sxtl") << (q ? "2" : "") << '\t' << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2<<q, 2);
  if (imm) { sink << ", " << DisasmI(imm); }
};

sshll_v2d.execute = {
  typedef typename ARCH::U64 DST;

  unsigned const elements = 2, srcidx = elements*q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVS32(rn, srcidx + idx)) << imm;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
};

/*
 * end of SSHLL
 *******************************************************************/

op sshr_ddi( 0b0101111101[10] : lro[6] : 0b000001[6] : rn[5] : rd[5] );
sshr_ddi.var shift : {unsigned} = {64 - lro};

sshr_ddi.disasm = {
  sink << "sshr\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

sshr_ddi.execute = {
  cpu.SetVS64(rd, NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(-shift)));
}

op ssra_ddi( 0b0101111101[10] : lro[6] : 0b000101[6] : rn[5] : rd[5] );
ssra_ddi.var shift : {unsigned} = {64 - lro};

ssra_ddi.disasm = {
  sink << "ssra\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

ssra_ddi.execute = {
  cpu.SetVS64(rd, cpu.GetVS64(rd, 0) + NeonSHL(cpu, cpu.GetVS64(rn, 0), typename ARCH::S8(-shift)));
}

op ssubl2_v2dv4sv4s( 0b01001110101[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

ssubl2_v2dv4sv4s.disasm = {
  sink << "ssubl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

ssubl2_v2dv4sv4s.execute = {
  typedef typename ARCH::S64 DST;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = S64(cpu.GetVS32(rn, elements + idx)) - S64(cpu.GetVS32(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op ssubl2_v4sv8hv8h( 0b01001110011[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

ssubl2_v4sv8hv8h.disasm = {
  sink << "ssubl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

ssubl2_v4sv8hv8h.execute = {
  typedef typename ARCH::S32 DST;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = S32(cpu.GetVS16(rn, elements + idx)) - S32(cpu.GetVS16(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op ssubl2_v8hv16bv16b( 0b01001110001[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

ssubl2_v8hv16bv16b.disasm = {
  sink << "ssubl2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

ssubl2_v8hv16bv16b.execute = {
  typedef typename ARCH::S16 DST;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = S16(cpu.GetVS8(rn, elements + idx)) - S16(cpu.GetVS8(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op ssubl_v2dv2sv2s( 0b00001110101[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

ssubl_v2dv2sv2s.disasm = {
  sink << "ssubl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

ssubl_v2dv2sv2s.execute = {
  typedef typename ARCH::S64 S64;
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVS64(rd, idx, S64(cpu.GetVS32(rn, idx)) - S64(cpu.GetVS32(rm, idx)));
    }
}

op ssubl_v4sv4hv4h( 0b00001110011[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

ssubl_v4sv4hv4h.disasm = {
  sink << "ssubl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

ssubl_v4sv4hv4h.execute = {
  typedef typename ARCH::S32 S32;
  for (unsigned idx = 0; idx < 4; ++idx)
    {
      cpu.SetVS32(rd, idx, S32(cpu.GetVS16(rn, idx)) - S32(cpu.GetVS16(rm, idx)));
    }
}

op ssubl_v8hv8bv8b( 0b00001110001[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

ssubl_v8hv8bv8b.disasm = {
  sink << "ssubl\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

ssubl_v8hv8bv8b.execute = {
  typedef typename ARCH::S16 S16;
  for (unsigned idx = 0; idx < 8; ++idx)
    {
      cpu.SetVS16(rd, idx, S16(cpu.GetVS8(rn, idx)) - S16(cpu.GetVS8(rm, idx)));
    }
}

op ssubw2_v2dv2dv4s( 0b01001110101[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

ssubw2_v2dv2dv4s.disasm = {
  sink << "ssubw2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 4, 2);
};

ssubw2_v2dv2dv4s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rn, idx) - DST(cpu.GetVS32(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op ssubw2_v4sv4sv8h( 0b01001110011[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

ssubw2_v4sv4sv8h.disasm = {
  sink << "ssubw2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 8, 1);
};

ssubw2_v4sv4sv8h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rn, idx) - DST(cpu.GetVS16(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op ssubw2_v8hv8hv16b( 0b01001110001[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

ssubw2_v8hv8hv16b.disasm = {
  sink << "ssubw2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 16, 0);
};

ssubw2_v8hv8hv16b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rn, idx) - DST(cpu.GetVS8(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

op ssubw_v2dv2dv2s( 0b00001110101[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

ssubw_v2dv2dv2s.disasm = {
  sink << "ssubw\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 2);
};

ssubw_v2dv2dv2s.execute = {
  typedef typename ARCH::S64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rn, idx) - DST(cpu.GetVS32(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }
}

op ssubw_v4sv4sv4h( 0b00001110011[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

ssubw_v4sv4sv4h.disasm = {
  sink << "ssubw\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 1);
};

ssubw_v4sv4sv4h.execute = {
  typedef typename ARCH::S32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rn, idx) - DST(cpu.GetVS16(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
}

op ssubw_v8hv8hv8b( 0b00001110001[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

ssubw_v8hv8hv8b.disasm = {
  sink << "ssubw\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 0);
};

ssubw_v8hv8hv8b.execute = {
  typedef typename ARCH::S16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rn, idx) - DST(cpu.GetVS8(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
}

/*******************************************************************
 * STP (SIMD&FP)
 *
 * Store pair of SIMD&FP registers
 */

op stp_so( 0b0010110[7] : am[2] : 0[1] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );

stp_so.disasm = {
  sink << "st" << (am ? "" : "n") << "p\t" << DisasmS(rt) << ", " << DisasmS(rt2) << ", " << DisasmMemoryRI(rn, imm, am);
};

stp_so.execute = {
  /* TODO: catch Non-temporal hint (am == 0) */
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U32 data0( cpu.GetVU32(rt, 0) ), data1( cpu.GetVU32(rt2, 0) );
  cpu.MemWrite32( addr + U64(0), data0 );
  cpu.MemWrite32( addr + U64(4), data1 );
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op stp_do( 0b0110110[7] : am[2] : 0[1] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );

stp_do.disasm = {
  sink << "st" << (am ? "" : "n") << "p\t" << DisasmD(rt) << ", " << DisasmD(rt2) << ", " << DisasmMemoryRI(rn, imm, am);
};

stp_do.execute = {
  /* TODO: catch Non-temporal hint (am == 0) */
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U64 data0( cpu.GetVU64(rt, 0) ), data1( cpu.GetVU64(rt2, 0) );
  cpu.MemWrite64( addr + U64(0), data0 );
  cpu.MemWrite64( addr + U64(8), data1 );
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op stp_qo( 0b1010110[7] : am[2] : 0[1] : shl<4> sext imm[7] : rt2[5] : rn[5] : rt[5] );

stp_qo.disasm = {
  sink << "st" << (am ? "" : "n") << "p\t" << DisasmQ(rt) << ", " << DisasmQ(rt2) << ", " << DisasmMemoryRI(rn, imm, am);
};

stp_qo.execute = {
  /* TODO: catch Non-temporal hint (am == 0) */
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U64 data0( cpu.GetVU64(rt, 0) ),
      data1( cpu.GetVU64(rt, 1) ),
      data2( cpu.GetVU64(rt2, 0) ),
      data3( cpu.GetVU64(rt2, 1) );
  cpu.MemWrite64( addr + U64( 0), data0 );
  cpu.MemWrite64( addr + U64( 8), data1 );
  cpu.MemWrite64( addr + U64(16), data2 );
  cpu.MemWrite64( addr + U64(24), data3 );
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

/*
 * end of STP (SIMD&FP)
 *******************************************************************/

/*******************************************************************
 * STR (immediate, SIMD&FP)
 *
 * Store SIMD&FP register (immediate offset)
 */

op str_bxi( 0b00111100000[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
str_bxi.var reject : {Reject} = {am == 2};

str_bxi.disasm = {
  sink << "st" << (am ? "" : "u") << "r\t" << DisasmB(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

str_bxi.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U8 data( cpu.GetVU8(rt, 0) );
  cpu.MemWrite8(addr, data);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op str_buo( 0b0011110100[10] : imm[12] : rn[5] : rt[5] );

str_buo.disasm = {
  sink << "str\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

str_buo.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U8 data( cpu.GetVU8(rt, 0) );
  cpu.MemWrite8(addr, data);
};

op str_hxi( 0b01111100000[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
str_hxi.var reject : {Reject} = {am == 2};

str_hxi.disasm = {
  sink << "st" << (am ? "" : "u") << "r\t" << DisasmH(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

str_hxi.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U16 data( cpu.GetVU16(rt, 0) );
  cpu.MemWrite16(addr, data);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op str_huo( 0b0111110100[10] : shl<1> imm[12] : rn[5] : rt[5] );

str_huo.disasm = {
  sink << "str\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

str_huo.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U16 data( cpu.GetVU16(rt, 0) );
  cpu.MemWrite16(addr, data);
};

op str_sxi( 0b10111100000[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
str_sxi.var reject : {Reject} = {am == 2};

str_sxi.disasm = {
  sink << "st" << (am ? "" : "u") << "r\t" << DisasmS(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

str_sxi.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U32 data( cpu.GetVU32(rt, 0) );
  cpu.MemWrite32(addr, data);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op str_suo( 0b1011110100[10] : shl<2> imm[12] : rn[5] : rt[5] );

str_suo.disasm = {
  sink << "str\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

str_suo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U32 data( cpu.GetVU32(rt, 0) );
  cpu.MemWrite32(addr, data);
};

op str_dxi( 0b11111100000[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
str_dxi.var reject : {Reject} = {am == 2};

str_dxi.disasm = {
  sink << "st" << (am ? "" : "u") << "r\t" << DisasmD(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

str_dxi.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U64 data( cpu.GetVU64(rt, 0) );
  cpu.MemWrite64(addr, data);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op str_duo( 0b1111110100[10] : shl<3> imm[12] : rn[5] : rt[5] );

str_duo.disasm = {
  sink << "str\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

str_duo.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U64 data( cpu.GetVU64(rt, 0) );
  cpu.MemWrite64(addr, data);
};

op str_qxi( 0b00111100100[11] : sext imm[9] : am[2] : rn[5] : rt[5] );
str_qxi.var reject : {Reject} = {am == 2};

str_qxi.disasm = {
  sink << "st" << (am ? "" : "u") << "r\t" << DisasmQ(rt) << ", " << DisasmMemoryRI(rn, imm, am);
};

str_qxi.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) ), oaddr( addr + U64(imm) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = (am == 1 ? addr : oaddr);
  U64 data0( cpu.GetVU64(rt, 0) ), data1( cpu.GetVU64(rt, 1) );
  cpu.MemWrite64(addr + U64(0), data0);
  cpu.MemWrite64(addr + U64(8), data1);
  if (am & 1)
    cpu.SetGSR(rn, oaddr);
};

op str_quo( 0b0011110110[10] : shl<4> imm[12] : rn[5] : rt[5] );

str_quo.disasm = {
  sink << "str\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmI(imm) << "]";
};

str_quo.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + U64(imm);
  U64 data0( cpu.GetVU64(rt, 0) ), data1( cpu.GetVU64(rt, 1) );
  cpu.MemWrite64(addr + U64(0), data0);
  cpu.MemWrite64(addr + U64(8), data1);
};

/*
 * end of STR (immediate, SIMD&FP)
 *******************************************************************/

/*******************************************************************
 * STR (register, SIMD&FP)
 *
 * Store SIMD&FP register (register offset)
 */

op str_bxwu( 0b00111100001[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_bxwu.var shift : {uint8_t} = {s*0};

str_bxwu.disasm = {
  sink << "str\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

str_bxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U8 U8;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U8 data( cpu.GetVU8(rt, 0) );
  cpu.MemWrite8(addr, data);
};

op str_bxxu( 0b00111100001[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_bxxu.var shift : {uint8_t} = {s*0};

str_bxxu.disasm = {
  sink << "str\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

str_bxxu.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U8 U8;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U8 data( cpu.GetVU8(rt, 0) );
  cpu.MemWrite8(addr, data);
};

op str_bxws( 0b00111100001[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_bxws.var shift : {uint8_t} = {s*0};

str_bxws.disasm = {
  sink << "str\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

str_bxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U8 U8;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U8 data( cpu.GetVU8(rt, 0) );
  cpu.MemWrite8(addr, data);
};

op str_bxxs( 0b00111100001[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_bxxs.var shift : {uint8_t} = {s*0};

str_bxxs.disasm = {
  sink << "str\t" << DisasmB(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

str_bxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U8 U8;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U8 data( cpu.GetVU8(rt, 0) );
  cpu.MemWrite8(addr, data);
};

op str_hxwu( 0b01111100001[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_hxwu.var shift : {uint8_t} = {s*1};

str_hxwu.disasm = {
  sink << "str\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

str_hxwu.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U16 data( cpu.GetVU16(rt, 0) );
  cpu.MemWrite16(addr, data);
};

op str_hxxu( 0b01111100001[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_hxxu.var shift : {uint8_t} = {s*1};

str_hxxu.disasm = {
  sink << "str\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

str_hxxu.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U16 data( cpu.GetVU16(rt, 0) );
  cpu.MemWrite16(addr, data);
};

op str_hxws( 0b01111100001[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_hxws.var shift : {uint8_t} = {s*1};

str_hxws.disasm = {
  sink << "str\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

str_hxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U16 data( cpu.GetVU16(rt, 0) );
  cpu.MemWrite16(addr, data);
};

op str_hxxs( 0b01111100001[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_hxxs.var shift : {uint8_t} = {s*1};

str_hxxs.disasm = {
  sink << "str\t" << DisasmH(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

str_hxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U16 data( cpu.GetVU16(rt, 0) );
  cpu.MemWrite16(addr, data);
};

op str_sxwu( 0b10111100001[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_sxwu.var shift : {uint8_t} = {s*2};

str_sxwu.disasm = {
  sink << "str\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

str_sxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U32 data( cpu.GetVU32(rt, 0) );
  cpu.MemWrite32(addr, data);
};

op str_sxxu( 0b10111100001[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_sxxu.var shift : {uint8_t} = {s*2};

str_sxxu.disasm = {
  sink << "str\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

str_sxxu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U32 data( cpu.GetVU32(rt, 0) );
  cpu.MemWrite32(addr, data);
};

op str_sxws( 0b10111100001[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_sxws.var shift : {uint8_t} = {s*2};

str_sxws.disasm = {
  sink << "str\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

str_sxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U32 data( cpu.GetVU32(rt, 0) );
  cpu.MemWrite32(addr, data);
};

op str_sxxs( 0b10111100001[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_sxxs.var shift : {uint8_t} = {s*2};

str_sxxs.disasm = {
  sink << "str\t" << DisasmS(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

str_sxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U32 data( cpu.GetVU32(rt, 0) );
  cpu.MemWrite32(addr, data);
};

op str_dxwu( 0b11111100001[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_dxwu.var shift : {uint8_t} = {s*3};

str_dxwu.disasm = {
  sink << "str\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

str_dxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data( cpu.GetVU64(rt, 0) );
  cpu.MemWrite64(addr, data);
};

op str_dxxu( 0b11111100001[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_dxxu.var shift : {uint8_t} = {s*3};

str_dxxu.disasm = {
  sink << "str\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

str_dxxu.execute = {
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data( cpu.GetVU64(rt, 0) );
  cpu.MemWrite64(addr, data);
};

op str_dxws( 0b11111100001[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_dxws.var shift : {uint8_t} = {s*3};

str_dxws.disasm = {
  sink << "str\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

str_dxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data( cpu.GetVU64(rt, 0) );
  cpu.MemWrite64(addr, data);
};

op str_dxxs( 0b11111100001[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_dxxs.var shift : {uint8_t} = {s*3};

str_dxxs.disasm = {
  sink << "str\t" << DisasmD(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

str_dxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data( cpu.GetVU64(rt, 0) );
  cpu.MemWrite64(addr, data);
};

op str_qxwu( 0b00111100101[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_qxwu.var shift : {uint8_t} = {s*4};

str_qxwu.disasm = {
  sink << "str\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", shift) << "]";
};

str_qxwu.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data0( cpu.GetVU64(rt, 0) ), data1( cpu.GetVU64(rt, 1) );
  cpu.MemWrite64(addr + U64(0), data0);
  cpu.MemWrite64(addr + U64(8), data1);
};

op str_qxxu( 0b00111100101[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_qxxu.var shift : {uint8_t} = {s*4};

str_qxxu.disasm = {
  sink << "str\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ", shift) << "]";
};

str_qxxu.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data0( cpu.GetVU64(rt, 0) ), data1( cpu.GetVU64(rt, 1) );
  cpu.MemWrite64(addr + U64(0), data0);
  cpu.MemWrite64(addr + U64(8), data1);
};

op str_qxws( 0b00111100101[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_qxws.var shift : {uint8_t} = {s*4};

str_qxws.disasm = {
  sink << "str\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", shift) << "]";
};

str_qxws.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data0( cpu.GetVU64(rt, 0) ), data1( cpu.GetVU64(rt, 1) );
  cpu.MemWrite64(addr + U64(0), data0);
  cpu.MemWrite64(addr + U64(8), data1);
};

op str_qxxs( 0b00111100101[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_qxxs.var shift : {uint8_t} = {s*4};

str_qxxs.disasm = {
  sink << "str\t" << DisasmQ(rt) << ", [" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", shift) << "]";
};

str_qxxs.execute = {
  /* XXX: handling of quad vector */
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);
  addr = addr + offset;
  U64 data0( cpu.GetVU64(rt, 0) ), data1( cpu.GetVU64(rt, 1) );
  cpu.MemWrite64(addr + U64(0), data0);
  cpu.MemWrite64(addr + U64(8), data1);
};

/*
 * end of STR (register, SIMD&FP)
 *******************************************************************/

op sub_ddd( 0b01111110111[11] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

sub_ddd.disasm = {
  sink << "sub\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

sub_ddd.execute = {
  cpu.SetVU64(rd, cpu.GetVU64(rn, 0) - cpu.GetVU64(rm, 0));
}

op sub_v2dv2dv2d( 0b01101110111[11] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

sub_v2dv2dv2d.disasm = {
  sink << "sub\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

sub_v2dv2dv2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVU64(rd, idx, cpu.GetVU64(rn, idx) - cpu.GetVU64(rm, idx));
}

op subhn2_v16bv8hv8h( 0b01001110001[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

subhn2_v16bv8hv8h.disasm = {
  sink << "subhn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

subhn2_v16bv8hv8h.execute = {
  typedef typename ARCH::U8 DST;
  for (unsigned idx = 0, end = 8; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx + end, DST((cpu.GetVU16(rn, idx) - cpu.GetVU16(rm, idx)) >> 8));
    }
}

op subhn2_v4sv2dv2d( 0b01001110101[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

subhn2_v4sv2dv2d.disasm = {
  sink << "subhn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

subhn2_v4sv2dv2d.execute = {
  typedef typename ARCH::U32 DST;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx + end, DST((cpu.GetVU64(rn, idx) - cpu.GetVU64(rm, idx)) >> 32));
    }
}

op subhn2_v8hv4sv4s( 0b01001110011[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

subhn2_v8hv4sv4s.disasm = {
  sink << "subhn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

subhn2_v8hv4sv4s.execute = {
  typedef typename ARCH::U16 DST;
  for (unsigned idx = 0, end = 4; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx + end, DST((cpu.GetVU32(rn, idx) - cpu.GetVU32(rm, idx)) >> 16));
    }
}

op subhn_v2sv2dv2d( 0b00001110101[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

subhn_v2sv2dv2d.disasm = {
  sink << "subhn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

subhn_v2sv2dv2d.execute = {
  typedef typename ARCH::U32 DST;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, DST((cpu.GetVU64(rn, idx) - cpu.GetVU64(rm, idx)) >> 32));
    }
  cpu.ClearHighV(rd, 8);
}

op subhn_v4hv4sv4s( 0b00001110011[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

subhn_v4hv4sv4s.disasm = {
  sink << "subhn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

subhn_v4hv4sv4s.execute = {
  typedef typename ARCH::U16 DST;
  for (unsigned idx = 0, end = 4; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, DST((cpu.GetVU32(rn, idx) - cpu.GetVU32(rm, idx)) >> 16));
    }
  cpu.ClearHighV(rd, 8);
}

op subhn_v8bv8hv8h( 0b00001110001[11] : rm[5] : 0b011000[6] : rn[5] : rd[5] );

subhn_v8bv8hv8h.disasm = {
  sink << "subhn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

subhn_v8bv8hv8h.execute = {
  typedef typename ARCH::U8 DST;
  for (unsigned idx = 0, end = 8; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, DST((cpu.GetVU16(rn, idx) - cpu.GetVU16(rm, idx)) >> 8));
    }
  cpu.ClearHighV(rd, 8);
}

op suqadd_bb( 0b0101111000100000001110[22] : rn[5] : rd[5] );

suqadd_bb.disasm = {
  sink << "suqadd\t" << DisasmB(rd) << ", " << DisasmB(rn);
};

suqadd_bb.execute = {
  cpu.SetVS8(rd, SatAdd(cpu, cpu.GetVS8(rd, 0), cpu.GetVU8(rn, 0)));
}

op suqadd_dd( 0b0101111011100000001110[22] : rn[5] : rd[5] );

suqadd_dd.disasm = {
  sink << "suqadd\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

suqadd_dd.execute = {
  cpu.SetVS64(rd, SatAdd(cpu, cpu.GetVS64(rd, 0), cpu.GetVU64(rn, 0)));
}

op suqadd_hh( 0b0101111001100000001110[22] : rn[5] : rd[5] );

suqadd_hh.disasm = {
  sink << "suqadd\t" << DisasmH(rd) << ", " << DisasmH(rn);
};

suqadd_hh.execute = {
  cpu.SetVS16(rd, SatAdd(cpu, cpu.GetVS16(rd, 0), cpu.GetVU16(rn, 0)));
}

op suqadd_ss( 0b0101111010100000001110[22] : rn[5] : rd[5] );

suqadd_ss.disasm = {
  sink << "suqadd\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

suqadd_ss.execute = {
  cpu.SetVS32(rd, SatAdd(cpu, cpu.GetVS32(rd, 0), cpu.GetVU32(rn, 0)));
}

op suqadd_v2d2d( 0b0100111011100000001110[22] : rn[5] : rd[5] );

suqadd_v2d2d.disasm = {
  sink << "suqadd\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3);
};

suqadd_v2d2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVS64(rd, idx, SatAdd(cpu, cpu.GetVS64(rd, idx), cpu.GetVU64(rn, idx)));
    }
};

op uabal2_v2dv4sv4s( 0b01101110101[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

uabal2_v2dv4sv4s.disasm = {
  sink << "uabal2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

uabal2_v2dv4sv4s.execute = {
  typedef typename ARCH::U64 DST;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) + U64(Abs(cpu, S64(U64(cpu.GetVU32(rn, elements + idx)) - U64(cpu.GetVU32(rm, elements + idx)))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op uabal2_v4sv8hv8h( 0b01101110011[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

uabal2_v4sv8hv8h.disasm = {
  sink << "uabal2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

uabal2_v4sv8hv8h.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) + U32(Abs(cpu, S32(U32(cpu.GetVU16(rn, elements + idx)) - U32(cpu.GetVU16(rm, elements + idx)))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op uabal2_v8hv16bv16b( 0b01101110001[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

uabal2_v8hv16bv16b.disasm = {
  sink << "uabal2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

uabal2_v8hv16bv16b.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rd, idx) + U16(Abs(cpu, S16(U16(cpu.GetVU8(rn, elements + idx)) - U16(cpu.GetVU8(rm, elements + idx)))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op uabal_v2dv2sv2s( 0b00101110101[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

uabal_v2dv2sv2s.disasm = {
  sink << "uabal\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

uabal_v2dv2sv2s.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVU64(rd, idx, cpu.GetVU64(rd, idx) + U64(Abs(cpu, S64(U64(cpu.GetVU32(rn, idx)) - U64(cpu.GetVU32(rm, idx))))));
    }
}

op uabal_v4sv4hv4h( 0b00101110011[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

uabal_v4sv4hv4h.disasm = {
  sink << "uabal\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

uabal_v4sv4hv4h.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  for (unsigned idx = 0; idx < 4; ++idx)
    {
      cpu.SetVU32(rd, idx, cpu.GetVU32(rd, idx) + U32(Abs(cpu, S32(cpu.GetVU16(rn, idx)) - S32(cpu.GetVU16(rm, idx)))));
    }
}

op uabal_v8hv8bv8b( 0b00101110001[11] : rm[5] : 0b010100[6] : rn[5] : rd[5] );

uabal_v8hv8bv8b.disasm = {
  sink << "uabal\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

uabal_v8hv8bv8b.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::S16 S16;
  for (unsigned idx = 0; idx < 8; ++idx)
    {
      cpu.SetVU16(rd, idx, cpu.GetVU16(rd, idx) + U16(Abs(cpu, S16(cpu.GetVU8(rn, idx)) - S16(cpu.GetVU8(rm, idx)))));
    }
}

op uabdl2_v2dv4sv4s( 0b01101110101[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

uabdl2_v2dv4sv4s.disasm = {
  sink << "uabdl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

uabdl2_v2dv4sv4s.execute = {
  typedef typename ARCH::U64 DST;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = U64(Abs(cpu, S64(U64(cpu.GetVU32(rn, elements + idx))) - S64(U64(cpu.GetVU32(rm, elements + idx)))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op uabdl2_v4sv8hv8h( 0b01101110011[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

uabdl2_v4sv8hv8h.disasm = {
  sink << "uabdl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

uabdl2_v4sv8hv8h.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = U32(Abs(cpu, S32(U32(cpu.GetVU16(rn, elements + idx))) - S32(U32(cpu.GetVU16(rm, elements + idx)))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op uabdl2_v8hv16bv16b( 0b01101110001[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

uabdl2_v8hv16bv16b.disasm = {
  sink << "uabdl2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

uabdl2_v8hv16bv16b.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = U16(Abs(cpu, S16(U16(cpu.GetVU8(rn, elements + idx))) - S16(U16(cpu.GetVU8(rm, elements + idx)))));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op uabdl_v2dv2sv2s( 0b00101110101[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

uabdl_v2dv2sv2s.disasm = {
  sink << "uabdl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

uabdl_v2dv2sv2s.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVU64(rd, idx, U64(Abs(cpu, S64(U64(cpu.GetVU32(rn, idx))) - S64(U64(cpu.GetVU32(rm, idx))))));
    }
}

op uabdl_v4sv4hv4h( 0b00101110011[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

uabdl_v4sv4hv4h.disasm = {
  sink << "uabdl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

uabdl_v4sv4hv4h.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  for (unsigned idx = 0; idx < 4; ++idx)
    {
      cpu.SetVU32(rd, idx, U32(Abs(cpu, S32(U32(cpu.GetVU16(rn, idx))) - S32(U32(cpu.GetVU16(rm, idx))))));
    }
}

op uabdl_v8hv8bv8b( 0b00101110001[11] : rm[5] : 0b011100[6] : rn[5] : rd[5] );

uabdl_v8hv8bv8b.disasm = {
  sink << "uabdl\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

uabdl_v8hv8bv8b.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::S16 S16;
  for (unsigned idx = 0; idx < 8; ++idx)
    {
      cpu.SetVU16(rd, idx, U16(Abs(cpu, S16(U16(cpu.GetVU8(rn, idx))) - S16(U16(cpu.GetVU8(rm, idx))))));
    }
}

op uaddl2_v2dv4sv4s( 0b01101110101[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

uaddl2_v2dv4sv4s.disasm = {
  sink << "uaddl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

uaddl2_v2dv4sv4s.execute = {
  typedef typename ARCH::U64 DST;
  typedef typename ARCH::U64 U64;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = U64(cpu.GetVU32(rn, elements + idx)) + U64(cpu.GetVU32(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op uaddl2_v4sv8hv8h( 0b01101110011[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

uaddl2_v4sv8hv8h.disasm = {
  sink << "uaddl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

uaddl2_v4sv8hv8h.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U32 U32;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = U32(cpu.GetVU16(rn, elements + idx)) + U32(cpu.GetVU16(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op uaddl2_v8hv16bv16b( 0b01101110001[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

uaddl2_v8hv16bv16b.disasm = {
  sink << "uaddl2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

uaddl2_v8hv16bv16b.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U16 U16;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = U16(cpu.GetVU8(rn, elements + idx)) + U16(cpu.GetVU8(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op uaddl_v2dv2sv2s( 0b00101110101[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

uaddl_v2dv2sv2s.disasm = {
  sink << "uaddl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

uaddl_v2dv2sv2s.execute = {
  typedef typename ARCH::U64 U64;
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVU64(rd, idx, U64(cpu.GetVU32(rn, idx)) + U64(cpu.GetVU32(rm, idx)));
    }
}

op uaddl_v4sv4hv4h( 0b00101110011[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

uaddl_v4sv4hv4h.disasm = {
  sink << "uaddl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

uaddl_v4sv4hv4h.execute = {
  typedef typename ARCH::U32 U32;
  for (unsigned idx = 0; idx < 4; ++idx)
    {
      cpu.SetVU32(rd, idx, U32(cpu.GetVU16(rn, idx)) + U32(cpu.GetVU16(rm, idx)));
    }
}

op uaddl_v8hv8bv8b( 0b00101110001[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );

uaddl_v8hv8bv8b.disasm = {
  sink << "uaddl\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

uaddl_v8hv8bv8b.execute = {
  typedef typename ARCH::U16 U16;
  for (unsigned idx = 0; idx < 8; ++idx)
    {
      cpu.SetVU16(rd, idx, U16(cpu.GetVU8(rn, idx)) + U16(cpu.GetVU8(rm, idx)));
    }
}

op uaddlv_dv4s( 0b0110111010110000001110[22] : rn[5] : rd[5] );

uaddlv_dv4s.disasm = {
  sink << "uaddlv\t" << DisasmD(rd) << ", " << DisasmTV(rn, 4, 2);
};

uaddlv_dv4s.execute = {
  unsigned const elements = 4;
  typedef typename ARCH::U64 U64;
  
  U64 sum = U64(cpu.GetVU32(rn, 0));
  for (unsigned e=1; e < elements; e += 1)
    {
      sum += U64(cpu.GetVU32(rn, e));
    }
  
  cpu.SetVU64(rd, sum);
}

op uaddw2_v2dv2dv4s( 0b01101110101[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

uaddw2_v2dv2dv4s.disasm = {
  sink << "uaddw2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 4, 2);
};

uaddw2_v2dv2dv4s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rn, idx) + DST(cpu.GetVU32(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op uaddw2_v4sv4sv8h( 0b01101110011[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

uaddw2_v4sv4sv8h.disasm = {
  sink << "uaddw2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 8, 1);
};

uaddw2_v4sv4sv8h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rn, idx) + DST(cpu.GetVU16(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op uaddw2_v8hv8hv16b( 0b01101110001[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

uaddw2_v8hv8hv16b.disasm = {
  sink << "uaddw2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 16, 0);
};

uaddw2_v8hv8hv16b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rn, idx) + DST(cpu.GetVU8(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op uaddw_v2dv2dv2s( 0b00101110101[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

uaddw_v2dv2dv2s.disasm = {
  sink << "uaddw\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 2);
};

uaddw_v2dv2dv2s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rn, idx) + DST(cpu.GetVU32(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op uaddw_v4sv4sv4h( 0b00101110011[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

uaddw_v4sv4sv4h.disasm = {
  sink << "uaddw\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 1);
};

uaddw_v4sv4sv4h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rn, idx) + DST(cpu.GetVU16(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op uaddw_v8hv8hv8b( 0b00101110001[11] : rm[5] : 0b000100[6] : rn[5] : rd[5] );

uaddw_v8hv8hv8b.disasm = {
  sink << "uaddw\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 0);
};

uaddw_v8hv8hv8b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rn, idx) + DST(cpu.GetVU8(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op umlal2_v2dv4sv4s( 0b01101110101[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

umlal2_v2dv4sv4s.disasm = {
  sink << "umlal2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

umlal2_v2dv4sv4s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) + (DST(cpu.GetVU32(rn, elements + idx)) * DST(cpu.GetVU32(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umlal2_v2dv4svsi( 0b0110111110[10] : index0[1] : rm[5] : 0b0010[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
umlal2_v2dv4svsi.var index : {unsigned} = {index1|index0};

umlal2_v2dv4svsi.disasm = {
  sink << "umlal2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

umlal2_v2dv4svsi.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVU32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) + (DST(cpu.GetVU32(rn, elements + idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umlal2_v4sv8hv8h( 0b01101110011[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

umlal2_v4sv8hv8h.disasm = {
  sink << "umlal2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

umlal2_v4sv8hv8h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) + (DST(cpu.GetVU16(rn, elements + idx)) * DST(cpu.GetVU16(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umlal2_v4sv8hvhi( 0b0110111101[10] : index0[2] : rm[4] : 0b0010[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
umlal2_v4sv8hvhi.var index : {unsigned} = {index1|index0};

umlal2_v4sv8hvhi.disasm = {
  sink << "umlal2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

umlal2_v4sv8hvhi.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVU16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) + (DST(cpu.GetVU16(rn, elements + idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umlal2_v8hv16bv16b( 0b01101110001[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

umlal2_v8hv16bv16b.disasm = {
  sink << "umlal2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

umlal2_v8hv16bv16b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rd, idx) + (DST(cpu.GetVU8(rn, elements + idx)) * DST(cpu.GetVU8(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op umlal_v2dv2sv2s( 0b00101110101[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

umlal_v2dv2sv2s.disasm = {
  sink << "umlal\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

umlal_v2dv2sv2s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) + (DST(cpu.GetVU32(rn, idx)) * DST(cpu.GetVU32(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umlal_v2dv2svsi( 0b0010111110[10] : index0[1] : rm[5] : 0b0010[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
umlal_v2dv2svsi.var index : {unsigned} = {index1|index0};

umlal_v2dv2svsi.disasm = {
  sink << "umlal\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

umlal_v2dv2svsi.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVU32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) + (DST(cpu.GetVU32(rn, idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umlal_v4sv4hv4h( 0b00101110011[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

umlal_v4sv4hv4h.disasm = {
  sink << "umlal\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

umlal_v4sv4hv4h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) + (DST(cpu.GetVU16(rn, idx)) * DST(cpu.GetVU16(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umlal_v4sv4hvhi( 0b0010111101[10] : index0[2] : rm[4] : 0b0010[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
umlal_v4sv4hvhi.var index : {unsigned} = {index1|index0};

umlal_v4sv4hvhi.disasm = {
  sink << "umlal\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

umlal_v4sv4hvhi.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVU16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) + (DST(cpu.GetVU16(rn, idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umlal_v8hv8bv8b( 0b00101110001[11] : rm[5] : 0b100000[6] : rn[5] : rd[5] );

umlal_v8hv8bv8b.disasm = {
  sink << "umlal\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

umlal_v8hv8bv8b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rd, idx) + (DST(cpu.GetVU8(rn, idx)) * DST(cpu.GetVU8(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op umlsl2_v2dv4sv4s( 0b01101110101[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

umlsl2_v2dv4sv4s.disasm = {
  sink << "umlsl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

umlsl2_v2dv4sv4s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) - (DST(cpu.GetVU32(rn, elements + idx)) * DST(cpu.GetVU32(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umlsl2_v2dv4svsi( 0b0110111110[10] : index0[1] : rm[5] : 0b0110[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
umlsl2_v2dv4svsi.var index : {unsigned} = {index1|index0};

umlsl2_v2dv4svsi.disasm = {
  sink << "umlsl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

umlsl2_v2dv4svsi.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVU32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) - (DST(cpu.GetVU32(rn, elements + idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umlsl2_v4sv8hv8h( 0b01101110011[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

umlsl2_v4sv8hv8h.disasm = {
  sink << "umlsl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

umlsl2_v4sv8hv8h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) - (DST(cpu.GetVU16(rn, elements + idx)) * DST(cpu.GetVU16(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umlsl2_v4sv8hvhi( 0b0110111101[10] : index0[2] : rm[4] : 0b0110[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
umlsl2_v4sv8hvhi.var index : {unsigned} = {index1|index0};

umlsl2_v4sv8hvhi.disasm = {
  sink << "umlsl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

umlsl2_v4sv8hvhi.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVU16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) - (DST(cpu.GetVU16(rn, elements + idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umlsl2_v8hv16bv16b( 0b01101110001[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

umlsl2_v8hv16bv16b.disasm = {
  sink << "umlsl2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

umlsl2_v8hv16bv16b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rd, idx) - (DST(cpu.GetVU8(rn, elements + idx)) * DST(cpu.GetVU8(rm, elements + idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op umlsl_v2dv2sv2s( 0b00101110101[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

umlsl_v2dv2sv2s.disasm = {
  sink << "umlsl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

umlsl_v2dv2sv2s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) - (DST(cpu.GetVU32(rn, idx)) * DST(cpu.GetVU32(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umlsl_v2dv2svsi( 0b0010111110[10] : index0[1] : rm[5] : 0b0110[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
umlsl_v2dv2svsi.var index : {unsigned} = {index1|index0};

umlsl_v2dv2svsi.disasm = {
  sink << "umlsl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

umlsl_v2dv2svsi.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVU32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) - (DST(cpu.GetVU32(rn, idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umlsl_v4sv4hv4h( 0b00101110011[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

umlsl_v4sv4hv4h.disasm = {
  sink << "umlsl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

umlsl_v4sv4hv4h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) - (DST(cpu.GetVU16(rn, idx)) * DST(cpu.GetVU16(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umlsl_v4sv4hvhi( 0b0010111101[10] : index0[2] : rm[4] : 0b0110[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
umlsl_v4sv4hvhi.var index : {unsigned} = {index1|index0};

umlsl_v4sv4hvhi.disasm = {
  sink << "umlsl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

umlsl_v4sv4hvhi.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVU16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) - (DST(cpu.GetVU16(rn, idx)) * element);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umlsl_v8hv8bv8b( 0b00101110001[11] : rm[5] : 0b101000[6] : rn[5] : rd[5] );

umlsl_v8hv8bv8b.disasm = {
  sink << "umlsl\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

umlsl_v8hv8bv8b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rd, idx) - (DST(cpu.GetVU8(rn, idx)) * DST(cpu.GetVU8(rm, idx)));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

/*******************************************************************
 * UMOV
 *
 * Unsigned move vector element to general-purpose register
 */

op umov_wvb( 0b00001110000[11] : index[4] : 0b1001111[7] : rn[5] : rd[5] );

umov_wvb.disasm = {
  sink << "umov\t" << DisasmGZWR(rd) << ", " << DisasmTV(rn, 0, 0) << DisasmSubscript(index);
};

umov_wvb.execute = {
  cpu.SetGZR(rd, typename ARCH::U32( cpu.GetVU8(rn, index) ) );
};

op umov_wvh( 0b00001110000[11] : index[3] : 0b10001111[8] : rn[5] : rd[5] );

umov_wvh.disasm = {
  sink << "umov\t" << DisasmGZWR(rd) << ", " << DisasmTV(rn, 0, 1) << DisasmSubscript(index);
};

umov_wvh.execute = {
  cpu.SetGZR(rd, typename ARCH::U32( cpu.GetVU16(rn, index) ) );
};

op umov_wvs( 0b00001110000[11] : index[2] : 0b100001111[9] : rn[5] : rd[5] );

umov_wvs.disasm = {
  sink << "mov\t" << DisasmGZWR(rd) << ", " << DisasmTV(rn, 0, 2) << DisasmSubscript(index);
};

umov_wvs.execute = {
  cpu.SetGZR(rd, typename ARCH::U32( cpu.GetVU32(rn, index) ) );
};

op umov_xvd( 0b01001110000[11] : index[1] : 0b1000001111[10] : rn[5] : rd[5] );

umov_xvd.disasm = {
  sink << "mov\t" << DisasmGZXR(rd) << ", " << DisasmTV(rn, 0, 3) << DisasmSubscript(index);
};

umov_xvd.execute = {
  cpu.SetGZR(rd, cpu.GetVU64(rn, index) );
};

/*
 * end of UMOV
 *******************************************************************/

op umull2_v2dv4sv4s( 0b01101110101[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

umull2_v2dv4sv4s.disasm = {
  sink << "umull2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

umull2_v2dv4sv4s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rm, elements + idx)) * DST(cpu.GetVU32(rn, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umull2_v2dv4svsi( 0b0110111110[10] : index0[1] : rm[5] : 0b1010[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
umull2_v2dv4svsi.var index : {unsigned} = {index1|index0};

umull2_v2dv4svsi.disasm = {
  sink << "umull2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

umull2_v2dv4svsi.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVU32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rn, elements + idx)) * element;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umull2_v4sv8hv8h( 0b01101110011[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

umull2_v4sv8hv8h.disasm = {
  sink << "umull2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

umull2_v4sv8hv8h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rm, elements + idx)) * DST(cpu.GetVU16(rn, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umull2_v4sv8hvhi( 0b0110111101[10] : index0[2] : rm[4] : 0b1010[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
umull2_v4sv8hvhi.var index : {unsigned} = {index1|index0};

umull2_v4sv8hvhi.disasm = {
  sink << "umull2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

umull2_v4sv8hvhi.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVU16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rn, elements + idx)) * element;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umull2_v8hv16bv16b( 0b01101110001[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

umull2_v8hv16bv16b.disasm = {
  sink << "umull2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

umull2_v8hv16bv16b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU8(rm, elements + idx)) * DST(cpu.GetVU8(rn, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op umull_v2dv2sv2s( 0b00101110101[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

umull_v2dv2sv2s.disasm = {
  sink << "umull\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

umull_v2dv2sv2s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rm, idx)) * DST(cpu.GetVU32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umull_v2dv2svsi( 0b0010111110[10] : index0[1] : rm[5] : 0b1010[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
umull_v2dv2svsi.var index : {unsigned} = {index1|index0};

umull_v2dv2svsi.disasm = {
  sink << "umull\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

umull_v2dv2svsi.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  DST element(cpu.GetVU32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rn, idx)) * element;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op umull_v4sv4hv4h( 0b00101110011[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

umull_v4sv4hv4h.disasm = {
  sink << "umull\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

umull_v4sv4hv4h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rm, idx)) * DST(cpu.GetVU16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umull_v4sv4hvhi( 0b0010111101[10] : index0[2] : rm[4] : 0b1010[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
umull_v4sv4hvhi.var index : {unsigned} = {index1|index0};

umull_v4sv4hvhi.disasm = {
  sink << "umull\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

umull_v4sv4hvhi.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  DST element(cpu.GetVU16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rn, idx)) * element;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op umull_v8hv8bv8b( 0b00101110001[11] : rm[5] : 0b110000[6] : rn[5] : rd[5] );

umull_v8hv8bv8b.disasm = {
  sink << "umull\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

umull_v8hv8bv8b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU8(rm, idx)) * DST(cpu.GetVU8(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op uqadd_bbb( 0b01111110001[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

uqadd_bbb.disasm = {
  sink << "uqadd\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmB(rm);
};

uqadd_bbb.execute = {
  cpu.SetVU8(rd, SatAdd(cpu, cpu.GetVU8(rn, 0), cpu.GetVU8(rm, 0)));
}

op uqadd_ddd( 0b01111110111[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

uqadd_ddd.disasm = {
  sink << "uqadd\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

uqadd_ddd.execute = {
  cpu.SetVU64(rd, SatAdd(cpu, cpu.GetVU64(rn, 0), cpu.GetVU64(rm, 0)));
}

op uqadd_hhh( 0b01111110011[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

uqadd_hhh.disasm = {
  sink << "uqadd\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

uqadd_hhh.execute = {
  cpu.SetVU16(rd, SatAdd(cpu, cpu.GetVU16(rn, 0), cpu.GetVU16(rm, 0)));
}

op uqadd_sss( 0b01111110101[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

uqadd_sss.disasm = {
  sink << "uqadd\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

uqadd_sss.execute = {
  cpu.SetVU32(rd, SatAdd(cpu, cpu.GetVU32(rn, 0), cpu.GetVU32(rm, 0)));
}

op uqadd_v2dv2dv2d( 0b01101110111[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

uqadd_v2dv2dv2d.disasm = {
  sink << "uqadd\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

uqadd_v2dv2dv2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVU64(rd, idx, SatAdd(cpu, cpu.GetVU64(rn, idx), cpu.GetVU64(rm, idx)));
    }
};

op uqrshl_bbb( 0b01111110001[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

uqrshl_bbb.disasm = {
  sink << "uqrshl\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmB(rm);
};

uqrshl_bbb.execute = {
  cpu.SetVU8(rd, NeonSHL(cpu, cpu.GetVU8(rn, 0), cpu.GetVS8(rm, 0), /* round */ true, /* sat */ true));
}

op uqrshl_ddd( 0b01111110111[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

uqrshl_ddd.disasm = {
  sink << "uqrshl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

uqrshl_ddd.execute = {
  cpu.SetVU64(rd, NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(cpu.GetVS64(rm, 0)), /* round */ true, /* sat */ true));
}

op uqrshl_hhh( 0b01111110011[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

uqrshl_hhh.disasm = {
  sink << "uqrshl\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

uqrshl_hhh.execute = {
  cpu.SetVU16(rd, NeonSHL(cpu, cpu.GetVU16(rn, 0), typename ARCH::S8(cpu.GetVS16(rm, 0)), /* round */ true, /* sat */ true));
}

op uqrshl_sss( 0b01111110101[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

uqrshl_sss.disasm = {
  sink << "uqrshl\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

uqrshl_sss.execute = {
  cpu.SetVU32(rd, NeonSHL(cpu, cpu.GetVU32(rn, 0), typename ARCH::S8(cpu.GetVS32(rm, 0)), /* round */ true, /* sat */ true));
}

op uqrshl_v2dv2dv2d( 0b01101110111[11] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

uqrshl_v2dv2dv2d.disasm = {
  sink << "uqrshl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

uqrshl_v2dv2dv2d.execute = {
  typedef typename ARCH::S8 S8;
  
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU64(rd, idx, NeonSHL(cpu, cpu.GetVU64(rn, idx), S8(cpu.GetVS64(rm, idx)), /* round */ true, /* sat */ true));
    }
}

op uqrshrn2_v16b8hi( 0b0110111100001[13] : lro[3] : 0b100111[6] : rn[5] : rd[5] );
uqrshrn2_v16b8hi.var shift : {unsigned} = {8 - lro};

uqrshrn2_v16b8hi.disasm = {
  sink << "uqrshrn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

uqrshrn2_v16b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU16(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, elements + idx, res[idx]);
    }
}

op uqrshrn2_v4s2di( 0b01101111001[11] : lro[5] : 0b100111[6] : rn[5] : rd[5] );
uqrshrn2_v4s2di.var shift : {unsigned} = {32 - lro};

uqrshrn2_v4s2di.disasm = {
  sink << "uqrshrn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

uqrshrn2_v4s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU64(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, elements + idx, res[idx]);
    }
}

op uqrshrn2_v8h4si( 0b011011110001[12] : lro[4] : 0b100111[6] : rn[5] : rd[5] );
uqrshrn2_v8h4si.var shift : {unsigned} = {16 - lro};

uqrshrn2_v8h4si.disasm = {
  sink << "uqrshrn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

uqrshrn2_v8h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU32(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, elements + idx, res[idx]);
    }
}

op uqrshrn_bhi( 0b0111111100001[13] : lro[3] : 0b100111[6] : rn[5] : rd[5] );
uqrshrn_bhi.var shift : {unsigned} = {8 - lro};

uqrshrn_bhi.disasm = {
  sink << "uqrshrn\t" << DisasmB(rd) << ", " << DisasmH(rn) << ", " << DisasmI(shift);
};

uqrshrn_bhi.execute = {
  cpu.SetVU8(rd, SatNarrow<typename ARCH::U8>(cpu, NeonSHL(cpu, cpu.GetVU16(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ true)));
}

op uqrshrn_hsi( 0b011111110001[12] : lro[4] : 0b100111[6] : rn[5] : rd[5] );
uqrshrn_hsi.var shift : {unsigned} = {16 - lro};

uqrshrn_hsi.disasm = {
  sink << "uqrshrn\t" << DisasmH(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

uqrshrn_hsi.execute = {
  cpu.SetVU16(rd, SatNarrow<typename ARCH::U16>(cpu, NeonSHL(cpu, cpu.GetVU32(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ true)));
}

op uqrshrn_sdi( 0b01111111001[11] : lro[5] : 0b100111[6] : rn[5] : rd[5] );
uqrshrn_sdi.var shift : {unsigned} = {32 - lro};

uqrshrn_sdi.disasm = {
  sink << "uqrshrn\t" << DisasmS(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

uqrshrn_sdi.execute = {
  cpu.SetVU32(rd, SatNarrow<typename ARCH::U32>(cpu, NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ true)));
}

op uqrshrn_v2s2di( 0b00101111001[11] : lro[5] : 0b100111[6] : rn[5] : rd[5] );
uqrshrn_v2s2di.var shift : {unsigned} = {32 - lro};

uqrshrn_v2s2di.disasm = {
  sink << "uqrshrn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

uqrshrn_v2s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU64(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op uqrshrn_v4h4si( 0b001011110001[12] : lro[4] : 0b100111[6] : rn[5] : rd[5] );
uqrshrn_v4h4si.var shift : {unsigned} = {16 - lro};

uqrshrn_v4h4si.disasm = {
  sink << "uqrshrn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

uqrshrn_v4h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU32(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op uqrshrn_v8b8hi( 0b0010111100001[13] : lro[3] : 0b100111[6] : rn[5] : rd[5] );
uqrshrn_v8b8hi.var shift : {unsigned} = {8 - lro};

uqrshrn_v8b8hi.disasm = {
  sink << "uqrshrn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

uqrshrn_v8b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU16(rn, idx), typename ARCH::S8(-shift), /* round */ true, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op uqshl_bbb( 0b01111110001[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

uqshl_bbb.disasm = {
  sink << "uqshl\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmB(rm);
};

uqshl_bbb.execute = {
  cpu.SetVU8(rd, NeonSHL(cpu, cpu.GetVU8(rn, 0), cpu.GetVS8(rm, 0), /* round */ false, /* sat */ true));
}

op uqshl_bbi( 0b0111111100001[13] : shift[3] : 0b011101[6] : rn[5] : rd[5] );

uqshl_bbi.disasm = {
  sink << "uqshl\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmI(shift);
};

uqshl_bbi.execute = {
  cpu.SetVU8(rd, NeonSHL(cpu, cpu.GetVU8(rn, 0), typename ARCH::S8(shift), /* round */ false, /* sat */ true));
}

op uqshl_ddd( 0b01111110111[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

uqshl_ddd.disasm = {
  sink << "uqshl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

uqshl_ddd.execute = {
  cpu.SetVU64(rd, NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(cpu.GetVS64(rm, 0)), /* round */ false, /* sat */ true));
}

op uqshl_ddi( 0b0111111101[10] : shift[6] : 0b011101[6] : rn[5] : rd[5] );

uqshl_ddi.disasm = {
  sink << "uqshl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

uqshl_ddi.execute = {
  cpu.SetVU64(rd, NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(shift), /* round */ false, /* sat */ true));
}

op uqshl_hhh( 0b01111110011[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

uqshl_hhh.disasm = {
  sink << "uqshl\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

uqshl_hhh.execute = {
  cpu.SetVU16(rd, NeonSHL(cpu, cpu.GetVU16(rn, 0), typename ARCH::S8(cpu.GetVS16(rm, 0)), /* round */ false, /* sat */ true));
}

op uqshl_hhi( 0b011111110001[12] : shift[4] : 0b011101[6] : rn[5] : rd[5] );

uqshl_hhi.disasm = {
  sink << "uqshl\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmI(shift);
};

uqshl_hhi.execute = {
  cpu.SetVU16(rd, NeonSHL(cpu, cpu.GetVU16(rn, 0), typename ARCH::S8(shift), /* round */ false, /* sat */ true));
}

op uqshl_ssi( 0b01111111001[11] : shift[5] : 0b011101[6] : rn[5] : rd[5] );

uqshl_ssi.disasm = {
  sink << "uqshl\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

uqshl_ssi.execute = {
  cpu.SetVU32(rd, NeonSHL(cpu, cpu.GetVU32(rn, 0), typename ARCH::S8(shift), /* round */ false, /* sat */ true));
}

op uqshl_sss( 0b01111110101[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

uqshl_sss.disasm = {
  sink << "uqshl\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

uqshl_sss.execute = {
  cpu.SetVU32(rd, NeonSHL(cpu, cpu.GetVU32(rn, 0), typename ARCH::S8(cpu.GetVS32(rm, 0)), /* round */ false, /* sat */ true));
}

op uqshl_v2d2di( 0b0110111101[10] : imm[6] : 0b011101[6] : rn[5] : rd[5] );

uqshl_v2d2di.disasm = {
  sink << "uqshl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(imm);
};

uqshl_v2d2di.execute = {
  typedef typename ARCH::S8 S8;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU64(rd, idx, NeonSHL(cpu, cpu.GetVU64(rn, idx), S8(imm), /* round */ false, /* sat */ true));
    }
}

op uqshl_v2dv2dv2d( 0b01101110111[11] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

uqshl_v2dv2dv2d.disasm = {
  sink << "uqshl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

uqshl_v2dv2dv2d.execute = {
  typedef typename ARCH::S8 S8;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU64(rd, idx, NeonSHL(cpu, cpu.GetVU64(rn, idx), S8(cpu.GetVS64(rm, idx)), /* round */ false, /* sat */ true));
    }
}

op uqshrn2_v16b8hi( 0b0110111100001[13] : lro[3] : 0b100101[6] : rn[5] : rd[5] );
uqshrn2_v16b8hi.var shift : {unsigned} = {8 - lro};

uqshrn2_v16b8hi.disasm = {
  sink << "uqshrn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

uqshrn2_v16b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU16(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, elements + idx, res[idx]);
    }
}

op uqshrn2_v4s2di( 0b01101111001[11] : lro[5] : 0b100101[6] : rn[5] : rd[5] );
uqshrn2_v4s2di.var shift : {unsigned} = {32 - lro};

uqshrn2_v4s2di.disasm = {
  sink << "uqshrn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

uqshrn2_v4s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU64(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, elements + idx, res[idx]);
    }
}

op uqshrn2_v8h4si( 0b011011110001[12] : lro[4] : 0b100101[6] : rn[5] : rd[5] );
uqshrn2_v8h4si.var shift : {unsigned} = {16 - lro};

uqshrn2_v8h4si.disasm = {
  sink << "uqshrn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

uqshrn2_v8h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU32(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, elements + idx, res[idx]);
    }
}

op uqshrn_bhi( 0b0111111100001[13] : lro[3] : 0b100101[6] : rn[5] : rd[5] );
uqshrn_bhi.var shift : {unsigned} = {8 - lro};

uqshrn_bhi.disasm = {
  sink << "uqshrn\t" << DisasmB(rd) << ", " << DisasmH(rn) << ", " << DisasmI(shift);
};

uqshrn_bhi.execute = {
  cpu.SetVU8(rd, SatNarrow<typename ARCH::U8>(cpu, NeonSHL(cpu, cpu.GetVU16(rn, 0), typename ARCH::S8(-shift), /* round */ false, /* sat */ true)));
}

op uqshrn_hsi( 0b011111110001[12] : lro[4] : 0b100101[6] : rn[5] : rd[5] );
uqshrn_hsi.var shift : {unsigned} = {16 - lro};

uqshrn_hsi.disasm = {
  sink << "uqshrn\t" << DisasmH(rd) << ", " << DisasmS(rn) << ", " << DisasmI(shift);
};

uqshrn_hsi.execute = {
  cpu.SetVU16(rd, SatNarrow<typename ARCH::U16>(cpu, NeonSHL(cpu, cpu.GetVU32(rn, 0), typename ARCH::S8(-shift), /* round */ false, /* sat */ true)));
}

op uqshrn_sdi( 0b01111111001[11] : lro[5] : 0b100101[6] : rn[5] : rd[5] );
uqshrn_sdi.var shift : {unsigned} = {32 - lro};

uqshrn_sdi.disasm = {
  sink << "uqshrn\t" << DisasmS(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

uqshrn_sdi.execute = {
  cpu.SetVU32(rd, SatNarrow<typename ARCH::U32>(cpu, NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(-shift), /* round */ false, /* sat */ true)));
}

op uqshrn_v2s2di( 0b00101111001[11] : lro[5] : 0b100101[6] : rn[5] : rd[5] );
uqshrn_v2s2di.var shift : {unsigned} = {32 - lro};

uqshrn_v2s2di.disasm = {
  sink << "uqshrn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

uqshrn_v2s2di.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU64(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op uqshrn_v4h4si( 0b001011110001[12] : lro[4] : 0b100101[6] : rn[5] : rd[5] );
uqshrn_v4h4si.var shift : {unsigned} = {16 - lro};

uqshrn_v4h4si.disasm = {
  sink << "uqshrn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmI(shift);
};

uqshrn_v4h4si.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU32(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op uqshrn_v8b8hi( 0b0010111100001[13] : lro[3] : 0b100101[6] : rn[5] : rd[5] );
uqshrn_v8b8hi.var shift : {unsigned} = {8 - lro};

uqshrn_v8b8hi.disasm = {
  sink << "uqshrn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmI(shift);
};

uqshrn_v8b8hi.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, cpu.GetVU16(rn, idx), typename ARCH::S8(-shift), /* round */ false, /* sat */ true));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op uqsub_bbb( 0b01111110001[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

uqsub_bbb.disasm = {
  sink << "uqsub\t" << DisasmB(rd) << ", " << DisasmB(rn) << ", " << DisasmB(rm);
};

uqsub_bbb.execute = {
  cpu.SetVU8(rd, SatSub(cpu, cpu.GetVU8(rn, 0), cpu.GetVU8(rm, 0)));
}

op uqsub_ddd( 0b01111110111[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

uqsub_ddd.disasm = {
  sink << "uqsub\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

uqsub_ddd.execute = {
  cpu.SetVU64(rd, SatSub(cpu, cpu.GetVU64(rn, 0), cpu.GetVU64(rm, 0)));
}

op uqsub_hhh( 0b01111110011[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

uqsub_hhh.disasm = {
  sink << "uqsub\t" << DisasmH(rd) << ", " << DisasmH(rn) << ", " << DisasmH(rm);
};

uqsub_hhh.execute = {
  cpu.SetVU16(rd, SatSub(cpu, cpu.GetVU16(rn, 0), cpu.GetVU16(rm, 0)));
}

op uqsub_sss( 0b01111110101[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

uqsub_sss.disasm = {
  sink << "uqsub\t" << DisasmS(rd) << ", " << DisasmS(rn) << ", " << DisasmS(rm);
};

uqsub_sss.execute = {
  cpu.SetVU32(rd, SatSub(cpu, cpu.GetVU32(rn, 0), cpu.GetVU32(rm, 0)));
}

op uqsub_v2dv2dv2d( 0b01101110111[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

uqsub_v2dv2dv2d.disasm = {
  sink << "uqsub\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

uqsub_v2dv2dv2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVU64(rd, idx, SatSub(cpu, cpu.GetVU64(rn, idx), cpu.GetVU64(rm, idx)));
    }
};

op uqxtn2_v16b8h( 0b0110111000100001010010[22] : rn[5] : rd[5] );

uqxtn2_v16b8h.disasm = {
  sink << "uqxtn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1);
};

uqxtn2_v16b8h.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVU16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, elements + idx, res[idx]);
    }
}

op uqxtn2_v4s2d( 0b0110111010100001010010[22] : rn[5] : rd[5] );

uqxtn2_v4s2d.disasm = {
  sink << "uqxtn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3);
};

uqxtn2_v4s2d.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu , cpu.GetVU64(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, elements + idx, res[idx]);
    }
}

op uqxtn2_v8h4s( 0b0110111001100001010010[22] : rn[5] : rd[5] );

uqxtn2_v8h4s.disasm = {
  sink << "uqxtn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2);
};

uqxtn2_v8h4s.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVU32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, elements + idx, res[idx]);
    }
}

op uqxtn_bh( 0b0111111000100001010010[22] : rn[5] : rd[5] );

uqxtn_bh.disasm = {
  sink << "uqxtn\t" << DisasmB(rd) << ", " << DisasmH(rn);
};

uqxtn_bh.execute = {
  cpu.SetVU8(rd, SatNarrow<typename ARCH::U8>(cpu, cpu.GetVU16(rn, 0)));
}

op uqxtn_hs( 0b0111111001100001010010[22] : rn[5] : rd[5] );

uqxtn_hs.disasm = {
  sink << "uqxtn\t" << DisasmH(rd) << ", " << DisasmS(rn);
};

uqxtn_hs.execute = {
  cpu.SetVU16(rd, SatNarrow<typename ARCH::U16>(cpu, cpu.GetVU32(rn, 0)));
}

op uqxtn_sd( 0b0111111010100001010010[22] : rn[5] : rd[5] );

uqxtn_sd.disasm = {
  sink << "uqxtn\t" << DisasmS(rd) << ", " << DisasmD(rn);
};

uqxtn_sd.execute = {
  cpu.SetVU32(rd, SatNarrow<typename ARCH::U32>(cpu, cpu.GetVU64(rn, 0)));
}

op uqxtn_v2s2d( 0b0010111010100001010010[22] : rn[5] : rd[5] );

uqxtn_v2s2d.disasm = {
  sink << "uqxtn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3);
};

uqxtn_v2s2d.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVU64(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op uqxtn_v4h4s( 0b0010111001100001010010[22] : rn[5] : rd[5] );

uqxtn_v4h4s.disasm = {
  sink << "uqxtn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2);
};

uqxtn_v4h4s.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVU32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op uqxtn_v8b8h( 0b0010111000100001010010[22] : rn[5] : rd[5] );

uqxtn_v8b8h.disasm = {
  sink << "uqxtn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1);
};

uqxtn_v8b8h.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, cpu.GetVU16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op urshl_ddd( 0b01111110111[11] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

urshl_ddd.disasm = {
  sink << "urshl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

urshl_ddd.execute = {
  typedef typename ARCH::S8 S8;
  cpu.SetVU64(rd, NeonSHL(cpu, cpu.GetVU64(rn, 0), S8(cpu.GetVS64(rm, 0)), /* round */ true, /* sat */ false));
}

op urshl_v2dv2dv2d( 0b01101110111[11] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

urshl_v2dv2dv2d.disasm = {
  sink << "urshl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

urshl_v2dv2dv2d.execute = {
  typedef typename ARCH::S8 S8;
  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      cpu.SetVU64(rd, idx, NeonSHL(cpu, cpu.GetVU64(rn, idx), S8(cpu.GetVS64(rm, idx)), /* round */ true, /* sat */ false));
    }
}

op urshr_ddi( 0b0111111101[10] : lro[6] : 0b001001[6] : rn[5] : rd[5] );
urshr_ddi.var shift : {unsigned} = {64 - lro};

urshr_ddi.disasm = {
  sink << "urshr\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

urshr_ddi.execute = {
  cpu.SetVU64(rd, NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ false));
}

op ursra_ddi( 0b0111111101[10] : lro[6] : 0b001101[6] : rn[5] : rd[5] );
ursra_ddi.var shift : {unsigned} = {64 - lro};

ursra_ddi.disasm = {
  sink << "ursra\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

ursra_ddi.execute = {
  cpu.SetVU64(rd, cpu.GetVU64(rd, 0) + NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(-shift), /* round */ true, /* sat */ false));
}

op ushr_ddi( 0b0111111101[10] : lro[6] : 0b000001[6] : rn[5] : rd[5] );
ushr_ddi.var shift : {unsigned} = {64 - lro};

ushr_ddi.disasm = {
  sink << "ushr\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

ushr_ddi.execute = {
  cpu.SetVU64(rd, NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(-shift)));
}

op usqadd_bb( 0b0111111000100000001110[22] : rn[5] : rd[5] );

usqadd_bb.disasm = {
  sink << "usqadd\t" << DisasmB(rd) << ", " << DisasmB(rn);
};

usqadd_bb.execute = {
  cpu.SetVU8(rd, SatAdd(cpu, cpu.GetVU8(rd, 0), cpu.GetVS8(rn, 0)));
}

op usqadd_dd( 0b0111111011100000001110[22] : rn[5] : rd[5] );

usqadd_dd.disasm = {
  sink << "usqadd\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

usqadd_dd.execute = {
  cpu.SetVU64(rd, SatAdd(cpu, cpu.GetVU64(rd, 0), cpu.GetVS64(rn, 0)));
}

op usqadd_hh( 0b0111111001100000001110[22] : rn[5] : rd[5] );

usqadd_hh.disasm = {
  sink << "usqadd\t" << DisasmH(rd) << ", " << DisasmH(rn);
};

usqadd_hh.execute = {
  cpu.SetVU16(rd, SatAdd(cpu, cpu.GetVU16(rd, 0), cpu.GetVS16(rn, 0)));
}

op usqadd_ss( 0b0111111010100000001110[22] : rn[5] : rd[5] );

usqadd_ss.disasm = {
  sink << "usqadd\t" << DisasmS(rd) << ", " << DisasmS(rn);
};

usqadd_ss.execute = {
  cpu.SetVU32(rd, SatAdd(cpu, cpu.GetVU32(rd, 0), cpu.GetVS32(rn, 0)));
}

op usqadd_v2d2d( 0b0110111011100000001110[22] : rn[5] : rd[5] );

usqadd_v2d2d.disasm = {
  sink << "usqadd\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3);
};

usqadd_v2d2d.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVU64(rd, idx, SatAdd(cpu, cpu.GetVU64(rd, idx), cpu.GetVS64(rn, idx)));
    }
};

op usra_ddi( 0b0111111101[10] : lro[6] : 0b000101[6] : rn[5] : rd[5] );
usra_ddi.var shift : {unsigned} = {64 - lro};

usra_ddi.disasm = {
  sink << "usra\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

usra_ddi.execute = {
  cpu.SetVU64(rd, cpu.GetVU64(rd, 0) + NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(-shift)));
}

op usubl2_v2dv4sv4s( 0b01101110101[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

usubl2_v2dv4sv4s.disasm = {
  sink << "usubl2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 2);
};

usubl2_v2dv4sv4s.execute = {
  typedef typename ARCH::U64 DST;
  typedef typename ARCH::U64 U64;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = U64(cpu.GetVU32(rn, elements + idx)) - U64(cpu.GetVU32(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op usubl2_v4sv8hv8h( 0b01101110011[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

usubl2_v4sv8hv8h.disasm = {
  sink << "usubl2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 1);
};

usubl2_v4sv8hv8h.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U32 U32;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = U32(cpu.GetVU16(rn, elements + idx)) - U32(cpu.GetVU16(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op usubl2_v8hv16bv16b( 0b01101110001[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

usubl2_v8hv16bv16b.disasm = {
  sink << "usubl2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 16, 0) << ", " << DisasmTV(rm, 16, 0);
};

usubl2_v8hv16bv16b.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U16 U16;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = U16(cpu.GetVU8(rn, elements + idx)) - U16(cpu.GetVU8(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op usubl_v2dv2sv2s( 0b00101110101[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

usubl_v2dv2sv2s.disasm = {
  sink << "usubl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 2) << ", " << DisasmTV(rm, 2, 2);
};

usubl_v2dv2sv2s.execute = {
  typedef typename ARCH::U64 U64;
  for (unsigned idx = 0; idx < 2; ++idx)
    {
      cpu.SetVU64(rd, idx, U64(cpu.GetVU32(rn, idx)) - U64(cpu.GetVU32(rm, idx)));
    }
}

op usubl_v4sv4hv4h( 0b00101110011[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

usubl_v4sv4hv4h.disasm = {
  sink << "usubl\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 1) << ", " << DisasmTV(rm, 4, 1);
};

usubl_v4sv4hv4h.execute = {
  typedef typename ARCH::U32 U32;
  for (unsigned idx = 0; idx < 4; ++idx)
    {
      cpu.SetVU32(rd, idx, U32(cpu.GetVU16(rn, idx)) - U32(cpu.GetVU16(rm, idx)));
    }
}

op usubl_v8hv8bv8b( 0b00101110001[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );

usubl_v8hv8bv8b.disasm = {
  sink << "usubl\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 0) << ", " << DisasmTV(rm, 8, 0);
};

usubl_v8hv8bv8b.execute = {
  typedef typename ARCH::U16 U16;
  for (unsigned idx = 0; idx < 8; ++idx)
    {
      cpu.SetVU16(rd, idx, U16(cpu.GetVU8(rn, idx)) - U16(cpu.GetVU8(rm, idx)));
    }
}

op usubw2_v2dv2dv4s( 0b01101110101[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

usubw2_v2dv2dv4s.disasm = {
  sink << "usubw2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 4, 2);
};

usubw2_v2dv2dv4s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rn, idx) - DST(cpu.GetVU32(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op usubw2_v4sv4sv8h( 0b01101110011[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

usubw2_v4sv4sv8h.disasm = {
  sink << "usubw2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 8, 1);
};

usubw2_v4sv4sv8h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rn, idx) - DST(cpu.GetVU16(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op usubw2_v8hv8hv16b( 0b01101110001[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

usubw2_v8hv8hv16b.disasm = {
  sink << "usubw2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 16, 0);
};

usubw2_v8hv8hv16b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rn, idx) - DST(cpu.GetVU8(rm, elements + idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op usubw_v2dv2dv2s( 0b00101110101[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

usubw_v2dv2dv2s.disasm = {
  sink << "usubw\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 2);
};

usubw_v2dv2dv2s.execute = {
  typedef typename ARCH::U64 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rn, idx) - DST(cpu.GetVU32(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op usubw_v4sv4sv4h( 0b00101110011[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

usubw_v4sv4sv4h.disasm = {
  sink << "usubw\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4, 2) << ", " << DisasmTV(rm, 4, 1);
};

usubw_v4sv4sv4h.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rn, idx) - DST(cpu.GetVU16(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
}

op usubw_v8hv8hv8b( 0b00101110001[11] : rm[5] : 0b001100[6] : rn[5] : rd[5] );

usubw_v8hv8hv8b.disasm = {
  sink << "usubw\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8, 1) << ", " << DisasmTV(rm, 8, 0);
};

usubw_v8hv8hv8b.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rn, idx) - DST(cpu.GetVU8(rm, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
}

op uzp1_v2dv2dv2d( 0b01001110110[11] : rm[5] : 0b000110[6] : rn[5] : rd[5] );

uzp1_v2dv2dv2d.disasm = {
  sink << "uzp1\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

uzp1_v2dv2dv2d.execute = {
  typedef typename ARCH::U64 DST;

  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0, srcidx = 0; idx < (elements/2); ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU64(rn, srcidx);
    }
  for (unsigned idx = elements/2, srcidx = 0; idx < elements; ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU64(rm, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op uzp2_v2dv2dv2d( 0b01001110110[11] : rm[5] : 0b010110[6] : rn[5] : rd[5] );

uzp2_v2dv2dv2d.disasm = {
  sink << "uzp2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

uzp2_v2dv2dv2d.execute = {
  typedef typename ARCH::U64 DST;

  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0, srcidx = 1; idx < (elements/2); ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU64(rn, srcidx);
    }
  for (unsigned idx = elements/2, srcidx = 1; idx < elements; ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU64(rm, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op uzp2_vhvhvh( 0b0[1] : q[1] : 0b001110010[9] : rm[5] : 0b010110[6] : rn[5] : rd[5] );

uzp2_vhvhvh.disasm = {
  sink << "uzp2\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uzp2_vhvhvh.execute = {
  typedef typename ARCH::U16 DST;

  unsigned const elements = 4<<q;
  DST res[elements];
  for (unsigned idx = 0, srcidx = 1; idx < (elements/2); ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU16(rn, srcidx);
    }
  for (unsigned idx = elements/2, srcidx = 1; idx < elements; ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU16(rm, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op xtn2_v16b8h( 0b0100111000100001001010[22] : rn[5] : rd[5] );

xtn2_v16b8h.disasm = {
  sink << "xtn2\t" << DisasmTV(rd, 16, 0) << ", " << DisasmTV(rn, 8, 1);
};

xtn2_v16b8h.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, elements + idx, res[idx]);
    }
}

op xtn2_v8h4s( 0b0100111001100001001010[22] : rn[5] : rd[5] );

xtn2_v8h4s.disasm = {
  sink << "xtn2\t" << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 4, 2);
};

xtn2_v8h4s.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, elements + idx, res[idx]);
    }
}

op xtn2_v4s2d( 0b0100111010100001001010[22] : rn[5] : rd[5] );

xtn2_v4s2d.disasm = {
  sink << "xtn2\t" << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 2, 3);
};

xtn2_v4s2d.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU64(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, elements + idx, res[idx]);
    }
}

op xtn_v2s2d( 0b0000111010100001001010[22] : rn[5] : rd[5] );

xtn_v2s2d.disasm = {
  sink << "xtn\t" << DisasmTV(rd, 2, 2) << ", " << DisasmTV(rn, 2, 3);
};

xtn_v2s2d.execute = {
  typedef typename ARCH::U32 DST;
  unsigned const elements = 2;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU64(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op xtn_v4h4s( 0b0000111001100001001010[22] : rn[5] : rd[5] );

xtn_v4h4s.disasm = {
  sink << "xtn\t" << DisasmTV(rd, 4, 1) << ", " << DisasmTV(rn, 4, 2);
};

xtn_v4h4s.execute = {
  typedef typename ARCH::U16 DST;
  unsigned const elements = 4;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op xtn_v8b8h( 0b0000111000100001001010[22] : rn[5] : rd[5] );

xtn_v8b8h.disasm = {
  sink << "xtn\t" << DisasmTV(rd, 8, 0) << ", " << DisasmTV(rn, 8, 1);
};

xtn_v8b8h.execute = {
  typedef typename ARCH::U8 DST;
  unsigned const elements = 8;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rn, idx));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8);
}

op zip1_v2dv2dv2d( 0b01001110110[11] : rm[5] : 0b001110[6] : rn[5] : rd[5] );

zip1_v2dv2dv2d.disasm = {
  sink << "zip1\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

zip1_v2dv2dv2d.execute = {
  typedef typename ARCH::U64 DST;

  unsigned const elements = 2;
  DST res[elements];
  for( unsigned idx = 0; idx < elements; ++idx)
    {
      unsigned srcidx = idx / 2;
      res[idx] = cpu.GetVU64((idx & 1) ? rm : rn, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op zip2_v2dv2dv2d( 0b01001110110[11] : rm[5] : 0b011110[6] : rn[5] : rd[5] );

zip2_v2dv2dv2d.disasm = {
  sink << "zip2\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

zip2_v2dv2dv2d.execute = {
  typedef typename ARCH::U64 DST;

  unsigned const elements = 2;
  DST res[elements];
  for( unsigned idx = 0; idx < elements; ++idx)
    {
      unsigned srcidx = (idx / 2) + (elements / 2);
      res[idx] = cpu.GetVU64((idx & 1) ? rm : rn, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
}

op orr_vbvbvb( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b000111[6] : rn[5] : rd[5] );

orr_vbvbvb.disasm = {
  if (rn == rm)
    sink << "mov\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
  else
    sink << "orr\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

orr_vbvbvb.execute = {
  for (unsigned idx = 0, end=8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, cpu.GetVU8(rn, idx) | cpu.GetVU8(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op and_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b000111[6] : rn[5] : rd[5] );

and_vbvbvb.disasm = {
  sink << "and\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

and_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, cpu.GetVU8(rn, idx) & cpu.GetVU8(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

/*******************************************************************
 * BIC (vector, register)
 *
 * Bitwise bit Clear (vector, register).
 */

op bic_vbvbvb( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b000111[6] : rn[5] : rd[5] );

bic_vbvbvb.disasm = {
  sink << "bic\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

bic_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, cpu.GetVU8(rn, idx) & ~cpu.GetVU8(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of BIC (vector, register)
 *******************************************************************/

/*******************************************************************
 * BIC (vector, immediate)
 *
 * Bitwise bit Clear (vector, immediate).
 */

op bic_vhi( 0b0[1] : q[1] : 0b10111100000[11] : shl<5> imm1[3] : 0b10[2] : shl<3> sh[1] : 0b101[3] : imm0[5] : rd[5] );
bic_vhi.var imm : {uint16_t} = {uint16_t(imm1|imm0) << sh};

bic_vhi.disasm = {
  sink << "bic\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmI(int16_t(imm >> sh)) << ", lsl #" << +sh;
};

bic_vhi.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, cpu.GetVU16(rd, idx) & typename ARCH::U16(~imm));

  cpu.ClearHighV(rd, 8<<q);
};

op bic_vsi( 0b0[1] : q[1] : 0b10111100000[11] : shl<5> imm1[3] : 0b0[1] : shl<3> sh[2] : 0b101[3] : imm0[5] : rd[5] );
bic_vsi.var imm : {uint32_t} = {uint32_t(imm1|imm0) << sh};

bic_vsi.disasm = {
  sink << "bic\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmI(int32_t(imm >> sh)) << ", lsl #" << +sh;
};

bic_vsi.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, cpu.GetVU32(rd, idx) & typename ARCH::U32(~imm));

  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of BIC (vector, immediate)
 *******************************************************************/

/*******************************************************************
 * BIT, BIF and BSL
 *
 * Bitwise Insert if Condition and Bitwise Select.
 */

op bit( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b000111[6] : rn[5] : rd[5] );

bit.disasm = {
  sink << "bit\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

bit.execute = {
  // Working on 64 bits since the byte nature is irrelevant (TODO: respect the native type ? ... bitvector ?)
  for (unsigned e=0, end=1<<q; e < end; ++e)
    {
      typename ARCH::U64 sel = cpu.GetVU64(rm, e);
      cpu.SetVU64(rd, e, (cpu.GetVU64(rn, e) & sel) | (cpu.GetVU64(rd, e) & ~sel));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op bif( 0b0[1] : q[1] : 0b101110111[9] : rm[5] : 0b000111[6] : rn[5] : rd[5] );

bif.disasm = {
  sink << "bif\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

bif.execute = {
  // Working on 64 bits since the byte nature is irrelevant (TODO: respect the native type ? ... bitvector ?)
  for (unsigned e=0, end=1<<q; e < end; ++e)
    {
      typename ARCH::U64 sel = cpu.GetVU64(rm, e);
      cpu.SetVU64(rd, e, (cpu.GetVU64(rd, e) & sel) | (cpu.GetVU64(rn, e) & ~sel));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op bsl( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b000111[6] : rn[5] : rd[5] );

bsl.disasm = {
  sink << "bsl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

bsl.execute = {
  // Working on 64 bits since the byte nature is irrelevant (TODO: respect the native type ? ... bitvector ?)
  for (unsigned e=0, end=1<<q; e < end; ++e)
    {
      typename ARCH::U64 sel = cpu.GetVU64(rd, e);
      cpu.SetVU64(rd, e, (cpu.GetVU64(rn, e) & sel) | (cpu.GetVU64(rm, e) & ~sel));
    }
  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of BIT, BIF and BSL
 *******************************************************************/

op cls_vbb( 0b0[1] : q[1] : 0b00111000100000010010[20] : rn[5] : rd[5] );

cls_vbb.disasm = {
  sink << "cls\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

cls_vbb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      U8 val( cpu.GetVU8(rn, idx) );
      val = val ^ U8(S8(val) >> 1);

      if (cpu.Test( val == U8(0) ))
        val = U8(7);
      else
        val = U8(6) - BitScanReverse( val );

      cpu.SetVU8(rd, idx, val);
    }

  cpu.ClearHighV(rd, 8<<q);
}

op cls_vhh( 0b0[1] : q[1] : 0b00111001100000010010[20] : rn[5] : rd[5] );

cls_vhh.disasm = {
  sink << "cls\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

cls_vhh.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::S16 S16;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      U16 val( cpu.GetVU16(rn, idx) );
      val = val ^ U16(S16(val) >> 1);

      if (cpu.Test( val == U16(0) ))
        val = U16(15);
      else
        val = U16(14) - BitScanReverse( val );

      cpu.SetVU16(rd, idx, val);
    }

  cpu.ClearHighV(rd, 8<<q);
}

op cls_vss( 0b0[1] : q[1] : 0b00111010100000010010[20] : rn[5] : rd[5] );

cls_vss.disasm = {
  sink << "cls\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

cls_vss.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      U32 val( cpu.GetVU32(rn, idx) );
      val = val ^ U32(S32(val) >> 1);

      if (cpu.Test( val == U32(0) ))
        val = U32(31);
      else
        val = U32(30) - BitScanReverse( val );

      cpu.SetVU32(rd, idx, val);
    }

  cpu.ClearHighV(rd, 8<<q);
}

op clz_vbb( 0b0[1] : q[1] : 0b10111000100000010010[20] : rn[5] : rd[5] );

clz_vbb.disasm = {
  sink << "clz\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

clz_vbb.execute = {
  typedef typename ARCH::U8 U8;

  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      U8 val( cpu.GetVU8(rn, idx) );
      if (cpu.Test( val == U8(0) ))
        val = U8(8);
      else
        val = U8(7) - BitScanReverse( val );

      cpu.SetVU8(rd, idx, val);
    }

  cpu.ClearHighV(rd, 8<<q);
}

op clz_vhh( 0b0[1] : q[1] : 0b10111001100000010010[20] : rn[5] : rd[5] );

clz_vhh.disasm = {
  sink << "clz\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

clz_vhh.execute = {
  typedef typename ARCH::U16 U16;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      U16 val( cpu.GetVU16(rn, idx) );
      if (cpu.Test( val == U16(0) ))
        val = U16(16);
      else
        val = U16(15) - BitScanReverse( val );

      cpu.SetVU16(rd, idx, val);
    }

  cpu.ClearHighV(rd, 8<<q);
}

op clz_vss( 0b0[1] : q[1] : 0b10111010100000010010[20] : rn[5] : rd[5] );

clz_vss.disasm = {
  sink << "clz\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

clz_vss.execute = {
  typedef typename ARCH::U32 U32;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      U32 val( cpu.GetVU32(rn, idx) );
      if (cpu.Test( val == U32(0) ))
        val = U32(32);
      else
        val = U32(31) - BitScanReverse( val );

      cpu.SetVU32(rd, idx, val);
    }

  cpu.ClearHighV(rd, 8<<q);
}

op cmtst_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmtst_vbvbvb.disasm = {
  sink << "cmtst\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

cmtst_vbvbvb.execute = {
  typedef typename ARCH::U8 U8;

  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      U8 val( cpu.GetVU8(rn, idx) & cpu.GetVU8(rm, idx) );
      cpu.SetVU8(rd, idx, cpu.Test(val != U8(0)) ? ~U8(0) : U8(0));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op cmtst_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmtst_vhvhvh.disasm = {
  sink << "cmtst\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

cmtst_vhvhvh.execute = {
  typedef typename ARCH::U16 U16;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      U16 val( cpu.GetVU16(rn, idx) & cpu.GetVU16(rm, idx) );
      cpu.SetVU16(rd, idx, cpu.Test(val != U16(0)) ? ~U16(0) : U16(0));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op cmtst_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b100011[6] : rn[5] : rd[5] );

cmtst_vsvsvs.disasm = {
  sink << "cmtst\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

cmtst_vsvsvs.execute = {
  typedef typename ARCH::U32 U32;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      U32 val( cpu.GetVU32(rn, idx) & cpu.GetVU32(rm, idx) );
      cpu.SetVU32(rd, idx, cpu.Test(val != U32(0)) ? ~U32(0) : U32(0));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op cnt_vbb( 0b0[1] : q[1] : 0b00111000100000010110[20] : rn[5] : rd[5] );

cnt_vbb.disasm = {
  sink << "cnt\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

cnt_vbb.execute = {
  typedef typename ARCH::U8 U8;

  for (unsigned idx = 0, end=8<<q; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, U8(PopCount(cpu.GetVU8(rn, idx))));
    }
  cpu.ClearHighV(rd, 8<<q);
};

/*******************************************************************
 * DUP (element)
 * Duplicate vector element to vector or scalar.
 */

op mov_bvb( 0b01011110000[11] : index[4] : 0b1000001[7] : rn[5] : rd[5] );

mov_bvb.disasm = {
  sink << "mov\t" << DisasmB(rd) << ", " << DisasmTV(rn, 0, 0) << DisasmSubscript(index);
};

mov_bvb.execute = {
  cpu.SetVU8(rd, 0, cpu.GetVU8(rn, index));
  cpu.ClearHighV(rd, 1);
};

op mov_hvh( 0b01011110000[11] : index[3] : 0b10000001[8] : rn[5] : rd[5] );

mov_hvh.disasm = {
  sink << "mov\t" << DisasmH(rd) << ", " << DisasmTV(rn, 0, 1) << DisasmSubscript(index);
};

mov_hvh.execute = {
  cpu.SetVU16(rd, 0, cpu.GetVU16(rn, index));
  cpu.ClearHighV(rd, 2);
};

op mov_svs( 0b01011110000[11] : index[2] : 0b100000001[9] : rn[5] : rd[5] );

mov_svs.disasm = {
  sink << "mov\t" << DisasmS(rd) << ", " << DisasmTV(rn, 0, 2) << DisasmSubscript(index);
};

mov_svs.execute = {
  cpu.SetVU32(rd, 0, cpu.GetVU32(rn, index));
  cpu.ClearHighV(rd, 4);
};

op mov_dvd( 0b01011110000[11] : index[1] : 0b1000000001[10] : rn[5] : rd[5] );

mov_dvd.disasm = {
  sink << "mov\t" << DisasmD(rd) << ", " << DisasmTV(rn, 0, 3) << DisasmSubscript(index);
};

mov_dvd.execute = {
  cpu.SetVU64(rd, cpu.GetVU64(rn, index));
};

op dup_vbvb( 0b0[1] : q[1] : 0b001110000[9] : index[4] : 0b1000001[7] : rn[5] : rd[5] );

dup_vbvb.disasm = {
  sink << "dup\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 0, 0) << DisasmSubscript(index);
};

dup_vbvb.execute = {
  typename ARCH::U8 element( cpu.GetVU8(rn, index) );
  for (unsigned e=0, end=8<<q; e < end; ++e)
    cpu.SetVU8(rd, e, element);
  cpu.ClearHighV(rd, 8<<q);
};

op dup_vhvh( 0b0[1] : q[1] : 0b001110000[9] : index[3] : 0b10000001[8] : rn[5] : rd[5] );

dup_vhvh.disasm = {
  sink << "dup\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 0, 1) << DisasmSubscript(index);
};

dup_vhvh.execute = {
  typename ARCH::U16 element( cpu.GetVU16(rn, index) );
  for (unsigned e=0, end=4<<q; e < end; ++e)
    cpu.SetVU16(rd, e, element);
  cpu.ClearHighV(rd, 8<<q);
};

op dup_vsvs( 0b0[1] : q[1] : 0b001110000[9] : index[2] : 0b100000001[9] : rn[5] : rd[5] );

dup_vsvs.disasm = {
  sink << "dup\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 0, 2) << DisasmSubscript(index);
};

dup_vsvs.execute = {
  typename ARCH::U32 element( cpu.GetVU32(rn, index) );
  for (unsigned e=0, end=2<<q; e < end; ++e)
    cpu.SetVU32(rd, e, element);
  cpu.ClearHighV(rd, 8<<q);
};

op dup_v2dvd( 0b01001110000[11] : index[1] : 0b1000000001[10] : rn[5] : rd[5] );

dup_v2dvd.disasm = {
  sink << "dup\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 0, 3) << DisasmSubscript(index);
};

dup_v2dvd.execute = {
  typename ARCH::U64 element( cpu.GetVU64(rn, index) );
  for (unsigned e=0, end=1<<1; e < end; ++e)
    cpu.SetVU64(rd, e, element);
  cpu.ClearHighV(rd, 8<<1);
};

/*
 * end of DUP (element)
 *******************************************************************/

/*******************************************************************
 * DUP (general)
 *
 * Duplicate general-purpose register to vector.
 */

op dup_vb( 0b0[1] : q[1] : 0b001110000[9] : ?[4] : 0b1000011[7] : rn[5] : rd[5] );

dup_vb.disasm = {
  sink << "dup\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmGZWR(rn);
};

dup_vb.execute = {
  typename ARCH::U8 element( cpu.GetGZR(rn) );
  for (unsigned e=0, end=8<<q; e < end; ++e)
    cpu.SetVU8(rd, e, element);
  cpu.ClearHighV(rd, 8<<q);
};

op dup_vh( 0b0[1] : q[1] : 0b001110000[9] : ?[3] : 0b10000011[8] : rn[5] : rd[5] );

dup_vh.disasm = {
  sink << "dup\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmGZWR(rn);
};

dup_vh.execute = {
  typename ARCH::U16 element( cpu.GetGZR(rn) );
  for (unsigned e=0, end=4<<q; e < end; ++e)
    cpu.SetVU16(rd, e, element);
  cpu.ClearHighV(rd, 8<<q);
};

op dup_vs( 0b0[1] : q[1] : 0b001110000[9] : ?[2] : 0b100000011[9] : rn[5] : rd[5] );

dup_vs.disasm = {
  sink << "dup\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmGZWR(rn);
};

dup_vs.execute = {
  typename ARCH::U32 element( cpu.GetGZR(rn) );
  for (unsigned e=0, end=2<<q; e < end; ++e)
    cpu.SetVU32(rd, e, element);
  cpu.ClearHighV(rd, 8<<q);
};

op dup_v2d( 0b01001110000[11] : ?[1] : 0b1000000011[10] : rn[5] : rd[5] );

dup_v2d.disasm = {
  sink << "dup\t" << DisasmTV(rd, 2, 3) << ", " << DisasmGZXR(rn);
};

dup_v2d.execute = {
  typename ARCH::U64 element( cpu.GetGZR(rn) );
  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVU64(rd, idx, element);
  cpu.ClearHighV(rd, 16);
};

/*
 * end of DUP (general)
 *******************************************************************/

op eor_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b000111[6] : rn[5] : rd[5] );

eor_vbvbvb.disasm = {
  sink << "eor\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

eor_vbvbvb.execute = {
  for (unsigned idx = 0, end=8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, cpu.GetVU8(rn, idx) ^ cpu.GetVU8(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op ext_vb( 0b0[1] : q[1] : 0b101110000[9] : rm[5] : 0b0[1] : index[4] : 0b0[1] : rn[5] : rd[5] );
ext_vb.var reject : {Reject} = {(q == 0) and (index & 8)};

ext_vb.disasm = {
  sink << "ext\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0) << ", " << DisasmI(index);
};

ext_vb.execute = {
  unsigned ed = 0, end = 8<<q;
  for (unsigned es = index; es < end; ++es, ++ed)
    cpu.SetVU8(rd, ed, cpu.GetVU8(rn, es));
  for (unsigned es = 0; ed < end; ++es, ++ed)
    cpu.SetVU8(rd, ed, cpu.GetVU8(rm, es));
  cpu.ClearHighV(rd, 8<<q);
};

op mla_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b100101[6] : rn[5] : rd[5] );

mla_vbvbvb.disasm = {
  sink << "mla\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

mla_vbvbvb.execute = {
  typedef typename ARCH::U8 U8;
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      U8 res( cpu.GetVU8(rd, idx) + (cpu.GetVU8(rn, idx) * cpu.GetVU8(rm, idx)) );
      cpu.SetVU8(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op mla_vhvhvhi( 0b0[1] : q[1] : 0b10111101[8] : index0[2] : rm[4] : 0b0000[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
mla_vhvhvhi.var index : {unsigned} = {index1|index0};

mla_vhvhvhi.disasm = {
  sink << "mla\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

mla_vhvhvhi.execute = {
  typedef typename ARCH::U16 U16;
  U16 element( cpu.GetVU16(rm, index) );
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      U16 res( cpu.GetVU16(rd, idx) + (cpu.GetVU16(rn, idx) * element) );
      cpu.SetVU16(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op mla_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b100101[6] : rn[5] : rd[5] );

mla_vhvhvh.disasm = {
  sink << "mla\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

mla_vhvhvh.execute = {
  typedef typename ARCH::U16 U16;
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      U16 res( cpu.GetVU16(rd, idx) + (cpu.GetVU16(rn, idx) * cpu.GetVU16(rm, idx)) );
      cpu.SetVU16(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op mla_vsvsvsi( 0b0[1] : q[1] : 0b10111110[8] : index0[1] : rm[5] : 0b0000[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
mla_vsvsvsi.var index : {unsigned} = {index1|index0};

mla_vsvsvsi.disasm = {
  sink << "mla\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

mla_vsvsvsi.execute = {
  typedef typename ARCH::U32 U32;
  U32 element( cpu.GetVU32(rm, index) );
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      U32 res( cpu.GetVU32(rd, idx) + (cpu.GetVU32(rn, idx) * element) );
      cpu.SetVU32(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op mla_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b100101[6] : rn[5] : rd[5] );

mla_vsvsvs.disasm = {
  sink << "mla\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

mla_vsvsvs.execute = {
  typedef typename ARCH::U32 U32;
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      U32 res( cpu.GetVU32(rd, idx) + (cpu.GetVU32(rn, idx) * cpu.GetVU32(rm, idx)) );
      cpu.SetVU32(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op mls_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b100101[6] : rn[5] : rd[5] );

mls_vbvbvb.disasm = {
  sink << "mls\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

mls_vbvbvb.execute = {
  typedef typename ARCH::U8 U8;
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      U8 res( cpu.GetVU8(rd, idx) - (cpu.GetVU8(rn, idx) * cpu.GetVU8(rm, idx)) );
      cpu.SetVU8(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op mls_vhvhvhi( 0b0[1] : q[1] : 0b10111101[8] : index0[2] : rm[4] : 0b0100[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
mls_vhvhvhi.var index : {unsigned} = {index1|index0};

mls_vhvhvhi.disasm = {
  sink << "mls\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

mls_vhvhvhi.execute = {
  typedef typename ARCH::U16 U16;
  U16 element( cpu.GetVU16(rm, index) );
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      U16 res( cpu.GetVU16(rd, idx) - (cpu.GetVU16(rn, idx) * element) );
      cpu.SetVU16(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op mls_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b100101[6] : rn[5] : rd[5] );

mls_vhvhvh.disasm = {
  sink << "mls\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

mls_vhvhvh.execute = {
  typedef typename ARCH::U16 U16;
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      U16 res( cpu.GetVU16(rd, idx) - (cpu.GetVU16(rn, idx) * cpu.GetVU16(rm, idx)) );
      cpu.SetVU16(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op mls_vsvsvsi( 0b0[1] : q[1] : 0b10111110[8] : index0[1] : rm[5] : 0b0100[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
mls_vsvsvsi.var index : {unsigned} = {index1|index0};

mls_vsvsvsi.disasm = {
  sink << "mls\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

mls_vsvsvsi.execute = {
  typedef typename ARCH::U32 U32;
  U32 element( cpu.GetVU32(rm, index) );
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      U32 res( cpu.GetVU32(rd, idx) - (cpu.GetVU32(rn, idx) * element) );
      cpu.SetVU32(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op mls_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b100101[6] : rn[5] : rd[5] );

mls_vsvsvs.disasm = {
  sink << "mls\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

mls_vsvsvs.execute = {
  typedef typename ARCH::U32 U32;
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      U32 res( cpu.GetVU32(rd, idx) - (cpu.GetVU32(rn, idx) * cpu.GetVU32(rm, idx)) );
      cpu.SetVU32(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
}

/*******************************************************************
 * MOVI
 *
 * Move Immediate (vector).
 */

op movi_vbi( 0b0[1] : q[1] : 0b00111100000[11] : shl<5> imm1[3] : 0b111001[6] : imm0[5] : rd[5] );
movi_vbi.var imm : {uint8_t} = {imm1|imm0};

movi_vbi.disasm = {
  sink << "movi\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmI(int8_t(imm));
};

movi_vbi.execute = {
  typedef typename ARCH::U8 U8;

  for (unsigned idx = 0, end=8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, U8(imm));
  cpu.ClearHighV(rd, 8<<q);
};

op movi_vhi( 0b0[1] : q[1] : 0b00111100000[11] : shl<5> imm1[3] : 0b10[2] : shl<3> sh[1] : 0b001[3] : imm0[5] : rd[5] );
movi_vhi.var imm : {uint16_t} = {uint16_t(imm1|imm0) << sh};

movi_vhi.disasm = {
  sink << "movi\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmI(int16_t(imm >> sh)) << ", lsl #" << +sh;
};

movi_vhi.execute = {
  typedef typename ARCH::U16 U16;

  for (unsigned idx = 0, end=4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, U16(imm));
  cpu.ClearHighV(rd, 8<<q);
};

op movi_vsi( 0b0[1] : q[1] : 0b00111100000[11] : shl<5> imm1[3] : 0b0[1] : shl<3> sh[2] : 0b001[3] : imm0[5] : rd[5] );
movi_vsi.var imm : {uint32_t} = {uint32_t(imm1|imm0) << sh};

movi_vsi.disasm = {
  sink << "movi\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmI(int32_t(imm >> sh)) << ", lsl #" << +sh;
};

movi_vsi.execute = {
  typedef typename ARCH::U32 U32;

  for (unsigned idx = 0, end=2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, U32(imm));
  cpu.ClearHighV(rd, 8<<q);
};

op movi_di( 0b0010111100000[13] : a[1] : b[1] : c[1] : 0b111001[6] : d[1] : e[1] : f[1] : g[1] : h[1] : rd[5] );
movi_di.var imm : {uint64_t} = {((uint64_t(a)<<56)|(uint64_t(b)<<48)|(uint64_t(c)<<40)|(uint64_t(d)<<32)|(uint64_t(e)<<24)|(uint64_t(f)<<16)|(uint64_t(g)<<8)|(uint64_t(h)<<0))*0xff};

movi_di.disasm = {
  sink << "movi\t" << DisasmD(rd) << ", " << DisasmI(imm);
};

movi_di.execute = {
  typedef typename ARCH::U64 U64;

  cpu.SetVU64(rd, U64(imm));
};

op movi_v2di( 0b0110111100000[13] : a[1] : b[1] : c[1] : 0b111001[6] : d[1] : e[1] : f[1] : g[1] : h[1] : rd[5] );
movi_v2di.var imm : {uint64_t} = {((uint64_t(a)<<56)|(uint64_t(b)<<48)|(uint64_t(c)<<40)|(uint64_t(d)<<32)|(uint64_t(e)<<24)|(uint64_t(f)<<16)|(uint64_t(g)<<8)|(uint64_t(h)<<0))*0xff};

movi_v2di.disasm = {
  sink << "movi\t" << DisasmTV(rd, 2, 3) << ", " << DisasmI(imm);
};

movi_v2di.execute = {
  typedef typename ARCH::U64 U64;

  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVU64(rd, idx, U64(imm));
};

op movi_vsmsl( 0b0[1] : q[1] : 0b00111100000[11] : shl<21> imm1[3] : 0b110[3] : sh[1] : 0b01[2] : shl<16> imm0[5] : rd[5] );
movi_vsmsl.var imm : {uint32_t} = {(imm1|imm0|0xffff) >> (sh ? 0 : 8)};

movi_vsmsl.disasm = {
  sink << "movi\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmI(int32_t(uint32_t(imm1|imm0) >> 16)) << ", msl #" << (sh ? "16" : "8");
};

movi_vsmsl.execute = {
  typedef typename ARCH::U32 U32;

  for (unsigned idx = 0, end=2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, U32(imm));
  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of MOVI
 *******************************************************************/

/*******************************************************************
 * MUL (vector)
 *
 * Multiply (vector)
 */

op mul_vb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b100111[6] : rn[5] : rd[5] );

mul_vb.disasm = {
  sink << "mul\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

mul_vb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, cpu.GetVU8(rn, idx) * cpu.GetVU8(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op mul_vh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b100111[6] : rn[5] : rd[5] );

mul_vh.disasm = {
  sink << "mul\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

mul_vh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, cpu.GetVU16(rn, idx) * cpu.GetVU16(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op mul_vs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b100111[6] : rn[5] : rd[5] );

mul_vs.disasm = {
  sink << "mul\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

mul_vs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, cpu.GetVU32(rn, idx) * cpu.GetVU32(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of MUL (vector)
 *******************************************************************/

op mul_vhvhvhi( 0b0[1] : q[1] : 0b00111101[8] : index0[2] : rm[4] : 0b1000[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
mul_vhvhvhi.var index : {unsigned} = {index1|index0};

mul_vhvhvhi.disasm = {
  sink << "mul\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

mul_vhvhvhi.execute = {
  typedef typename ARCH::U16 U16;
  U16 element( cpu.GetVU16(rm, index) );
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, cpu.GetVU16(rn, idx) * element);
  cpu.ClearHighV(rd, 8<<q);
}

op mul_vsvsvsi( 0b0[1] : q[1] : 0b00111110[8] : index0[1] : rm[5] : 0b1000[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
mul_vsvsvsi.var index : {unsigned} = {index1|index0};

mul_vsvsvsi.disasm = {
  sink << "mul\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

mul_vsvsvsi.execute = {
  typedef typename ARCH::U32 U32;
  U32 element( cpu.GetVU32(rm, index) );
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, cpu.GetVU32(rn, idx) * element);
  cpu.ClearHighV(rd, 8<<q);
}

/*******************************************************************
 * MVN
 *
 * Bitwise NOT (vector).
 */

op mvn_vb( 0b0[1] : q[1] : 0b10111000100000010110[20] : rn[5] : rd[5] );

mvn_vb.disasm = {
  sink << "mvn\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

mvn_vb.execute = {
  /* Using a U64 arrangement (by convention arm exhibit a U8 arrangement) */
  for (unsigned idx = 0, end=1<<q; idx < end; ++idx)
    cpu.SetVU64(rd, idx, ~cpu.GetVU64(rn, idx));
  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of MVN
 *******************************************************************/

/*******************************************************************
 * MVNI
 *
 * Move inverted Immediate (vector).
 */

op mvni_vhi( 0b0[1] : q[1] : 0b10111100000[11] : shl<5> imm1[3] : 0b10[2] : shl<3> sh[1] : 0b001[3] : imm0[5] : rd[5] );
mvni_vhi.var imm : {uint16_t} = {uint16_t(imm1|imm0) << sh};

mvni_vhi.disasm = {
  sink << "mvni\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmI(imm, 16);
};

mvni_vhi.execute = {
  typedef typename ARCH::U16 U16;

  for (unsigned idx = 0, end=4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, U16(~imm));
  cpu.ClearHighV(rd, 8<<q);
};

op mvni_vsi( 0b0[1] : q[1] : 0b10111100000[11] : shl<5> imm1[3] : 0b0[1] : shl<3> sh[2] : 0b001[3] : imm0[5] : rd[5] );
mvni_vsi.var imm : {uint32_t} = {uint32_t(imm1|imm0) << sh};

mvni_vsi.disasm = {
  sink << "mvni\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmI(imm, 16);
};

mvni_vsi.execute = {
  typedef typename ARCH::U32 U32;

  for (unsigned idx = 0, end=2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, U32(~imm));
  cpu.ClearHighV(rd, 8<<q);
};

op mvni_vsmsl( 0b0[1] : q[1] : 0b10111100000[11] : shl<21> imm1[3] : 0b110[3] : sh[1] : 0b01[2] : shl<16> imm0[5] : rd[5] );
mvni_vsmsl.var imm : {uint32_t} = {(imm1|imm0|0xffff) >> (sh ? 0 : 8)};

mvni_vsmsl.disasm = {
  sink << "mvni\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmI(imm, 16);
};

mvni_vsmsl.execute = {
  typedef typename ARCH::U32 U32;

  for (unsigned idx = 0, end=2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, U32(~imm));
  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of MVNI
 *******************************************************************/

/*******************************************************************
 * NEG
 *
 * Negate
 */

op neg_vb( 0b0[1] : q[1] : 0b10111000100000101110[20] : rn[5] : rd[5] );

neg_vb.disasm = {
  sink << "neg\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

neg_vb.execute = {
  unsigned const elements = 8<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS8(rd, e, -cpu.GetVS8(rn, e));
    }
  
  cpu.ClearHighV(rd, 8<<q);
};

op neg_vh( 0b0[1] : q[1] : 0b10111001100000101110[20] : rn[5] : rd[5] );

neg_vh.disasm = {
  sink << "neg\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

neg_vh.execute = {
  unsigned const elements = 4<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS16(rd, e, -cpu.GetVS16(rn, e));
    }
  
  cpu.ClearHighV(rd, 8<<q);
};

op neg_vs( 0b0[1] : q[1] : 0b10111010100000101110[20] : rn[5] : rd[5] );

neg_vs.disasm = {
  sink << "neg\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

neg_vs.execute = {
  unsigned const elements = 2<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS32(rd, e, -cpu.GetVS32(rn, e));
    }
  
  cpu.ClearHighV(rd, 8<<q);
};

op neg_v2d( 0b0110111011100000101110[22] : rn[5] : rd[5] );

neg_v2d.disasm = {
  sink << "neg\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3);
};

neg_v2d.execute = {
  unsigned const elements = 2;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS64(rd, e, -cpu.GetVS64(rn, e));
    }
};

op neg_d( 0b0111111011100000101110[22] : rn[5] : rd[5] );

neg_d.disasm = {
  sink << "neg\t" << DisasmD(rd) << ", " << DisasmD(rn);
};

neg_d.execute = {
  cpu.SetVS64(rd, -cpu.GetVS64(rn, 0));
};

/*
 * end of NEG
 *******************************************************************/

op orn_vbvbvb( 0b0[1] : q[1] : 0b001110111[9] : rm[5] : 0b000111[6] : rn[5] : rd[5] );

orn_vbvbvb.disasm = {
  sink << "orn\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

orn_vbvbvb.execute = {
  for (unsigned idx = 0, end=8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, cpu.GetVU8(rn, idx) | ~cpu.GetVU8(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
};

op orr_vhi( 0b0[1] : q[1] : 0b00111100000[11] : shl<5> imm1[3] : 0b10[2] : shl<3> sh[1] : 0b101[3] : imm0[5] : rd[5] );
orr_vhi.var imm : {uint16_t} = {uint16_t(imm1|imm0) << sh};

orr_vhi.disasm = {
  sink << "orr\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmI(imm, 16);
};

orr_vhi.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, cpu.GetVU16(rd, idx) | typename ARCH::U16(imm));

  cpu.ClearHighV(rd, 8<<q);
}

op orr_vsi( 0b0[1] : q[1] : 0b00111100000[11] : shl<5> imm1[3] : 0b0[1] : shl<3> sh[2] : 0b101[3] : imm0[5] : rd[5] );
orr_vsi.var imm : {uint32_t} = {uint32_t(imm1|imm0) << sh};

orr_vsi.disasm = {
  sink << "orr\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmI(imm, 16);
};

orr_vsi.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, cpu.GetVU32(rd, idx) | typename ARCH::U32(imm));

  cpu.ClearHighV(rd, 8<<q);
}

op pmul_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b100111[6] : rn[5] : rd[5] );

pmul_vbvbvb.disasm = {
  sink << "pmul\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

pmul_vbvbvb.execute = {
  typedef typename ARCH::U8 U8;

  for (unsigned idx = 0, end=8<<q; idx < end; ++idx)
    {
      U8 op1(cpu.GetVU8(rn, idx)), op2(cpu.GetVU8(rm, idx)), res(0);
      for (unsigned bit = 0; bit < 8; ++bit)
        res = res ^ (op2*(op1 & U8(1<<bit)));
      cpu.SetVU8(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op rbit_vbb( 0b0[1] : q[1] : 0b10111001100000010110[20] : rn[5] : rd[5] );

rbit_vbb.disasm = {
  sink << "rbit\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

rbit_vbb.execute = {
  typedef typename ARCH::U8 U8;
  unsigned const elements = 8<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      U8 res( cpu.GetVU8(rn, e) );
      U8 const masks[] = { U8(0x55), U8(0x33), U8(0x0f) };

      for (unsigned i = 0; i < 3; ++i)
        {
          unsigned shift = (1<<i);
          U8 mask = U8(masks[i]);
          res = ((res >> shift) & mask) | ((res & mask) << shift);
        }

      cpu.SetVU8(rd, e, res);
    }

  cpu.ClearHighV(rd, 8<<q);
}

/*******************************************************************
 * REV<x> (vector)
 *
 * Reverse elements in <x>-bit words (vector).
 */

op rev16_vbb( 0b0[1] : q[1] : 0b00111000100000000110[20] : rn[5] : rd[5] );

rev16_vbb.disasm = {
  sink << "rev16\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

rev16_vbb.execute = {
  unsigned const elements = 8<<q;
  typename ARCH::U8 res[elements];
  for (unsigned e=0; e < elements; e += 1)
    res[e] = cpu.GetVU8(rn, e^1);
  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU8(rd, e, res[e]);
  cpu.ClearHighV(rd, 8<<q);
};

op rev32_vbb( 0b0[1] : q[1] : 0b10111000100000000010[20] : rn[5] : rd[5] );

rev32_vbb.disasm = {
  sink << "rev32\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

rev32_vbb.execute = {
  unsigned const elements = 8<<q;
  typename ARCH::U8 res[elements];
  for (unsigned e=0; e < elements; e += 1)
    res[e] = cpu.GetVU8(rn, e^3);
  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU8(rd, e, res[e]);
  cpu.ClearHighV(rd, 8<<q);
};

op rev32_vhh( 0b0[1] : q[1] : 0b10111001100000000010[20] : rn[5] : rd[5] );

rev32_vhh.disasm = {
  sink << "rev32\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

rev32_vhh.execute = {
  unsigned const elements = 4<<q;
  typename ARCH::U16 res[elements];
  for (unsigned e=0; e < elements; e += 1)
    res[e] = cpu.GetVU16(rn, e^1);
  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU16(rd, e, res[e]);
  cpu.ClearHighV(rd, 8<<q);
};

op rev64_vbb( 0b0[1] : q[1] : 0b00111000100000000010[20] : rn[5] : rd[5] );

rev64_vbb.disasm = {
  sink << "rev64\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

rev64_vbb.execute = {
  unsigned const elements = 8<<q;
  typename ARCH::U8 res[elements];
  for (unsigned e=0; e < elements; e += 1)
    res[e] = cpu.GetVU8(rn, e^7);
  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU8(rd, e, res[e]);
  cpu.ClearHighV(rd, 8<<q);
};

op rev64_vhh( 0b0[1] : q[1] : 0b00111001100000000010[20] : rn[5] : rd[5] );

rev64_vhh.disasm = {
  sink << "rev64\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

rev64_vhh.execute = {
  unsigned const elements = 4<<q;
  typename ARCH::U16 res[elements];
  for (unsigned e=0; e < elements; e += 1)
    res[e] = cpu.GetVU16(rn, e^3);
  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU16(rd, e, res[e]);
  cpu.ClearHighV(rd, 8<<q);
};

op rev64_vss( 0b0[1] : q[1] : 0b00111010100000000010[20] : rn[5] : rd[5] );

rev64_vss.disasm = {
  sink << "rev64\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

rev64_vss.execute = {
  unsigned const elements = 2<<q;
  typename ARCH::U32 res[elements];
  for (unsigned e=0; e < elements; e += 1)
    res[e] = cpu.GetVU32(rn, e^1);
  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU32(rd, e, res[e]);
  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of REV<x> (vector)
 *******************************************************************/

op saba_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b011111[6] : rn[5] : rd[5] );

saba_vbvbvb.disasm = {
  sink << "saba\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

saba_vbvbvb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS8(rd, idx, cpu.GetVS8(rd, idx) + S8(Abs(cpu, S16(cpu.GetVS8(rn, idx)) - S16(cpu.GetVS8(rm, idx)))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op saba_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b011111[6] : rn[5] : rd[5] );

saba_vhvhvh.disasm = {
  sink << "saba\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

saba_vhvhvh.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, cpu.GetVS16(rd, idx) + S16(Abs(cpu, S32(cpu.GetVS16(rn, idx)) - S32(cpu.GetVS16(rm, idx)))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op saba_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b011111[6] : rn[5] : rd[5] );

saba_vsvsvs.disasm = {
  sink << "saba\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

saba_vsvsvs.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, cpu.GetVS32(rd, idx) + S32(Abs(cpu, S64(cpu.GetVS32(rn, idx)) - S64(cpu.GetVS32(rm, idx)))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sabd_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b011101[6] : rn[5] : rd[5] );

sabd_vbvbvb.disasm = {
  sink << "sabd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

sabd_vbvbvb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS8(rd, idx, S8(Abs(cpu, S16(cpu.GetVS8(rn, idx)) - S16(cpu.GetVS8(rm, idx)))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sabd_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b011101[6] : rn[5] : rd[5] );

sabd_vhvhvh.disasm = {
  sink << "sabd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

sabd_vhvhvh.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, S16(Abs(cpu, S32(cpu.GetVS16(rn, idx)) - S32(cpu.GetVS16(rm, idx)))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sabd_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b011101[6] : rn[5] : rd[5] );

sabd_vsvsvs.disasm = {
  sink << "sabd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sabd_vsvsvs.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, S32(Abs(cpu, S64(cpu.GetVS32(rn, idx)) - S64(cpu.GetVS32(rm, idx)))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sadalp_vhb( 0b0[1] : q[1] : 0b00111000100000011010[20] : rn[5] : rd[5] );

sadalp_vhb.disasm = {
  sink << "sadalp\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 8<<q, 0);
};

sadalp_vhb.execute = {
  typedef typename ARCH::S16 DST;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 4<<q;

  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS16(rd, idx) + S16(cpu.GetVS8(rn, 2*idx)) + S16(cpu.GetVS8(rn, (2*idx)+1));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }

  cpu.ClearHighV(rd, 8<<q);
};

op sadalp_vsh( 0b0[1] : q[1] : 0b00111001100000011010[20] : rn[5] : rd[5] );

sadalp_vsh.disasm = {
  sink << "sadalp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 4<<q, 1);
};

sadalp_vsh.execute = {
  typedef typename ARCH::S32 DST;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 2<<q;

  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS32(rd, idx) + S32(cpu.GetVS16(rn, 2*idx)) + S32(cpu.GetVS16(rn, (2*idx)+1));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }

  cpu.ClearHighV(rd, 8<<q);
};

op sadalp_vds( 0b0[1] : q[1] : 0b00111010100000011010[20] : rn[5] : rd[5] );

sadalp_vds.disasm = {
  sink << "sadalp\t" << DisasmTV(rd, 1<<q, 3) << ", " << DisasmTV(rn, 2<<q, 2);
};

sadalp_vds.execute = {
  typedef typename ARCH::S64 DST;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 1<<q;

  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVS64(rd, idx) + S64(cpu.GetVS32(rn, 2*idx)) + S64(cpu.GetVS32(rn, (2*idx)+1));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS64(rd, idx, res[idx]);
    }

  cpu.ClearHighV(rd, 8<<q);
};

op saddlp_vhb( 0b0[1] : q[1] : 0b00111000100000001010[20] : rn[5] : rd[5] );

saddlp_vhb.disasm = {
  sink << "saddlp\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 8<<q, 0);
};

saddlp_vhb.execute = {
  unsigned const elements = 4<<q;
  typedef typename ARCH::S16 S16;

  for (unsigned e=0; e < elements; e += 1)
    {
      cpu.SetVS16(rd, e, S16(cpu.GetVS8(rn, 2*e+0)) + S16(cpu.GetVS8(rn, 2*e+1)) );
    }

  cpu.ClearHighV(rd, 8<<q);
};

op saddlp_vsh( 0b0[1] : q[1] : 0b00111001100000001010[20] : rn[5] : rd[5] );

saddlp_vsh.disasm = {
  sink << "saddlp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 4<<q, 1);
};

saddlp_vsh.execute = {
  unsigned const elements = 2<<q;
  typedef typename ARCH::S32 S32;

  for (unsigned e=0; e < elements; e += 1)
    {
      cpu.SetVS32(rd, e, S32(cpu.GetVS16(rn, 2*e+0)) + S32(cpu.GetVS16(rn, 2*e+1)) );
    }

  cpu.ClearHighV(rd, 8<<q);
};

op saddlp_vds( 0b0[1] : q[1] : 0b00111010100000001010[20] : rn[5] : rd[5] );

saddlp_vds.disasm = {
  sink << "saddlp\t" << DisasmTV(rd, 1<<q, 3) << ", " << DisasmTV(rn, 2<<q, 2);
};

saddlp_vds.execute = {
  unsigned const elements = 1<<q;
  typedef typename ARCH::S64 S64;

  for (unsigned e=0; e < elements; e += 1)
    {
      cpu.SetVS64(rd, e, S64(cpu.GetVS32(rn, 2*e+0)) + S64(cpu.GetVS32(rn, 2*e+1)) );
    }

  cpu.ClearHighV(rd, 8<<q);
};

op saddlv_hvb( 0b0[1] : q[1] : 0b00111000110000001110[20] : rn[5] : rd[5] );

saddlv_hvb.disasm = {
  sink << "saddlv\t" << DisasmH(rd) << ", " << DisasmTV(rn, 8<<q, 0);
};

saddlv_hvb.execute = {
  unsigned const elements = 8<<q;
  typedef typename ARCH::S16 S16;

  S16 sum = S16(cpu.GetVS8(rn, 0));
  for (unsigned e=1; e < elements; e += 1)
    {
      sum += S16(cpu.GetVS8(rn, e));
    }

  cpu.SetVS16(rd, 0, sum);
  cpu.ClearHighV(rd, 2);
}

op saddlv_svh( 0b0[1] : q[1] : 0b00111001110000001110[20] : rn[5] : rd[5] );

saddlv_svh.disasm = {
  sink << "saddlv\t" << DisasmS(rd) << ", " << DisasmTV(rn, 4<<q, 1);
};

saddlv_svh.execute = {
  unsigned const elements = 4<<q;
  typedef typename ARCH::S32 S32;

  S32 sum = S32(cpu.GetVS16(rn, 0));
  for (unsigned e=1; e < elements; e += 1)
    {
      sum += S32(cpu.GetVS16(rn, e));
    }

  cpu.SetVS32(rd, 0, sum);
  cpu.ClearHighV(rd, 4);
}

op shadd_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b000001[6] : rn[5] : rd[5] );

shadd_vbvbvb.disasm = {
  sink << "shadd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

shadd_vbvbvb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S16 S16;
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVS8(rd, idx, S8((S16(cpu.GetVS8(rn, idx)) + S16(cpu.GetVS8(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op shadd_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b000001[6] : rn[5] : rd[5] );

shadd_vhvhvh.disasm = {
  sink << "shadd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

shadd_vhvhvh.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVS16(rd, idx, S16((S32(cpu.GetVS16(rn, idx)) + S32(cpu.GetVS16(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op shadd_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b000001[6] : rn[5] : rd[5] );

shadd_vsvsvs.disasm = {
  sink << "shadd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

shadd_vsvsvs.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVS32(rd, idx, S32((S64(cpu.GetVS32(rn, idx)) + S64(cpu.GetVS32(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

/*******************************************************************
 * SHL
 *
 * Shift Left (immediate).
 */

op shl_ddi( 0b0101111101[10] : shift[6] : 0b010101[6] : rn[5] : rd[5] );

shl_ddi.disasm = {
  sink << "shl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

shl_ddi.execute = {
  cpu.SetVU64(rd, cpu.GetVU64(rn, 0) << shift);
};

op shl_vbbi( 0b0[1] : q[1] : 0b00111100001[11] : imm[3] : 0b010101[6] : rn[5] : rd[5] );

shl_vbbi.disasm = {
  sink << "shl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmI(imm);
};

shl_vbbi.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, cpu.GetVU8(rn, idx) << imm);
  cpu.ClearHighV(rd, 8<<q);
};

op shl_vhhi( 0b0[1] : q[1] : 0b0011110001[10] : imm[4] : 0b010101[6] : rn[5] : rd[5] );

shl_vhhi.disasm = {
  sink << "shl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmI(imm);
};

shl_vhhi.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, cpu.GetVU16(rn, idx) << imm);
  cpu.ClearHighV(rd, 8<<q);
};

op shl_vssi( 0b0[1] : q[1] : 0b001111001[9] : imm[5] : 0b010101[6] : rn[5] : rd[5] );

shl_vssi.disasm = {
  sink << "shl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmI(imm);
};

shl_vssi.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, cpu.GetVU32(rn, idx) << imm);
  cpu.ClearHighV(rd, 8<<q);
};

op shl_v2d2di( 0b0100111101[10] : imm[6] : 0b010101[6] : rn[5] : rd[5] );

shl_v2d2di.disasm = {
  sink << "shl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(imm);
};

shl_v2d2di.execute = {
  for (unsigned idx = 0; idx < 2; ++idx)
    cpu.SetVU64(rd, idx, cpu.GetVU64(rn, idx) << imm);
};

/*
 * end of SHL
 *******************************************************************/

op shsub_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b001001[6] : rn[5] : rd[5] );

shsub_vbvbvb.disasm = {
  sink << "shsub\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

shsub_vbvbvb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S16 S16;
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVS8(rd, idx, S8((S16(cpu.GetVS8(rn, idx)) - S16(cpu.GetVS8(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op shsub_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b001001[6] : rn[5] : rd[5] );

shsub_vhvhvh.disasm = {
  sink << "shsub\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

shsub_vhvhvh.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVS16(rd, idx, S16((S32(cpu.GetVS16(rn, idx)) - S32(cpu.GetVS16(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op shsub_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b001001[6] : rn[5] : rd[5] );

shsub_vsvsvs.disasm = {
  sink << "shsub\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

shsub_vsvsvs.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVS32(rd, idx, S32((S64(cpu.GetVS32(rn, idx)) - S64(cpu.GetVS32(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

/*******************************************************************
 * SLI
 *
 * Shift Left and Insert (immediate).
 */

op sli_ddi( 0b0111111101[10] : shift[6] : 0b010101[6] : rn[5] : rd[5] );

sli_ddi.disasm = {
  sink << "sli\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmI(shift);
};

sli_ddi.execute = {
  cpu.SetVU64(rd, (cpu.GetVU64(rn, 0) << shift) | (cpu.GetVU64(rd, 0) & typename ARCH::U64((1ull<<shift)-1)));
};

op sli_vbbi( 0b0[1] : q[1] : 0b10111100001[11] : shift[3] : 0b010101[6] : rn[5] : rd[5] );

sli_vbbi.disasm = {
  sink << "sli\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmI(shift);
};

sli_vbbi.execute = {
  for (unsigned e = 0, end = 8<<q; e < end; e += 1)
    cpu.SetVU8(rd, e, (cpu.GetVU8(rn, e) << shift) | (cpu.GetVU8(rd, e) & typename ARCH::U8((1<<shift)-1)));
  cpu.ClearHighV(rd, 8<<q);
};

op sli_vhhi( 0b0[1] : q[1] : 0b1011110001[10] : shift[4] : 0b010101[6] : rn[5] : rd[5] );

sli_vhhi.disasm = {
  sink << "sli\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmI(shift);
};

sli_vhhi.execute = {
  for (unsigned e = 0, end = 4<<q; e < end; e += 1)
    cpu.SetVU16(rd, e, (cpu.GetVU16(rn, e) << shift) | (cpu.GetVU16(rd, e) & typename ARCH::U16((1<<shift)-1)));
  cpu.ClearHighV(rd, 8<<q);
};

op sli_vssi( 0b0[1] : q[1] : 0b101111001[9] : shift[5] : 0b010101[6] : rn[5] : rd[5] );

sli_vssi.disasm = {
  sink << "sli\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmI(shift);
};

sli_vssi.execute = {
  for (unsigned e = 0, end = 2<<q; e < end; e += 1)
    cpu.SetVU32(rd, e, (cpu.GetVU32(rn, e) << shift) | (cpu.GetVU32(rd, e) & typename ARCH::U32((1<<shift)-1)));
  cpu.ClearHighV(rd, 8<<q);
};

op sli_v2d2di( 0b0110111101[10] : shift[6] : 0b010101[6] : rn[5] : rd[5] );

sli_v2d2di.disasm = {
  sink << "sli\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(shift);
};

sli_v2d2di.execute = {
  for (unsigned e = 0; e < 2; e += 1)
    cpu.SetVU64(rd, e, (cpu.GetVU64(rn, e) << shift) | (cpu.GetVU64(rd, e) & typename ARCH::U64((1ull<<shift)-1)));
};

/*
 * end of SLI
 *******************************************************************/

op smax_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b011001[6] : rn[5] : rd[5] );

smax_vbvbvb.disasm = {
  sink << "smax\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

smax_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVS8(rd, idx, Maximum(cpu.GetVS8(rn, idx), cpu.GetVS8(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op smax_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b011001[6] : rn[5] : rd[5] );

smax_vhvhvh.disasm = {
  sink << "smax\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

smax_vhvhvh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVS16(rd, idx, Maximum(cpu.GetVS16(rn, idx), cpu.GetVS16(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op smax_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b011001[6] : rn[5] : rd[5] );

smax_vsvsvs.disasm = {
  sink << "smax\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

smax_vsvsvs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVS32(rd, idx, Maximum(cpu.GetVS32(rn, idx), cpu.GetVS32(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op smaxp_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b101001[6] : rn[5] : rd[5] );

smaxp_vbvbvb.disasm = {
  sink << "smaxp\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

smaxp_vbvbvb.execute = {
  unsigned const elements = 8<<q;
  typename ARCH::S8 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Maximum(cpu.GetVS8(rn, e), cpu.GetVS8(rn, e+1));
      res[(elements+e)/2] = Maximum(cpu.GetVS8(rm, e), cpu.GetVS8(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVS8(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
}

op smaxp_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b101001[6] : rn[5] : rd[5] );

smaxp_vhvhvh.disasm = {
  sink << "smaxp\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

smaxp_vhvhvh.execute = {
  unsigned const elements = 4<<q;
  typename ARCH::S16 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Maximum(cpu.GetVS16(rn, e), cpu.GetVS16(rn, e+1));
      res[(elements+e)/2] = Maximum(cpu.GetVS16(rm, e), cpu.GetVS16(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVS16(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
}

op smaxp_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b101001[6] : rn[5] : rd[5] );

smaxp_vsvsvs.disasm = {
  sink << "smaxp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

smaxp_vsvsvs.execute = {
  unsigned const elements = 2<<q;
  typename ARCH::S32 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Maximum(cpu.GetVS32(rn, e), cpu.GetVS32(rn, e+1));
      res[(elements+e)/2] = Maximum(cpu.GetVS32(rm, e), cpu.GetVS32(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVS32(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
}

op smin_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b011011[6] : rn[5] : rd[5] );

smin_vbvbvb.disasm = {
  sink << "smin\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

smin_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVS8(rd, idx, Minimum(cpu.GetVS8(rn, idx), cpu.GetVS8(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op smin_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b011011[6] : rn[5] : rd[5] );

smin_vhvhvh.disasm = {
  sink << "smin\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

smin_vhvhvh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVS16(rd, idx, Minimum(cpu.GetVS16(rn, idx), cpu.GetVS16(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op smin_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b011011[6] : rn[5] : rd[5] );

smin_vsvsvs.disasm = {
  sink << "smin\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

smin_vsvsvs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVS32(rd, idx, Minimum(cpu.GetVS32(rn, idx), cpu.GetVS32(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sminp_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b101011[6] : rn[5] : rd[5] );

sminp_vbvbvb.disasm = {
  sink << "sminp\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

sminp_vbvbvb.execute = {
  unsigned const elements = 8<<q;
  typename ARCH::S8 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Minimum(cpu.GetVS8(rn, e), cpu.GetVS8(rn, e+1));
      res[(elements+e)/2] = Minimum(cpu.GetVS8(rm, e), cpu.GetVS8(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVS8(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
}

op sminp_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b101011[6] : rn[5] : rd[5] );

sminp_vhvhvh.execute =
{
  unsigned const elements = 4<<q;
  typename ARCH::S16 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Minimum(cpu.GetVS16(rn, e), cpu.GetVS16(rn, e+1));
      res[(elements+e)/2] = Minimum(cpu.GetVS16(rm, e), cpu.GetVS16(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVS16(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
}

sminp_vhvhvh.disasm = {
  sink << "sminp\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

op sminp_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b101011[6] : rn[5] : rd[5] );

sminp_vsvsvs.disasm = {
  sink << "sminp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sminp_vsvsvs.execute = {
  unsigned const elements = 2<<q;
  typename ARCH::S32 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Minimum(cpu.GetVS32(rn, e), cpu.GetVS32(rn, e+1));
      res[(elements+e)/2] = Minimum(cpu.GetVS32(rm, e), cpu.GetVS32(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVS32(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
}

op sqabs_vbb( 0b0[1] : q[1] : 0b00111000100000011110[20] : rn[5] : rd[5] );

sqabs_vbb.disasm = {
  sink << "sqabs\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

sqabs_vbb.execute = {
  unsigned const elements = 8<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS8(rd, e, Abs(cpu, cpu.GetVS8(rn, e), /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sqabs_vhh( 0b0[1] : q[1] : 0b00111001100000011110[20] : rn[5] : rd[5] );

sqabs_vhh.disasm = {
  sink << "sqabs\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

sqabs_vhh.execute = {
  unsigned const elements = 4<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS16(rd, e, Abs(cpu, cpu.GetVS16(rn, e), /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sqabs_vss( 0b0[1] : q[1] : 0b00111010100000011110[20] : rn[5] : rd[5] );

sqabs_vss.disasm = {
  sink << "sqabs\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

sqabs_vss.execute = {
  unsigned const elements = 2<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS32(rd, e, Abs(cpu, cpu.GetVS32(rn, e), /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sqadd_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

sqadd_vbvbvb.disasm = {
  sink << "sqadd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

sqadd_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVS8(rd, idx, SatAdd(cpu, cpu.GetVS8(rn, idx), cpu.GetVS8(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op sqadd_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

sqadd_vhvhvh.disasm = {
  sink << "sqadd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

sqadd_vhvhvh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVS16(rd, idx, SatAdd(cpu, cpu.GetVS16(rn, idx), cpu.GetVS16(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op sqadd_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

sqadd_vsvsvs.disasm = {
  sink << "sqadd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sqadd_vsvsvs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVS32(rd, idx, SatAdd(cpu, cpu.GetVS32(rn, idx), cpu.GetVS32(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op sqdmulh_vhvhvhi( 0b0[1] : q[1] : 0b00111101[8] : index0[2] : rm[4] : 0b1100[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmulh_vhvhvhi.var index : {unsigned} = {index1|index0};

sqdmulh_vhvhvhi.disasm = {
  sink << "sqdmulh\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqdmulh_vhvhvhi.execute = {
  typedef typename ARCH::S16 DST;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4<<q;
  DST res[elements];
  S32 element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, S32(cpu.GetVS16(rn, idx)) * element, typename ARCH::S8(-15), /* round */ false, /* sat */ false));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sqdmulh_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b101101[6] : rn[5] : rd[5] );

sqdmulh_vhvhvh.disasm = {
  sink << "sqdmulh\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

sqdmulh_vhvhvh.execute = {
  typedef typename ARCH::S16 DST;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4<<q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, S32(cpu.GetVS16(rm, idx)) * S32(cpu.GetVS16(rn, idx)), typename ARCH::S8(-15), /* round */ false, /* sat */ false));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sqdmulh_vsvsvsi( 0b0[1] : q[1] : 0b00111110[8] : index0[1] : rm[5] : 0b1100[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqdmulh_vsvsvsi.var index : {unsigned} = {index1|index0};

sqdmulh_vsvsvsi.disasm = {
  sink << "sqdmulh\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqdmulh_vsvsvsi.execute = {
  typedef typename ARCH::S32 DST;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2<<q;
  DST res[elements];
  S64 element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, S64(cpu.GetVS32(rn, idx)) * element, typename ARCH::S8(-31), /* round */ false, /* sat */ false));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sqdmulh_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b101101[6] : rn[5] : rd[5] );

sqdmulh_vsvsvs.disasm = {
  sink << "sqdmulh\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sqdmulh_vsvsvs.execute = {
  typedef typename ARCH::S32 DST;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2<<q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, S64(cpu.GetVS32(rm, idx)) * S64(cpu.GetVS32(rn, idx)), typename ARCH::S8(-31), /* round */ false, /* sat */ false));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sqneg_vbb( 0b0[1] : q[1] : 0b10111000100000011110[20] : rn[5] : rd[5] );

sqneg_vbb.disasm = {
  sink << "sqneg\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

sqneg_vbb.execute = {
  unsigned const elements = 8<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS8(rd, e, Neg(cpu, cpu.GetVS8(rn, e), /* sat */ true));
    }
  
  cpu.ClearHighV(rd, 8<<q);
};

op sqneg_vhh( 0b0[1] : q[1] : 0b10111001100000011110[20] : rn[5] : rd[5] );

sqneg_vhh.disasm = {
  sink << "sqneg\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

sqneg_vhh.execute = {
  unsigned const elements = 4<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS16(rd, e, Neg(cpu, cpu.GetVS16(rn, e), /* sat */ true));
    }
  
  cpu.ClearHighV(rd, 8<<q);
};

op sqneg_vss( 0b0[1] : q[1] : 0b10111010100000011110[20] : rn[5] : rd[5] );

sqneg_vss.disasm = {
  sink << "sqneg\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

sqneg_vss.execute = {
  unsigned const elements = 2<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS32(rd, e, Neg(cpu, cpu.GetVS32(rn, e), /* sat */ true));
    }
  
  cpu.ClearHighV(rd, 8<<q);
};

op sqrdmulh_vhvhvhi( 0b0[1] : q[1] : 0b00111101[8] : index0[2] : rm[4] : 0b1101[4] : shl<2> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqrdmulh_vhvhvhi.var index : {unsigned} = {index1|index0};

sqrdmulh_vhvhvhi.disasm = {
  sink << "sqrdmulh\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 0, 1) << DisasmSubscript(index);
};

sqrdmulh_vhvhvhi.execute = {
  typedef typename ARCH::S16 DST;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4<<q;
  DST res[elements];
  S32 element(cpu.GetVS16(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, S32(cpu.GetVS16(rn, idx)) * element, typename ARCH::S8(-15), /* round */ true, /* sat */ false));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sqrdmulh_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b101101[6] : rn[5] : rd[5] );

sqrdmulh_vhvhvh.disasm = {
  sink << "sqrdmulh\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

sqrdmulh_vhvhvh.execute = {
  typedef typename ARCH::S16 DST;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4<<q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, S32(cpu.GetVS16(rm, idx)) * S32(cpu.GetVS16(rn, idx)), typename ARCH::S8(-15), /* round */ true, /* sat */ false));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sqrdmulh_vsvsvsi( 0b0[1] : q[1] : 0b00111110[8] : index0[1] : rm[5] : 0b1101[4] : shl<1> index1[1] : 0b0[1] : rn[5] : rd[5] );
sqrdmulh_vsvsvsi.var index : {unsigned} = {index1|index0};

sqrdmulh_vsvsvsi.disasm = {
  sink << "sqrdmulh\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 0, 2) << DisasmSubscript(index);
};

sqrdmulh_vsvsvsi.execute = {
  typedef typename ARCH::S32 DST;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2<<q;
  DST res[elements];
  S64 element(cpu.GetVS32(rm, index));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, S64(cpu.GetVS32(rn, idx)) * element, typename ARCH::S8(-31), /* round */ true, /* sat */ false));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sqrdmulh_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b101101[6] : rn[5] : rd[5] );

sqrdmulh_vsvsvs.disasm = {
  sink << "sqrdmulh\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sqrdmulh_vsvsvs.execute = {
  typedef typename ARCH::S32 DST;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2<<q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = SatNarrow<DST>(cpu, NeonSHL(cpu, S64(cpu.GetVS32(rm, idx)) * S64(cpu.GetVS32(rn, idx)), typename ARCH::S8(-31), /* round */ true, /* sat */ false));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVS32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op sqrshl_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

sqrshl_vbvbvb.disasm = {
  sink << "sqrshl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

sqrshl_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVS8(rd, idx, NeonSHL(cpu, cpu.GetVS8(rn, idx), cpu.GetVS8(rm, idx), /* round */ true, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sqrshl_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

sqrshl_vhvhvh.disasm = {
  sink << "sqrshl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

sqrshl_vhvhvh.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVS16(rd, idx, NeonSHL(cpu, cpu.GetVS16(rn, idx), S8(cpu.GetVS16(rm, idx)), /* round */ true, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sqrshl_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

sqrshl_vsvsvs.disasm = {
  sink << "sqrshl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sqrshl_vsvsvs.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVS32(rd, idx, NeonSHL(cpu, cpu.GetVS32(rn, idx), S8(cpu.GetVS32(rm, idx)), /* round */ true, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sqshl_vbbi( 0b0[1] : q[1] : 0b00111100001[11] : imm[3] : 0b011101[6] : rn[5] : rd[5] );

sqshl_vbbi.disasm = {
  sink << "sqshl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmI(imm);
};

sqshl_vbbi.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVS8(rd, idx, NeonSHL(cpu, cpu.GetVS8(rn, idx), typename ARCH::S8(imm), /* round */ false, /* sat */ true));
  cpu.ClearHighV(rd, 8<<q);
};

op sqshl_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

sqshl_vbvbvb.disasm = {
  sink << "sqshl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

sqshl_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVS8(rd, idx, NeonSHL(cpu, cpu.GetVS8(rn, idx), cpu.GetVS8(rm, idx), /* round */ false, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sqshl_vhhi( 0b0[1] : q[1] : 0b0011110001[10] : imm[4] : 0b011101[6] : rn[5] : rd[5] );

sqshl_vhhi.disasm = {
  sink << "sqshl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmI(imm);
};

sqshl_vhhi.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVS16(rd, idx, NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(imm), /* round */ false, /* sat */ true));
  cpu.ClearHighV(rd, 8<<q);
};

op sqshl_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

sqshl_vhvhvh.disasm = {
  sink << "sqshl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

sqshl_vhvhvh.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVS16(rd, idx, NeonSHL(cpu, cpu.GetVS16(rn, idx), S8(cpu.GetVS16(rm, idx)), /* round */ false, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sqshl_vssi( 0b0[1] : q[1] : 0b001111001[9] : imm[5] : 0b011101[6] : rn[5] : rd[5] );

sqshl_vssi.disasm = {
  sink << "sqshl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmI(imm);
};

sqshl_vssi.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVS32(rd, idx, NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(imm), /* round */ false, /* sat */ true));
  cpu.ClearHighV(rd, 8<<q);
};

op sqshl_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

sqshl_vsvsvs.disasm = {
  sink << "sqshl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sqshl_vsvsvs.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVS32(rd, idx, NeonSHL(cpu, cpu.GetVS32(rn, idx), S8(cpu.GetVS32(rm, idx)), /* round */ false, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sqshlu_vbbi( 0b0[1] : q[1] : 0b10111100001[11] : shift[3] : 0b011001[6] : rn[5] : rd[5] );

sqshlu_vbbi.disasm = {
  sink << "sqshlu\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmI(shift);
};

sqshlu_vbbi.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U8 U8;

  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      S8 op = cpu.GetVS8(rn, idx);
      U8 res(0);
      if (cpu.Test(op < S8(0)))
        {
          cpu.SetQC();
        }
      else
        {
          res = NeonSHL(cpu, U8(op), S8(shift), /* round */ false, /* sat */ true);
        }

      cpu.SetVU8(rd, idx, res);
    }

  cpu.ClearHighV(rd, 8<<q);
};

op sqshlu_vhhi( 0b0[1] : q[1] : 0b1011110001[10] : shift[4] : 0b011001[6] : rn[5] : rd[5] );

sqshlu_vhhi.disasm = {
  sink << "sqshlu\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmI(shift);
};

sqshlu_vhhi.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::U16 U16;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      S16 op = cpu.GetVS16(rn, idx);
      U16 res(0);
      if (cpu.Test(op < S16(0)))
        {
          cpu.SetQC();
        }
      else
        {
          res = NeonSHL(cpu, U16(op), S8(shift), /* round */ false, /* sat */ true);
        }

      cpu.SetVU16(rd, idx, res);
    }

  cpu.ClearHighV(rd, 8<<q);
};

op sqshlu_vssi( 0b0[1] : q[1] : 0b101111001[9] : shift[5] : 0b011001[6] : rn[5] : rd[5] );

sqshlu_vssi.disasm = {
  sink << "sqshlu\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmI(shift);
};

sqshlu_vssi.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      S32 op = cpu.GetVS32(rn, idx);
      U32 res(0);
      if (cpu.Test(op < S32(0)))
        {
          cpu.SetQC();
        }
      else
        {
          res = NeonSHL(cpu, U32(op), S8(shift), /* round */ false, /* sat */ true);
        }

      cpu.SetVU32(rd, idx, res);
    }

  cpu.ClearHighV(rd, 8<<q);
};

op sqsub_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

sqsub_vbvbvb.disasm = {
  sink << "sqsub\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

sqsub_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVS8(rd, idx, SatSub(cpu, cpu.GetVS8(rn, idx), cpu.GetVS8(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
}

op sqsub_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

sqsub_vhvhvh.disasm = {
  sink << "sqsub\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

sqsub_vhvhvh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVS16(rd, idx, SatSub(cpu, cpu.GetVS16(rn, idx), cpu.GetVS16(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op sqsub_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

sqsub_vsvsvs.disasm = {
  sink << "sqsub\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sqsub_vsvsvs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVS32(rd, idx, SatSub(cpu, cpu.GetVS32(rn, idx), cpu.GetVS32(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op srhadd_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b000101[6] : rn[5] : rd[5] );

srhadd_vbvbvb.disasm = {
  sink << "srhadd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

srhadd_vbvbvb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S16 S16;
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVS8(rd, idx, S8((S16(cpu.GetVS8(rn, idx)) + S16(cpu.GetVS8(rm, idx)) + S16(1)) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op srhadd_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b000101[6] : rn[5] : rd[5] );

srhadd_vhvhvh.disasm = {
  sink << "srhadd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

srhadd_vhvhvh.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVS16(rd, idx, S16((S32(cpu.GetVS16(rn, idx)) + S32(cpu.GetVS16(rm, idx)) + S32(1)) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op srhadd_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b000101[6] : rn[5] : rd[5] );

srhadd_vsvsvs.disasm = {
  sink << "srhadd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

srhadd_vsvsvs.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVS32(rd, idx, S32((S64(cpu.GetVS32(rn, idx)) + S64(cpu.GetVS32(rm, idx)) + S64(1)) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op sri_vbbi( 0b0[1] : q[1] : 0b10111100001[11] : lro[3] : 0b010001[6] : rn[5] : rd[5] );
sri_vbbi.var shift : {unsigned} = {8 - lro};

sri_vbbi.disasm = {
  sink << "sri\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmI(shift);
};

sri_vbbi.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::S8 S8;
  unsigned const elements = 8<<q;
  
  U8 mask(~NeonSHL(cpu, U8(~U8(0)), -S8(shift)));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      U8 op1(cpu.GetVU8(rd, idx)), op2(cpu.GetVU8(rn, idx)), res(U8(op1 & mask) | NeonSHL(cpu, op2, -S8(shift)));
      cpu.SetVU8(rd, idx, res);
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sri_vhhi( 0b0[1] : q[1] : 0b1011110001[10] : lro[4] : 0b010001[6] : rn[5] : rd[5] );
sri_vhhi.var shift : {unsigned} = {16 - lro};

sri_vhhi.disasm = {
  sink << "sri\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmI(shift);
};

sri_vhhi.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::S8 S8;
  unsigned const elements = 4<<q;

  U16 mask(~NeonSHL(cpu, U16(~U16(0)), -S8(shift)));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      U16 op1(cpu.GetVU16(rd, idx)), op2(cpu.GetVU16(rn, idx)), res(U16(op1 & mask) | NeonSHL(cpu, op2, -S8(shift)));
      cpu.SetVU16(rd, idx, res);
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sri_vssi( 0b0[1] : q[1] : 0b101111001[9] : lro[5] : 0b010001[6] : rn[5] : rd[5] );
sri_vssi.var shift : {unsigned} = {32 - lro};

sri_vssi.disasm = {
  sink << "sri\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmI(shift);
};

sri_vssi.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S8 S8;
  unsigned const elements = 2<<q;

  U32 mask(~NeonSHL(cpu, U32(~U32(0)), -S8(shift)));
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      U32 op1(cpu.GetVU32(rd, idx)), op2(cpu.GetVU32(rn, idx)), res(U32(op1 & mask) | NeonSHL(cpu, op2, -S8(shift)));
      cpu.SetVU32(rd, idx, res);
    }

  cpu.ClearHighV(rd, 8<<q);
}

op srshl_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

srshl_vbvbvb.disasm = {
  sink << "srshl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

srshl_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVS8(rd, idx, NeonSHL(cpu, cpu.GetVS8(rn, idx), cpu.GetVS8(rm, idx), /* round */ true, /* sat */ false));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op srshl_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

srshl_vhvhvh.disasm = {
  sink << "srshl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

srshl_vhvhvh.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVS16(rd, idx, NeonSHL(cpu, cpu.GetVS16(rn, idx), S8(cpu.GetVS16(rm, idx)), /* round */ true, /* sat */ false));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op srshl_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

srshl_vsvsvs.disasm = {
  sink << "srshl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

srshl_vsvsvs.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVS32(rd, idx, NeonSHL(cpu, cpu.GetVS32(rn, idx), S8(cpu.GetVS32(rm, idx)), /* round */ true, /* sat */ false));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op sshl_vbvbvb( 0b0[1] : q[1] : 0b001110001[9] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

sshl_vbvbvb.disasm = {
  sink << "sshl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

sshl_vbvbvb.execute = {
  unsigned const elements = 8<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS8(rd, e, NeonSHL(cpu, cpu.GetVS8(rn, e), typename ARCH::S8(cpu.GetVS8(rm, e))));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op sshl_vhvhvh( 0b0[1] : q[1] : 0b001110011[9] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

sshl_vhvhvh.disasm = {
  sink << "sshl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

sshl_vhvhvh.execute = {
  unsigned const elements = 4<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS16(rd, e, NeonSHL(cpu, cpu.GetVS16(rn, e), typename ARCH::S8(cpu.GetVS16(rm, e))));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op sshl_vsvsvs( 0b0[1] : q[1] : 0b001110101[9] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

sshl_vsvsvs.disasm = {
  sink << "sshl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sshl_vsvsvs.execute = {
  unsigned const elements = 2<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVS32(rd, e, NeonSHL(cpu, cpu.GetVS32(rn, e), typename ARCH::S8(cpu.GetVS32(rm, e))));
    }
  cpu.ClearHighV(rd, 8<<q);
};

/*******************************************************************
 * SSHR
 *
 * Signed Shift Right (immediate).
 */

op  sshr_vbbi( 0b0[1] : q[1] : 0b00111100001[11] : lro[3] : 0b00[2] : sm[2] : 1[2] : rn[5] : rd[5] );
sshr_vbbi.var shift : {unsigned} = {8 - lro};

sshr_vbbi.disasm = {
  sink << (sm&2?"sr":"s") << (sm&1?"sra\t":"shr\t") << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmI(shift);
};

sshr_vbbi.execute = {
  typedef typename ARCH::U8 U8;

  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      U8 res(NeonSHL(cpu, cpu.GetVS8(rn, idx), typename ARCH::S8(-shift), /* round */ sm & 2, /* sat */ false));
      if (sm & 1)
        res += cpu.GetVU8(rd, idx);
      cpu.SetVU8(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op sshr_vhhi( 0b0[1] : q[1] : 0b0011110001[10] : lro[4] : 0b00[2] : sm[2] : 1[2] : rn[5] : rd[5] );
sshr_vhhi.var shift : {unsigned} = {16 - lro};

sshr_vhhi.disasm = {
  sink << (sm&2?"sr":"s") << (sm&1?"sra\t":"shr\t") << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmI(shift);
};

sshr_vhhi.execute = {
  typedef typename ARCH::U16 U16;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      U16 res( NeonSHL(cpu, cpu.GetVS16(rn, idx), typename ARCH::S8(-shift), /* round */ sm & 2, /* sat */ false) );
      if (sm & 1)
        res += cpu.GetVU16(rd, idx);
      cpu.SetVU16(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op sshr_vssi( 0b0[1] : q[1] : 0b001111001[9] : lro[5] : 0b00[2] : sm[2] : 1[2] : rn[5] : rd[5] );
sshr_vssi.var shift : {unsigned} = {32 - lro};

sshr_vssi.disasm = {
  sink << (sm&2?"sr":"s") << (sm&1?"sra\t":"shr\t") << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmI(shift);
};

sshr_vssi.execute = {
  typedef typename ARCH::U32 U32;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      U32 res( NeonSHL(cpu, cpu.GetVS32(rn, idx), typename ARCH::S8(-shift), /* round */ sm & 2, /* sat */ false) );
      if (sm & 1)
        res += cpu.GetVU32(rd, idx);
      cpu.SetVU32(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op sshr_v2d2di( 0b0100111101[10] : lro[6] : 0b00[2] : sm[2] : 1[2] : rn[5] : rd[5] );
sshr_v2d2di.var shift : {uint8_t} = { 64 - lro };

sshr_v2d2di.disasm = {
  sink << (sm&2?"sr":"s") << (sm&1?"sra\t":"shr\t") << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(64-lro);
};

sshr_v2d2di.execute = {
  typedef typename ARCH::U64 U64;

  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      U64 res( NeonSHL(cpu, cpu.GetVS64(rn, idx), typename ARCH::S8(-shift), /* round */ sm & 2, /* sat */ false) );
      if (sm & 1)
        res += cpu.GetVU64(rd, idx);
      cpu.SetVU64(rd, idx, res);
    }
};

/*
 * end of SSHR
 *******************************************************************/

op sub_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

sub_vbvbvb.disasm = {
  sink << "sub\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

sub_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, cpu.GetVU8(rn, idx) - cpu.GetVU8(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
}

op sub_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

sub_vhvhvh.disasm = {
  sink << "sub\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

sub_vhvhvh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, cpu.GetVU16(rn, idx) - cpu.GetVU16(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
}

op sub_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b100001[6] : rn[5] : rd[5] );

sub_vsvsvs.disasm = {
  sink << "sub\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

sub_vsvsvs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, cpu.GetVU32(rn, idx) - cpu.GetVU32(rm, idx));
  cpu.ClearHighV(rd, 8<<q);
}

op suqadd_vbb( 0b0[1] : q[1] : 0b00111000100000001110[20] : rn[5] : rd[5] );

suqadd_vbb.disasm = {
  sink << "suqadd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

suqadd_vbb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVS8(rd, idx, SatAdd(cpu, cpu.GetVS8(rd, idx), cpu.GetVU8(rn, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op suqadd_vhh( 0b0[1] : q[1] : 0b00111001100000001110[20] : rn[5] : rd[5] );

suqadd_vhh.disasm = {
  sink << "suqadd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

suqadd_vhh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVS16(rd, idx, SatAdd(cpu, cpu.GetVS16(rd, idx), cpu.GetVU16(rn, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op suqadd_vss( 0b0[1] : q[1] : 0b00111010100000001110[20] : rn[5] : rd[5] );

suqadd_vss.disasm = {
  sink << "suqadd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

suqadd_vss.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVS32(rd, idx, SatAdd(cpu, cpu.GetVS32(rd, idx), cpu.GetVU32(rn, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op tbl( 0b0[1] : q[1] : 0b001110000[9] : rm[5] : 0[1] : len[2] : 0[3] : rn[5] : rd[5] );

tbl.disasm = {
  sink << "tbl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmBunch(rn, len+1, 16, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

tbl.execute = {
  typedef typename ARCH::U8 U8;
  unsigned const elements = 8<<q, regs = len+1;
  
  U8 res[elements];
  for (unsigned e=0; e < elements; e += 1)
    res[e] = cpu.GetTVU8(rn, 16, regs, cpu.GetVU8(rm, e), U8(0));
  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU8(rd, e, res[e]);
  cpu.ClearHighV(rd, 8<<q);
};

op tbx( 0b0[1] : q[1] : 0b001110000[9] : rm[5] : 0[1] : len[2] : 4[3] : rn[5] : rd[5] );

tbx.disasm = {
  sink << "tbx\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmBunch(rn, len+1, 16, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

tbx.execute = {
  typedef typename ARCH::U8 U8;
  unsigned const elements = 8<<q, regs = len+1;
  
  U8 res[elements];
  for (unsigned e=0; e < elements; e += 1)
    res[e] = cpu.GetTVU8(rn, 16, regs, cpu.GetVU8(rm, e), cpu.GetVU8(rd, e));
  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU8(rd, e, res[e]);
  cpu.ClearHighV(rd, 8<<q);
};

/*******************************************************************
 * TRN
 *
 * Transpose vectors
 */

op trn_vb( 0b0[1] : q[1] : 0b001110000[9] : rm[5] : 0b0[1] : op[1] : 0b1010[4] : rn[5] : rd[5] );

trn_vb.disasm = {
  sink << "trn" << int(op+1) << "\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

trn_vb.execute = {
  unsigned const elements = 8<<q;
  for (unsigned e=0; e < elements; e += 2)
    {
      typename ARCH::U8 op0 = cpu.GetVU8(rn, e|op), op1 = cpu.GetVU8(rm, e|op);
      cpu.SetVU8(rd, e|0, op0);
      cpu.SetVU8(rd, e|1, op1);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op trn_vh( 0b0[1] : q[1] : 0b001110010[9] : rm[5] : 0b0[1] : op[1] : 0b1010[4] : rn[5] : rd[5] );

trn_vh.disasm = {
  sink << "trn" << int(op+1) << "\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

trn_vh.execute = {
  unsigned const elements = 4<<q;
  for (unsigned e=0; e < elements; e += 2)
    {
      typename ARCH::U16 op0 = cpu.GetVU16(rn, e|op), op1 = cpu.GetVU16(rm, e|op);
      cpu.SetVU16(rd, e|0, op0);
      cpu.SetVU16(rd, e|1, op1);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op trn_vs( 0b0[1] : q[1] : 0b001110100[9] : rm[5] : 0b0[1] : op[1] : 0b1010[4] : rn[5] : rd[5] );

trn_vs.disasm = {
  sink << "trn" << int(op+1) << "\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

trn_vs.execute = {
  unsigned const elements = 2<<q;
  for (unsigned e=0; e < elements; e += 2)
    {
      typename ARCH::U32 op0 = cpu.GetVU32(rn, e|op), op1 = cpu.GetVU32(rm, e|op);
      cpu.SetVU32(rd, e|0, op0);
      cpu.SetVU32(rd, e|1, op1);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op trn_v2d( 0b01001110110[11] : rm[5] : 0b0[1] : op[1] : 0b1010[4] : rn[5] : rd[5] );

trn_v2d.disasm = {
  sink << "trn" << int(op+1) << "\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

trn_v2d.execute = {
  typename ARCH::U64 op0 = cpu.GetVU64(rn, op), op1 = cpu.GetVU64(rm, op);
  cpu.SetVU64(rd, 0, op0);
  cpu.SetVU64(rd, 1, op1);
};

/*
 * end of TRN
 *
 * Transpose vectors
 *******************************************************************/

op uaba_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b011111[6] : rn[5] : rd[5] );

uaba_vbvbvb.disasm = {
  sink << "uaba\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uaba_vbvbvb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, cpu.GetVU8(rd, idx) + U8(Abs(cpu, S16(U16(cpu.GetVU8(rn, idx)) - U16(cpu.GetVU8(rm, idx))))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uaba_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b011111[6] : rn[5] : rd[5] );

uaba_vhvhvh.disasm = {
  sink << "uaba\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uaba_vhvhvh.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, cpu.GetVU16(rd, idx) + U16(Abs(cpu, S32(U32(cpu.GetVU16(rn, idx)) - U32(cpu.GetVU16(rm, idx))))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uaba_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b011111[6] : rn[5] : rd[5] );

uaba_vsvsvs.disasm = {
  sink << "uaba\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uaba_vsvsvs.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, cpu.GetVU32(rd, idx) + U32(Abs(cpu, S64(U64(cpu.GetVU32(rn, idx)) - U64(cpu.GetVU32(rm, idx))))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uabd_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b011101[6] : rn[5] : rd[5] );

uabd_vbvbvb.disasm = {
  sink << "uabd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uabd_vbvbvb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::S16 S16;
  unsigned const elements = 8<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, U8(Abs(cpu, S16(U16(cpu.GetVU8(rn, idx))) - S16(U16(cpu.GetVU8(rm, idx))))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uabd_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b011101[6] : rn[5] : rd[5] );

uabd_vhvhvh.disasm = {
  sink << "uabd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uabd_vhvhvh.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  unsigned const elements = 4<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, U16(Abs(cpu, S32(U32(cpu.GetVU16(rn, idx))) - S32(U32(cpu.GetVU16(rm, idx))))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uabd_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b011101[6] : rn[5] : rd[5] );

uabd_vsvsvs.disasm = {
  sink << "uabd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uabd_vsvsvs.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  unsigned const elements = 2<<q;
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, U32(Abs(cpu, S64(U64(cpu.GetVU32(rn, idx))) - S64(U64(cpu.GetVU32(rm, idx))))));
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uadalp_vhb( 0b0[1] : q[1] : 0b10111000100000011010[20] : rn[5] : rd[5] );

uadalp_vhb.disasm = {
  sink << "uadalp\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 8<<q, 0);
};

uadalp_vhb.execute = {
  typedef typename ARCH::U16 DST;
  typedef typename ARCH::U16 U16;
  unsigned const elements = 4<<q;

  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU16(rd, idx) + U16(cpu.GetVU8(rn, 2*idx)) + U16(cpu.GetVU8(rn, (2*idx)+1));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }

  cpu.ClearHighV(rd, 8<<q);
};

op uadalp_vsh( 0b0[1] : q[1] : 0b10111001100000011010[20] : rn[5] : rd[5] );

uadalp_vsh.disasm = {
  sink << "uadalp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 4<<q, 1);
};

uadalp_vsh.execute = {
  typedef typename ARCH::U32 DST;
  typedef typename ARCH::U32 U32;
  unsigned const elements = 2<<q;

  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU32(rd, idx) + U32(cpu.GetVU16(rn, 2*idx)) + U32(cpu.GetVU16(rn, (2*idx)+1));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }

  cpu.ClearHighV(rd, 8<<q);
};

op uadalp_vds( 0b0[1] : q[1] : 0b10111010100000011010[20] : rn[5] : rd[5] );

uadalp_vds.disasm = {
  sink << "uadalp\t" << DisasmTV(rd, 1<<q, 3) << ", " << DisasmTV(rn, 2<<q, 2);
};

uadalp_vds.execute = {
  typedef typename ARCH::U64 DST;
  typedef typename ARCH::U64 U64;
  unsigned const elements = 1<<q;

  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = cpu.GetVU64(rd, idx) + U64(cpu.GetVU32(rn, 2*idx)) + U64(cpu.GetVU32(rn, (2*idx)+1));
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }

  cpu.ClearHighV(rd, 8<<q);
};

/*******************************************************************
 * UADDLP
 *
 * Unsigned Add Long Pairwise.
 */

op uaddlp_vhb( 0b0[1] : q[1] : 0b10111000100000001010[20] : rn[5] : rd[5] );

uaddlp_vhb.disasm = {
  sink << "uaddlp\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 8<<q, 0);
};

uaddlp_vhb.execute = {
  unsigned const elements = 4<<q;
  typedef typename ARCH::U16 U16;

  for (unsigned e=0; e < elements; e += 1)
    {
      cpu.SetVU16(rd, e, U16(cpu.GetVU8(rn, 2*e+0)) + U16(cpu.GetVU8(rn, 2*e+1)) );
    }

  cpu.ClearHighV(rd, 8<<q);
};

op uaddlp_vsh( 0b0[1] : q[1] : 0b10111001100000001010[20] : rn[5] : rd[5] );

uaddlp_vsh.disasm = {
  sink << "uaddlp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 4<<q, 1);
};

uaddlp_vsh.execute = {
  unsigned const elements = 2<<q;
  typedef typename ARCH::U32 U32;

  for (unsigned e=0; e < elements; e += 1)
    {
      cpu.SetVU32(rd, e, U32(cpu.GetVU16(rn, 2*e+0)) + U32(cpu.GetVU16(rn, 2*e+1)) );
    }

  cpu.ClearHighV(rd, 8<<q);
};

op uaddlp_vds( 0b0[1] : q[1] : 0b10111010100000001010[20] : rn[5] : rd[5] );

uaddlp_vds.disasm = {
  sink << "uaddlp\t" << DisasmTV(rd, 1<<q, 3) << ", " << DisasmTV(rn, 2<<q, 2);
};

uaddlp_vds.execute = {
  unsigned const elements = 1<<q;
  typedef typename ARCH::U64 U64;

  for (unsigned e=0; e < elements; e += 1)
    {
      cpu.SetVU64(rd, e, U64(cpu.GetVU32(rn, 2*e+0)) + U64(cpu.GetVU32(rn, 2*e+1)) );
    }

  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of UADDLP
 *******************************************************************/

op uaddlv_hvb( 0b0[1] : q[1] : 0b10111000110000001110[20] : rn[5] : rd[5] );

uaddlv_hvb.disasm = {
  sink << "uaddlv\t" << DisasmH(rd) << ", " << DisasmTV(rn, 8<<q, 0);
};

uaddlv_hvb.execute = {
  unsigned const elements = 8<<q;
  typedef typename ARCH::U16 U16;
  
  U16 sum = U16(cpu.GetVU8(rn, 0));
  for (unsigned e=1; e < elements; e += 1)
    {
      sum += U16(cpu.GetVU8(rn, e));
    }
  
  cpu.SetVU16(rd, 0, sum);
  cpu.ClearHighV(rd, 2);
}

op uaddlv_svh( 0b0[1] : q[1] : 0b10111001110000001110[20] : rn[5] : rd[5] );

uaddlv_svh.disasm = {
  sink << "uaddlv\t" << DisasmS(rd) << ", " << DisasmTV(rn, 4<<q, 1);
};

uaddlv_svh.execute = {
  unsigned const elements = 4<<q;
  typedef typename ARCH::U32 U32;
  
  U32 sum = U32(cpu.GetVU16(rn, 0));
  for (unsigned e=1; e < elements; e += 1)
    {
      sum += U32(cpu.GetVU16(rn, e));
    }
  
  cpu.SetVU32(rd, 0, sum);
  cpu.ClearHighV(rd, 4);
}

op uhadd_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b000001[6] : rn[5] : rd[5] );

uhadd_vbvbvb.disasm = {
  sink << "uhadd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uhadd_vbvbvb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U16 U16;
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, U8((U16(cpu.GetVU8(rn, idx)) + U16(cpu.GetVU8(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op uhadd_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b000001[6] : rn[5] : rd[5] );

uhadd_vhvhvh.disasm = {
  sink << "uhadd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uhadd_vhvhvh.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, U16((U32(cpu.GetVU16(rn, idx)) + U32(cpu.GetVU16(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op uhadd_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b000001[6] : rn[5] : rd[5] );

uhadd_vsvsvs.disasm = {
  sink << "uhadd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uhadd_vsvsvs.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, U32((U64(cpu.GetVU32(rn, idx)) + U64(cpu.GetVU32(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op uhsub_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b001001[6] : rn[5] : rd[5] );

uhsub_vbvbvb.disasm = {
  sink << "uhsub\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uhsub_vbvbvb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U16 U16;
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, U8((U16(cpu.GetVU8(rn, idx)) - U16(cpu.GetVU8(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op uhsub_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b001001[6] : rn[5] : rd[5] );

uhsub_vhvhvh.disasm = {
  sink << "uhsub\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uhsub_vhvhvh.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, U16((U32(cpu.GetVU16(rn, idx)) - U32(cpu.GetVU16(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op uhsub_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b001001[6] : rn[5] : rd[5] );

uhsub_vsvsvs.disasm = {
  sink << "uhsub\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uhsub_vsvsvs.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, U32((U64(cpu.GetVU32(rn, idx)) - U64(cpu.GetVU32(rm, idx))) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op umax_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b011001[6] : rn[5] : rd[5] );

umax_vbvbvb.disasm = {
  sink << "umax\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

umax_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, Maximum(cpu.GetVU8(rn, idx), cpu.GetVU8(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op umax_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b011001[6] : rn[5] : rd[5] );

umax_vhvhvh.disasm = {
  sink << "umax\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

umax_vhvhvh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, Maximum(cpu.GetVU16(rn, idx), cpu.GetVU16(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op umax_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b011001[6] : rn[5] : rd[5] );

umax_vsvsvs.disasm = {
  sink << "umax\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

umax_vsvsvs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, Maximum(cpu.GetVU32(rn, idx), cpu.GetVU32(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

/*******************************************************************
 * UMAXP
 *
 * Unsigned Maximum Pairwise.
 */

op umaxp_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b101001[6] : rn[5] : rd[5] );

umaxp_vbvbvb.disasm = {
  sink << "umaxp\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

umaxp_vbvbvb.execute = {
  unsigned const elements = 8<<q;
  typename ARCH::U8 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Maximum(cpu.GetVU8(rn, e), cpu.GetVU8(rn, e+1));
      res[(elements+e)/2] = Maximum(cpu.GetVU8(rm, e), cpu.GetVU8(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU8(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

op umaxp_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b101001[6] : rn[5] : rd[5] );

umaxp_vhvhvh.disasm = {
  sink << "umaxp\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

umaxp_vhvhvh.execute = {
  unsigned const elements = 4<<q;
  typename ARCH::U16 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Maximum(cpu.GetVU16(rn, e), cpu.GetVU16(rn, e+1));
      res[(elements+e)/2] = Maximum(cpu.GetVU16(rm, e), cpu.GetVU16(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU16(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

op umaxp_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b101001[6] : rn[5] : rd[5] );

umaxp_vsvsvs.disasm = {
  sink << "umaxp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

umaxp_vsvsvs.execute = {
  unsigned const elements = 2<<q;
  typename ARCH::U32 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Maximum(cpu.GetVU32(rn, e), cpu.GetVU32(rn, e+1));
      res[(elements+e)/2] = Maximum(cpu.GetVU32(rm, e), cpu.GetVU32(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU32(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of UMAXP
 *******************************************************************/

op umin_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b011011[6] : rn[5] : rd[5] );

umin_vbvbvb.disasm = {
  sink << "umin\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

umin_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, Minimum(cpu.GetVU8(rn, idx), cpu.GetVU8(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op umin_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b011011[6] : rn[5] : rd[5] );

umin_vhvhvh.disasm = {
  sink << "umin\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

umin_vhvhvh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, Minimum(cpu.GetVU16(rn, idx), cpu.GetVU16(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op umin_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b011011[6] : rn[5] : rd[5] );

umin_vsvsvs.disasm = {
  sink << "umin\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

umin_vsvsvs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, Minimum(cpu.GetVU32(rn, idx), cpu.GetVU32(rm, idx)));
    }

  cpu.ClearHighV(rd, 8<<q);
}

/*******************************************************************
 * UMINP
 *
 * Unsigned Minimum Pairwise.
 */

op uminp_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b101011[6] : rn[5] : rd[5] );

uminp_vbvbvb.disasm = {
  sink << "uminp\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uminp_vbvbvb.execute = {
  unsigned const elements = 8<<q;
  typename ARCH::U8 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Minimum(cpu.GetVU8(rn, e), cpu.GetVU8(rn, e+1));
      res[(elements+e)/2] = Minimum(cpu.GetVU8(rm, e), cpu.GetVU8(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU8(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

op uminp_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b101011[6] : rn[5] : rd[5] );

uminp_vhvhvh.disasm = {
  sink << "uminp\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uminp_vhvhvh.execute = {
  unsigned const elements = 4<<q;
  typename ARCH::U16 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Minimum(cpu.GetVU16(rn, e), cpu.GetVU16(rn, e+1));
      res[(elements+e)/2] = Minimum(cpu.GetVU16(rm, e), cpu.GetVU16(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU16(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

op uminp_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b101011[6] : rn[5] : rd[5] );

uminp_vsvsvs.disasm = {
  sink << "uminp\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uminp_vsvsvs.execute = {
  unsigned const elements = 2<<q;
  typename ARCH::U32 res[elements];

  for (unsigned e=0; e < elements; e += 2)
    {
      res[       (0+e)/2] = Minimum(cpu.GetVU32(rn, e), cpu.GetVU32(rn, e+1));
      res[(elements+e)/2] = Minimum(cpu.GetVU32(rm, e), cpu.GetVU32(rm, e+1));
    }

  for (unsigned e=0; e < elements; e += 1)
    cpu.SetVU32(rd, e, res[e]);

  cpu.ClearHighV(rd, 8<<q);
};

/*
 * end of UMINP
 *******************************************************************/

op uqadd_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

uqadd_vbvbvb.disasm = {
  sink << "uqadd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uqadd_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, SatAdd(cpu, cpu.GetVU8(rn, idx), cpu.GetVU8(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op uqadd_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

uqadd_vhvhvh.disasm = {
  sink << "uqadd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uqadd_vhvhvh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, SatAdd(cpu, cpu.GetVU16(rn, idx), cpu.GetVU16(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op uqadd_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b000011[6] : rn[5] : rd[5] );

uqadd_vsvsvs.disasm = {
  sink << "uqadd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uqadd_vsvsvs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, SatAdd(cpu, cpu.GetVU32(rn, idx), cpu.GetVU32(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op uqrshl_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

uqrshl_vbvbvb.disasm = {
  sink << "uqrshl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uqrshl_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, NeonSHL(cpu, cpu.GetVU8(rn, idx), cpu.GetVS8(rm, idx), /* round */ true, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op uqrshl_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

uqrshl_vhvhvh.disasm = {
  sink << "uqrshl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uqrshl_vhvhvh.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, NeonSHL(cpu, cpu.GetVU16(rn, idx), S8(cpu.GetVS16(rm, idx)), /* round */ true, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op uqrshl_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b010111[6] : rn[5] : rd[5] );

uqrshl_vsvsvs.disasm = {
  sink << "uqrshl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uqrshl_vsvsvs.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, NeonSHL(cpu, cpu.GetVU32(rn, idx), S8(cpu.GetVS32(rm, idx)), /* round */ true, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op uqshl_vbbi( 0b0[1] : q[1] : 0b10111100001[11] : imm[3] : 0b011101[6] : rn[5] : rd[5] );

uqshl_vbbi.disasm = {
  sink << "uqshl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmI(imm);
};

uqshl_vbbi.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, NeonSHL(cpu, cpu.GetVU8(rn, idx), typename ARCH::S8(imm), /* round */ false, /* sat */ true));
  cpu.ClearHighV(rd, 8<<q);
};

op uqshl_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

uqshl_vbvbvb.disasm = {
  sink << "uqshl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uqshl_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, NeonSHL(cpu, cpu.GetVU8(rn, idx), cpu.GetVS8(rm, idx), /* round */ false, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op uqshl_vhhi( 0b0[1] : q[1] : 0b1011110001[10] : imm[4] : 0b011101[6] : rn[5] : rd[5] );

uqshl_vhhi.disasm = {
  sink << "uqshl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmI(imm);
};

uqshl_vhhi.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, NeonSHL(cpu, cpu.GetVU16(rn, idx), typename ARCH::S8(imm), /* round */ false, /* sat */ true));
  cpu.ClearHighV(rd, 8<<q);
};

op uqshl_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

uqshl_vhvhvh.disasm = {
  sink << "uqshl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uqshl_vhvhvh.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, NeonSHL(cpu, cpu.GetVU16(rn, idx), S8(cpu.GetVS16(rm, idx)), /* round */ false, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op uqshl_vssi( 0b0[1] : q[1] : 0b101111001[9] : imm[5] : 0b011101[6] : rn[5] : rd[5] );

uqshl_vssi.disasm = {
  sink << "uqshl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmI(imm);
};

uqshl_vssi.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, NeonSHL(cpu, cpu.GetVU32(rn, idx), typename ARCH::S8(imm), /* round */ false, /* sat */ true));
  cpu.ClearHighV(rd, 8<<q);
};

op uqshl_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b010011[6] : rn[5] : rd[5] );

uqshl_vsvsvs.disasm = {
  sink << "uqshl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uqshl_vsvsvs.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, NeonSHL(cpu, cpu.GetVU32(rn, idx), S8(cpu.GetVS32(rm, idx)), /* round */ false, /* sat */ true));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op uqsub_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

uqsub_vbvbvb.disasm = {
  sink << "uqsub\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uqsub_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, SatSub(cpu, cpu.GetVU8(rn, idx), cpu.GetVU8(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op uqsub_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

uqsub_vhvhvh.disasm = {
  sink << "uqsub\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uqsub_vhvhvh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, SatSub(cpu, cpu.GetVU16(rn, idx), cpu.GetVU16(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op uqsub_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b001011[6] : rn[5] : rd[5] );

uqsub_vsvsvs.disasm = {
  sink << "uqsub\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uqsub_vsvsvs.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, SatSub(cpu, cpu.GetVU32(rn, idx), cpu.GetVU32(rm, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op urecpe_vss( 0b0[1] : q[1] : 0b00111010100001110010[20] : rn[5] : rd[5] );

urecpe_vss.disasm = {
  sink << "urecpe\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

op urhadd_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b000101[6] : rn[5] : rd[5] );

urhadd_vbvbvb.disasm = {
  sink << "urhadd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

urhadd_vbvbvb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U16 U16;
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    cpu.SetVU8(rd, idx, U8((U16(cpu.GetVU8(rn, idx)) + U16(cpu.GetVU8(rm, idx)) + U16(1)) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op urhadd_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b000101[6] : rn[5] : rd[5] );

urhadd_vhvhvh.disasm = {
  sink << "urhadd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

urhadd_vhvhvh.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    cpu.SetVU16(rd, idx, U16((U32(cpu.GetVU16(rn, idx)) + U32(cpu.GetVU16(rm, idx)) + U32(1)) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op urhadd_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b000101[6] : rn[5] : rd[5] );

urhadd_vsvsvs.disasm = {
  sink << "urhadd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

urhadd_vsvsvs.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    cpu.SetVU32(rd, idx, U32((U64(cpu.GetVU32(rn, idx)) + U64(cpu.GetVU32(rm, idx)) + U64(1)) >> 1));
  cpu.ClearHighV(rd, 8<<q);
};

op urshl_vbvbvb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

urshl_vbvbvb.disasm = {
  sink << "urshl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

urshl_vbvbvb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, NeonSHL(cpu, cpu.GetVU8(rn, idx), cpu.GetVS8(rm, idx), /* round */ true, /* sat */ false));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op urshl_vhvhvh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

urshl_vhvhvh.disasm = {
  sink << "urshl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

urshl_vhvhvh.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, NeonSHL(cpu, cpu.GetVU16(rn, idx), S8(cpu.GetVS16(rm, idx)), /* round */ true, /* sat */ false));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op urshl_vsvsvs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b010101[6] : rn[5] : rd[5] );

urshl_vsvsvs.disasm = {
  sink << "urshl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

urshl_vsvsvs.execute = {
  typedef typename ARCH::S8 S8;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, NeonSHL(cpu, cpu.GetVU32(rn, idx), S8(cpu.GetVS32(rm, idx)), /* round */ true, /* sat */ false));
    }

  cpu.ClearHighV(rd, 8<<q);
}

op ursqrte_vss( 0b0[1] : q[1] : 0b10111010100001110010[20] : rn[5] : rd[5] );

ursqrte_vss.disasm = {
  sink << "ursqrte\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

/*******************************************************************
 * USHL
 *
 * Unsigned Shift Left (register).
 */

op ushl_d( 0b01111110111[11] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

ushl_d.disasm = {
  sink << "ushl\t" << DisasmD(rd) << ", " << DisasmD(rn) << ", " << DisasmD(rm);
};

ushl_d.execute = {
  cpu.SetVU64(rd, NeonSHL(cpu, cpu.GetVU64(rn, 0), typename ARCH::S8(cpu.GetVU64(rm, 0))));
};

op ushl_vb( 0b0[1] : q[1] : 0b101110001[9] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

ushl_vb.disasm = {
  sink << "ushl\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

ushl_vb.execute = {
  unsigned const elements = 8<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVU8(rd, e, NeonSHL(cpu, cpu.GetVU8(rn, e), typename ARCH::S8(cpu.GetVU8(rm, e))));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op ushl_vh( 0b0[1] : q[1] : 0b101110011[9] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

ushl_vh.disasm = {
  sink << "ushl\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

ushl_vh.execute = {
  unsigned const elements = 4<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVU16(rd, e, NeonSHL(cpu, cpu.GetVU16(rn, e), typename ARCH::S8(cpu.GetVU16(rm, e))));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op ushl_vs( 0b0[1] : q[1] : 0b101110101[9] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

ushl_vs.disasm = {
  sink << "ushl\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

ushl_vs.execute = {
  unsigned const elements = 2<<q;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVU32(rd, e, NeonSHL(cpu, cpu.GetVU32(rn, e), typename ARCH::S8(cpu.GetVU32(rm, e))));
    }
  cpu.ClearHighV(rd, 8<<q);
};

op ushl_v2d( 0b01101110111[11] : rm[5] : 0b010001[6] : rn[5] : rd[5] );

ushl_v2d.disasm = {
  sink << "ushl\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmTV(rm, 2, 3);
};

ushl_v2d.execute = {
  unsigned const elements = 2;

  for (unsigned e = 0; e < elements; ++e)
    {
      cpu.SetVU64(rd, e, NeonSHL(cpu, cpu.GetVU64(rn, e), typename ARCH::S8(cpu.GetVU64(rm, e))));
    }
};

/*
 * end of USHL
 *******************************************************************/

/*******************************************************************
 * USHLL
 *
 * Unsigned Shift Left Long (immediate)
 */

op ushll_v8h( 0b0[1] : q[1] : 0b10111100001[11] : imm[3] : 0b101001[6] : rn[5] : rd[5] );

ushll_v8h.disasm = {
  sink << (imm ? "ushll" : "uxtl") << (q ? "2" : "") << '\t' << DisasmTV(rd, 8, 1) << ", " << DisasmTV(rn, 8<<q, 0);
  if (imm) { sink << ", " << DisasmI(imm); }
};

ushll_v8h.execute = {
  typedef typename ARCH::U16 DST;

  unsigned const elements = 8, srcidx = elements*q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU8(rn, srcidx + idx)) << imm;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
};

op ushll_v4s( 0b0[1] : q[1] : 0b1011110001[10] : imm[4] : 0b101001[6] : rn[5] : rd[5] );

ushll_v4s.disasm = {
  sink << (imm ? "ushll" : "uxtl") << (q ? "2" : "") << '\t' << DisasmTV(rd, 4, 2) << ", " << DisasmTV(rn, 4<<q, 1);
  if (imm) { sink << ", " << DisasmI(imm); }
};

ushll_v4s.execute = {
  typedef typename ARCH::U32 DST;

  unsigned const elements = 4, srcidx = elements*q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU16(rn, srcidx + idx)) << imm;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
};

op ushll_v2d( 0b0[1] : q[1] : 0b101111001[9] : imm[5] : 0b101001[6] : rn[5] : rd[5] );

ushll_v2d.disasm = {
  sink << (imm ? "ushll" : "uxtl") << (q ? "2" : "") << '\t' << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2<<q, 2);
  if (imm) { sink << ", " << DisasmI(imm); }
};

ushll_v2d.execute = {
  typedef typename ARCH::U64 DST;

  unsigned const elements = 2, srcidx = elements*q;
  DST res[elements];
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      res[idx] = DST(cpu.GetVU32(rn, srcidx + idx)) << imm;
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU64(rd, idx, res[idx]);
    }
};

/*
 * end of USHLL
 *******************************************************************/

/*******************************************************************
 * USHR
 *
 * Unsigned Shift Right (immediate).
 */

op ushr_vbbi( 0b0[1] : q[1] : 0b10111100001[11] : lro[3] : 0[2] : sm[2] : 1[2] : rn[5] : rd[5] );
ushr_vbbi.var round : {uint8_t} = {uint8_t(sm >> 1 << 7) >> lro}, shift : {unsigned} = {8 - lro};

ushr_vbbi.disasm = {
  sink << (sm&2?"ur":"u") << (sm&1?"sra\t":"shr\t") << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmI(shift);
};

ushr_vbbi.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U16 U16;

  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      U8 res( (U16(cpu.GetVU8(rn, idx)) + U16(round)) >> shift );
      if (sm & 1)
        res += cpu.GetVU8(rd, idx);
      cpu.SetVU8(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op ushr_vhhi( 0b0[1] : q[1] : 0b1011110001[10] : lro[4] : 0[2] : sm[2] : 1[2] : rn[5] : rd[5] );
ushr_vhhi.var round : {uint16_t} = {uint16_t(sm >> 1 << 15) >> lro}, shift : {unsigned} = {16 - lro};

ushr_vhhi.disasm = {
  sink << "ushr\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmI(shift);
};

ushr_vhhi.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;

  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      U16 res( (U32(cpu.GetVU16(rn, idx)) + U32(round)) >> shift );
      if (sm & 1)
        res += cpu.GetVU16(rd, idx);
      cpu.SetVU16(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op ushr_vssi( 0b0[1] : q[1] : 0b101111001[9] : lro[5] : 0[2] : sm[2] : 1[2] : rn[5] : rd[5] );
ushr_vssi.var round : {uint32_t} = {uint32_t(sm >> 1 << 31) >> lro}, shift : {unsigned} = {32 - lro};

ushr_vssi.disasm = {
  sink << "ushr\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmI(shift);
};

ushr_vssi.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      U32 res( (U64(cpu.GetVU32(rn, idx)) + U64(round)) >> shift );
      if (sm & 1)
        res += cpu.GetVU32(rd, idx);
      cpu.SetVU32(rd, idx, res);
    }
  cpu.ClearHighV(rd, 8<<q);
};

op ushr_v2d2di( 0b0110111101[10] : lro[6] : 0[2] : sm[2] : 1[2] : rn[5] : rd[5] );
ushr_v2d2di.var round : {uint64_t} = {uint64_t(uint64_t(sm) >> 1 << 63) >> lro}, shift0 : {uint8_t} = {(64-lro)>>1}, shift1 : {uint8_t} = {32-(lro>>1)};

ushr_v2d2di.disasm = {
  sink << "ushr\t" << DisasmTV(rd, 2, 3) << ", " << DisasmTV(rn, 2, 3) << ", " << DisasmI(64-lro);
};

ushr_v2d2di.execute = {
  typedef typename ARCH::U64 U64;

  for (unsigned idx = 0, end = 2; idx < end; ++idx)
    {
      /* the weird, decomposed, computation is here to accomodate 64 right-shifts */
      U64 op( cpu.GetVU64(rn, idx) ), rb(op & U64(round)), res( ((op >> shift1) + (rb >> (shift1-1))) >> shift0 );
      if (sm & 1)
        res += cpu.GetVU64(rd, idx);
      cpu.SetVU64(rd, idx, res);
    }
};

/*
 * end of USHR
 *******************************************************************/

op usqadd_vbb( 0b0[1] : q[1] : 0b10111000100000001110[20] : rn[5] : rd[5] );

usqadd_vbb.disasm = {
  sink << "usqadd\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0);
};

usqadd_vbb.execute = {
  for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
    {
      cpu.SetVU8(rd, idx, SatAdd(cpu, cpu.GetVU8(rd, idx), cpu.GetVS8(rn, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op usqadd_vhh( 0b0[1] : q[1] : 0b10111001100000001110[20] : rn[5] : rd[5] );

usqadd_vhh.disasm = {
  sink << "usqadd\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1);
};

usqadd_vhh.execute = {
  for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
    {
      cpu.SetVU16(rd, idx, SatAdd(cpu, cpu.GetVU16(rd, idx), cpu.GetVS16(rn, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op usqadd_vss( 0b0[1] : q[1] : 0b10111010100000001110[20] : rn[5] : rd[5] );

usqadd_vss.disasm = {
  sink << "usqadd\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2);
};

usqadd_vss.execute = {
  for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
    {
      cpu.SetVU32(rd, idx, SatAdd(cpu, cpu.GetVU32(rd, idx), cpu.GetVS32(rn, idx)));
    }
    
  cpu.ClearHighV(rd, 8<<q);
};

op uzp1_vbvbvb( 0b0[1] : q[1] : 0b001110000[9] : rm[5] : 0b000110[6] : rn[5] : rd[5] );

uzp1_vbvbvb.disasm = {
  sink << "uzp1\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uzp1_vbvbvb.execute = {
  typedef typename ARCH::U8 DST;

  unsigned const elements = 8<<q;
  DST res[elements];
  for (unsigned idx = 0, srcidx = 0; idx < (elements/2); ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU8(rn, srcidx);
    }
  for (unsigned idx = elements/2, srcidx = 0; idx < elements; ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU8(rm, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uzp1_vhvhvh( 0b0[1] : q[1] : 0b001110010[9] : rm[5] : 0b000110[6] : rn[5] : rd[5] );

uzp1_vhvhvh.disasm = {
  sink << "uzp1\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

uzp1_vhvhvh.execute = {
  typedef typename ARCH::U16 DST;

  unsigned const elements = 4<<q;
  DST res[elements];
  for (unsigned idx = 0, srcidx = 0; idx < (elements/2); ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU16(rn, srcidx);
    }
  for (unsigned idx = elements/2, srcidx = 0; idx < elements; ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU16(rm, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uzp1_vsvsvs( 0b0[1] : q[1] : 0b001110100[9] : rm[5] : 0b000110[6] : rn[5] : rd[5] );

uzp1_vsvsvs.disasm = {
  sink << "uzp1\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uzp1_vsvsvs.execute = {
  typedef typename ARCH::U32 DST;

  unsigned const elements = 2<<q;
  DST res[elements];
  for (unsigned idx = 0, srcidx = 0; idx < (elements/2); ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU32(rn, srcidx);
    }
  for (unsigned idx = elements/2, srcidx = 0; idx < elements; ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU32(rm, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uzp2_vbvbvb( 0b0[1] : q[1] : 0b001110000[9] : rm[5] : 0b010110[6] : rn[5] : rd[5] );

uzp2_vbvbvb.disasm = {
  sink << "uzp2\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

uzp2_vbvbvb.execute = {
  typedef typename ARCH::U8 DST;

  unsigned const elements = 8<<q;
  DST res[elements];
  for (unsigned idx = 0, srcidx = 1; idx < (elements/2); ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU8(rn, srcidx);
    }
  for (unsigned idx = elements/2, srcidx = 1; idx < elements; ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU8(rm, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op uzp2_vsvsvs( 0b0[1] : q[1] : 0b001110100[9] : rm[5] : 0b010110[6] : rn[5] : rd[5] );

uzp2_vsvsvs.disasm = {
  sink << "uzp2\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

uzp2_vsvsvs.execute = {
  typedef typename ARCH::U32 DST;

  unsigned const elements = 2<<q;
  DST res[elements];
  for (unsigned idx = 0, srcidx = 1; idx < (elements/2); ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU32(rn, srcidx);
    }
  for (unsigned idx = elements/2, srcidx = 1; idx < elements; ++idx, srcidx += 2)
    {
      res[idx] = cpu.GetVU32(rm, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op zip1_vbvbvb( 0b0[1] : q[1] : 0b001110000[9] : rm[5] : 0b001110[6] : rn[5] : rd[5] );

zip1_vbvbvb.disasm = {
  sink << "zip1\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

zip1_vbvbvb.execute = {
  typedef typename ARCH::U8 DST;

  unsigned const elements = 8<<q;
  DST res[elements];
  for( unsigned idx = 0; idx < elements; ++idx)
    {
      unsigned srcidx = idx / 2;
      res[idx] = cpu.GetVU8((idx & 1) ? rm : rn, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op zip1_vhvhvh( 0b0[1] : q[1] : 0b001110010[9] : rm[5] : 0b001110[6] : rn[5] : rd[5] );

zip1_vhvhvh.disasm = {
  sink << "zip1\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

zip1_vhvhvh.execute = {
  typedef typename ARCH::U16 DST;

  unsigned const elements = 4<<q;
  DST res[elements];
  for( unsigned idx = 0; idx < elements; ++idx)
    {
      unsigned srcidx = idx / 2;
      res[idx] = cpu.GetVU16((idx & 1) ? rm : rn, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op zip1_vsvsvs( 0b0[1] : q[1] : 0b001110100[9] : rm[5] : 0b001110[6] : rn[5] : rd[5] );

zip1_vsvsvs.disasm = {
  sink << "zip1\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

zip1_vsvsvs.execute = {
  typedef typename ARCH::U32 DST;

  unsigned const elements = 2<<q;
  DST res[elements];
  for( unsigned idx = 0; idx < elements; ++idx)
    {
      unsigned srcidx = idx / 2;
      res[idx] = cpu.GetVU32((idx & 1) ? rm : rn, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op zip2_vbvbvb( 0b0[1] : q[1] : 0b001110000[9] : rm[5] : 0b011110[6] : rn[5] : rd[5] );

zip2_vbvbvb.disasm = {
  sink << "zip2\t" << DisasmTV(rd, 8<<q, 0) << ", " << DisasmTV(rn, 8<<q, 0) << ", " << DisasmTV(rm, 8<<q, 0);
};

zip2_vbvbvb.execute = {
  typedef typename ARCH::U8 DST;

  unsigned const elements = 8<<q;
  DST res[elements];
  for( unsigned idx = 0; idx < elements; ++idx)
    {
      unsigned srcidx = (idx / 2) + (elements / 2);
      res[idx] = cpu.GetVU8((idx & 1) ? rm : rn, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU8(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op zip2_vhvhvh( 0b0[1] : q[1] : 0b001110010[9] : rm[5] : 0b011110[6] : rn[5] : rd[5] );

zip2_vhvhvh.disasm = {
  sink << "zip2\t" << DisasmTV(rd, 4<<q, 1) << ", " << DisasmTV(rn, 4<<q, 1) << ", " << DisasmTV(rm, 4<<q, 1);
};

zip2_vhvhvh.execute = {
  typedef typename ARCH::U16 DST;

  unsigned const elements = 4<<q;
  DST res[elements];
  for( unsigned idx = 0; idx < elements; ++idx)
    {
      unsigned srcidx = (idx / 2) + (elements / 2);
      res[idx] = cpu.GetVU16((idx & 1) ? rm : rn, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU16(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

op zip2_vsvsvs( 0b0[1] : q[1] : 0b001110100[9] : rm[5] : 0b011110[6] : rn[5] : rd[5] );

zip2_vsvsvs.disasm = {
  sink << "zip2\t" << DisasmTV(rd, 2<<q, 2) << ", " << DisasmTV(rn, 2<<q, 2) << ", " << DisasmTV(rm, 2<<q, 2);
};

zip2_vsvsvs.execute = {
  typedef typename ARCH::U32 DST;

  unsigned const elements = 2<<q;
  DST res[elements];
  for( unsigned idx = 0; idx < elements; ++idx)
    {
      unsigned srcidx = (idx / 2) + (elements / 2);
      res[idx] = cpu.GetVU32((idx & 1) ? rm : rn, srcidx);
    }
  for (unsigned idx = 0; idx < elements; ++idx)
    {
      cpu.SetVU32(rd, idx, res[idx]);
    }
  cpu.ClearHighV(rd, 8<<q);
}

/*** Load/Store multiple structures ***/

op stvms_bno( 0[1] : q[1] : 0b00110000000000[14] : opcode[4] : 0b00[2] : rn[5] : rt[5] );
stvms_bno.var vms : {Vms} = {opcode};

stvms_bno.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>0, 0) << ", [" << DisasmGSXR(rn) << "]";
};

stvms_bno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>0;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite8(addr + U64(1*idx), cpu.GetVU8((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite8(addr + U64(1*idx), cpu.GetVU8((rt+idx%vms.regs)%32, idx/vms.regs));
};

op stvms_bio( 0[1] : q[1] : 0b00110010011111[14] : opcode[4] : 0b00[2] : rn[5] : rt[5] );
stvms_bio.var vms : {Vms} = {opcode};

stvms_bio.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>0, 0) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (8*vms.regs << q);
};

stvms_bio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>0;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite8(addr + U64(1*idx), cpu.GetVU8((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite8(addr + U64(1*idx), cpu.GetVU8((rt+idx%vms.regs)%32, idx/vms.regs));

  cpu.SetGSR(rn, addr + U64(8*vms.regs << q) );
};

op stvms_bro( 0[1] : q[1] : 0b001100100[9] : rm[5] : opcode[4] : 0b00[2] : rn[5] : rt[5] );
stvms_bro.var vms : {Vms} = {opcode}, reject : {Reject} = {rm == 31};

stvms_bro.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>0, 0) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

stvms_bro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>0;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite8(addr + U64(1*idx), cpu.GetVU8((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite8(addr + U64(1*idx), cpu.GetVU8((rt+idx%vms.regs)%32, idx/vms.regs));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op stvms_hno( 0[1] : q[1] : 0b00110000000000[14] : opcode[4] : 0b01[2] : rn[5] : rt[5] );
stvms_hno.var vms : {Vms} = {opcode};

stvms_hno.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>1, 1) << ", [" << DisasmGSXR(rn) << "]";
};

stvms_hno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>1;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite16(addr + U64(2*idx), cpu.GetVU16((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite16(addr + U64(2*idx), cpu.GetVU16((rt+idx%vms.regs)%32, idx/vms.regs));
};

op stvms_hio( 0[1] : q[1] : 0b00110010011111[14] : opcode[4] : 0b01[2] : rn[5] : rt[5] );
stvms_hio.var vms : {Vms} = {opcode};

stvms_hio.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>1, 1) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (8*vms.regs << q);
};

stvms_hio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>1;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite16(addr + U64(2*idx), cpu.GetVU16((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite16(addr + U64(2*idx), cpu.GetVU16((rt+idx%vms.regs)%32, idx/vms.regs));

  cpu.SetGSR(rn, addr + U64(8*vms.regs << q) );
};

op stvms_hro( 0[1] : q[1] : 0b001100100[9] : rm[5] : opcode[4] : 0b01[2] : rn[5] : rt[5] );
stvms_hro.var vms : {Vms} = {opcode}, reject : {Reject} = {rm == 31};

stvms_hro.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>1, 1) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

stvms_hro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>1;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite16(addr + U64(2*idx), cpu.GetVU16((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite16(addr + U64(2*idx), cpu.GetVU16((rt+idx%vms.regs)%32, idx/vms.regs));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op stvms_sno( 0[1] : q[1] : 0b00110000000000[14] : opcode[4] : 0b10[2] : rn[5] : rt[5] );
stvms_sno.var vms : {Vms} = {opcode};

stvms_sno.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>2, 2) << ", [" << DisasmGSXR(rn) << "]";
};

stvms_sno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>2;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite32(addr + U64(4*idx), cpu.GetVU32((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite32(addr + U64(4*idx), cpu.GetVU32((rt+idx%vms.regs)%32, idx/vms.regs));
};

op stvms_sio( 0[1] : q[1] : 0b00110010011111[14] : opcode[4] : 0b10[2] : rn[5] : rt[5] );
stvms_sio.var vms : {Vms} = {opcode};

stvms_sio.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>2, 2) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (8*vms.regs << q);
};

stvms_sio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>2;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite32(addr + U64(4*idx), cpu.GetVU32((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite32(addr + U64(4*idx), cpu.GetVU32((rt+idx%vms.regs)%32, idx/vms.regs));

  cpu.SetGSR(rn, addr + U64(8*vms.regs << q) );
};

op stvms_sro( 0[1] : q[1] : 0b001100100[9] : rm[5] : opcode[4] : 0b10[2] : rn[5] : rt[5] );
stvms_sro.var vms : {Vms} = {opcode}, reject : {Reject} = {rm == 31};

stvms_sro.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>2, 2) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

stvms_sro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>2;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite32(addr + U64(4*idx), cpu.GetVU32((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite32(addr + U64(4*idx), cpu.GetVU32((rt+idx%vms.regs)%32, idx/vms.regs));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op stvms_dno( 0[1] : q[1] : 0b00110000000000[14] : opcode[4] : 0b11[2] : rn[5] : rt[5] );
stvms_dno.var vms : {Vms} = {opcode}, reject : {Reject} = {not (q or vms.ses)};

stvms_dno.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>3, 3) << ", [" << DisasmGSXR(rn) << "]";
};

stvms_dno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>3;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite64(addr + U64(8*idx), cpu.GetVU64((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite64(addr + U64(8*idx), cpu.GetVU64((rt+idx%vms.regs)%32, idx/vms.regs));
};

op stvms_dio( 0[1] : q[1] : 0b00110010011111[14] : opcode[4] : 0b11[2] : rn[5] : rt[5] );
stvms_dio.var vms : {Vms} = {opcode}, reject : {Reject} = {not (q or vms.ses)};

stvms_dio.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>3, 3) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (8*vms.regs << q);
};

stvms_dio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>3;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite64(addr + U64(8*idx), cpu.GetVU64((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite64(addr + U64(8*idx), cpu.GetVU64((rt+idx%vms.regs)%32, idx/vms.regs));

  cpu.SetGSR(rn, addr + U64(8*vms.regs << q) );
};

op stvms_dro( 0[1] : q[1] : 0b001100100[9] : rm[5] : opcode[4] : 0b11[2] : rn[5] : rt[5] );
stvms_dro.var vms : {Vms} = {opcode}, reject : {Reject} = {(rm == 31) or (not (q or vms.ses))};

stvms_dro.disasm = {
  sink << "st";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>3, 3) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

stvms_dro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>3;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite64(addr + U64(8*idx), cpu.GetVU64((rt+idx/elements)%32, idx%elements));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.MemWrite64(addr + U64(8*idx), cpu.GetVU64((rt+idx%vms.regs)%32, idx/vms.regs));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvms_bno( 0[1] : q[1] : 0b00110001000000[14] : opcode[4] : 0b00[2] : rn[5] : rt[5] );
ldvms_bno.var vms : {Vms} = {opcode};

ldvms_bno.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>0, 0) << ", [" << DisasmGSXR(rn) << "]";
};

ldvms_bno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>0;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU8((rt+idx/elements)%32, idx%elements, cpu.MemRead8(addr + U64(1*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU8((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead8(addr + U64(1*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);
};

op ldvms_bio( 0[1] : q[1] : 0b00110011011111[14] : opcode[4] : 0b00[2] : rn[5] : rt[5] );
ldvms_bio.var vms : {Vms} = {opcode};

ldvms_bio.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>0, 0) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (8*vms.regs << q);
};

ldvms_bio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>0;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU8((rt+idx/elements)%32, idx%elements, cpu.MemRead8(addr + U64(1*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU8((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead8(addr + U64(1*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);

  cpu.SetGSR(rn, addr + U64(8*vms.regs << q) );
};

op ldvms_bro( 0[1] : q[1] : 0b001100110[9] : rm[5] : opcode[4] : 0b00[2] : rn[5] : rt[5] );
ldvms_bro.var vms : {Vms} = {opcode}, reject : {Reject} = {rm == 31};

ldvms_bro.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>0, 0) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvms_bro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>0;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU8((rt+idx/elements)%32, idx%elements, cpu.MemRead8(addr + U64(1*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU8((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead8(addr + U64(1*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvms_hno( 0[1] : q[1] : 0b00110001000000[14] : opcode[4] : 0b01[2] : rn[5] : rt[5] );
ldvms_hno.var vms : {Vms} = {opcode};

ldvms_hno.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>1, 1) << ", [" << DisasmGSXR(rn) << "]";
};

ldvms_hno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>1;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU16((rt+idx/elements)%32, idx%elements, cpu.MemRead16(addr + U64(2*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU16((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead16(addr + U64(2*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);
};

op ldvms_hio( 0[1] : q[1] : 0b00110011011111[14] : opcode[4] : 0b01[2] : rn[5] : rt[5] );
ldvms_hio.var vms : {Vms} = {opcode};

ldvms_hio.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>1, 1) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (8*vms.regs << q);
};

ldvms_hio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>1;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU16((rt+idx/elements)%32, idx%elements, cpu.MemRead16(addr + U64(2*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU16((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead16(addr + U64(2*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);

  cpu.SetGSR(rn, addr + U64(8*vms.regs << q) );
};

op ldvms_hro( 0[1] : q[1] : 0b001100110[9] : rm[5] : opcode[4] : 0b01[2] : rn[5] : rt[5] );
ldvms_hro.var vms : {Vms} = {opcode}, reject : {Reject} = {rm == 31};

ldvms_hro.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>1, 1) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvms_hro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>1;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU16((rt+idx/elements)%32, idx%elements, cpu.MemRead16(addr + U64(2*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU16((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead16(addr + U64(2*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvms_sno( 0[1] : q[1] : 0b00110001000000[14] : opcode[4] : 0b10[2] : rn[5] : rt[5] );
ldvms_sno.var vms : {Vms} = {opcode};

ldvms_sno.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>2, 2) << ", [" << DisasmGSXR(rn) << "]";
};

ldvms_sno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>2;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU32((rt+idx/elements)%32, idx%elements, cpu.MemRead32(addr + U64(4*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU32((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead32(addr + U64(4*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);
};

op ldvms_sio( 0[1] : q[1] : 0b00110011011111[14] : opcode[4] : 0b10[2] : rn[5] : rt[5] );
ldvms_sio.var vms : {Vms} = {opcode};

ldvms_sio.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>2, 2) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (8*vms.regs << q);
};

ldvms_sio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>2;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU32((rt+idx/elements)%32, idx%elements, cpu.MemRead32(addr + U64(4*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU32((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead32(addr + U64(4*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);

  cpu.SetGSR(rn, addr + U64(8*vms.regs << q) );
};

op ldvms_sro( 0[1] : q[1] : 0b001100110[9] : rm[5] : opcode[4] : 0b10[2] : rn[5] : rt[5] );
ldvms_sro.var vms : {Vms} = {opcode}, reject : {Reject} = {rm == 31};

ldvms_sro.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>2, 2) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvms_sro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>2;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU32((rt+idx/elements)%32, idx%elements, cpu.MemRead32(addr + U64(4*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU32((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead32(addr + U64(4*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvms_dno( 0[1] : q[1] : 0b00110001000000[14] : opcode[4] : 0b11[2] : rn[5] : rt[5] );
ldvms_dno.var vms : {Vms} = {opcode}, reject : {Reject} = {not (q or vms.ses)};

ldvms_dno.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>3, 3) << ", [" << DisasmGSXR(rn) << "]";
};

ldvms_dno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>3;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU64((rt+idx/elements)%32, idx%elements, cpu.MemRead64(addr + U64(8*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU64((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead64(addr + U64(8*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);
};

op ldvms_dio( 0[1] : q[1] : 0b00110011011111[14] : opcode[4] : 0b11[2] : rn[5] : rt[5] );
ldvms_dio.var vms : {Vms} = {opcode}, reject : {Reject} = {not (q or vms.ses)};

ldvms_dio.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>3, 3) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (8*vms.regs << q);
};

ldvms_dio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>3;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU64((rt+idx/elements)%32, idx%elements, cpu.MemRead64(addr + U64(8*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU64((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead64(addr + U64(8*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);

  cpu.SetGSR(rn, addr + U64(8*vms.regs << q) );
};

op ldvms_dro( 0[1] : q[1] : 0b001100110[9] : rm[5] : opcode[4] : 0b11[2] : rn[5] : rt[5] );
ldvms_dro.var vms : {Vms} = {opcode}, reject : {Reject} = {(rm == 31) or (not (q or vms.ses))};

ldvms_dro.disasm = {
  sink << "ld";
  sink << (vms.ses ? 1 : int(vms.regs));
  sink << '\t' << DisasmBunch(rt, vms.regs, (8<<q)>>3, 3) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvms_dro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  unsigned const elements = (8<<q)>>3;
  if (vms.ses)
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU64((rt+idx/elements)%32, idx%elements, cpu.MemRead64(addr + U64(8*idx)));
  else
    for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
      cpu.SetVU64((rt+idx%vms.regs)%32, idx/vms.regs, cpu.MemRead64(addr + U64(8*idx)));

  if (not q) for (unsigned idx = 0; idx < vms.regs; ++idx) cpu.ClearHighV((rt+idx)%32, 8);

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

/***/
op stvsl_bno( 0[1] : index1[1] : 0b00110100[8] : regs0[1] : 0b00000[5] : 0b00[2] : regs1[1] : index0[3] : rn[5] : rt[5] );
stvsl_bno.var index : {unsigned} = {index1<<3|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_bno.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 0) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]";
};

stvsl_bno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite8(addr + U64(1*idx), cpu.GetVU8((rt+idx)%32, index));
};

op stvsl_bio( 0[1] : index1[1] : 0b00110110[8] : regs0[1] : 0b11111[5] : 0b00[2] : regs1[1] : index0[3] : rn[5] : rt[5] );
stvsl_bio.var index : {unsigned} = {index1<<3|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_bio.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 0) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 0);
};

stvsl_bio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite8(addr + U64(1*idx), cpu.GetVU8((rt+idx)%32, index));

  cpu.SetGSR(rn, addr + U64(regs << 0) );
};

op stvsl_bro( 0[1] : index1[1] : 0b00110110[8] : regs0[1] : rm[5] : 0b00[2] : regs1[1] : index0[3] : rn[5] : rt[5] );
stvsl_bro.var reject : {Reject} = {rm == 31}, index : {unsigned} = {index1<<3|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_bro.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 0) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

stvsl_bro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite8(addr + U64(1*idx), cpu.GetVU8((rt+idx)%32, index));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op stvsl_hno( 0[1] : index1[1] : 0b00110100[8] : regs0[1] : 0b00000[5] : 0b01[2] : regs1[1] : index0[2] : 0[1] : rn[5] : rt[5] );
stvsl_hno.var index : {unsigned} = {index1<<2|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_hno.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 1) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]";
};

stvsl_hno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite16(addr + U64(2*idx), cpu.GetVU16((rt+idx)%32, index));
};

op stvsl_hio( 0[1] : index1[1] : 0b00110110[8] : regs0[1] : 0b11111[5] : 0b01[2] : regs1[1] : index0[2] : 0[1] : rn[5] : rt[5] );
stvsl_hio.var index : {unsigned} = {index1<<2|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_hio.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 1) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 1);
};

stvsl_hio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite16(addr + U64(2*idx), cpu.GetVU16((rt+idx)%32, index));

  cpu.SetGSR(rn, addr + U64(regs << 1) );
};

op stvsl_hro( 0[1] : index1[1] : 0b00110110[8] : regs0[1] : rm[5] : 0b01[2] : regs1[1] : index0[2] : 0[1] : rn[5] : rt[5] );
stvsl_hro.var reject : {Reject} = {rm == 31}, index : {unsigned} = {index1<<2|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_hro.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 1) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

stvsl_hro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite16(addr + U64(2*idx), cpu.GetVU16((rt+idx)%32, index));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op stvsl_sno( 0[1] : index1[1] : 0b00110100[8] : regs0[1] : 0b00000[5] : 0b10[2] : regs1[1] : index0[1] : 0[2] : rn[5] : rt[5] );
stvsl_sno.var index : {unsigned} = {index1<<1|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_sno.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 2) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]";
};

stvsl_sno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite32(addr + U64(4*idx), cpu.GetVU32((rt+idx)%32, index));
};

op stvsl_sio( 0[1] : index1[1] : 0b00110110[8] : regs0[1] : 0b11111[5] : 0b10[2] : regs1[1] : index0[1] : 0[2] : rn[5] : rt[5] );
stvsl_sio.var index : {unsigned} = {index1<<1|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_sio.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 2) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 2);
};

stvsl_sio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite32(addr + U64(4*idx), cpu.GetVU32((rt+idx)%32, index));

  cpu.SetGSR(rn, addr + U64(regs << 2) );
};

op stvsl_sro( 0[1] : index1[1] : 0b00110110[8] : regs0[1] : rm[5] : 0b10[2] : regs1[1] : index0[1] : 0[2] : rn[5] : rt[5] );
stvsl_sro.var reject : {Reject} = {rm == 31}, index : {unsigned} = {index1<<1|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_sro.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 2) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

stvsl_sro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite32(addr + U64(4*idx), cpu.GetVU32((rt+idx)%32, index));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op stvsl_dno( 0[1] : index[1] : 0b00110100[8] : regs0[1] : 0b00000[5] : 0b10[2] : regs1[1] : 1[3] : rn[5] : rt[5] );
stvsl_dno.var regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_dno.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 3) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]";
};

stvsl_dno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite64(addr + U64(8*idx), cpu.GetVU64((rt+idx)%32, index));
};

op stvsl_dio( 0[1] : index[1] : 0b00110110[8] : regs0[1] : 0b11111[5] : 0b10[2] : regs1[1] : 1[3] : rn[5] : rt[5] );
stvsl_dio.var regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_dio.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 3) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 3);
};

stvsl_dio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite64(addr + U64(8*idx), cpu.GetVU64((rt+idx)%32, index));

  cpu.SetGSR(rn, addr + U64(regs << 3) );
};

op stvsl_dro( 0[1] : index[1] : 0b00110110[8] : regs0[1] : rm[5] : 0b10[2] : regs1[1] : 1[3] : rn[5] : rt[5] );
stvsl_dro.var reject : {Reject} = {rm == 31}, regs : {unsigned} = {(regs1<<1|regs0)+1}

stvsl_dro.disasm = {
  sink << "st" << regs << '\t' << DisasmBunch(rt, regs, 0, 3) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

stvsl_dro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.MemWrite64(addr + U64(8*idx), cpu.GetVU64((rt+idx)%32, index));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvsl_bno( 0[1] : index1[1] : 0b00110101[8] : regs0[1] : 0b00000[5] : 0b00[2] : regs1[1] : index0[3] : rn[5] : rt[5] );
ldvsl_bno.var index : {unsigned} = {index1<<3|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_bno.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 0) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]";
};

ldvsl_bno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU8((rt+idx)%32, index, cpu.MemRead8(addr + U64(1*idx)));
};

op ldvsl_bio( 0[1] : index1[1] : 0b00110111[8] : regs0[1] : 0b11111[5] : 0b00[2] : regs1[1] : index0[3] : rn[5] : rt[5] );
ldvsl_bio.var index : {unsigned} = {index1<<3|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_bio.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 0) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 0);
};

ldvsl_bio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU8((rt+idx)%32, index, cpu.MemRead8(addr + U64(1*idx)));

  cpu.SetGSR(rn, addr + U64(regs << 0) );
};

op ldvsl_bro( 0[1] : index1[1] : 0b00110111[8] : regs0[1] : rm[5] : 0b00[2] : regs1[1] : index0[3] : rn[5] : rt[5] );
ldvsl_bro.var reject : {Reject} = {rm == 31}, index : {unsigned} = {index1<<3|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_bro.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 0) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvsl_bro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU8((rt+idx)%32, index, cpu.MemRead8(addr + U64(1*idx)));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvsl_hno( 0[1] : index1[1] : 0b00110101[8] : regs0[1] : 0b00000[5] : 0b01[2] : regs1[1] : index0[2] : 0[1] : rn[5] : rt[5] );
ldvsl_hno.var index : {unsigned} = {index1<<2|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_hno.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 1) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]";
};

ldvsl_hno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU16((rt+idx)%32, index, cpu.MemRead16(addr + U64(2*idx)));
};

op ldvsl_hio( 0[1] : index1[1] : 0b00110111[8] : regs0[1] : 0b11111[5] : 0b01[2] : regs1[1] : index0[2] : 0[1] : rn[5] : rt[5] );
ldvsl_hio.var index : {unsigned} = {index1<<2|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_hio.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 1) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 1);
};

ldvsl_hio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU16((rt+idx)%32, index, cpu.MemRead16(addr + U64(2*idx)));

  cpu.SetGSR(rn, addr + U64(regs << 1) );
};

op ldvsl_hro( 0[1] : index1[1] : 0b00110111[8] : regs0[1] : rm[5] : 0b01[2] : regs1[1] : index0[2] : 0[1] : rn[5] : rt[5] );
ldvsl_hro.var reject : {Reject} = {rm == 31}, index : {unsigned} = {index1<<2|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_hro.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 1) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvsl_hro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU16((rt+idx)%32, index, cpu.MemRead16(addr + U64(2*idx)));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvsl_sno( 0[1] : index1[1] : 0b00110101[8] : regs0[1] : 0b00000[5] : 0b10[2] : regs1[1] : index0[1] : 0[2] : rn[5] : rt[5] );
ldvsl_sno.var index : {unsigned} = {index1<<1|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_sno.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 2) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]";
};

ldvsl_sno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU32((rt+idx)%32, index, cpu.MemRead32(addr + U64(4*idx)));
};

op ldvsl_sio( 0[1] : index1[1] : 0b00110111[8] : regs0[1] : 0b11111[5] : 0b10[2] : regs1[1] : index0[1] : 0[2] : rn[5] : rt[5] );
ldvsl_sio.var index : {unsigned} = {index1<<1|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_sio.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 2) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 2);
};

ldvsl_sio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU32((rt+idx)%32, index, cpu.MemRead32(addr + U64(4*idx)));

  cpu.SetGSR(rn, addr + U64(regs << 2) );
};

op ldvsl_sro( 0[1] : index1[1] : 0b00110111[8] : regs0[1] : rm[5] : 0b10[2] : regs1[1] : index0[1] : 0[2] : rn[5] : rt[5] );
ldvsl_sro.var reject : {Reject} = {rm == 31}, index : {unsigned} = {index1<<1|index0}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_sro.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 2) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvsl_sro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU32((rt+idx)%32, index, cpu.MemRead32(addr + U64(4*idx)));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvsl_dno( 0[1] : index[1] : 0b00110101[8] : regs0[1] : 0b00000[5] : 0b10[2] : regs1[1] : 1[3] : rn[5] : rt[5] );
ldvsl_dno.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_dno.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 3) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]";
};

ldvsl_dno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU64((rt+idx)%32, index, cpu.MemRead64(addr + U64(8*idx)));
};

op ldvsl_dio( 0[1] : index[1] : 0b00110111[8] : regs0[1] : 0b11111[5] : 0b10[2] : regs1[1] : 1[3] : rn[5] : rt[5] );
ldvsl_dio.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_dio.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 3) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 3);
};

ldvsl_dio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU64((rt+idx)%32, index, cpu.MemRead64(addr + U64(8*idx)));

  cpu.SetGSR(rn, addr + U64(regs << 3) );
};

op ldvsl_dro( 0[1] : index[1] : 0b00110111[8] : regs0[1] : rm[5] : 0b10[2] : regs1[1] : 1[3] : rn[5] : rt[5] );
ldvsl_dro.var reject : {Reject} = {rm == 31}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvsl_dro.disasm = {
  sink << "ld" << regs << '\t' << DisasmBunch(rt, regs, 0, 3) << DisasmSubscript(index) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvsl_dro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

    for (unsigned idx = 0, end = regs; idx < end; ++idx)
      cpu.SetVU64((rt+idx)%32, index, cpu.MemRead64(addr + U64(8*idx)));

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

/*** Load multi-element single structure and Replicate to all lanes of multiple registers ***/

op ldvr_bno( 0[1] : q[1] : 0b00110101[8] : regs0[1] : 0b00000[5] : 0b11[2] : regs1[1] : 0[1] : 0[2] : rn[5] : rt[5] );
ldvr_bno.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_bno.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 8<<q, 0) << ", [" << DisasmGSXR(rn) << "]";
};

ldvr_bno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U8 val = cpu.MemRead8(addr + U64(1*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
        cpu.SetVU8(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }
};

op ldvr_bio( 0[1] : q[1] : 0b00110111[8] : regs0[1] : 0b11111[5] : 0b11[2] : regs1[1] : 0[1] : 0[2] : rn[5] : rt[5] );
ldvr_bio.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_bio.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 8<<q, 0) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 0);
};

ldvr_bio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U8 val = cpu.MemRead8(addr + U64(1*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
        cpu.SetVU8(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }

  cpu.SetGSR(rn, addr + U64(regs << 0) );
};

op ldvr_bro( 0[1] : q[1] : 0b00110111[8] : regs0[1] : rm[5] : 0b11[2] : regs1[1] : 0[1] : 0[2] : rn[5] : rt[5] );
ldvr_bro.var reject : {Reject} = {rm == 31}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_bro.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 8<<q, 0) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvr_bro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U8 val = cpu.MemRead8(addr + U64(1*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 8<<q; idx < end; ++idx)
        cpu.SetVU8(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvr_hno( 0[1] : q[1] : 0b00110101[8] : regs0[1] : 0b00000[5] : 0b11[2] : regs1[1] : 0[1] : 1[2] : rn[5] : rt[5] );
ldvr_hno.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_hno.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 4<<q, 1) << ", [" << DisasmGSXR(rn) << "]";
};

ldvr_hno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U16 val = cpu.MemRead16(addr + U64(2*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
        cpu.SetVU16(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }
};

op ldvr_hio( 0[1] : q[1] : 0b00110111[8] : regs0[1] : 0b11111[5] : 0b11[2] : regs1[1] : 0[1] : 1[2] : rn[5] : rt[5] );
ldvr_hio.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_hio.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 4<<q, 1) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 1);
};

ldvr_hio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U16 val = cpu.MemRead16(addr + U64(2*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
        cpu.SetVU16(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }

  cpu.SetGSR(rn, addr + U64(regs << 1) );
};

op ldvr_hro( 0[1] : q[1] : 0b00110111[8] : regs0[1] : rm[5] : 0b11[2] : regs1[1] : 0[1] : 1[2] : rn[5] : rt[5] );
ldvr_hro.var reject : {Reject} = {rm == 31}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_hro.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 4<<q, 1) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvr_hro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U16 val = cpu.MemRead16(addr + U64(2*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 4<<q; idx < end; ++idx)
        cpu.SetVU16(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvr_sno( 0[1] : q[1] : 0b00110101[8] : regs0[1] : 0b00000[5] : 0b11[2] : regs1[1] : 0[1] : 2[2] : rn[5] : rt[5] );
ldvr_sno.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_sno.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 2<<q, 2) << ", [" << DisasmGSXR(rn) << "]";
};

ldvr_sno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U32 val = cpu.MemRead32(addr + U64(4*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
        cpu.SetVU32(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }
};

op ldvr_sio( 0[1] : q[1] : 0b00110111[8] : regs0[1] : 0b11111[5] : 0b11[2] : regs1[1] : 0[1] : 2[2] : rn[5] : rt[5] );
ldvr_sio.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_sio.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 2<<q, 2) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 2);
};

ldvr_sio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U32 val = cpu.MemRead32(addr + U64(4*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
        cpu.SetVU32(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }

  cpu.SetGSR(rn, addr + U64(regs << 2) );
};

op ldvr_sro( 0[1] : q[1] : 0b00110111[8] : regs0[1] : rm[5] : 0b11[2] : regs1[1] : 0[1] : 2[2] : rn[5] : rt[5] );
ldvr_sro.var reject : {Reject} = {rm == 31}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_sro.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 2<<q, 2) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvr_sro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U32 val = cpu.MemRead32(addr + U64(4*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 2<<q; idx < end; ++idx)
        cpu.SetVU32(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

op ldvr_dno( 0[1] : q[1] : 0b00110101[8] : regs0[1] : 0b00000[5] : 0b11[2] : regs1[1] : 0[1] : 3[2] : rn[5] : rt[5] );
ldvr_dno.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_dno.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 1<<q, 3) << ", [" << DisasmGSXR(rn) << "]";
};

ldvr_dno.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U64 val = cpu.MemRead64(addr + U64(8*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 1<<q; idx < end; ++idx)
        cpu.SetVU64(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }
};

op ldvr_dio( 0[1] : q[1] : 0b00110111[8] : regs0[1] : 0b11111[5] : 0b11[2] : regs1[1] : 0[1] : 3[2] : rn[5] : rt[5] );
ldvr_dio.var regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_dio.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 1<<q, 3) << ", [" << DisasmGSXR(rn) << "]" << ", #" << (regs << 3);
};

ldvr_dio.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U64 val = cpu.MemRead64(addr + U64(8*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 1<<q; idx < end; ++idx)
        cpu.SetVU64(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }

  cpu.SetGSR(rn, addr + U64(regs << 3) );
};

op ldvr_dro( 0[1] : q[1] : 0b00110111[8] : regs0[1] : rm[5] : 0b11[2] : regs1[1] : 0[1] : 3[2] : rn[5] : rt[5] );
ldvr_dro.var reject : {Reject} = {rm == 31}, regs : {unsigned} = {(regs1<<1|regs0)+1}

ldvr_dro.disasm = {
  sink << "ld" << regs << "r\t" << DisasmBunch(rt, regs, 1<<q, 3) << ", [" << DisasmGSXR(rn) << "]" << ", " << DisasmGZXR(rm);
};

ldvr_dro.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr( cpu.GetGSR(rn) );
  if (rn == 31)
    cpu.CheckSPAlignment(addr);

  for (unsigned r = 0; r < regs; ++r)
    {
      typename ARCH::U64 val = cpu.MemRead64(addr + U64(8*r));
      unsigned reg = (rt+r)%32;
      for (unsigned idx = 0, end = 1<<q; idx < end; ++idx)
        cpu.SetVU64(reg, idx, val);
      cpu.ClearHighV(reg, 8<<q);
    }

  cpu.SetGSR(rn, addr + cpu.GetGZR(rm) );
};

