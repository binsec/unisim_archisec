#include "aarch32/top_arm32.hh"

#include <unisim/component/cxx/processor/arm/isa/decode.hh>
#include <unisim/component/cxx/processor/arm/disasm.hh>
#include <unisim/component/cxx/processor/arm/models.hh>
#include <unisim/component/cxx/processor/arm/exception.hh>
#include <unisim/util/arithmetic/arithmetic.hh>
#include <unisim/util/likely/likely.hh>
#include <unisim/util/endian/endian.hh>
#include <iostream>
#include <iomanip>

using unisim::util::arithmetic::BitScanReverse;
using unisim::util::endian::ByteSwap;
using unisim::util::arithmetic::RotateRight;
// using unisim::util::arithmetic::UnsignedAdd8;
// using unisim::util::arithmetic::SignedSatAdd32;
// using unisim::util::arithmetic::SignedSatSub32;
// using unisim::util::arithmetic::SignExtend;
// using unisim::util::arithmetic::UnsignedSatSub8;
// using unisim::util::arithmetic::RotateRight;
// using unisim::util::arithmetic::UnsignedSub8;

#include <unisim/component/cxx/processor/arm/execute.hh>

namespace unisim { namespace component { namespace cxx { namespace processor { namespace arm { namespace isa { namespace arm32 {
template <	typename	ARCH>
Operation<	ARCH>::Operation(CodeType _code, uint32_t _addr, const char *_name)
:
encoding(_code),
addr(_addr),
name(_name)
{
}

template <	typename	ARCH>
Operation<	ARCH>::~Operation()
{
}

template <	typename	ARCH>
void Operation<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "; Unknown ARM instruction";
}}
template <	typename	ARCH>
void Operation<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UndefinedInstruction( this );
}}
template <	typename	ARCH>
class OpUsada8 : public Operation<	ARCH>
{
public:
	OpUsada8(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t ra;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMsr_imm_psr : public Operation<	ARCH>
{
public:
	OpMsr_imm_psr(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t mask;
	uint8_t write_spsr;
	uint8_t cond;
	uint32_t imm;   uint32_t psr_mask; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAnd_32imm : public Operation<	ARCH>
{
public:
	OpAnd_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAnd_imm_shift : public Operation<	ARCH>
{
public:
	OpAnd_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAnd_reg_shift : public Operation<	ARCH>
{
public:
	OpAnd_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpEor_32imm : public Operation<	ARCH>
{
public:
	OpEor_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpEor_imm_shift : public Operation<	ARCH>
{
public:
	OpEor_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpEor_reg_shift : public Operation<	ARCH>
{
public:
	OpEor_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSub_32imm : public Operation<	ARCH>
{
public:
	OpSub_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSub_imm_shift : public Operation<	ARCH>
{
public:
	OpSub_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSub_reg_shift : public Operation<	ARCH>
{
public:
	OpSub_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsb_32imm : public Operation<	ARCH>
{
public:
	OpRsb_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsb_imm_shift : public Operation<	ARCH>
{
public:
	OpRsb_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsb_reg_shift : public Operation<	ARCH>
{
public:
	OpRsb_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_32imm : public Operation<	ARCH>
{
public:
	OpAdd_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_imm_shift : public Operation<	ARCH>
{
public:
	OpAdd_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_reg_shift : public Operation<	ARCH>
{
public:
	OpAdd_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdc_32imm : public Operation<	ARCH>
{
public:
	OpAdc_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdc_imm_shift : public Operation<	ARCH>
{
public:
	OpAdc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdc_reg_shift : public Operation<	ARCH>
{
public:
	OpAdc_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbc_32imm : public Operation<	ARCH>
{
public:
	OpSbc_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbc_imm_shift : public Operation<	ARCH>
{
public:
	OpSbc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbc_reg_shift : public Operation<	ARCH>
{
public:
	OpSbc_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsc_32imm : public Operation<	ARCH>
{
public:
	OpRsc_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsc_imm_shift : public Operation<	ARCH>
{
public:
	OpRsc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsc_reg_shift : public Operation<	ARCH>
{
public:
	OpRsc_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrr_32imm : public Operation<	ARCH>
{
public:
	OpOrr_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrr_imm_shift : public Operation<	ARCH>
{
public:
	OpOrr_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrr_reg_shift : public Operation<	ARCH>
{
public:
	OpOrr_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBic_32imm : public Operation<	ARCH>
{
public:
	OpBic_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBic_imm_shift : public Operation<	ARCH>
{
public:
	OpBic_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBic_reg_shift : public Operation<	ARCH>
{
public:
	OpBic_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rd;
	uint8_t rn;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTst_32imm : public Operation<	ARCH>
{
public:
	OpTst_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTst_imm_shift : public Operation<	ARCH>
{
public:
	OpTst_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTst_reg_shift : public Operation<	ARCH>
{
public:
	OpTst_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTeq_32imm : public Operation<	ARCH>
{
public:
	OpTeq_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTeq_imm_shift : public Operation<	ARCH>
{
public:
	OpTeq_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTeq_reg_shift : public Operation<	ARCH>
{
public:
	OpTeq_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmp_32imm : public Operation<	ARCH>
{
public:
	OpCmp_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmp_imm_shift : public Operation<	ARCH>
{
public:
	OpCmp_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmp_reg_shift : public Operation<	ARCH>
{
public:
	OpCmp_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmn_32imm : public Operation<	ARCH>
{
public:
	OpCmn_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmn_imm_shift : public Operation<	ARCH>
{
public:
	OpCmn_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmn_reg_shift : public Operation<	ARCH>
{
public:
	OpCmn_reg_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t rs;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMov_32imm : public Operation<	ARCH>
{
public:
	OpMov_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMov_imm_shift : public Operation<	ARCH>
{
public:
	OpMov_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMov_reg_shift : public Operation<	ARCH>
{
public:
	OpMov_reg_shift(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t shift;
	uint8_t rm;
	uint8_t rd;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMvn_32imm : public Operation<	ARCH>
{
public:
	OpMvn_32imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rd;
	uint8_t s;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMvn_imm_shift : public Operation<	ARCH>
{
public:
	OpMvn_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rd;
	uint8_t s;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMvn_reg_shift : public Operation<	ARCH>
{
public:
	OpMvn_reg_shift(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t shift;
	uint8_t rm;
	uint8_t rd;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpClz : public Operation<	ARCH>
{
public:
	OpClz(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRbit : public Operation<	ARCH>
{
public:
	OpRbit(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRev : public Operation<	ARCH>
{
public:
	OpRev(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRev16 : public Operation<	ARCH>
{
public:
	OpRev16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRevsh : public Operation<	ARCH>
{
public:
	OpRevsh(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMovw : public Operation<	ARCH>
{
public:
	OpMovw(CodeType code, uint32_t addr);
	uint16_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMovt : public Operation<	ARCH>
{
public:
	OpMovt(CodeType code, uint32_t addr);
	uint16_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_imm : public Operation<	ARCH>
{
public:
	OpLdr_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_reg : public Operation<	ARCH>
{
public:
	OpLdr_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrh_imm : public Operation<	ARCH>
{
public:
	OpLdrh_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrh_reg : public Operation<	ARCH>
{
public:
	OpLdrh_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsh_imm : public Operation<	ARCH>
{
public:
	OpLdrsh_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsh_reg : public Operation<	ARCH>
{
public:
	OpLdrsh_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrb_imm : public Operation<	ARCH>
{
public:
	OpLdrb_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrb_reg : public Operation<	ARCH>
{
public:
	OpLdrb_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsb_imm : public Operation<	ARCH>
{
public:
	OpLdrsb_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsb_reg : public Operation<	ARCH>
{
public:
	OpLdrsb_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrd_imm : public Operation<	ARCH>
{
public:
	OpLdrd_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrd_reg : public Operation<	ARCH>
{
public:
	OpLdrd_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStr_imm : public Operation<	ARCH>
{
public:
	OpStr_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStr_reg : public Operation<	ARCH>
{
public:
	OpStr_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrh_imm : public Operation<	ARCH>
{
public:
	OpStrh_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrh_reg : public Operation<	ARCH>
{
public:
	OpStrh_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrb_imm : public Operation<	ARCH>
{
public:
	OpStrb_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrb_reg : public Operation<	ARCH>
{
public:
	OpStrb_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrd_imm : public Operation<	ARCH>
{
public:
	OpStrd_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrd_reg : public Operation<	ARCH>
{
public:
	OpStrd_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrt_imm : public Operation<	ARCH>
{
public:
	OpLdrt_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrt_reg : public Operation<	ARCH>
{
public:
	OpLdrt_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrht_imm : public Operation<	ARCH>
{
public:
	OpLdrht_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrht_reg : public Operation<	ARCH>
{
public:
	OpLdrht_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsht_imm : public Operation<	ARCH>
{
public:
	OpLdrsht_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsht_reg : public Operation<	ARCH>
{
public:
	OpLdrsht_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrbt_imm : public Operation<	ARCH>
{
public:
	OpLdrbt_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrbt_reg : public Operation<	ARCH>
{
public:
	OpLdrbt_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsbt_imm : public Operation<	ARCH>
{
public:
	OpLdrsbt_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsbt_reg : public Operation<	ARCH>
{
public:
	OpLdrsbt_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrt_imm : public Operation<	ARCH>
{
public:
	OpStrt_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrt_reg : public Operation<	ARCH>
{
public:
	OpStrt_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrht_imm : public Operation<	ARCH>
{
public:
	OpStrht_imm(CodeType code, uint32_t addr);
	uint8_t im0;
	uint8_t im1;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrht_reg : public Operation<	ARCH>
{
public:
	OpStrht_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrbt_imm : public Operation<	ARCH>
{
public:
	OpStrbt_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrbt_reg : public Operation<	ARCH>
{
public:
	OpStrbt_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rt;
	uint8_t rn;
	uint8_t u;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdm : public Operation<	ARCH>
{
public:
	OpLdm(CodeType code, uint32_t addr);
	uint16_t reglist;
	uint8_t rn;
	uint8_t w;
	uint8_t mod;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStm : public Operation<	ARCH>
{
public:
	OpStm(CodeType code, uint32_t addr);
	uint16_t reglist;
	uint8_t rn;
	uint8_t w;
	uint8_t mod;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdm_usr : public Operation<	ARCH>
{
public:
	OpLdm_usr(CodeType code, uint32_t addr);
	uint16_t reglist;
	uint8_t rn;
	uint8_t mod;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdm_rfe : public Operation<	ARCH>
{
public:
	OpLdm_rfe(CodeType code, uint32_t addr);
	uint16_t regnpclist;
	uint8_t rn;
	uint8_t w;
	uint8_t mod;
	uint8_t cond;
	uint32_t reglist;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStm_usr : public Operation<	ARCH>
{
public:
	OpStm_usr(CodeType code, uint32_t addr);
	uint16_t reglist;
	uint8_t rn;
	uint8_t mod;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSwp : public Operation<	ARCH>
{
public:
	OpSwp(CodeType code, uint32_t addr);
	uint8_t rt2;
	uint8_t rt;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSwpb : public Operation<	ARCH>
{
public:
	OpSwpb(CodeType code, uint32_t addr);
	uint8_t rt2;
	uint8_t rt;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrex : public Operation<	ARCH>
{
public:
	OpLdrex(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrexh : public Operation<	ARCH>
{
public:
	OpLdrexh(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrexb : public Operation<	ARCH>
{
public:
	OpLdrexb(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrexd : public Operation<	ARCH>
{
public:
	OpLdrexd(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrex : public Operation<	ARCH>
{
public:
	OpStrex(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrexh : public Operation<	ARCH>
{
public:
	OpStrexh(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrexb : public Operation<	ARCH>
{
public:
	OpStrexb(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrexd : public Operation<	ARCH>
{
public:
	OpStrexd(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMla : public Operation<	ARCH>
{
public:
	OpMla(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t ra;
	uint8_t rd;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMls : public Operation<	ARCH>
{
public:
	OpMls(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t ra;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMul : public Operation<	ARCH>
{
public:
	OpMul(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlal : public Operation<	ARCH>
{
public:
	OpSmlal(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t rdlo;
	uint8_t rdhi;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmull : public Operation<	ARCH>
{
public:
	OpSmull(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t rdlo;
	uint8_t rdhi;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUmlal : public Operation<	ARCH>
{
public:
	OpUmlal(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t rdlo;
	uint8_t rdhi;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUmaal : public Operation<	ARCH>
{
public:
	OpUmaal(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t rdlo;
	uint8_t rdhi;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUmull : public Operation<	ARCH>
{
public:
	OpUmull(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t rdlo;
	uint8_t rdhi;
	uint8_t s;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlaxy : public Operation<	ARCH>
{
public:
	OpSmlaxy(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t n;
	uint8_t m;
	uint8_t rm;
	uint8_t ra;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlalxy : public Operation<	ARCH>
{
public:
	OpSmlalxy(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t n;
	uint8_t m;
	uint8_t rm;
	uint8_t rdlo;
	uint8_t rdhi;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlawy : public Operation<	ARCH>
{
public:
	OpSmlawy(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t m;
	uint8_t rm;
	uint8_t ra;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmulxy : public Operation<	ARCH>
{
public:
	OpSmulxy(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t n;
	uint8_t m;
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmulwy : public Operation<	ARCH>
{
public:
	OpSmulwy(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t m;
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSdiv : public Operation<	ARCH>
{
public:
	OpSdiv(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUdiv : public Operation<	ARCH>
{
public:
	OpUdiv(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlad : public Operation<	ARCH>
{
public:
	OpSmlad(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t swap;
	uint8_t rm;
	uint8_t ra;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlald : public Operation<	ARCH>
{
public:
	OpSmlald(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t swap;
	uint8_t rm;
	uint8_t rdlo;
	uint8_t rdhi;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlsd : public Operation<	ARCH>
{
public:
	OpSmlsd(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t swap;
	uint8_t rm;
	uint8_t ra;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlsld : public Operation<	ARCH>
{
public:
	OpSmlsld(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t swap;
	uint8_t rm;
	uint8_t rdlo;
	uint8_t rdhi;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmmla : public Operation<	ARCH>
{
public:
	OpSmmla(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t round;
	uint8_t rm;
	uint8_t ra;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmmls : public Operation<	ARCH>
{
public:
	OpSmmls(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t round;
	uint8_t rm;
	uint8_t ra;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmmul : public Operation<	ARCH>
{
public:
	OpSmmul(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t round;
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmuad : public Operation<	ARCH>
{
public:
	OpSmuad(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t swap;
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmusd : public Operation<	ARCH>
{
public:
	OpSmusd(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t swap;
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQadd : public Operation<	ARCH>
{
public:
	OpQadd(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQadd16 : public Operation<	ARCH>
{
public:
	OpQadd16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQadd8 : public Operation<	ARCH>
{
public:
	OpQadd8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQsub : public Operation<	ARCH>
{
public:
	OpQsub(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQsub16 : public Operation<	ARCH>
{
public:
	OpQsub16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQsub8 : public Operation<	ARCH>
{
public:
	OpQsub8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQdadd : public Operation<	ARCH>
{
public:
	OpQdadd(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQdsub : public Operation<	ARCH>
{
public:
	OpQdsub(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPkh : public Operation<	ARCH>
{
public:
	OpPkh(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t tb;
	uint8_t imm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtab16 : public Operation<	ARCH>
{
public:
	OpSxtab16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtb16 : public Operation<	ARCH>
{
public:
	OpSxtb16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtab16 : public Operation<	ARCH>
{
public:
	OpUxtab16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtb16 : public Operation<	ARCH>
{
public:
	OpUxtb16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSel : public Operation<	ARCH>
{
public:
	OpSel(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsat : public Operation<	ARCH>
{
public:
	OpSsat(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t sh;
	uint8_t imm;
	uint8_t rd;
	uint8_t sat_imm;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsat16 : public Operation<	ARCH>
{
public:
	OpSsat16(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rd;
	uint8_t sat_imm;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsat : public Operation<	ARCH>
{
public:
	OpUsat(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t sh;
	uint8_t imm;
	uint8_t rd;
	uint8_t sat_imm;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsat16 : public Operation<	ARCH>
{
public:
	OpUsat16(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rd;
	uint8_t sat_imm;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtab : public Operation<	ARCH>
{
public:
	OpSxtab(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtb : public Operation<	ARCH>
{
public:
	OpSxtb(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtah : public Operation<	ARCH>
{
public:
	OpSxtah(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxth : public Operation<	ARCH>
{
public:
	OpSxth(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtab : public Operation<	ARCH>
{
public:
	OpUxtab(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtb : public Operation<	ARCH>
{
public:
	OpUxtb(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t cond;
	uint32_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtah : public Operation<	ARCH>
{
public:
	OpUxtah(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxth : public Operation<	ARCH>
{
public:
	OpUxth(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t cond;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsad8 : public Operation<	ARCH>
{
public:
	OpUsad8(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbfx : public Operation<	ARCH>
{
public:
	OpSbfx(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t lsb;
	uint8_t rd;
	uint8_t widthm1;
	uint8_t cond;
	uint32_t width;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBfi : public Operation<	ARCH>
{
public:
	OpBfi(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t lsb;
	uint8_t rd;
	uint8_t msb;
	uint8_t cond;
	uint32_t width;   uint32_t clear;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBfc : public Operation<	ARCH>
{
public:
	OpBfc(CodeType code, uint32_t addr);
	uint8_t lsb;
	uint8_t rd;
	uint8_t msb;
	uint8_t cond;
	uint32_t width;   uint32_t clear;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUbfx : public Operation<	ARCH>
{
public:
	OpUbfx(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t lsb;
	uint8_t rd;
	uint8_t widthm1;
	uint8_t cond;
	uint32_t width;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUadd16 : public Operation<	ARCH>
{
public:
	OpUadd16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUadd8 : public Operation<	ARCH>
{
public:
	OpUadd8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsub16 : public Operation<	ARCH>
{
public:
	OpUsub16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsub8 : public Operation<	ARCH>
{
public:
	OpUsub8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSadd16 : public Operation<	ARCH>
{
public:
	OpSadd16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSadd8 : public Operation<	ARCH>
{
public:
	OpSadd8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsub16 : public Operation<	ARCH>
{
public:
	OpSsub16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsub8 : public Operation<	ARCH>
{
public:
	OpSsub8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqadd16 : public Operation<	ARCH>
{
public:
	OpUqadd16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqadd8 : public Operation<	ARCH>
{
public:
	OpUqadd8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqsub16 : public Operation<	ARCH>
{
public:
	OpUqsub16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqsub8 : public Operation<	ARCH>
{
public:
	OpUqsub8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhadd16 : public Operation<	ARCH>
{
public:
	OpUhadd16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhadd8 : public Operation<	ARCH>
{
public:
	OpUhadd8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShadd16 : public Operation<	ARCH>
{
public:
	OpShadd16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShadd8 : public Operation<	ARCH>
{
public:
	OpShadd8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhsub16 : public Operation<	ARCH>
{
public:
	OpUhsub16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhsub8 : public Operation<	ARCH>
{
public:
	OpUhsub8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShsub16 : public Operation<	ARCH>
{
public:
	OpShsub16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShsub8 : public Operation<	ARCH>
{
public:
	OpShsub8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQasx : public Operation<	ARCH>
{
public:
	OpQasx(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQsax : public Operation<	ARCH>
{
public:
	OpQsax(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqasx : public Operation<	ARCH>
{
public:
	OpUqasx(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqsax : public Operation<	ARCH>
{
public:
	OpUqsax(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSasx : public Operation<	ARCH>
{
public:
	OpSasx(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsax : public Operation<	ARCH>
{
public:
	OpSsax(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUasx : public Operation<	ARCH>
{
public:
	OpUasx(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsax : public Operation<	ARCH>
{
public:
	OpUsax(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShasx : public Operation<	ARCH>
{
public:
	OpShasx(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShsax : public Operation<	ARCH>
{
public:
	OpShsax(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhasx : public Operation<	ARCH>
{
public:
	OpUhasx(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhsax : public Operation<	ARCH>
{
public:
	OpUhsax(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpNop : public Operation<	ARCH>
{
public:
	OpNop(CodeType code, uint32_t addr);
	uint8_t idx;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpYield : public Operation<	ARCH>
{
public:
	OpYield(CodeType code, uint32_t addr);
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpWfe : public Operation<	ARCH>
{
public:
	OpWfe(CodeType code, uint32_t addr);
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpWfi : public Operation<	ARCH>
{
public:
	OpWfi(CodeType code, uint32_t addr);
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSev : public Operation<	ARCH>
{
public:
	OpSev(CodeType code, uint32_t addr);
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpDbg : public Operation<	ARCH>
{
public:
	OpDbg(CodeType code, uint32_t addr);
	uint8_t idx;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpB : public Operation<	ARCH>
{
public:
	OpB(CodeType code, uint32_t addr);
	int32_t imm;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBl : public Operation<	ARCH>
{
public:
	OpBl(CodeType code, uint32_t addr);
	int32_t imm;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBx : public Operation<	ARCH>
{
public:
	OpBx(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBxj : public Operation<	ARCH>
{
public:
	OpBxj(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpBlx_reg : public Operation<	ARCH>
{
public:
	OpBlx_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCdp : public Operation<	ARCH>
{
public:
	OpCdp(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t crn;
	uint8_t opc1;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdc : public Operation<	ARCH>
{
public:
	OpLdc(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t rn;
	uint8_t w;
	uint8_t d;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdc_unindexed : public Operation<	ARCH>
{
public:
	OpLdc_unindexed(CodeType code, uint32_t addr);
	uint8_t option;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t rn;
	uint8_t d;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMcr : public Operation<	ARCH>
{
public:
	OpMcr(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t rd;
	uint8_t crn;
	uint8_t opc1;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrc : public Operation<	ARCH>
{
public:
	OpMrc(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t rt;
	uint8_t crn;
	uint8_t opc1;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStc : public Operation<	ARCH>
{
public:
	OpStc(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t rn;
	uint8_t w;
	uint8_t d;
	uint8_t u;
	uint8_t p;
	uint8_t cond;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStc_unindexed : public Operation<	ARCH>
{
public:
	OpStc_unindexed(CodeType code, uint32_t addr);
	uint8_t option;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t rn;
	uint8_t d;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMcrr : public Operation<	ARCH>
{
public:
	OpMcrr(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc1;
	uint8_t cp_num;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrrc : public Operation<	ARCH>
{
public:
	OpMrrc(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc1;
	uint8_t cp_num;
	uint8_t rd;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCp15_mcr : public Operation<	ARCH>
{
public:
	OpCp15_mcr(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc2;
	uint8_t rt;
	uint8_t crn;
	uint8_t opc1;
	uint8_t cond;
	typename ARCH::CP15Reg const* cp15reg;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCp15_mrc : public Operation<	ARCH>
{
public:
	OpCp15_mrc(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc2;
	uint8_t rt;
	uint8_t crn;
	uint8_t opc1;
	uint8_t cond;
	typename ARCH::CP15Reg const* cp15reg; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSwi : public Operation<	ARCH>
{
public:
	OpSwi(CodeType code, uint32_t addr);
	uint32_t imm;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpHvc : public Operation<	ARCH>
{
public:
	OpHvc(CodeType code, uint32_t addr);
	uint8_t im0;
	uint16_t im1;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpSmc : public Operation<	ARCH>
{
public:
	OpSmc(CodeType code, uint32_t addr);
	uint8_t im0;
	uint16_t im1;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpEret : public Operation<	ARCH>
{
public:
	OpEret(CodeType code, uint32_t addr);
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpSubspc_imm : public Operation<	ARCH>
{
public:
	OpSubspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSubspc_imm_shift : public Operation<	ARCH>
{
public:
	OpSubspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMovspc_imm : public Operation<	ARCH>
{
public:
	OpMovspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMovspc_imm_shift : public Operation<	ARCH>
{
public:
	OpMovspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAndspc_imm : public Operation<	ARCH>
{
public:
	OpAndspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAndspc_imm_shift : public Operation<	ARCH>
{
public:
	OpAndspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpEorspc_imm : public Operation<	ARCH>
{
public:
	OpEorspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpEorspc_imm_shift : public Operation<	ARCH>
{
public:
	OpEorspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsbspc_imm : public Operation<	ARCH>
{
public:
	OpRsbspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsbspc_imm_shift : public Operation<	ARCH>
{
public:
	OpRsbspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAddspc_imm : public Operation<	ARCH>
{
public:
	OpAddspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAddspc_imm_shift : public Operation<	ARCH>
{
public:
	OpAddspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdcspc_imm : public Operation<	ARCH>
{
public:
	OpAdcspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdcspc_imm_shift : public Operation<	ARCH>
{
public:
	OpAdcspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbcspc_imm : public Operation<	ARCH>
{
public:
	OpSbcspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbcspc_imm_shift : public Operation<	ARCH>
{
public:
	OpSbcspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRscspc_imm : public Operation<	ARCH>
{
public:
	OpRscspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRscspc_imm_shift : public Operation<	ARCH>
{
public:
	OpRscspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrrspc_imm : public Operation<	ARCH>
{
public:
	OpOrrspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrrspc_imm_shift : public Operation<	ARCH>
{
public:
	OpOrrspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBicspc_imm : public Operation<	ARCH>
{
public:
	OpBicspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t rn;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBicspc_imm_shift : public Operation<	ARCH>
{
public:
	OpBicspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMvnspc_imm : public Operation<	ARCH>
{
public:
	OpMvnspc_imm(CodeType code, uint32_t addr);
	uint8_t imb;
	uint8_t imr;
	uint8_t cond;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMvnspc_imm_shift : public Operation<	ARCH>
{
public:
	OpMvnspc_imm_shift(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t cond;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrs : public Operation<	ARCH>
{
public:
	OpMrs(CodeType code, uint32_t addr);
	uint8_t sr1;
	uint8_t rd;
	uint8_t sr0;
	uint8_t sr2;
	uint8_t cond;
	uint8_t sr;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMsr_reg : public Operation<	ARCH>
{
public:
	OpMsr_reg(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t sr1;
	uint8_t sr0;
	uint8_t sr2;
	uint8_t cond;
	uint8_t sr; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpMsr_reg_psr : public Operation<	ARCH>
{
public:
	OpMsr_reg_psr(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t mask;
	uint8_t write_spsr;
	uint8_t cond;
	uint32_t psr_mask; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVabs_f32 : public Operation<	ARCH>
{
public:
	OpVabs_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVabs_f64 : public Operation<	ARCH>
{
public:
	OpVabs_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_f32 : public Operation<	ARCH>
{
public:
	OpVadd_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_f64 : public Operation<	ARCH>
{
public:
	OpVadd_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcmp_f32d : public Operation<	ARCH>
{
public:
	OpVcmp_f32d(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t e;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcmp_f64d : public Operation<	ARCH>
{
public:
	OpVcmp_f64d(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t e;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcmp_f32i : public Operation<	ARCH>
{
public:
	OpVcmp_f32i(CodeType code, uint32_t addr);
	uint8_t e;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcmp_f64i : public Operation<	ARCH>
{
public:
	OpVcmp_f64i(CodeType code, uint32_t addr);
	uint8_t e;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u32 : public Operation<	ARCH>
{
public:
	OpVcvt_f32u32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64u32 : public Operation<	ARCH>
{
public:
	OpVcvt_f64u32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32s32 : public Operation<	ARCH>
{
public:
	OpVcvt_f32s32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64s32 : public Operation<	ARCH>
{
public:
	OpVcvt_f64s32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f32 : public Operation<	ARCH>
{
public:
	OpVcvt_u32f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvtr_u32f32 : public Operation<	ARCH>
{
public:
	OpVcvtr_u32f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f64 : public Operation<	ARCH>
{
public:
	OpVcvt_u32f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvtr_u32f64 : public Operation<	ARCH>
{
public:
	OpVcvtr_u32f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f32 : public Operation<	ARCH>
{
public:
	OpVcvt_s32f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvtr_s32f32 : public Operation<	ARCH>
{
public:
	OpVcvtr_s32f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f64 : public Operation<	ARCH>
{
public:
	OpVcvt_s32f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvtr_s32f64 : public Operation<	ARCH>
{
public:
	OpVcvtr_s32f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32s16i : public Operation<	ARCH>
{
public:
	OpVcvt_f32s16i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32s32i : public Operation<	ARCH>
{
public:
	OpVcvt_f32s32i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64s16i : public Operation<	ARCH>
{
public:
	OpVcvt_f64s16i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64s32i : public Operation<	ARCH>
{
public:
	OpVcvt_f64s32i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u16i : public Operation<	ARCH>
{
public:
	OpVcvt_f32u16i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u32i : public Operation<	ARCH>
{
public:
	OpVcvt_f32u32i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64u16i : public Operation<	ARCH>
{
public:
	OpVcvt_f64u16i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64u32i : public Operation<	ARCH>
{
public:
	OpVcvt_f64u32i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s16f32i : public Operation<	ARCH>
{
public:
	OpVcvt_s16f32i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s16f64i : public Operation<	ARCH>
{
public:
	OpVcvt_s16f64i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f32i : public Operation<	ARCH>
{
public:
	OpVcvt_s32f32i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f64i : public Operation<	ARCH>
{
public:
	OpVcvt_s32f64i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u16f32i : public Operation<	ARCH>
{
public:
	OpVcvt_u16f32i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u16f64i : public Operation<	ARCH>
{
public:
	OpVcvt_u16f64i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f32i : public Operation<	ARCH>
{
public:
	OpVcvt_u32f32i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f64i : public Operation<	ARCH>
{
public:
	OpVcvt_u32f64i(CodeType code, uint32_t addr);
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64f32 : public Operation<	ARCH>
{
public:
	OpVcvt_f64f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32f64 : public Operation<	ARCH>
{
public:
	OpVcvt_f32f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdiv_f32 : public Operation<	ARCH>
{
public:
	OpVdiv_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdiv_f64 : public Operation<	ARCH>
{
public:
	OpVdiv_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfma_f32 : public Operation<	ARCH>
{
public:
	OpVfma_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfma_f64 : public Operation<	ARCH>
{
public:
	OpVfma_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfms_f32 : public Operation<	ARCH>
{
public:
	OpVfms_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfms_f64 : public Operation<	ARCH>
{
public:
	OpVfms_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfnma_f32 : public Operation<	ARCH>
{
public:
	OpVfnma_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfnma_f64 : public Operation<	ARCH>
{
public:
	OpVfnma_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfnms_f32 : public Operation<	ARCH>
{
public:
	OpVfnms_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfnms_f64 : public Operation<	ARCH>
{
public:
	OpVfnms_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldmdb_f32 : public Operation<	ARCH>
{
public:
	OpVldmdb_f32(CodeType code, uint32_t addr);
	uint8_t regs;
	uint8_t vd1;
	uint8_t rn;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldmdb_f64 : public Operation<	ARCH>
{
public:
	OpVldmdb_f64(CodeType code, uint32_t addr);
	uint8_t fldm;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldmia_f32 : public Operation<	ARCH>
{
public:
	OpVldmia_f32(CodeType code, uint32_t addr);
	uint8_t regs;
	uint8_t vd1;
	uint8_t rn;
	uint8_t w;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldmia_f64 : public Operation<	ARCH>
{
public:
	OpVldmia_f64(CodeType code, uint32_t addr);
	uint8_t fldm;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t w;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldr_32 : public Operation<	ARCH>
{
public:
	OpVldr_32(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t vd1;
	uint8_t rn;
	uint8_t vd0;
	uint8_t u;
	uint8_t cond;
	uint32_t vd;   int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldr_64 : public Operation<	ARCH>
{
public:
	OpVldr_64(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t u;
	uint8_t cond;
	uint32_t vd;   int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmla_f32 : public Operation<	ARCH>
{
public:
	OpVmla_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmla_f64 : public Operation<	ARCH>
{
public:
	OpVmla_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmls_f32 : public Operation<	ARCH>
{
public:
	OpVmls_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmls_f64 : public Operation<	ARCH>
{
public:
	OpVmls_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmla_f32 : public Operation<	ARCH>
{
public:
	OpVnmla_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmla_f64 : public Operation<	ARCH>
{
public:
	OpVnmla_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmls_f32 : public Operation<	ARCH>
{
public:
	OpVnmls_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmls_f64 : public Operation<	ARCH>
{
public:
	OpVnmls_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_f32i : public Operation<	ARCH>
{
public:
	OpVmov_f32i(CodeType code, uint32_t addr);
	uint8_t man;
	uint8_t vd1;
	uint8_t exp;
	uint8_t n;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vd;   typename ARCH::F32 fpimm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_f64i : public Operation<	ARCH>
{
public:
	OpVmov_f64i(CodeType code, uint32_t addr);
	uint8_t man;
	uint8_t vd0;
	uint8_t exp;
	uint8_t n;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vd;   typename ARCH::F64 fpimm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_f32s : public Operation<	ARCH>
{
public:
	OpVmov_f32s(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_f64d : public Operation<	ARCH>
{
public:
	OpVmov_f64d(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_rs : public Operation<	ARCH>
{
public:
	OpVmov_rs(CodeType code, uint32_t addr);
	uint8_t vn0;
	uint8_t rt;
	uint8_t vn1;
	uint8_t cond;
	uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_sr : public Operation<	ARCH>
{
public:
	OpVmov_sr(CodeType code, uint32_t addr);
	uint8_t vn0;
	uint8_t rt;
	uint8_t vn1;
	uint8_t cond;
	uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_ssrr : public Operation<	ARCH>
{
public:
	OpVmov_ssrr(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t rt;
	uint8_t rt2;
	uint8_t cond;
	uint32_t vm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_rrss : public Operation<	ARCH>
{
public:
	OpVmov_rrss(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t rt;
	uint8_t rt2;
	uint8_t cond;
	uint32_t vm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_rrd : public Operation<	ARCH>
{
public:
	OpVmov_rrd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t rt;
	uint8_t rt2;
	uint8_t cond;
	uint32_t vm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_drr : public Operation<	ARCH>
{
public:
	OpVmov_drr(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t rt;
	uint8_t rt2;
	uint8_t cond;
	uint32_t vm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmrs : public Operation<	ARCH>
{
public:
	OpVmrs(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t spr;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmsr : public Operation<	ARCH>
{
public:
	OpVmsr(CodeType code, uint32_t addr);
	uint8_t rt;
	uint8_t spr;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_f32 : public Operation<	ARCH>
{
public:
	OpVmul_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_f64 : public Operation<	ARCH>
{
public:
	OpVmul_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmul_f32 : public Operation<	ARCH>
{
public:
	OpVnmul_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmul_f64 : public Operation<	ARCH>
{
public:
	OpVnmul_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVneg_f32 : public Operation<	ARCH>
{
public:
	OpVneg_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVneg_f64 : public Operation<	ARCH>
{
public:
	OpVneg_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsqrt_f32s : public Operation<	ARCH>
{
public:
	OpVsqrt_f32s(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsqrt_f64d : public Operation<	ARCH>
{
public:
	OpVsqrt_f64d(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstmdb_f32 : public Operation<	ARCH>
{
public:
	OpVstmdb_f32(CodeType code, uint32_t addr);
	uint8_t regs;
	uint8_t vd1;
	uint8_t rn;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstmdb_f64 : public Operation<	ARCH>
{
public:
	OpVstmdb_f64(CodeType code, uint32_t addr);
	uint8_t fstm;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstmia_f32 : public Operation<	ARCH>
{
public:
	OpVstmia_f32(CodeType code, uint32_t addr);
	uint8_t regs;
	uint8_t vd1;
	uint8_t rn;
	uint8_t w;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstmia_f64 : public Operation<	ARCH>
{
public:
	OpVstmia_f64(CodeType code, uint32_t addr);
	uint8_t fstm;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t w;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstr_32 : public Operation<	ARCH>
{
public:
	OpVstr_32(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t vn1;
	uint8_t rn;
	uint8_t vn0;
	uint8_t u;
	uint8_t cond;
	uint32_t vn;   int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstr_64 : public Operation<	ARCH>
{
public:
	OpVstr_64(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t vn0;
	uint8_t rn;
	uint8_t vn1;
	uint8_t u;
	uint8_t cond;
	uint32_t vn;   int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_f32 : public Operation<	ARCH>
{
public:
	OpVsub_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_f64 : public Operation<	ARCH>
{
public:
	OpVsub_f64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t cond;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup8_r : public Operation<	ARCH>
{
public:
	OpVdup8_r(CodeType code, uint32_t addr);
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd0;
	uint8_t q;
	uint8_t cond;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup16_r : public Operation<	ARCH>
{
public:
	OpVdup16_r(CodeType code, uint32_t addr);
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd0;
	uint8_t q;
	uint8_t cond;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup32_r : public Operation<	ARCH>
{
public:
	OpVdup32_r(CodeType code, uint32_t addr);
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd0;
	uint8_t q;
	uint8_t cond;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_8dr : public Operation<	ARCH>
{
public:
	OpVmov_8dr(CodeType code, uint32_t addr);
	uint8_t index0;
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd0;
	uint8_t index1;
	uint8_t cond;
	uint8_t vd;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_16dr : public Operation<	ARCH>
{
public:
	OpVmov_16dr(CodeType code, uint32_t addr);
	uint8_t index0;
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd0;
	uint8_t index1;
	uint8_t cond;
	uint8_t vd;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_32dr : public Operation<	ARCH>
{
public:
	OpVmov_32dr(CodeType code, uint32_t addr);
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd0;
	uint8_t index;
	uint8_t cond;
	uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_s8rd : public Operation<	ARCH>
{
public:
	OpVmov_s8rd(CodeType code, uint32_t addr);
	uint8_t index0;
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn0;
	uint8_t index1;
	uint8_t cond;
	uint8_t vn;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_u8rd : public Operation<	ARCH>
{
public:
	OpVmov_u8rd(CodeType code, uint32_t addr);
	uint8_t index0;
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn0;
	uint8_t index1;
	uint8_t cond;
	uint8_t vn;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_s16rd : public Operation<	ARCH>
{
public:
	OpVmov_s16rd(CodeType code, uint32_t addr);
	uint8_t index0;
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn0;
	uint8_t index1;
	uint8_t cond;
	uint8_t vn;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_u16rd : public Operation<	ARCH>
{
public:
	OpVmov_u16rd(CodeType code, uint32_t addr);
	uint8_t index0;
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn0;
	uint8_t index1;
	uint8_t cond;
	uint8_t vn;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_32rd : public Operation<	ARCH>
{
public:
	OpVmov_32rd(CodeType code, uint32_t addr);
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn0;
	uint8_t index;
	uint8_t cond;
	uint8_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUnconditional : public Operation<	ARCH>
{
public:
	OpUnconditional(CodeType code, uint32_t addr);
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_s8 : public Operation<	ARCH>
{
public:
	OpVshll_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_s16 : public Operation<	ARCH>
{
public:
	OpVshll_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_s32 : public Operation<	ARCH>
{
public:
	OpVshll_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_u8 : public Operation<	ARCH>
{
public:
	OpVshll_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_u16 : public Operation<	ARCH>
{
public:
	OpVshll_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_u32 : public Operation<	ARCH>
{
public:
	OpVshll_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSetend : public Operation<	ARCH>
{
public:
	OpSetend(CodeType code, uint32_t addr);
	uint8_t endianness;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPld_imm : public Operation<	ARCH>
{
public:
	OpPld_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rn;
	uint8_t r;
	uint8_t u;
	int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPld_reg : public Operation<	ARCH>
{
public:
	OpPld_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t r;
	uint8_t u;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPli_imm : public Operation<	ARCH>
{
public:
	OpPli_imm(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t rn;
	uint8_t u;
	int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPli_reg : public Operation<	ARCH>
{
public:
	OpPli_reg(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t shift;
	uint8_t imm;
	uint8_t rn;
	uint8_t u;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpClrex : public Operation<	ARCH>
{
public:
	OpClrex(CodeType code, uint32_t addr);
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpDmb : public Operation<	ARCH>
{
public:
	OpDmb(CodeType code, uint32_t addr);
	uint8_t opt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpDsb : public Operation<	ARCH>
{
public:
	OpDsb(CodeType code, uint32_t addr);
	uint8_t opt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpIsb : public Operation<	ARCH>
{
public:
	OpIsb(CodeType code, uint32_t addr);
	uint8_t opt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBlx_pcrel : public Operation<	ARCH>
{
public:
	OpBlx_pcrel(CodeType code, uint32_t addr);
	int32_t im1;
	uint8_t im0;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCdp2 : public Operation<	ARCH>
{
public:
	OpCdp2(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t crn;
	uint8_t opc1;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdc2 : public Operation<	ARCH>
{
public:
	OpLdc2(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t rn;
	uint8_t w;
	uint8_t d;
	uint8_t u;
	uint8_t p;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdc2_unindexed : public Operation<	ARCH>
{
public:
	OpLdc2_unindexed(CodeType code, uint32_t addr);
	uint8_t option;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t rn;
	uint8_t d;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMcr2 : public Operation<	ARCH>
{
public:
	OpMcr2(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t rd;
	uint8_t crn;
	uint8_t opc1;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrc2 : public Operation<	ARCH>
{
public:
	OpMrc2(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t rt;
	uint8_t crn;
	uint8_t opc1;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStc2 : public Operation<	ARCH>
{
public:
	OpStc2(CodeType code, uint32_t addr);
	uint16_t offset;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t rn;
	uint8_t w;
	uint8_t d;
	uint8_t u;
	uint8_t p;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStc2_unindexed : public Operation<	ARCH>
{
public:
	OpStc2_unindexed(CodeType code, uint32_t addr);
	uint8_t option;
	uint8_t cp_num;
	uint8_t crd;
	uint8_t rn;
	uint8_t d;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMcrr2 : public Operation<	ARCH>
{
public:
	OpMcrr2(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc1;
	uint8_t cp_num;
	uint8_t rd;
	uint8_t rn;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrrc2 : public Operation<	ARCH>
{
public:
	OpMrrc2(CodeType code, uint32_t addr);
	uint8_t crm;
	uint8_t opc1;
	uint8_t cp_num;
	uint8_t rd;
	uint8_t rn;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBkpt : public Operation<	ARCH>
{
public:
	OpBkpt(CodeType code, uint32_t addr);
	uint8_t im0;
	uint16_t im1;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCps : public Operation<	ARCH>
{
public:
	OpCps(CodeType code, uint32_t addr);
	uint8_t mode;
	uint8_t f;
	uint8_t i;
	uint8_t a;
	uint8_t chmod;
	uint8_t dis;
	uint8_t chitm;
	Reject reject;   uint32_t psr_mask;   uint32_t psr_bits; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRfe : public Operation<	ARCH>
{
public:
	OpRfe(CodeType code, uint32_t addr);
	uint8_t rn;
	uint8_t w;
	uint8_t mod;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpSrs : public Operation<	ARCH>
{
public:
	OpSrs(CodeType code, uint32_t addr);
	uint8_t mode;
	uint8_t w;
	uint8_t mod;
	virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvtb_f16_f32 : public Operation<	ARCH>
{
public:
	OpVcvtb_f16_f32(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t t;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint8_t vm;   uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvtb_f32_f16 : public Operation<	ARCH>
{
public:
	OpVcvtb_f32_f16(CodeType code, uint32_t addr);
	uint8_t vm1;
	uint8_t vm0;
	uint8_t t;
	uint8_t vd1;
	uint8_t vd0;
	uint8_t cond;
	uint8_t vm;   uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVaba_s8 : public Operation<	ARCH>
{
public:
	OpVaba_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVaba_s16 : public Operation<	ARCH>
{
public:
	OpVaba_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVaba_s32 : public Operation<	ARCH>
{
public:
	OpVaba_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVaba_u8 : public Operation<	ARCH>
{
public:
	OpVaba_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVaba_u16 : public Operation<	ARCH>
{
public:
	OpVaba_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVaba_u32 : public Operation<	ARCH>
{
public:
	OpVaba_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabal_s8qd : public Operation<	ARCH>
{
public:
	OpVabal_s8qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabal_s16qd : public Operation<	ARCH>
{
public:
	OpVabal_s16qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabal_s32qd : public Operation<	ARCH>
{
public:
	OpVabal_s32qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabal_u8qd : public Operation<	ARCH>
{
public:
	OpVabal_u8qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabal_u16qd : public Operation<	ARCH>
{
public:
	OpVabal_u16qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabal_u32qd : public Operation<	ARCH>
{
public:
	OpVabal_u32qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabd_s8 : public Operation<	ARCH>
{
public:
	OpVabd_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabd_s16 : public Operation<	ARCH>
{
public:
	OpVabd_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabd_s32 : public Operation<	ARCH>
{
public:
	OpVabd_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabd_u8 : public Operation<	ARCH>
{
public:
	OpVabd_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabd_u16 : public Operation<	ARCH>
{
public:
	OpVabd_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabd_u32 : public Operation<	ARCH>
{
public:
	OpVabd_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_s8qd : public Operation<	ARCH>
{
public:
	OpVabdl_s8qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_s16qd : public Operation<	ARCH>
{
public:
	OpVabdl_s16qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_s32qd : public Operation<	ARCH>
{
public:
	OpVabdl_s32qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_u8qd : public Operation<	ARCH>
{
public:
	OpVabdl_u8qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_u16qd : public Operation<	ARCH>
{
public:
	OpVabdl_u16qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_u32qd : public Operation<	ARCH>
{
public:
	OpVabdl_u32qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabd_f32 : public Operation<	ARCH>
{
public:
	OpVabd_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabs_s8 : public Operation<	ARCH>
{
public:
	OpVabs_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabs_s16 : public Operation<	ARCH>
{
public:
	OpVabs_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabs_s32 : public Operation<	ARCH>
{
public:
	OpVabs_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVabs_f32v : public Operation<	ARCH>
{
public:
	OpVabs_f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVacge_f32 : public Operation<	ARCH>
{
public:
	OpVacge_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVacgt_f32 : public Operation<	ARCH>
{
public:
	OpVacgt_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVadd_f32v : public Operation<	ARCH>
{
public:
	OpVadd_f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVadd_i8 : public Operation<	ARCH>
{
public:
	OpVadd_i8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	typedef struct { enum { elements=8 }; } CFG;   typedef typename ARCH::U8 OP;   uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_i16 : public Operation<	ARCH>
{
public:
	OpVadd_i16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	typedef struct { enum { elements=4 }; } CFG;   typedef typename ARCH::U16 OP;   uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_i32 : public Operation<	ARCH>
{
public:
	OpVadd_i32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	typedef struct { enum { elements=2 }; } CFG;   typedef typename ARCH::U32 OP;   uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_i64 : public Operation<	ARCH>
{
public:
	OpVadd_i64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	typedef struct { enum { elements=1 }; } CFG;   typedef typename ARCH::U64 OP;   uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddhn_i16dq : public Operation<	ARCH>
{
public:
	OpVaddhn_i16dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVaddhn_i32dq : public Operation<	ARCH>
{
public:
	OpVaddhn_i32dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVaddhn_i64dq : public Operation<	ARCH>
{
public:
	OpVaddhn_i64dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVaddl_s8 : public Operation<	ARCH>
{
public:
	OpVaddl_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_s16 : public Operation<	ARCH>
{
public:
	OpVaddl_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_s32 : public Operation<	ARCH>
{
public:
	OpVaddl_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_u8 : public Operation<	ARCH>
{
public:
	OpVaddl_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_u16 : public Operation<	ARCH>
{
public:
	OpVaddl_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_u32 : public Operation<	ARCH>
{
public:
	OpVaddl_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_s8 : public Operation<	ARCH>
{
public:
	OpVaddw_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_s16 : public Operation<	ARCH>
{
public:
	OpVaddw_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_s32 : public Operation<	ARCH>
{
public:
	OpVaddw_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_u8 : public Operation<	ARCH>
{
public:
	OpVaddw_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_u16 : public Operation<	ARCH>
{
public:
	OpVaddw_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_u32 : public Operation<	ARCH>
{
public:
	OpVaddw_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVand : public Operation<	ARCH>
{
public:
	OpVand(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVbic : public Operation<	ARCH>
{
public:
	OpVbic(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVbic_i16i : public Operation<	ARCH>
{
public:
	OpVbic_i16i(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVbic_i32i : public Operation<	ARCH>
{
public:
	OpVbic_i32i(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVbif : public Operation<	ARCH>
{
public:
	OpVbif(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVbit : public Operation<	ARCH>
{
public:
	OpVbit(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVbsl : public Operation<	ARCH>
{
public:
	OpVbsl(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_f32 : public Operation<	ARCH>
{
public:
	OpVceq_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVceq_f8z : public Operation<	ARCH>
{
public:
	OpVceq_f8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVceq_f16z : public Operation<	ARCH>
{
public:
	OpVceq_f16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVceq_f32z : public Operation<	ARCH>
{
public:
	OpVceq_f32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVceq_i8z : public Operation<	ARCH>
{
public:
	OpVceq_i8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i16z : public Operation<	ARCH>
{
public:
	OpVceq_i16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i32z : public Operation<	ARCH>
{
public:
	OpVceq_i32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i8 : public Operation<	ARCH>
{
public:
	OpVceq_i8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i16 : public Operation<	ARCH>
{
public:
	OpVceq_i16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i32 : public Operation<	ARCH>
{
public:
	OpVceq_i32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_f8z : public Operation<	ARCH>
{
public:
	OpVcge_f8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcge_f16z : public Operation<	ARCH>
{
public:
	OpVcge_f16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcge_f32 : public Operation<	ARCH>
{
public:
	OpVcge_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcge_f32z : public Operation<	ARCH>
{
public:
	OpVcge_f32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcge_s8z : public Operation<	ARCH>
{
public:
	OpVcge_s8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s16z : public Operation<	ARCH>
{
public:
	OpVcge_s16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s32z : public Operation<	ARCH>
{
public:
	OpVcge_s32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s8 : public Operation<	ARCH>
{
public:
	OpVcge_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s16 : public Operation<	ARCH>
{
public:
	OpVcge_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s32 : public Operation<	ARCH>
{
public:
	OpVcge_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_u8 : public Operation<	ARCH>
{
public:
	OpVcge_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_u16 : public Operation<	ARCH>
{
public:
	OpVcge_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_u32 : public Operation<	ARCH>
{
public:
	OpVcge_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_f8z : public Operation<	ARCH>
{
public:
	OpVcgt_f8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcgt_f16z : public Operation<	ARCH>
{
public:
	OpVcgt_f16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcgt_f32z : public Operation<	ARCH>
{
public:
	OpVcgt_f32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcgt_f32 : public Operation<	ARCH>
{
public:
	OpVcgt_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcgt_s8z : public Operation<	ARCH>
{
public:
	OpVcgt_s8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s16z : public Operation<	ARCH>
{
public:
	OpVcgt_s16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s32z : public Operation<	ARCH>
{
public:
	OpVcgt_s32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s8 : public Operation<	ARCH>
{
public:
	OpVcgt_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s16 : public Operation<	ARCH>
{
public:
	OpVcgt_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s32 : public Operation<	ARCH>
{
public:
	OpVcgt_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_u8 : public Operation<	ARCH>
{
public:
	OpVcgt_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_u16 : public Operation<	ARCH>
{
public:
	OpVcgt_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_u32 : public Operation<	ARCH>
{
public:
	OpVcgt_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcle_f8z : public Operation<	ARCH>
{
public:
	OpVcle_f8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcle_f16z : public Operation<	ARCH>
{
public:
	OpVcle_f16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcle_f32z : public Operation<	ARCH>
{
public:
	OpVcle_f32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcle_s8z : public Operation<	ARCH>
{
public:
	OpVcle_s8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcle_s16z : public Operation<	ARCH>
{
public:
	OpVcle_s16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcle_s32z : public Operation<	ARCH>
{
public:
	OpVcle_s32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcls_s8 : public Operation<	ARCH>
{
public:
	OpVcls_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcls_s16 : public Operation<	ARCH>
{
public:
	OpVcls_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcls_s32 : public Operation<	ARCH>
{
public:
	OpVcls_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVclt_f8z : public Operation<	ARCH>
{
public:
	OpVclt_f8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVclt_f16z : public Operation<	ARCH>
{
public:
	OpVclt_f16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVclt_f32z : public Operation<	ARCH>
{
public:
	OpVclt_f32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVclt_s8z : public Operation<	ARCH>
{
public:
	OpVclt_s8z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVclt_s16z : public Operation<	ARCH>
{
public:
	OpVclt_s16z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVclt_s32z : public Operation<	ARCH>
{
public:
	OpVclt_s32z(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVclz_i8 : public Operation<	ARCH>
{
public:
	OpVclz_i8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVclz_i16 : public Operation<	ARCH>
{
public:
	OpVclz_i16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVclz_i32 : public Operation<	ARCH>
{
public:
	OpVclz_i32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcnt_8 : public Operation<	ARCH>
{
public:
	OpVcnt_8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f16_f32 : public Operation<	ARCH>
{
public:
	OpVcvt_f16_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32_f16 : public Operation<	ARCH>
{
public:
	OpVcvt_f32_f16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32_s32 : public Operation<	ARCH>
{
public:
	OpVcvt_f32_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32s32vi : public Operation<	ARCH>
{
public:
	OpVcvt_f32s32vi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	int32_t imm;   uint8_t vd;   uint8_t vm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u32v : public Operation<	ARCH>
{
public:
	OpVcvt_f32u32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u32vi : public Operation<	ARCH>
{
public:
	OpVcvt_f32u32vi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_s32_f32 : public Operation<	ARCH>
{
public:
	OpVcvt_s32_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f32vi : public Operation<	ARCH>
{
public:
	OpVcvt_s32f32vi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	int32_t imm;   uint8_t vd;   uint8_t vm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f32v : public Operation<	ARCH>
{
public:
	OpVcvt_u32f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f32vi : public Operation<	ARCH>
{
public:
	OpVcvt_u32f32vi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVdup_8dp : public Operation<	ARCH>
{
public:
	OpVdup_8dp(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t part;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup_16dp : public Operation<	ARCH>
{
public:
	OpVdup_16dp(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t part;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup_32dp : public Operation<	ARCH>
{
public:
	OpVdup_32dp(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t part;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVeor : public Operation<	ARCH>
{
public:
	OpVeor(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVext_8i : public Operation<	ARCH>
{
public:
	OpVext_8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t imm;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVfma_f32v : public Operation<	ARCH>
{
public:
	OpVfma_f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVfms_f32v : public Operation<	ARCH>
{
public:
	OpVfms_f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_s8 : public Operation<	ARCH>
{
public:
	OpVhadd_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_s16 : public Operation<	ARCH>
{
public:
	OpVhadd_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_s32 : public Operation<	ARCH>
{
public:
	OpVhadd_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_u8 : public Operation<	ARCH>
{
public:
	OpVhadd_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_u16 : public Operation<	ARCH>
{
public:
	OpVhadd_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_u32 : public Operation<	ARCH>
{
public:
	OpVhadd_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_s8 : public Operation<	ARCH>
{
public:
	OpVhsub_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_s16 : public Operation<	ARCH>
{
public:
	OpVhsub_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_s32 : public Operation<	ARCH>
{
public:
	OpVhsub_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_u8 : public Operation<	ARCH>
{
public:
	OpVhsub_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_u16 : public Operation<	ARCH>
{
public:
	OpVhsub_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_u32 : public Operation<	ARCH>
{
public:
	OpVhsub_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVldms_8 : public Operation<	ARCH>
{
public:
	OpVldms_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms_16 : public Operation<	ARCH>
{
public:
	OpVldms_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms_32 : public Operation<	ARCH>
{
public:
	OpVldms_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms_64 : public Operation<	ARCH>
{
public:
	OpVldms_64(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms2s_8 : public Operation<	ARCH>
{
public:
	OpVldms2s_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms2s_16 : public Operation<	ARCH>
{
public:
	OpVldms2s_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms2s_32 : public Operation<	ARCH>
{
public:
	OpVldms2s_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVld2_8 : public Operation<	ARCH>
{
public:
	OpVld2_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVld2_16 : public Operation<	ARCH>
{
public:
	OpVld2_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVld2_32 : public Operation<	ARCH>
{
public:
	OpVld2_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldal_8 : public Operation<	ARCH>
{
public:
	OpVldal_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVldal_16 : public Operation<	ARCH>
{
public:
	OpVldal_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVldal_32 : public Operation<	ARCH>
{
public:
	OpVldal_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVldqal_8 : public Operation<	ARCH>
{
public:
	OpVldqal_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldqal_16 : public Operation<	ARCH>
{
public:
	OpVldqal_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldqal_32 : public Operation<	ARCH>
{
public:
	OpVldqal_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldsl_8 : public Operation<	ARCH>
{
public:
	OpVldsl_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVldsl_16 : public Operation<	ARCH>
{
public:
	OpVldsl_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVldsl_32 : public Operation<	ARCH>
{
public:
	OpVldsl_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmax_f32 : public Operation<	ARCH>
{
public:
	OpVmax_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmax_s8 : public Operation<	ARCH>
{
public:
	OpVmax_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_s16 : public Operation<	ARCH>
{
public:
	OpVmax_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_s32 : public Operation<	ARCH>
{
public:
	OpVmax_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_u8 : public Operation<	ARCH>
{
public:
	OpVmax_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_u16 : public Operation<	ARCH>
{
public:
	OpVmax_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_u32 : public Operation<	ARCH>
{
public:
	OpVmax_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_f32 : public Operation<	ARCH>
{
public:
	OpVmin_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmin_s8 : public Operation<	ARCH>
{
public:
	OpVmin_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_s16 : public Operation<	ARCH>
{
public:
	OpVmin_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_s32 : public Operation<	ARCH>
{
public:
	OpVmin_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_u8 : public Operation<	ARCH>
{
public:
	OpVmin_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_u16 : public Operation<	ARCH>
{
public:
	OpVmin_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_u32 : public Operation<	ARCH>
{
public:
	OpVmin_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmla_f32v : public Operation<	ARCH>
{
public:
	OpVmla_f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmla_f32dp : public Operation<	ARCH>
{
public:
	OpVmla_f32dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVml_i8 : public Operation<	ARCH>
{
public:
	OpVml_i8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t sub;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVml_i16 : public Operation<	ARCH>
{
public:
	OpVml_i16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t sub;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVml_i32 : public Operation<	ARCH>
{
public:
	OpVml_i32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t sub;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmla_i16dp : public Operation<	ARCH>
{
public:
	OpVmla_i16dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmla_i32dp : public Operation<	ARCH>
{
public:
	OpVmla_i32dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmll_s8qd : public Operation<	ARCH>
{
public:
	OpVmll_s8qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_s16qd : public Operation<	ARCH>
{
public:
	OpVmll_s16qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_s32qd : public Operation<	ARCH>
{
public:
	OpVmll_s32qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_u8qd : public Operation<	ARCH>
{
public:
	OpVmll_u8qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_u16qd : public Operation<	ARCH>
{
public:
	OpVmll_u16qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_u32qd : public Operation<	ARCH>
{
public:
	OpVmll_u32qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmlal_s16qdp : public Operation<	ARCH>
{
public:
	OpVmlal_s16qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmlal_s32qdp : public Operation<	ARCH>
{
public:
	OpVmlal_s32qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmlal_u16qdp : public Operation<	ARCH>
{
public:
	OpVmlal_u16qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmlal_u32qdp : public Operation<	ARCH>
{
public:
	OpVmlal_u32qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmls_f16dp : public Operation<	ARCH>
{
public:
	OpVmls_f16dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmls_f32v : public Operation<	ARCH>
{
public:
	OpVmls_f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmls_f32dp : public Operation<	ARCH>
{
public:
	OpVmls_f32dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmls_i16dp : public Operation<	ARCH>
{
public:
	OpVmls_i16dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmls_i32dp : public Operation<	ARCH>
{
public:
	OpVmls_i32dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmlsl_s16qdp : public Operation<	ARCH>
{
public:
	OpVmlsl_s16qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmlsl_s32qdp : public Operation<	ARCH>
{
public:
	OpVmlsl_s32qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmlsl_u16qdp : public Operation<	ARCH>
{
public:
	OpVmlsl_u16qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmlsl_u32qdp : public Operation<	ARCH>
{
public:
	OpVmlsl_u32qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmov_f32vi : public Operation<	ARCH>
{
public:
	OpVmov_f32vi(CodeType code, uint32_t addr);
	uint8_t man;
	uint8_t q;
	uint8_t vd0;
	uint8_t exp;
	uint8_t vd1;
	uint8_t n;
	uint8_t vd;   float fpimm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmov_i8i : public Operation<	ARCH>
{
public:
	OpVmov_i8i(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	unsigned vd;   uint8_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_i16i : public Operation<	ARCH>
{
public:
	OpVmov_i16i(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint16_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_i32i : public Operation<	ARCH>
{
public:
	OpVmov_i32i(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_i64i : public Operation<	ARCH>
{
public:
	OpVmov_i64i(CodeType code, uint32_t addr);
	uint8_t h;
	uint8_t g;
	uint8_t f;
	uint8_t e;
	uint8_t q;
	uint8_t vd0;
	uint8_t d;
	uint8_t c;
	uint8_t b;
	uint8_t vd1;
	uint8_t a;
	uint8_t vd;   uint64_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_i32in : public Operation<	ARCH>
{
public:
	OpVmov_i32in(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_s8 : public Operation<	ARCH>
{
public:
	OpVmovl_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_s16 : public Operation<	ARCH>
{
public:
	OpVmovl_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_s32 : public Operation<	ARCH>
{
public:
	OpVmovl_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_u8 : public Operation<	ARCH>
{
public:
	OpVmovl_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_u16 : public Operation<	ARCH>
{
public:
	OpVmovl_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_u32 : public Operation<	ARCH>
{
public:
	OpVmovl_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovn_i16 : public Operation<	ARCH>
{
public:
	OpVmovn_i16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovn_i32 : public Operation<	ARCH>
{
public:
	OpVmovn_i32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovn_i64 : public Operation<	ARCH>
{
public:
	OpVmovn_i64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_f32v : public Operation<	ARCH>
{
public:
	OpVmul_f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmul_f32dp : public Operation<	ARCH>
{
public:
	OpVmul_f32dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmul_i8 : public Operation<	ARCH>
{
public:
	OpVmul_i8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_i16 : public Operation<	ARCH>
{
public:
	OpVmul_i16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_i32 : public Operation<	ARCH>
{
public:
	OpVmul_i32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_i16dp : public Operation<	ARCH>
{
public:
	OpVmul_i16dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmul_i32dp : public Operation<	ARCH>
{
public:
	OpVmul_i32dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmul_p8 : public Operation<	ARCH>
{
public:
	OpVmul_p8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmul_p16 : public Operation<	ARCH>
{
public:
	OpVmul_p16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmul_p32 : public Operation<	ARCH>
{
public:
	OpVmul_p32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmull_p8qd : public Operation<	ARCH>
{
public:
	OpVmull_p8qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmull_s8 : public Operation<	ARCH>
{
public:
	OpVmull_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_s16 : public Operation<	ARCH>
{
public:
	OpVmull_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_s32 : public Operation<	ARCH>
{
public:
	OpVmull_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_u8 : public Operation<	ARCH>
{
public:
	OpVmull_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_u16 : public Operation<	ARCH>
{
public:
	OpVmull_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_u32 : public Operation<	ARCH>
{
public:
	OpVmull_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_s16qdp : public Operation<	ARCH>
{
public:
	OpVmull_s16qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmull_s32qdp : public Operation<	ARCH>
{
public:
	OpVmull_s32qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmull_u16qdp : public Operation<	ARCH>
{
public:
	OpVmull_u16qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmull_u32qdp : public Operation<	ARCH>
{
public:
	OpVmull_u32qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVmvn_i16i : public Operation<	ARCH>
{
public:
	OpVmvn_i16i(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmvn_i32i : public Operation<	ARCH>
{
public:
	OpVmvn_i32i(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmvn_i32in : public Operation<	ARCH>
{
public:
	OpVmvn_i32in(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmvn : public Operation<	ARCH>
{
public:
	OpVmvn(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVneg_f8 : public Operation<	ARCH>
{
public:
	OpVneg_f8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVneg_f16 : public Operation<	ARCH>
{
public:
	OpVneg_f16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVneg_f32v : public Operation<	ARCH>
{
public:
	OpVneg_f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVneg_s8 : public Operation<	ARCH>
{
public:
	OpVneg_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVneg_s16 : public Operation<	ARCH>
{
public:
	OpVneg_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVneg_s32 : public Operation<	ARCH>
{
public:
	OpVneg_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVorn : public Operation<	ARCH>
{
public:
	OpVorn(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVorr : public Operation<	ARCH>
{
public:
	OpVorr(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVorr_i16i : public Operation<	ARCH>
{
public:
	OpVorr_i16i(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint16_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVorr_i32i : public Operation<	ARCH>
{
public:
	OpVorr_i32i(CodeType code, uint32_t addr);
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpadal_s8 : public Operation<	ARCH>
{
public:
	OpVpadal_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_s16 : public Operation<	ARCH>
{
public:
	OpVpadal_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_s32 : public Operation<	ARCH>
{
public:
	OpVpadal_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_u8 : public Operation<	ARCH>
{
public:
	OpVpadal_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_u16 : public Operation<	ARCH>
{
public:
	OpVpadal_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_u32 : public Operation<	ARCH>
{
public:
	OpVpadal_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpadd_f32 : public Operation<	ARCH>
{
public:
	OpVpadd_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpadd_i8 : public Operation<	ARCH>
{
public:
	OpVpadd_i8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpadd_i16 : public Operation<	ARCH>
{
public:
	OpVpadd_i16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpadd_i32 : public Operation<	ARCH>
{
public:
	OpVpadd_i32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpaddl_s8 : public Operation<	ARCH>
{
public:
	OpVpaddl_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_s16 : public Operation<	ARCH>
{
public:
	OpVpaddl_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_s32 : public Operation<	ARCH>
{
public:
	OpVpaddl_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_u8 : public Operation<	ARCH>
{
public:
	OpVpaddl_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_u16 : public Operation<	ARCH>
{
public:
	OpVpaddl_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_u32 : public Operation<	ARCH>
{
public:
	OpVpaddl_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpmax_f32 : public Operation<	ARCH>
{
public:
	OpVpmax_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_s8 : public Operation<	ARCH>
{
public:
	OpVpmax_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_s16 : public Operation<	ARCH>
{
public:
	OpVpmax_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_s32 : public Operation<	ARCH>
{
public:
	OpVpmax_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_u8 : public Operation<	ARCH>
{
public:
	OpVpmax_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_u16 : public Operation<	ARCH>
{
public:
	OpVpmax_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_u32 : public Operation<	ARCH>
{
public:
	OpVpmax_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_f32 : public Operation<	ARCH>
{
public:
	OpVpmin_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_s8 : public Operation<	ARCH>
{
public:
	OpVpmin_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_s16 : public Operation<	ARCH>
{
public:
	OpVpmin_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_s32 : public Operation<	ARCH>
{
public:
	OpVpmin_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_u8 : public Operation<	ARCH>
{
public:
	OpVpmin_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_u16 : public Operation<	ARCH>
{
public:
	OpVpmin_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_u32 : public Operation<	ARCH>
{
public:
	OpVpmin_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqabs_s8 : public Operation<	ARCH>
{
public:
	OpVqabs_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqabs_s16 : public Operation<	ARCH>
{
public:
	OpVqabs_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqabs_s32 : public Operation<	ARCH>
{
public:
	OpVqabs_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_s8 : public Operation<	ARCH>
{
public:
	OpVqadd_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_s16 : public Operation<	ARCH>
{
public:
	OpVqadd_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_s32 : public Operation<	ARCH>
{
public:
	OpVqadd_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_s64 : public Operation<	ARCH>
{
public:
	OpVqadd_s64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_u8 : public Operation<	ARCH>
{
public:
	OpVqadd_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_u16 : public Operation<	ARCH>
{
public:
	OpVqadd_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_u32 : public Operation<	ARCH>
{
public:
	OpVqadd_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_u64 : public Operation<	ARCH>
{
public:
	OpVqadd_u64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlal_s16qd : public Operation<	ARCH>
{
public:
	OpVqdmlal_s16qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlal_s16qdp : public Operation<	ARCH>
{
public:
	OpVqdmlal_s16qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlal_s32qd : public Operation<	ARCH>
{
public:
	OpVqdmlal_s32qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlal_s32qdp : public Operation<	ARCH>
{
public:
	OpVqdmlal_s32qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlsl_s16qd : public Operation<	ARCH>
{
public:
	OpVqdmlsl_s16qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlsl_s16qdp : public Operation<	ARCH>
{
public:
	OpVqdmlsl_s16qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlsl_s32qd : public Operation<	ARCH>
{
public:
	OpVqdmlsl_s32qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlsl_s32qdp : public Operation<	ARCH>
{
public:
	OpVqdmlsl_s32qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmulh_s16 : public Operation<	ARCH>
{
public:
	OpVqdmulh_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmulh_s16dp : public Operation<	ARCH>
{
public:
	OpVqdmulh_s16dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmulh_s32 : public Operation<	ARCH>
{
public:
	OpVqdmulh_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmulh_s32dp : public Operation<	ARCH>
{
public:
	OpVqdmulh_s32dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmull_s16qd : public Operation<	ARCH>
{
public:
	OpVqdmull_s16qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmull_s16qdp : public Operation<	ARCH>
{
public:
	OpVqdmull_s16qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmull_s32qd : public Operation<	ARCH>
{
public:
	OpVqdmull_s32qd(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqdmull_s32qdp : public Operation<	ARCH>
{
public:
	OpVqdmull_s32qdp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_s16 : public Operation<	ARCH>
{
public:
	OpVqmovn_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_s32 : public Operation<	ARCH>
{
public:
	OpVqmovn_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_s64 : public Operation<	ARCH>
{
public:
	OpVqmovn_s64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_u16 : public Operation<	ARCH>
{
public:
	OpVqmovn_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_u32 : public Operation<	ARCH>
{
public:
	OpVqmovn_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_u64 : public Operation<	ARCH>
{
public:
	OpVqmovn_u64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqmovun_s16 : public Operation<	ARCH>
{
public:
	OpVqmovun_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqmovun_s32 : public Operation<	ARCH>
{
public:
	OpVqmovun_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqmovun_s64 : public Operation<	ARCH>
{
public:
	OpVqmovun_s64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqneg_s8 : public Operation<	ARCH>
{
public:
	OpVqneg_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqneg_s16 : public Operation<	ARCH>
{
public:
	OpVqneg_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqneg_s32 : public Operation<	ARCH>
{
public:
	OpVqneg_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrdmulh_s16 : public Operation<	ARCH>
{
public:
	OpVqrdmulh_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrdmulh_s16dp : public Operation<	ARCH>
{
public:
	OpVqrdmulh_s16dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrdmulh_s32 : public Operation<	ARCH>
{
public:
	OpVqrdmulh_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrdmulh_s32dp : public Operation<	ARCH>
{
public:
	OpVqrdmulh_s32dp(CodeType code, uint32_t addr);
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_s8 : public Operation<	ARCH>
{
public:
	OpVqrshl_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_s16 : public Operation<	ARCH>
{
public:
	OpVqrshl_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_s32 : public Operation<	ARCH>
{
public:
	OpVqrshl_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_s64 : public Operation<	ARCH>
{
public:
	OpVqrshl_s64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_u8 : public Operation<	ARCH>
{
public:
	OpVqrshl_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_u16 : public Operation<	ARCH>
{
public:
	OpVqrshl_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_u32 : public Operation<	ARCH>
{
public:
	OpVqrshl_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_u64 : public Operation<	ARCH>
{
public:
	OpVqrshl_u64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_s16dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_s16dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_s32dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_s32dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_s64dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_s64dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_u16dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_u16dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_u32dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_u32dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_u64dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_u64dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrun_s16dqi : public Operation<	ARCH>
{
public:
	OpVqrshrun_s16dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrun_s32dqi : public Operation<	ARCH>
{
public:
	OpVqrshrun_s32dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrun_s64dqi : public Operation<	ARCH>
{
public:
	OpVqrshrun_s64dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s8 : public Operation<	ARCH>
{
public:
	OpVqshl_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s8i : public Operation<	ARCH>
{
public:
	OpVqshl_s8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s16 : public Operation<	ARCH>
{
public:
	OpVqshl_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s16i : public Operation<	ARCH>
{
public:
	OpVqshl_s16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s32 : public Operation<	ARCH>
{
public:
	OpVqshl_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s32i : public Operation<	ARCH>
{
public:
	OpVqshl_s32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s64 : public Operation<	ARCH>
{
public:
	OpVqshl_s64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s64i : public Operation<	ARCH>
{
public:
	OpVqshl_s64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u8 : public Operation<	ARCH>
{
public:
	OpVqshl_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u8i : public Operation<	ARCH>
{
public:
	OpVqshl_u8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u16 : public Operation<	ARCH>
{
public:
	OpVqshl_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u16i : public Operation<	ARCH>
{
public:
	OpVqshl_u16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u32 : public Operation<	ARCH>
{
public:
	OpVqshl_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u32i : public Operation<	ARCH>
{
public:
	OpVqshl_u32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u64 : public Operation<	ARCH>
{
public:
	OpVqshl_u64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u64i : public Operation<	ARCH>
{
public:
	OpVqshl_u64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshlu_s8i : public Operation<	ARCH>
{
public:
	OpVqshlu_s8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshlu_s16i : public Operation<	ARCH>
{
public:
	OpVqshlu_s16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshlu_s32i : public Operation<	ARCH>
{
public:
	OpVqshlu_s32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshlu_s64i : public Operation<	ARCH>
{
public:
	OpVqshlu_s64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_s16dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_s16dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_s32dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_s32dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_s64dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_s64dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_u16dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_u16dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_u32dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_u32dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_u64dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_u64dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshrun_s16dqi : public Operation<	ARCH>
{
public:
	OpVqshrun_s16dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshrun_s32dqi : public Operation<	ARCH>
{
public:
	OpVqshrun_s32dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqshrun_s64dqi : public Operation<	ARCH>
{
public:
	OpVqshrun_s64dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_s8 : public Operation<	ARCH>
{
public:
	OpVqsub_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_s16 : public Operation<	ARCH>
{
public:
	OpVqsub_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_s32 : public Operation<	ARCH>
{
public:
	OpVqsub_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_s64 : public Operation<	ARCH>
{
public:
	OpVqsub_s64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_u8 : public Operation<	ARCH>
{
public:
	OpVqsub_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_u16 : public Operation<	ARCH>
{
public:
	OpVqsub_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_u32 : public Operation<	ARCH>
{
public:
	OpVqsub_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_u64 : public Operation<	ARCH>
{
public:
	OpVqsub_u64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVraddhn_i16dq : public Operation<	ARCH>
{
public:
	OpVraddhn_i16dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVraddhn_i32dq : public Operation<	ARCH>
{
public:
	OpVraddhn_i32dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVraddhn_i64dq : public Operation<	ARCH>
{
public:
	OpVraddhn_i64dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrecpe_f32 : public Operation<	ARCH>
{
public:
	OpVrecpe_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrecpe_u32 : public Operation<	ARCH>
{
public:
	OpVrecpe_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrecps_f32 : public Operation<	ARCH>
{
public:
	OpVrecps_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrev_8 : public Operation<	ARCH>
{
public:
	OpVrev_8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t op;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVrev_16 : public Operation<	ARCH>
{
public:
	OpVrev_16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t op;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVrev_32 : public Operation<	ARCH>
{
public:
	OpVrev_32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t op;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVrhadd_s8 : public Operation<	ARCH>
{
public:
	OpVrhadd_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_s16 : public Operation<	ARCH>
{
public:
	OpVrhadd_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_s32 : public Operation<	ARCH>
{
public:
	OpVrhadd_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_u8 : public Operation<	ARCH>
{
public:
	OpVrhadd_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_u16 : public Operation<	ARCH>
{
public:
	OpVrhadd_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_u32 : public Operation<	ARCH>
{
public:
	OpVrhadd_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_s8 : public Operation<	ARCH>
{
public:
	OpVrshl_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_s16 : public Operation<	ARCH>
{
public:
	OpVrshl_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_s32 : public Operation<	ARCH>
{
public:
	OpVrshl_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_s64 : public Operation<	ARCH>
{
public:
	OpVrshl_s64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_u8 : public Operation<	ARCH>
{
public:
	OpVrshl_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_u16 : public Operation<	ARCH>
{
public:
	OpVrshl_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_u32 : public Operation<	ARCH>
{
public:
	OpVrshl_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_u64 : public Operation<	ARCH>
{
public:
	OpVrshl_u64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_s8i : public Operation<	ARCH>
{
public:
	OpVrshr_s8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_s16i : public Operation<	ARCH>
{
public:
	OpVrshr_s16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_s32i : public Operation<	ARCH>
{
public:
	OpVrshr_s32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_s64i : public Operation<	ARCH>
{
public:
	OpVrshr_s64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_u8i : public Operation<	ARCH>
{
public:
	OpVrshr_u8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_u16i : public Operation<	ARCH>
{
public:
	OpVrshr_u16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_u32i : public Operation<	ARCH>
{
public:
	OpVrshr_u32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_u64i : public Operation<	ARCH>
{
public:
	OpVrshr_u64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshrn_i16dqi : public Operation<	ARCH>
{
public:
	OpVrshrn_i16dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshrn_i32dqi : public Operation<	ARCH>
{
public:
	OpVrshrn_i32dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrshrn_i64dqi : public Operation<	ARCH>
{
public:
	OpVrshrn_i64dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsqrte_f32 : public Operation<	ARCH>
{
public:
	OpVrsqrte_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsqrte_u32 : public Operation<	ARCH>
{
public:
	OpVrsqrte_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsqrts_f32 : public Operation<	ARCH>
{
public:
	OpVrsqrts_f32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_s8i : public Operation<	ARCH>
{
public:
	OpVrsra_s8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_s16i : public Operation<	ARCH>
{
public:
	OpVrsra_s16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_s32i : public Operation<	ARCH>
{
public:
	OpVrsra_s32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_s64i : public Operation<	ARCH>
{
public:
	OpVrsra_s64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_u8i : public Operation<	ARCH>
{
public:
	OpVrsra_u8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_u16i : public Operation<	ARCH>
{
public:
	OpVrsra_u16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_u32i : public Operation<	ARCH>
{
public:
	OpVrsra_u32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_u64i : public Operation<	ARCH>
{
public:
	OpVrsra_u64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsubhn_i16dq : public Operation<	ARCH>
{
public:
	OpVrsubhn_i16dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsubhn_i32dq : public Operation<	ARCH>
{
public:
	OpVrsubhn_i32dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVrsubhn_i64dq : public Operation<	ARCH>
{
public:
	OpVrsubhn_i64dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVshl_s8i : public Operation<	ARCH>
{
public:
	OpVshl_s8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s16i : public Operation<	ARCH>
{
public:
	OpVshl_s16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s32i : public Operation<	ARCH>
{
public:
	OpVshl_s32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s64i : public Operation<	ARCH>
{
public:
	OpVshl_s64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s8 : public Operation<	ARCH>
{
public:
	OpVshl_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s16 : public Operation<	ARCH>
{
public:
	OpVshl_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s32 : public Operation<	ARCH>
{
public:
	OpVshl_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s64 : public Operation<	ARCH>
{
public:
	OpVshl_s64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_u8 : public Operation<	ARCH>
{
public:
	OpVshl_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_u16 : public Operation<	ARCH>
{
public:
	OpVshl_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_u32 : public Operation<	ARCH>
{
public:
	OpVshl_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_u64 : public Operation<	ARCH>
{
public:
	OpVshl_u64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_i8 : public Operation<	ARCH>
{
public:
	OpVshll_i8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_i16 : public Operation<	ARCH>
{
public:
	OpVshll_i16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_i32 : public Operation<	ARCH>
{
public:
	OpVshll_i32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_s8i : public Operation<	ARCH>
{
public:
	OpVshr_s8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_s16i : public Operation<	ARCH>
{
public:
	OpVshr_s16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_s32i : public Operation<	ARCH>
{
public:
	OpVshr_s32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_s64i : public Operation<	ARCH>
{
public:
	OpVshr_s64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_u8i : public Operation<	ARCH>
{
public:
	OpVshr_u8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_u16i : public Operation<	ARCH>
{
public:
	OpVshr_u16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_u32i : public Operation<	ARCH>
{
public:
	OpVshr_u32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_u64i : public Operation<	ARCH>
{
public:
	OpVshr_u64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshrn_i16dqi : public Operation<	ARCH>
{
public:
	OpVshrn_i16dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVshrn_i32dqi : public Operation<	ARCH>
{
public:
	OpVshrn_i32dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVshrn_i64dqi : public Operation<	ARCH>
{
public:
	OpVshrn_i64dqi(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsli_8i : public Operation<	ARCH>
{
public:
	OpVsli_8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsli_16i : public Operation<	ARCH>
{
public:
	OpVsli_16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsli_32i : public Operation<	ARCH>
{
public:
	OpVsli_32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsli_64i : public Operation<	ARCH>
{
public:
	OpVsli_64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsra_s8i : public Operation<	ARCH>
{
public:
	OpVsra_s8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsra_s16i : public Operation<	ARCH>
{
public:
	OpVsra_s16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsra_s32i : public Operation<	ARCH>
{
public:
	OpVsra_s32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsra_s64i : public Operation<	ARCH>
{
public:
	OpVsra_s64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsra_u8i : public Operation<	ARCH>
{
public:
	OpVsra_u8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsra_u16i : public Operation<	ARCH>
{
public:
	OpVsra_u16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsra_u32i : public Operation<	ARCH>
{
public:
	OpVsra_u32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsra_u64i : public Operation<	ARCH>
{
public:
	OpVsra_u64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsri_8i : public Operation<	ARCH>
{
public:
	OpVsri_8i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsri_16i : public Operation<	ARCH>
{
public:
	OpVsri_16i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsri_32i : public Operation<	ARCH>
{
public:
	OpVsri_32i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsri_64i : public Operation<	ARCH>
{
public:
	OpVsri_64i(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVstms_8 : public Operation<	ARCH>
{
public:
	OpVstms_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms_16 : public Operation<	ARCH>
{
public:
	OpVstms_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms_32 : public Operation<	ARCH>
{
public:
	OpVstms_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms_64 : public Operation<	ARCH>
{
public:
	OpVstms_64(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms2s_8 : public Operation<	ARCH>
{
public:
	OpVstms2s_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms2s_16 : public Operation<	ARCH>
{
public:
	OpVstms2s_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms2s_32 : public Operation<	ARCH>
{
public:
	OpVstms2s_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVst2_8 : public Operation<	ARCH>
{
public:
	OpVst2_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVst2_16 : public Operation<	ARCH>
{
public:
	OpVst2_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVst2_32 : public Operation<	ARCH>
{
public:
	OpVst2_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstsl_8 : public Operation<	ARCH>
{
public:
	OpVstsl_8(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstsl_16 : public Operation<	ARCH>
{
public:
	OpVstsl_16(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstsl_32 : public Operation<	ARCH>
{
public:
	OpVstsl_32(CodeType code, uint32_t addr);
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t rn;
	uint8_t vd1;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_f32v : public Operation<	ARCH>
{
public:
	OpVsub_f32v(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsub_i8 : public Operation<	ARCH>
{
public:
	OpVsub_i8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_i16 : public Operation<	ARCH>
{
public:
	OpVsub_i16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_i32 : public Operation<	ARCH>
{
public:
	OpVsub_i32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_i64 : public Operation<	ARCH>
{
public:
	OpVsub_i64(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubhn_i16dq : public Operation<	ARCH>
{
public:
	OpVsubhn_i16dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsubhn_i32dq : public Operation<	ARCH>
{
public:
	OpVsubhn_i32dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsubhn_i64dq : public Operation<	ARCH>
{
public:
	OpVsubhn_i64dq(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVsubl_s8 : public Operation<	ARCH>
{
public:
	OpVsubl_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_s16 : public Operation<	ARCH>
{
public:
	OpVsubl_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_s32 : public Operation<	ARCH>
{
public:
	OpVsubl_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_u8 : public Operation<	ARCH>
{
public:
	OpVsubl_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_u16 : public Operation<	ARCH>
{
public:
	OpVsubl_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_u32 : public Operation<	ARCH>
{
public:
	OpVsubl_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_s8 : public Operation<	ARCH>
{
public:
	OpVsubw_s8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_s16 : public Operation<	ARCH>
{
public:
	OpVsubw_s16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_s32 : public Operation<	ARCH>
{
public:
	OpVsubw_s32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_u8 : public Operation<	ARCH>
{
public:
	OpVsubw_u8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_u16 : public Operation<	ARCH>
{
public:
	OpVsubw_u16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_u32 : public Operation<	ARCH>
{
public:
	OpVsubw_u32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVswp : public Operation<	ARCH>
{
public:
	OpVswp(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVtbl_8d : public Operation<	ARCH>
{
public:
	OpVtbl_8d(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVtbx_8d : public Operation<	ARCH>
{
public:
	OpVtbx_8d(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVtrn_8 : public Operation<	ARCH>
{
public:
	OpVtrn_8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVtrn_16 : public Operation<	ARCH>
{
public:
	OpVtrn_16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVtrn_32 : public Operation<	ARCH>
{
public:
	OpVtrn_32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVtst_i8 : public Operation<	ARCH>
{
public:
	OpVtst_i8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVtst_16 : public Operation<	ARCH>
{
public:
	OpVtst_16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVtst_32 : public Operation<	ARCH>
{
public:
	OpVtst_32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
private:
};

template <	typename	ARCH>
class OpVuzp_8 : public Operation<	ARCH>
{
public:
	OpVuzp_8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVuzp_16 : public Operation<	ARCH>
{
public:
	OpVuzp_16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVuzp_32 : public Operation<	ARCH>
{
public:
	OpVuzp_32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVzip_8 : public Operation<	ARCH>
{
public:
	OpVzip_8(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVzip_16 : public Operation<	ARCH>
{
public:
	OpVzip_16(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVzip_32 : public Operation<	ARCH>
{
public:
	OpVzip_32(CodeType code, uint32_t addr);
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream& buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
void OpUsada8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "usada8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpUsada8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm), res = cpu.GetGPR(ra);

		for (unsigned byte = 0; byte < 4; byte++) {
			U32 a = (op1 >> (8*byte)) & U32(0xff), b = (op2 >> (8*byte)) & U32(0xff), d = a - b;
			// Compute abs by arithetic means
			U32 neg( S32(d) >> 8 );
			res += ((d ^ neg) + (neg & U32(1)));
		}

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsada8(CodeType code, uint32_t addr)
{
	return new OpUsada8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMsr_imm_psr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "msr" << DisasmCondition(cond) << '\t' << DisasmPSRMask(write_spsr,mask) << ", #"
		<< std::hex << std::showbase << imm << std::noshowbase << std::dec;
}}
template <	typename	ARCH>
void OpMsr_imm_psr<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		if (write_spsr) {
			SPSRWriteByInstr( cpu, U32(imm), psr_mask );
			} else {
			CPSRWriteByInstr( cpu, U32(imm), psr_mask );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMsr_imm_psr(CodeType code, uint32_t addr)
{
	return new OpMsr_imm_psr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAnd_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "and" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAnd_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 & op2;
		cpu.SetGPR( rd, res );
		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (imr)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAnd_32imm(CodeType code, uint32_t addr)
{
	return new OpAnd_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAnd_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "and" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpAnd_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 & op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAnd_imm_shift(CodeType code, uint32_t addr)
{
	return new OpAnd_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAnd_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "and" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpAnd_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 & op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAnd_reg_shift(CodeType code, uint32_t addr)
{
	return new OpAnd_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpEor_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "eor" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpEor_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 ^ op2;
		cpu.SetGPR( rd, res );
		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (imr)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpEor_32imm(CodeType code, uint32_t addr)
{
	return new OpEor_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpEor_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "eor" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpEor_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 ^ op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpEor_imm_shift(CodeType code, uint32_t addr)
{
	return new OpEor_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpEor_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "eor" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpEor_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 ^ op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpEor_reg_shift(CodeType code, uint32_t addr)
{
	return new OpEor_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSub_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sub" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSub_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSub_32imm(CodeType code, uint32_t addr)
{
	return new OpSub_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSub_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sub" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpSub_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSub_imm_shift(CodeType code, uint32_t addr)
{
	return new OpSub_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSub_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sub" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpSub_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSub_reg_shift(CodeType code, uint32_t addr)
{
	return new OpSub_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsb_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rsb" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpRsb_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = U32(imm), op2 = cpu.GetGPR( rn ), res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsb_32imm(CodeType code, uint32_t addr)
{
	return new OpRsb_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsb_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rsb" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpRsb_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR( rn ),
		res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsb_imm_shift(CodeType code, uint32_t addr)
{
	return new OpRsb_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsb_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rsb" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpRsb_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = ComputeRegShift( cpu, rmval, shift, rsval ), op2 = cpu.GetGPR( rn ),
		res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsb_reg_shift(CodeType code, uint32_t addr)
{
	return new OpRsb_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "add" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdd_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 + op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_32imm(CodeType code, uint32_t addr)
{
	return new OpAdd_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "add" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpAdd_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 + op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_imm_shift(CodeType code, uint32_t addr)
{
	return new OpAdd_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "add" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpAdd_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 + op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_reg_shift(CodeType code, uint32_t addr)
{
	return new OpAdd_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdc_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "adc" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdc_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), carry = cpu.CPSR().Get( C ), res = op1 + op2 + carry;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAddWithCarry( cpu, res, op1, op2, carry );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdc_32imm(CodeType code, uint32_t addr)
{
	return new OpAdc_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "adc" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpAdc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ), carry = cpu.CPSR().Get( C ),
		res = op1 + op2 + carry;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAddWithCarry( cpu, res, op1, op2, carry );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpAdc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdc_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "adc" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpAdc_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ), carry = cpu.CPSR().Get( C ),
		res = op1 + op2 + carry;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAddWithCarry( cpu, res, op1, op2, carry );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdc_reg_shift(CodeType code, uint32_t addr)
{
	return new OpAdc_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbc_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sbc" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSbc_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), borrow = cpu.CPSR().Get( C ) ^ U32(1), res = op1 - op2 - borrow;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSubWithBorrow( cpu, res, op1, op2, borrow );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbc_32imm(CodeType code, uint32_t addr)
{
	return new OpSbc_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sbc" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpSbc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ), borrow = cpu.CPSR().Get( C ) ^ U32(1),
		res = op1 - op2 - borrow;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSubWithBorrow( cpu, res, op1, op2, borrow );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpSbc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbc_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sbc" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpSbc_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ), borrow = cpu.CPSR().Get( C ) ^ U32(1),
		res = op1 - op2 - borrow;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSubWithBorrow( cpu, res, op1, op2, borrow );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbc_reg_shift(CodeType code, uint32_t addr)
{
	return new OpSbc_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsc_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rsc" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpRsc_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = U32(imm), op2 = cpu.GetGPR( rn ), borrow = cpu.CPSR().Get( C ) ^ U32(1), res = op1 - op2 - borrow;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSubWithBorrow( cpu, res, op1, op2, borrow );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsc_32imm(CodeType code, uint32_t addr)
{
	return new OpRsc_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rsc" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpRsc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR( rn ), borrow = cpu.CPSR().Get( C ) ^ U32(1),
		res = op1 - op2 - borrow;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSubWithBorrow( cpu, res, op1, op2, borrow );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpRsc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsc_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rsc" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpRsc_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = ComputeRegShift( cpu, rmval, shift, rsval ), op2 = cpu.GetGPR( rn ), borrow = cpu.CPSR().Get( C ) ^ U32(1),
		res = op1 - op2 - borrow;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSubWithBorrow( cpu, res, op1, op2, borrow );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsc_reg_shift(CodeType code, uint32_t addr)
{
	return new OpRsc_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrr_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "orr" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpOrr_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 | op2;
		cpu.SetGPR( rd, res );
		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (imr)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrr_32imm(CodeType code, uint32_t addr)
{
	return new OpOrr_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrr_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "orr" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpOrr_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 | op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrr_imm_shift(CodeType code, uint32_t addr)
{
	return new OpOrr_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrr_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "orr" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpOrr_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 | op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrr_reg_shift(CodeType code, uint32_t addr)
{
	return new OpOrr_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBic_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bic" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpBic_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 & ~op2;
		cpu.SetGPR( rd, res );
		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (imr)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBic_32imm(CodeType code, uint32_t addr)
{
	return new OpBic_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBic_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bic" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpBic_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 & ~op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBic_imm_shift(CodeType code, uint32_t addr)
{
	return new OpBic_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBic_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bic" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpBic_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 & ~op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBic_reg_shift(CodeType code, uint32_t addr)
{
	return new OpBic_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTst_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "tst" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpTst_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 & op2;
		cpu.CPSR().Set( N, S32(res) < S32(0) );
		cpu.CPSR().Set( Z,     res == U32(0) );
		if (imr)
		cpu.CPSR().Set( C, S32(imm) < S32(0) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTst_32imm(CodeType code, uint32_t addr)
{
	return new OpTst_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTst_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "tst" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpTst_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 & op2;
		UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTst_imm_shift(CodeType code, uint32_t addr)
{
	return new OpTst_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTst_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "tst" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpTst_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 & op2;
		UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTst_reg_shift(CodeType code, uint32_t addr)
{
	return new OpTst_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTeq_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "teq" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpTeq_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 ^ op2;

		cpu.CPSR().Set( N, S32(res) < S32(0) );
		cpu.CPSR().Set( Z,     res == U32(0) );
		if (imr)
		cpu.CPSR().Set( C, S32(imm) < S32(0) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTeq_32imm(CodeType code, uint32_t addr)
{
	return new OpTeq_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTeq_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "teq" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpTeq_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 ^ op2;
		UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTeq_imm_shift(CodeType code, uint32_t addr)
{
	return new OpTeq_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTeq_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "teq" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpTeq_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 ^ op2;
		UpdateStatusRegShift( cpu, res, rmval, shift, rsval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTeq_reg_shift(CodeType code, uint32_t addr)
{
	return new OpTeq_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmp_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "cmp" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpCmp_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 - op2;
		UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmp_32imm(CodeType code, uint32_t addr)
{
	return new OpCmp_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmp_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "cmp" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpCmp_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 - op2;
		UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmp_imm_shift(CodeType code, uint32_t addr)
{
	return new OpCmp_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmp_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "cmp" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpCmp_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 - op2;
		UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmp_reg_shift(CodeType code, uint32_t addr)
{
	return new OpCmp_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmn_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "cmn" << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpCmn_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 + op2;
		UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmn_32imm(CodeType code, uint32_t addr)
{
	return new OpCmn_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmn_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "cmn" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpCmn_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 + op2;
		UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmn_imm_shift(CodeType code, uint32_t addr)
{
	return new OpCmn_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmn_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "cmn" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmShReg( shift, rs );
}}
template <	typename	ARCH>
void OpCmn_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rsval = cpu.GetGPR( rs ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeRegShift( cpu, rmval, shift, rsval ),
		res = op1 + op2;
		UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmn_reg_shift(CodeType code, uint32_t addr)
{
	return new OpCmn_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMov_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mov" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpMov_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 res = U32(imm);
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (imr)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMov_32imm(CodeType code, uint32_t addr)
{
	return new OpMov_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMov_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		uint32_t shift_value = imm;

		if (imm == 0) {
			if (shift == 0 or shift == 3) {
				buffer << (shift ? "rrx" : "mov") << (s?"s":"") << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rm);
				return;
			}
			shift_value = 32;
		}
		buffer << DisasmShift(shift) << (s?"s":"") << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << ", " << DisasmI(shift_value);
}}
template <	typename	ARCH>
void OpMov_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), res = ComputeImmShift( cpu, rmval, shift, imm );
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMov_imm_shift(CodeType code, uint32_t addr)
{
	return new OpMov_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMov_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << DisasmShift(shift) << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpMov_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32
		rnval = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		res = ComputeRegShift( cpu, rnval, shift, rmval );
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusRegShift( cpu, res, rnval, shift, rmval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMov_reg_shift(CodeType code, uint32_t addr)
{
	return new OpMov_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMvn_32imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mvn" << (s?"s":"") << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpMvn_32imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 res = U32(~imm);
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (imr)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMvn_32imm(CodeType code, uint32_t addr)
{
	return new OpMvn_32imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMvn_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mvn" << (s?"s":"") << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpMvn_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), res = ~(ComputeImmShift( cpu, rmval, shift, imm ));
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMvn_imm_shift(CodeType code, uint32_t addr)
{
	return new OpMvn_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMvn_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mvn" << (s?"s":"") << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmShReg( shift, rm );
}}
template <	typename	ARCH>
void OpMvn_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32
		rnval = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		res = ~(ComputeRegShift( cpu, rnval, shift, rmval ));
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusRegShift( cpu, res, rnval, shift, rmval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMvn_reg_shift(CodeType code, uint32_t addr)
{
	return new OpMvn_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpClz<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "clz" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpClz<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 val = cpu.GetGPR( rm );
		if (unlikely( cpu.Test(val == U32(0)) ))
		val = U32(32);
		else
		val = U32(31) - BitScanReverse( cpu.GetGPR( rm ) );

		cpu.SetGPR( rd, val );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpClz(CodeType code, uint32_t addr)
{
	return new OpClz<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRbit<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rbit" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRbit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 src = cpu.GetGPR( rm ), dst(0);
		for (int idx = 0; idx < 32; ++idx) { dst = (dst << 1) | (src & U32(1)); src >>= 1; }
		cpu.SetGPR( rd, dst );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRbit(CodeType code, uint32_t addr)
{
	return new OpRbit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRev<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rev" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRev<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR(rm), rdval = ByteSwap( rmval );

		cpu.SetGPR( rd, rdval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRev(CodeType code, uint32_t addr)
{
	return new OpRev<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRev16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rev16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRev16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rdval = ByteSwap( RotateRight( rmval, 16 ) );
		cpu.SetGPR( rd, rdval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRev16(CodeType code, uint32_t addr)
{
	return new OpRev16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRevsh<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "revsh" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRevsh<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U16 src( cpu.GetGPR(rm) );
		cpu.SetGPR( rd, U32(S32(S16((src >> 8) | (src << 8)))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRevsh(CodeType code, uint32_t addr)
{
	return new OpRevsh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMovw<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "movw" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpMovw<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMovw(CodeType code, uint32_t addr)
{
	return new OpMovw<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMovt<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "movt" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpMovt<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, (cpu.GetGPR( rd ) & U32(0xffff)) | U32(imm << 16) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMovt(CodeType code, uint32_t addr)
{
	return new OpMovt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldr" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdr_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
		cpu.SetGPR_mem( rt, cpu.MemURead32( p?oaddr:addr ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_imm(CodeType code, uint32_t addr)
{
	return new OpLdr_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldr" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rt) << ", "
		<< DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
}}
template <	typename	ARCH>
void OpLdr_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
		cpu.SetGPR_mem( rt, cpu.MemURead32( p?oaddr:addr ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_reg(CodeType code, uint32_t addr)
{
	return new OpLdr_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrh_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrh_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
		cpu.SetGPR_mem( rt, U32( cpu.MemURead16( p?oaddr:addr ) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrh_imm(CodeType code, uint32_t addr)
{
	return new OpLdrh_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrh_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
}}
template <	typename	ARCH>
void OpLdrh_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.SetGPR_mem( rt, U32( cpu.MemURead16( p?oaddr:addr ) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrh_reg(CodeType code, uint32_t addr)
{
	return new OpLdrh_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsh_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrsh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrsh_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( p?oaddr:addr ) ) ) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsh_imm(CodeType code, uint32_t addr)
{
	return new OpLdrsh_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsh_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrsh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
}}
template <	typename	ARCH>
void OpLdrsh_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 rmval = cpu.GetGPR( rm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( p?oaddr:addr ) ) ) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsh_reg(CodeType code, uint32_t addr)
{
	return new OpLdrsh_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrb_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrb_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( p?oaddr:addr ) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrb_imm(CodeType code, uint32_t addr)
{
	return new OpLdrb_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrb_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
		<< DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
}}
template <	typename	ARCH>
void OpLdrb_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( p?oaddr:addr ) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrb_reg(CodeType code, uint32_t addr)
{
	return new OpLdrb_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsb_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrsb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrsb_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( p?oaddr:addr ) ) ) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsb_imm(CodeType code, uint32_t addr)
{
	return new OpLdrsb_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsb_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrsb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
}}
template <	typename	ARCH>
void OpLdrsb_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 rmval = cpu.GetGPR( rm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( p?oaddr:addr ) ) ) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsb_reg(CodeType code, uint32_t addr)
{
	return new OpLdrsb_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrd_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrd_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
		cpu.SetGPR_mem( (rt+0) & 0xf, cpu.MemRead32( (p?oaddr:addr) + U32(0) ) );
		cpu.SetGPR_mem( (rt+1) & 0xf, cpu.MemRead32( (p?oaddr:addr) + U32(4) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrd_imm(CodeType code, uint32_t addr)
{
	return new OpLdrd_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrd_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
}}
template <	typename	ARCH>
void OpLdrd_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.SetGPR_mem( (rt+0) & 0xf, cpu.MemRead32( (p?oaddr:addr) + U32(0) ) );
		cpu.SetGPR_mem( (rt+1) & 0xf, cpu.MemRead32( (p?oaddr:addr) + U32(4) ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrd_reg(CodeType code, uint32_t addr)
{
	return new OpLdrd_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStr_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "str" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStr_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
		cpu.MemUWrite32( p?oaddr:addr, cpu.GetGPR( rt ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStr_imm(CodeType code, uint32_t addr)
{
	return new OpStr_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStr_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "str" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
		<< DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
}}
template <	typename	ARCH>
void OpStr_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
		cpu.MemUWrite32( p?oaddr:addr, cpu.GetGPR( rt ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStr_reg(CodeType code, uint32_t addr)
{
	return new OpStr_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrh_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStrh_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32(imm);
		cpu.MemUWrite16( p?oaddr:addr, U16(cpu.GetGPR( rt )) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrh_imm(CodeType code, uint32_t addr)
{
	return new OpStrh_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrh_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
}}
template <	typename	ARCH>
void OpStrh_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 rmval = cpu.GetGPR( rm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.MemUWrite16( p?oaddr:addr, U16(cpu.GetGPR( rt )) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrh_reg(CodeType code, uint32_t addr)
{
	return new OpStrh_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrb_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStrb_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
		cpu.MemWrite8( p?oaddr:addr, U8(cpu.GetGPR( rt )) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrb_imm(CodeType code, uint32_t addr)
{
	return new OpStrb_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrb_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
		<< DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
}}
template <	typename	ARCH>
void OpStrb_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
		cpu.MemWrite8( p?oaddr:addr, U8(cpu.GetGPR( rt )) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrb_reg(CodeType code, uint32_t addr)
{
	return new OpStrb_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrd_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStrd_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
		cpu.MemWrite32( (p?oaddr:addr) + U32(0), cpu.GetGPR( (rt+0) & 0xf ) );
		cpu.MemWrite32( (p?oaddr:addr) + U32(4), cpu.GetGPR( (rt+1) & 0xf ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrd_imm(CodeType code, uint32_t addr)
{
	return new OpStrd_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrd_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
}}
template <	typename	ARCH>
void OpStrd_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.MemWrite32( (p?oaddr:addr) + U32(0), cpu.GetGPR( (rt+0) & 0xf ) );
		cpu.MemWrite32( (p?oaddr:addr) + U32(4), cpu.GetGPR( (rt+1) & 0xf ) );
		if (not p or w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrd_reg(CodeType code, uint32_t addr)
{
	return new OpStrd_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrt_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
}}
template <	typename	ARCH>
void OpLdrt_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );
		cpu.SetGPR_mem( rt, cpu.MemURead32( addr ) );
		cpu.SetGPR( rn, addr+ U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrt_imm(CodeType code, uint32_t addr)
{
	return new OpLdrt_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrt_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
}}
template <	typename	ARCH>
void OpLdrt_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
		cpu.SetGPR_mem( rt, cpu.MemURead32( addr ) );
		cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrt_reg(CodeType code, uint32_t addr)
{
	return new OpLdrt_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrht_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
}}
template <	typename	ARCH>
void OpLdrht_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );
		cpu.SetGPR_mem( rt, U32( cpu.MemURead16( addr ) ) );
		cpu.SetGPR( rn, addr+ U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrht_imm(CodeType code, uint32_t addr)
{
	return new OpLdrht_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrht_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
}}
template <	typename	ARCH>
void OpLdrht_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.SetGPR_mem( rt, U32( cpu.MemURead16( addr ) ) );
		cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrht_reg(CodeType code, uint32_t addr)
{
	return new OpLdrht_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsht_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrsht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
}}
template <	typename	ARCH>
void OpLdrsht_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 addr = cpu.GetGPR( rn );
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( addr ) ) ) ) );
		cpu.SetGPR( rn, addr+ U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsht_imm(CodeType code, uint32_t addr)
{
	return new OpLdrsht_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsht_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrsht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
}}
template <	typename	ARCH>
void OpLdrsht_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 rmval = cpu.GetGPR( rm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( addr ) ) ) ) );
		cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsht_reg(CodeType code, uint32_t addr)
{
	return new OpLdrsht_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrbt_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
}}
template <	typename	ARCH>
void OpLdrbt_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( addr ) ) );
		cpu.SetGPR( rn, addr+ U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrbt_imm(CodeType code, uint32_t addr)
{
	return new OpLdrbt_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrbt_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
}}
template <	typename	ARCH>
void OpLdrbt_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( addr ) ) );
		cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrbt_reg(CodeType code, uint32_t addr)
{
	return new OpLdrbt_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsbt_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrsbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
}}
template <	typename	ARCH>
void OpLdrsbt_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 addr = cpu.GetGPR( rn );
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( addr ) ) ) ) );
		cpu.SetGPR( rn, addr+ U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsbt_imm(CodeType code, uint32_t addr)
{
	return new OpLdrsbt_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsbt_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrsbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
}}
template <	typename	ARCH>
void OpLdrsbt_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 rmval = cpu.GetGPR( rm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( addr ) ) ) ) );
		cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsbt_reg(CodeType code, uint32_t addr)
{
	return new OpLdrsbt_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrt_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
}}
template <	typename	ARCH>
void OpStrt_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );
		cpu.MemUWrite32( addr, cpu.GetGPR( rt ) );
		cpu.SetGPR( rn, addr+ U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrt_imm(CodeType code, uint32_t addr)
{
	return new OpStrt_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrt_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
}}
template <	typename	ARCH>
void OpStrt_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
		cpu.MemUWrite32( addr, cpu.GetGPR( rt ) );
		cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrt_reg(CodeType code, uint32_t addr)
{
	return new OpStrt_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrht_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
}}
template <	typename	ARCH>
void OpStrht_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 addr = cpu.GetGPR( rn );
		cpu.MemUWrite16( addr, U16(cpu.GetGPR( rt )) );
		cpu.SetGPR( rn, addr+ U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrht_imm(CodeType code, uint32_t addr)
{
	return new OpStrht_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrht_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
}}
template <	typename	ARCH>
void OpStrht_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 rmval = cpu.GetGPR( rm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
		cpu.MemUWrite16( addr, U16(cpu.GetGPR( rt )) );
		cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrht_reg(CodeType code, uint32_t addr)
{
	return new OpStrht_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrbt_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
}}
template <	typename	ARCH>
void OpStrbt_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 addr = cpu.GetGPR( rn );
		cpu.MemWrite8( addr, U8(cpu.GetGPR( rt )) );
		cpu.SetGPR( rn, addr + U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrbt_imm(CodeType code, uint32_t addr)
{
	return new OpStrbt_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrbt_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
}}
template <	typename	ARCH>
void OpStrbt_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
		addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
		cpu.MemWrite8( addr, U8(cpu.GetGPR( rt )) );
		cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrbt_reg(CodeType code, uint32_t addr)
{
	return new OpStrbt_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
		<< ", {" << DisasmRegList(reglist) << "}";
}}
template <	typename	ARCH>
void OpLdm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( rn );
		LSMIter itr(mod, reglist);
		while (itr.next()) {
			cpu.SetGPR_mem( itr.reg(), cpu.MemRead32( base + U32(itr.offset()) ) );
		}

		bool overwritten = (reglist >> rn) & 1;
		if (w and not overwritten) cpu.SetGPR( rn, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdm(CodeType code, uint32_t addr)
{
	return new OpLdm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "stm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
		<< ", {" << DisasmRegList(reglist) << "}";
}}
template <	typename	ARCH>
void OpStm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( rn );
		LSMIter itr(mod, reglist);
		while (itr.next()) {
			cpu.MemWrite32( base + U32(itr.offset()), cpu.GetGPR( itr.reg() ) );
		}

		if (w) cpu.SetGPR( rn, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStm(CodeType code, uint32_t addr)
{
	return new OpStm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdm_usr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn)
		<< ", {" << DisasmRegList(reglist) << "}^";
}}
template <	typename	ARCH>
void OpLdm_usr<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 runmode = cpu.CPSR().Get(M);
		if (unlikely( cpu.Test(runmode == U32(PSR::HYPERVISOR_MODE)) ))
		{
			cpu.UndefinedInstruction( this );
			return;
		}
		if (unlikely( cpu.Test((runmode == U32(PSR::USER_MODE)) or (runmode == U32(PSR::SYSTEM_MODE))) ))
		{
			cpu.UnpredictableInsnBehaviour();
			return;
		}

		U32 base = cpu.GetGPR( rn );
		LSMIter itr(mod, reglist);
		while (itr.next()) {
			cpu.SetBankedRegister( PSR::USER_MODE, itr.reg(), cpu.MemRead32( base + U32(itr.offset()) ) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdm_usr(CodeType code, uint32_t addr)
{
	return new OpLdm_usr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdm_rfe<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
		<< ", {" << DisasmRegList(reglist) << "}^";
}}
template <	typename	ARCH>
void OpLdm_rfe<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 runmode = cpu.CPSR().Get(M);
		if (unlikely( cpu.Test( runmode == U32(PSR::HYPERVISOR_MODE) ) ))
		{
			cpu.UndefinedInstruction( this );
			return;
		}
		if (unlikely( cpu.Test((runmode == U32(PSR::USER_MODE)) or (runmode == U32(PSR::SYSTEM_MODE))) ))
		{
			cpu.UnpredictableInsnBehaviour();
			return;
		}

		U32 base = cpu.GetGPR( rn );
		LSMIter itr(mod, reglist);
		U32 new_pc_value = U32(1); //< Illegal address to be sure that value is overwritten
		while (itr.next()) {
			U32 value = cpu.MemRead32( base + U32(itr.offset()) );
			if (itr.reg() != 15) cpu.SetGPR( itr.reg(), value );
			else                 new_pc_value = value;
		}
		if (w) cpu.SetGPR( rn, base + U32(itr.offset()) );

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );
		// Cannot return to Hyp mode and ThumbEE state
		if (unlikely( cpu.Test((cpu.CPSR().Get(M) == U32(PSR::HYPERVISOR_MODE)) and
		(cpu.CPSR().Get(J) == U32(1)) and (cpu.CPSR().Get(T) == U32(1))) ))
		cpu.UnpredictableInsnBehaviour();

		cpu.BranchExchange( new_pc_value, ARCH::B_RFE );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdm_rfe(CodeType code, uint32_t addr)
{
	return new OpLdm_rfe<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStm_usr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "stm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn)
		<< ", {" << DisasmRegList(reglist) << "}^";
}}
template <	typename	ARCH>
void OpStm_usr<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 runmode = cpu.CPSR().Get(M);
		if (unlikely( cpu.Test(runmode == U32(PSR::HYPERVISOR_MODE)) ))
		{
			cpu.UndefinedInstruction( this );
			return;
		}
		if (unlikely( cpu.Test((runmode == U32(PSR::USER_MODE)) or (runmode == U32(PSR::SYSTEM_MODE))) ))
		{
			cpu.UnpredictableInsnBehaviour();
			return;
		}

		U32 base = cpu.GetGPR( rn );
		LSMIter itr(mod, reglist);
		while (itr.next()) {
			cpu.MemWrite32( base + U32(itr.offset()), cpu.GetBankedRegister( PSR::USER_MODE, itr.reg() ) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStm_usr(CodeType code, uint32_t addr)
{
	return new OpStm_usr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSwp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "swp" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
		<< DisasmRegister(rt2) << ", "
		<< "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpSwp<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 address = cpu.GetGPR(rn);
		/* bus lock */
		U32 data = cpu.MemRead32(address);
		cpu.MemWrite32(address, cpu.GetGPR(rt2));
		/* bus unlock */
		cpu.SetGPR_mem( rt, data );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSwp(CodeType code, uint32_t addr)
{
	return new OpSwp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSwpb<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "swpb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
		<< DisasmRegister(rt2) << ", "
		<< "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpSwpb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;

		U32 address = cpu.GetGPR(rn);
		/* bus lock */
		U8 data( cpu.MemRead8(address) );
		cpu.MemWrite8(address, U8(cpu.GetGPR(rt2)));
		/* bus unlock */
		cpu.SetGPR_mem( rt, U32( data ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSwpb(CodeType code, uint32_t addr)
{
	return new OpSwpb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrex<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrex" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpLdrex<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 addr = cpu.GetGPR( rn );

		cpu.SetExclusiveMonitors( addr, 4 );
		cpu.SetGPR_mem( rt, cpu.MemRead32( addr ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrex(CodeType code, uint32_t addr)
{
	return new OpLdrex<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrexh<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrexh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
		<< "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpLdrexh<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 addr = cpu.GetGPR( rn );

		cpu.SetExclusiveMonitors( addr, 2 );
		cpu.SetGPR_mem( rt, U32( cpu.MemRead16( addr ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrexh(CodeType code, uint32_t addr)
{
	return new OpLdrexh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrexb<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrexb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
		<< "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpLdrexb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 addr = cpu.GetGPR( rn );

		cpu.SetExclusiveMonitors( addr, 1 );
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( addr ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrexb(CodeType code, uint32_t addr)
{
	return new OpLdrexb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrexd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldrexd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
		<< "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpLdrexd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );

		cpu.SetExclusiveMonitors( addr, 8 );
		cpu.SetGPR_mem( (rt+0) & 0xf, cpu.MemRead32( addr + U32(0) ) );
		cpu.SetGPR_mem( (rt+1) & 0xf, cpu.MemRead32( addr + U32(4) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrexd(CodeType code, uint32_t addr)
{
	return new OpLdrexd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrex<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strex" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
		<< DisasmRegister(rt) << ", "
		<< "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpStrex<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );

		if (cpu.ExclusiveMonitorsPass(addr, 4)) {
			cpu.MemWrite32( addr, cpu.GetGPR( rt ) );
			cpu.SetGPR( rd, U32(0) );
			} else {
			cpu.SetGPR( rd, U32(1) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrex(CodeType code, uint32_t addr)
{
	return new OpStrex<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrexh<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strexh" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
		<< DisasmRegister(rt) << ", "
		<< "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpStrexh<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );

		if (cpu.ExclusiveMonitorsPass(addr, 2)) {
			cpu.MemWrite16( addr, typename ARCH::U16(cpu.GetGPR( rt )) );
			cpu.SetGPR( rd, U32(0) );
			} else {
			cpu.SetGPR( rd, U32(1) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrexh(CodeType code, uint32_t addr)
{
	return new OpStrexh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrexb<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strexb" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
		<< DisasmRegister(rt) << ", "
		<< "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpStrexb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );

		if (cpu.ExclusiveMonitorsPass(addr, 1)) {
			cpu.MemWrite8( addr, typename ARCH::U8(cpu.GetGPR( rt )) );
			cpu.SetGPR( rd, U32(0) );
			} else {
			cpu.SetGPR( rd, U32(1) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrexb(CodeType code, uint32_t addr)
{
	return new OpStrexb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrexd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "strexd" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
		<< DisasmRegister(rt) << ", "
		<< "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpStrexd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );

		if (cpu.ExclusiveMonitorsPass(addr, 8)) {
			cpu.MemWrite32( addr + U32(0), cpu.GetGPR( (rt+0) & 0xf ) );
			cpu.MemWrite32( addr + U32(4), cpu.GetGPR( (rt+1) & 0xf ) );
			cpu.SetGPR( rd, U32(0) );
			} else {
			cpu.SetGPR( rd, U32(1) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrexd(CodeType code, uint32_t addr)
{
	return new OpStrexd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMla<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mla" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpMla<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 res = cpu.GetGPR(rn) * cpu.GetGPR(rm) + cpu.GetGPR(ra);
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMla(CodeType code, uint32_t addr)
{
	return new OpMla<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMls<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mls" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpMls<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rd, cpu.GetGPR( ra ) - (cpu.GetGPR( rn ) * cpu.GetGPR( rm )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMls(CodeType code, uint32_t addr)
{
	return new OpMls<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMul<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mul" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpMul<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 res = cpu.GetGPR(rn) * cpu.GetGPR(rm);
		cpu.SetGPR(rd, res);

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMul(CodeType code, uint32_t addr)
{
	return new OpMul<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlal<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smlal" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmlal<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		S64 op1 = S64( S32( cpu.GetGPR(rn) ) );
		S64 op2 = S64( S32( cpu.GetGPR(rm) ) );
		S64 res = ((S64( cpu.GetGPR(rdhi) ) << 32) | S64( cpu.GetGPR(rdlo) )) + (op1 * op2);

		cpu.SetGPR( rdlo, U32( res >> 0 ) );
		cpu.SetGPR( rdhi, U32( res >> 32 ) );

		if (s)
		{
			cpu.CPSR().Set( N, res <  S64(0) );
			cpu.CPSR().Set( Z, res == S64(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlal(CodeType code, uint32_t addr)
{
	return new OpSmlal<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmull<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smull" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmull<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		S64 res = S64( S32( cpu.GetGPR( rn ) ) ) * S64( S32( cpu.GetGPR( rm ) ) );
		cpu.SetGPR( rdlo, U32( res >> 0 ) );
		cpu.SetGPR( rdhi, U32( res >> 32 ) );

		if (s)
		{
			cpu.CPSR().Set( N, res <  S64(0) );
			cpu.CPSR().Set( Z, res == S64(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmull(CodeType code, uint32_t addr)
{
	return new OpSmull<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUmlal<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "umlal" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUmlal<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;

		U64 res = ((U64(cpu.GetGPR( rdlo ))) <<  0) | ((U64(cpu.GetGPR( rdhi ))) << 32);
		res += U64(cpu.GetGPR( rn )) * U64(cpu.GetGPR( rm ));

		cpu.SetGPR( rdlo, U32(res >> 0) );
		cpu.SetGPR( rdhi, U32(res >> 32) );

		if (s)
		{
			cpu.CPSR().Set( N, S64(res) < S64(0) );
			cpu.CPSR().Set( Z, res == U64(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUmlal(CodeType code, uint32_t addr)
{
	return new OpUmlal<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUmaal<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "umaal" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUmaal<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;
		typedef typename ARCH::U32 U32;
		U64 res = (U64(cpu.GetGPR( rn )) * U64(cpu.GetGPR( rm ))) + U64(cpu.GetGPR( rdlo )) + U64(cpu.GetGPR( rdhi ));
		cpu.SetGPR( rdlo, U32(res >> 0) );
		cpu.SetGPR( rdhi, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUmaal(CodeType code, uint32_t addr)
{
	return new OpUmaal<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUmull<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "umull" << (s?"s":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUmull<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;

		U64 res = U64(cpu.GetGPR( rn )) * U64(cpu.GetGPR( rm ));
		cpu.SetGPR( rdlo, U32(res >> 0) );
		cpu.SetGPR( rdhi, U32(res >> 32) );

		if (s)
		{
			cpu.CPSR().Set( N, S64(res) < S64(0) );
			cpu.CPSR().Set( Z,     res == U64(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUmull(CodeType code, uint32_t addr)
{
	return new OpUmull<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlaxy<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smla" << (n?"t":"b") << (m?"t":"b") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmlaxy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		S32 mop1 = S32(S16(cpu.GetGPR(rn) >> (16*n)));
		S32 mop2 = S32(S16(cpu.GetGPR(rm) >> (16*m)));

		// Compute operands and result of signed addition
		U32 op1 = U32(mop1 * mop2),
		op2 = cpu.GetGPR(ra),
		res = op1 + op2;

		U32 overflow = ((op1 & op2 & (~res)) | ((~op1) & (~op2) & res)) >> 31;
		cpu.CPSR().Set( Q, BOOL(overflow | cpu.CPSR().Get( Q )) );

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlaxy(CodeType code, uint32_t addr)
{
	return new OpSmlaxy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlalxy<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smlal" << (n?"t":"b") << (m?"t":"b") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmlalxy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S16 S16;

		S64 op1 = S64( S16(cpu.GetGPR(rn) >> (16*n)) );
		S64 op2 = S64( S16(cpu.GetGPR(rm) >> (16*m)) );
		S64 res = ((S64( cpu.GetGPR(rdhi) ) << 32) | S64( cpu.GetGPR(rdlo) )) + (op1 * op2);

		cpu.SetGPR( rdlo, U32( res >> 0 ) );
		cpu.SetGPR( rdhi, U32( res >> 32 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlalxy(CodeType code, uint32_t addr)
{
	return new OpSmlalxy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlawy<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smlaw" << (m?"t":"b") << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmlawy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		S64 mop1 = S64( S32(cpu.GetGPR(rn)) );
		S64 mop2 = S64( S16(cpu.GetGPR(rm) >> (16*m)) );

		U32 op1 = U32( (mop1 * mop2) >> 16 ),
		op2 = cpu.GetGPR(ra),
		res = op1 + op2;

		U32 overflow = ((op1 & op2 & (~res)) | ((~op1) & (~op2) & res)) >> 31;
		cpu.CPSR().Set( Q, BOOL(overflow | cpu.CPSR().Get( Q )) );

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlawy(CodeType code, uint32_t addr)
{
	return new OpSmlawy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmulxy<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smul" << (n?"t":"b") << (m?"t":"b") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmulxy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		S32 op1 = S32( S16(cpu.GetGPR(rn) >> (16*n)) );
		S32 op2 = S32( S16(cpu.GetGPR(rm) >> (16*m)) );

		cpu.SetGPR( rd, U32(op1 * op2) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmulxy(CodeType code, uint32_t addr)
{
	return new OpSmulxy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmulwy<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smulw" << (m?"t":"b") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmulwy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;

		U32 rmval = cpu.GetGPR(rm) >> (16*m);

		S64 res64 = S64(S32(cpu.GetGPR(rn))) * S64(S16(rmval));
		cpu.SetGPR( rd, U32((res64 >> 16) & S64(0xffffffffULL)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmulwy(CodeType code, uint32_t addr)
{
	return new OpSmulwy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSdiv<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sdiv" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSdiv<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		S32 op1( cpu.GetGPR(rn) ), op2( cpu.GetGPR(rm) ),
		res(0); // An untrapped division by zero result in 0.

		if (not cpu.IntegerZeroDivide( op2 == S32(0) )) {
			res = op1 / op2;
		}

		cpu.SetGPR( rd, U32(res) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSdiv(CodeType code, uint32_t addr)
{
	return new OpSdiv<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUdiv<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "udiv" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUdiv<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1( cpu.GetGPR(rn) ), op2( cpu.GetGPR(rm) ),
		res(0); // An untrapped division by zero result in 0.

		if (not cpu.IntegerZeroDivide( op2 == U32(0) )) {
			res = op1 / op2;
		}

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUdiv(CodeType code, uint32_t addr)
{
	return new OpUdiv<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlad<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smlad" << (swap?"x":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmlad<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 res = S64(product1) + S64(product2) + S64(S32(cpu.GetGPR(ra)));

		U32 saturation( res != S64(S32(res)) );

		cpu.CPSR().Set( Q, BOOL(saturation | cpu.CPSR().Get( Q )) );
		cpu.SetGPR( rd, U32(res) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlad(CodeType code, uint32_t addr)
{
	return new OpSmlad<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlald<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smlald" << (swap?"x":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmlald<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 addend = (S64( cpu.GetGPR(rdhi) ) << 32) | S64( cpu.GetGPR(rdlo) );
		S64 res = S64(product1) + S64(product2) + addend;

		cpu.SetGPR( rdlo, U32(res      ) );
		cpu.SetGPR( rdhi, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlald(CodeType code, uint32_t addr)
{
	return new OpSmlald<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlsd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smlsd" << (swap?"x":"") << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmlsd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 res = S64(product1) - S64(product2) + S64(S32(cpu.GetGPR(ra)));

		U32 saturation( res != S64(S32(res)) );

		cpu.CPSR().Set( Q, BOOL(saturation | cpu.CPSR().Get( Q )) );
		cpu.SetGPR( rd, U32(res) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlsd(CodeType code, uint32_t addr)
{
	return new OpSmlsd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlsld<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smlsld" << (swap?"x":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmlsld<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 addend = (S64( cpu.GetGPR(rdhi) ) << 32) | S64( cpu.GetGPR(rdlo) );
		S64 res = S64(product1) - S64(product2) + addend;

		cpu.SetGPR( rdlo, U32(res      ) );
		cpu.SetGPR( rdhi, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlsld(CodeType code, uint32_t addr)
{
	return new OpSmlsld<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmmla<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smmla" << (round?"r":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmmla<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		S64 a(S32(cpu.GetGPR(ra))), n(S32(cpu.GetGPR(rn))), m(S32(cpu.GetGPR(rm)));
		S64 res = (a<<32) + n*m + (S64(round)<<31);

		cpu.SetGPR( rd, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmmla(CodeType code, uint32_t addr)
{
	return new OpSmmla<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmmls<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smmls" << (round?"r":"") << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmmls<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		S64 a(S32(cpu.GetGPR(ra))), n(S32(cpu.GetGPR(rn))), m(S32(cpu.GetGPR(rm)));
		S64 res = (a<<32) - n*m + (S64(round)<<31);

		cpu.SetGPR( rd, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmmls(CodeType code, uint32_t addr)
{
	return new OpSmmls<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmmul<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smmul" << (round?"r":"") << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmmul<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		S64 n(S32(cpu.GetGPR(rn))), m(S32(cpu.GetGPR(rm)));
		S64 res = n*m + (S64(round)<<31);

		cpu.SetGPR( rd, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmmul(CodeType code, uint32_t addr)
{
	return new OpSmmul<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmuad<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smuad" << (swap?"x":"") << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmuad<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 res = S64(product1) + S64(product2);

		U32 saturation( res != S64(S32(res)) );

		cpu.CPSR().Set( Q, BOOL(saturation | cpu.CPSR().Get( Q )) );
		cpu.SetGPR( rd, U32(res) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmuad(CodeType code, uint32_t addr)
{
	return new OpSmuad<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmusd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smusd" << (swap?"x":"") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmusd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));

		cpu.SetGPR( rd, U32(product1 - product2) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmusd(CodeType code, uint32_t addr)
{
	return new OpSmusd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQadd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qadd" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpQadd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int32_t const nbound = -1 << 31, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q ));
		S32 op1 = S32(cpu.GetGPR(rn)), op2 = S32(cpu.GetGPR(rm)), res = op1 + op2;

		// n is the observed negative flag and sbn is what this flag should be
		BOOL n = res < S32(0), sbn = op1 <= S32(~op2), of = not sbn and n, uf = sbn and not n;
		U32 satres = CondMove<U32>( of, pbound, uf, nbound, res );

		cpu.SetGPR( rd, satres );
		cpu.CPSR().Set( Q, BOOL(q | of | uf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQadd(CodeType code, uint32_t addr)
{
	return new OpQadd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qadd16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << 15, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			S16 op1 = S16(opn >> 16*idx), op2 = S16(opm >> 16*idx), res = op1 + op2;

			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 <= S16(~op2), of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 16*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQadd16(CodeType code, uint32_t addr)
{
	return new OpQadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qadd8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int8_t const nbound = -1 << 7, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 4; ++idx)
		{
			S8 op1 = S8(opn >> 8*idx), op2 = S8(opm >> 8*idx), res = op1 + op2;

			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S8(0), sbn = op1 <= S8(~op2), of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U8>(of, pbound, uf, nbound, res)) << 8*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQadd8(CodeType code, uint32_t addr)
{
	return new OpQadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQsub<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qsub" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpQsub<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int32_t const nbound = -1 << 31, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q ));
		S32 op1 = S32(cpu.GetGPR(rn)), op2 = S32(cpu.GetGPR(rm)), res = op1 - op2;

		// n is the observed negative flag and sbn is what this flag should be
		BOOL n = res < S32(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
		U32 satres = CondMove<U32>(of, pbound, uf, nbound, res);

		cpu.SetGPR( rd, satres );
		cpu.CPSR().Set( Q, BOOL(q | of | uf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQsub(CodeType code, uint32_t addr)
{
	return new OpQsub<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qsub16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << 15, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			S16 op1 = S16(opn >> 16*idx), op2 = S16(opm >> 16*idx), res = op1 - op2;

			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 16*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQsub16(CodeType code, uint32_t addr)
{
	return new OpQsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qsub8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int8_t const nbound = -1 << 7, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 4; ++idx)
		{
			S8 op1 = S8(opn >> 8*idx), op2 = S8(opm >> 8*idx), res = op1 - op2;

			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S8(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U8>(of, pbound, uf, nbound, res)) << 8*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQsub8(CodeType code, uint32_t addr)
{
	return new OpQsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQdadd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qdadd" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpQdadd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int32_t const nbound = -1 << 31, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q )), n, sbn, of, uf;
		S32 opn = S32(cpu.GetGPR(rn)), opm = S32(cpu.GetGPR(rm)), op1, op2, res;

		// First operation doubles opn
		op1 = opn; op2 = opn; res = op1 + op2;
		// n is the observed negative flag and sbn is what this flag should be
		n = res < S32(0); sbn = op1 <= S32(~op2); of = not sbn and n; uf = sbn and not n;
		res = CondMove<S32>(of, pbound, uf, nbound, res);
		q |= of | uf;

		// Second operation adds to opm
		op1 = opm; op2 = res; res = op1 + op2;
		// n is the observed negative flag and sbn is what this flag should be
		n = res < S32(0); sbn = op1 <= S32(~op2); of = not sbn and n; uf = sbn and not n;
		res = CondMove<S32>(of, pbound, uf, nbound, res);
		q |= of | uf;

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( Q, BOOL(q) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQdadd(CodeType code, uint32_t addr)
{
	return new OpQdadd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQdsub<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qdsub" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpQdsub<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int32_t const nbound = -1 << 31, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q )), n, sbn, of, uf;
		S32 opn = S32(cpu.GetGPR(rn)), opm = S32(cpu.GetGPR(rm)), op1, op2, res;

		// First operation doubles opn
		op1 = opn; op2 = opn; res = op1 + op2;
		// n is the observed negative flag and sbn is what this flag should be
		n = res < S32(0); sbn = op1 <= S32(~op2); of = not sbn and n; uf = sbn and not n;
		res = CondMove<S32>(of, pbound, uf, nbound, res);
		q |= of | uf;

		// Second operation subtracts from opm
		op1 = opm; op2 = res; res = op1 - op2;
		// n is the observed negative flag and sbn is what this flag should be
		n = res < S32(0); sbn = op1 < op2; of = not sbn and n; uf = sbn and not n;
		res = CondMove<S32>(of, pbound, uf, nbound, res);
		q |= of | uf;

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( Q, BOOL(q) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQdsub(CodeType code, uint32_t addr)
{
	return new OpQdsub<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPkh<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "pkh" << (tb?"tb":"bt") << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( tb, imm );
}}
template <	typename	ARCH>
void OpPkh<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 op1 = cpu.GetGPR(rn), op2 = ComputeImmShift( cpu, cpu.GetGPR(rm), tb, imm ), res(0);

		if (tb) res = (op1 & U32(0xffff0000)) | (op2 & U32(0x0000ffff));
		else    res = (op2 & U32(0xffff0000)) | (op1 & U32(0x0000ffff));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPkh(CodeType code, uint32_t addr)
{
	return new OpPkh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtab16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sxtab16" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtab16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::S16 S16;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		S16 lo = S16( rmval << 8 ) >> 8, hi = S16( rmval >> 8 ) >> 8;

		lo += S16( rnval >> 0 ); hi += S16( rnval >> 16 );
		cpu.SetGPR( rd, (U32( U16( lo ) ) << 0) | (U32( U16( hi ) ) << 16) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtab16(CodeType code, uint32_t addr)
{
	return new OpSxtab16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtb16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sxtb16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtb16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::S16 S16;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		S16 lo = S16( rmval << 8 ) >> 8, hi = S16( rmval >> 8 ) >> 8;
		cpu.SetGPR( rd, (U32( U16( lo ) ) << 0) | (U32( U16( hi ) ) << 16) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtb16(CodeType code, uint32_t addr)
{
	return new OpSxtb16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtab16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uxtab16" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxtab16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		U16 lo = U16( rmval << 8 ) >> 8, hi = U16( rmval >> 8 ) >> 8;
		lo += U16( rnval >> 0 ); hi += U16( rnval >> 16 );
		cpu.SetGPR( rd, (U32( lo ) << 0) | (U32( hi ) << 16) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtab16(CodeType code, uint32_t addr)
{
	return new OpUxtab16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtb16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uxtb16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxtb16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rmval & U32( 0x00ff00ff ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtb16(CodeType code, uint32_t addr)
{
	return new OpUxtb16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSel<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sel" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSel<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;

		U32 rnval = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm );
		U32 word_mask(0);

		{
			U8 cpsr_ge( cpu.CPSR().Get( GE ) );
			for (unsigned byte_index = 0; byte_index < 4; byte_index++) {
				U8 byte_mask = ((cpsr_ge >> byte_index) & U8(1)) - U8(1);
				word_mask |= U32(byte_mask) << (8*byte_index);
			}
		}

		U32 res = (rnval & ~word_mask) | (rmval & word_mask);

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSel(CodeType code, uint32_t addr)
{
	return new OpSel<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsat<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ssat" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmI(sat_imm+1)
		<< ", " << DisasmRegister(rn) << DisasmShImm(sh,imm);
}}
template <	typename	ARCH>
void OpSsat<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		// negative bound
		int32_t const nbound = -1 << sat_imm, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q ));
		S32 src = S32(ComputeImmShift( cpu, cpu.GetGPR(rn), sh, imm ));

		BOOL of = src > S32(pbound), uf = src < S32(nbound);
		U32 res = CondMove<U32>(of, pbound, uf, nbound, src);

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( Q, BOOL(q | of | uf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsat(CodeType code, uint32_t addr)
{
	return new OpSsat<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsat16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ssat16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmI(sat_imm+1) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpSsat16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << sat_imm, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q ));

		U32 opn = cpu.GetGPR(rn), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			S16 src = S16(opn >> 16*idx);
			BOOL of = src > S16(pbound), uf = src < S16(nbound);
			res32 |= U32(CondMove<U16>(of,pbound,uf,nbound,src)) << 16*idx;
			q |= of | uf;
		}

		cpu.SetGPR( rd, res32 );
		cpu.CPSR().Set( Q, BOOL(q) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsat16(CodeType code, uint32_t addr)
{
	return new OpSsat16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsat<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "usat" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmI(sat_imm)
		<< ", " << DisasmRegister(rn) << DisasmShImm(sh,imm);
}}
template <	typename	ARCH>
void OpUsat<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		int32_t const bound = ~(-1 << sat_imm);

		BOOL q = BOOL(cpu.CPSR().Get( Q ));
		S32 src = S32(ComputeImmShift( cpu, cpu.GetGPR(rn), sh, imm ));

		BOOL of = src > S32(bound), uf = src < S32(0);
		U32 res = CondMove<U32>(of, bound, uf, 0, src);

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( Q, BOOL(q | of | uf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsat(CodeType code, uint32_t addr)
{
	return new OpUsat<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsat16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "usat16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmI(sat_imm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpUsat16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const bound = ~(-1 << sat_imm);

		BOOL q = BOOL(cpu.CPSR().Get( Q ));

		U32 opn = cpu.GetGPR(rn), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			S16 src = S16(opn >> 16*idx);
			BOOL of = src > S16(bound), uf = src < S16(0);
			res32 |= U32(CondMove<U16>(of,bound,uf,0,src)) << 16*idx;
			q |= of | uf;
		}

		cpu.SetGPR( rd, res32 );
		cpu.CPSR().Set( Q, BOOL(q) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsat16(CodeType code, uint32_t addr)
{
	return new OpUsat16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtab<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sxtab" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtab<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rnval + U32( S32( S8( rmval ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtab(CodeType code, uint32_t addr)
{
	return new OpSxtab<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtb<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sxtb" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, U32( S32( S8( rmval ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtb(CodeType code, uint32_t addr)
{
	return new OpSxtb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtah<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sxtah" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtah<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rnval + U32( S32( S16( rmval ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtah(CodeType code, uint32_t addr)
{
	return new OpSxtah<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxth<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sxth" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxth<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, U32( S32( S16( rmval ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxth(CodeType code, uint32_t addr)
{
	return new OpSxth<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtab<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uxtab" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxtab<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rnval + U32( U8( rmval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtab(CodeType code, uint32_t addr)
{
	return new OpUxtab<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtb<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uxtb" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << DisasmShImm( (ror ? 3 : 0), ror );
}}
template <	typename	ARCH>
void OpUxtb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, U32( U8( rmval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtb(CodeType code, uint32_t addr)
{
	return new OpUxtb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtah<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uxtah" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxtah<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rnval + U32( U16( rmval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtah(CodeType code, uint32_t addr)
{
	return new OpUxtah<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxth<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uxth" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxth<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, U32( U16( rmval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxth(CodeType code, uint32_t addr)
{
	return new OpUxth<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsad8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "usad8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUsad8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm), res(0);

		for (unsigned byte = 0; byte < 4; byte++) {
			U32 a = (op1 >> (8*byte)) & U32(0xff), b = (op2 >> (8*byte)) & U32(0xff), d = a - b;
			// Compute abs by arithetic means
			U32 neg( S32(d) >> 8 );
			res += ((d ^ neg) + (neg & U32(1)));
		}

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsad8(CodeType code, uint32_t addr)
{
	return new OpUsad8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbfx<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sbfx" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn)
		<< ", " << DisasmI(lsb) << ", " << DisasmI(widthm1+1);
}}
template <	typename	ARCH>
void OpSbfx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		cpu.SetGPR( rd, U32((S32(cpu.GetGPR( rn )) << (32 - width - lsb)) >> (32 - width)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbfx(CodeType code, uint32_t addr)
{
	return new OpSbfx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBfi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bfi"  << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmI(lsb) << ", " << DisasmI(width);
}}
template <	typename	ARCH>
void OpBfi<	ARCH>::execute( ARCH & cpu)
{
	{
		// if (msb < lsb) UNPREDICTABLE
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, (cpu.GetGPR( rd ) & U32(clear)) | ((cpu.GetGPR( rn ) << lsb) & U32(~clear)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBfi(CodeType code, uint32_t addr)
{
	return new OpBfi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBfc<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bfc"  << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmI(lsb) << ", " << DisasmI(width);
}}
template <	typename	ARCH>
void OpBfc<	ARCH>::execute( ARCH & cpu)
{
	{
		// if (msb < lsb) UNPREDICTABLE
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, cpu.GetGPR( rd ) & U32(clear) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBfc(CodeType code, uint32_t addr)
{
	return new OpBfc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUbfx<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ubfx" << DisasmCondition(cond) << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn)
		<< ", " << DisasmI(lsb) << ", " << DisasmI(widthm1+1);
}}
template <	typename	ARCH>
void OpUbfx<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rd, (cpu.GetGPR( rn ) << (32 - width - lsb)) >> (32 - width) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUbfx(CodeType code, uint32_t addr)
{
	return new OpUbfx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uadd16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
		cv = ((op1 & op2) | (~res & (op1 | op2))) & U32(msbs); //< Carries vector

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( GE, ((cv>>15)|(cv>>14)|(cv>>29)|(cv>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUadd16(CodeType code, uint32_t addr)
{
	return new OpUadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uadd8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
		cv = ((op1 & op2) | (~res & (op1 | op2))) & U32(msbs); //< Carries vector

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( GE, ((cv>>7)|(cv>>14)|(cv>>21)|(cv>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUadd8(CodeType code, uint32_t addr)
{
	return new OpUadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "usub16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
		cv = ((op1 & ~op2) | (~res & (op1 | ~op2))) & U32(msbs); //< Carries vector

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( GE, ((cv>>15)|(cv>>14)|(cv>>29)|(cv>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsub16(CodeType code, uint32_t addr)
{
	return new OpUsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "usub8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
		cv = ((op1 & ~op2) | (~res & (op1 | ~op2))) & U32(msbs); //< Carries vector

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( GE, ((cv>>7)|(cv>>14)|(cv>>21)|(cv>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsub8(CodeType code, uint32_t addr)
{
	return new OpUsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sadd16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
		gev = (((op1 & op2 & ~res) | (~op1 & ~op2 & res)) ^ ~res) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSadd16(CodeType code, uint32_t addr)
{
	return new OpSadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sadd8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
		gev = (((op1 & op2 & ~res) | (~op1 & ~op2 & res)) ^ ~res) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSadd8(CodeType code, uint32_t addr)
{
	return new OpSadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ssub16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
		gev = (((op1 & ~op2 & ~res) | (~op1 & op2 & res)) ^ ~res) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsub16(CodeType code, uint32_t addr)
{
	return new OpSsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ssub8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
		gev = (((op1 & ~op2 & ~res) | (~op1 & op2 & res)) ^ ~res) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsub8(CodeType code, uint32_t addr)
{
	return new OpSsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uqadd16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;

		uint16_t const bound = -1;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			U16 op1 = U16(opn >> 16*idx), op2 = U16(opm >> 16*idx), res = op1 + op2;
			res32 |= U32(CondMove<U16>(op1 > U16(~op2), bound, res)) << 16*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqadd16(CodeType code, uint32_t addr)
{
	return new OpUqadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uqadd8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U32 U32;

		uint8_t const bound = -1;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 4; ++idx)
		{
			U8 op1 = U8(opn >> 8*idx), op2 = U8(opm >> 8*idx), res = op1 + op2;
			res32 |= U32(CondMove<U8>(op1 > U8(~op2), bound, res)) << 8*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqadd8(CodeType code, uint32_t addr)
{
	return new OpUqadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uqsub16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			U16 op1 = U16(opn >> 16*idx), op2 = U16(opm >> 16*idx), res = op1 - op2;
			res32 |= U32(CondMove<U16>(op1 < op2, 0, res)) << 16*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqsub16(CodeType code, uint32_t addr)
{
	return new OpUqsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uqsub8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U32 U32;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 4; ++idx)
		{
			U8 op1 = U8(opn >> 8*idx), op2 = U8(opm >> 8*idx), res = op1 - op2;
			res32 |= U32(CondMove<U8>(op1 < op2, 0, res)) << 8*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqsub8(CodeType code, uint32_t addr)
{
	return new OpUqsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uhadd16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask), lsbs(SWP<16>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = (((op1 >> 1) & U32(~msbs)) + ((op2 >> 1) & U32(~msbs))) + (op1&op2&U32(lsbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhadd16(CodeType code, uint32_t addr)
{
	return new OpUhadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uhadd8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask), lsbs(SWP<8>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = (((op1 >> 1) & U32(~msbs)) + ((op2 >> 1) & U32(~msbs))) + (op1&op2&U32(lsbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhadd8(CodeType code, uint32_t addr)
{
	return new OpUhadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "shadd16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask), lsbs(SWP<16>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) & U32(~msbs)) + ((op2 >> 1) & U32(~msbs))) + (op1&op2&U32(lsbs))) ^ ((op1 ^ op2) & U32(msbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShadd16(CodeType code, uint32_t addr)
{
	return new OpShadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "shadd8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask), lsbs(SWP<8>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) & U32(~msbs)) + ((op2 >> 1) & U32(~msbs))) + (op1&op2&U32(lsbs))) ^ ((op1 ^ op2) & U32(msbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShadd8(CodeType code, uint32_t addr)
{
	return new OpShadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uhsub16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask), lsbs(SWP<16>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) | U32(msbs)) - ((op2 >> 1) & U32(~msbs))) - (~op1&op2&U32(lsbs))) ^ U32(msbs);

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhsub16(CodeType code, uint32_t addr)
{
	return new OpUhsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uhsub8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask), lsbs(SWP<8>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) | U32(msbs)) - ((op2 >> 1) & U32(~msbs))) - (~op1&op2&U32(lsbs))) ^ U32(msbs);

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhsub8(CodeType code, uint32_t addr)
{
	return new OpUhsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "shsub16" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask), lsbs(SWP<16>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = (((((op1 >> 1) | U32(msbs)) - ((op2 >> 1) & U32(~msbs))) - (~op1&op2&U32(lsbs)))) ^ ((~op1 ^ op2) & U32(msbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShsub16(CodeType code, uint32_t addr)
{
	return new OpShsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "shsub8" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask), lsbs(SWP<8>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) | U32(msbs)) - ((op2 >> 1) & U32(~msbs))) - (~op1&op2&U32(lsbs))) ^ ((~op1 ^ op2) & U32(msbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShsub8(CodeType code, uint32_t addr)
{
	return new OpShsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQasx<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qasx" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << 15, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		{
			S16 op1 = S16(opn), op2 = S16(opm >> 16), res = op1 - op2;
			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 0;
		}
		{
			S16 op1 = S16(opn >> 16), op2 = S16(opm), res = op1 + op2;
			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 <= S16(~op2), of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 16;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQasx(CodeType code, uint32_t addr)
{
	return new OpQasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQsax<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "qsax" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << 15, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		{
			S16 op1 = S16(opn), op2 = S16(opm >> 16), res = op1 + op2;
			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 <= S16(~op2), of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 0;
		}
		{
			S16 op1 = S16(opn >> 16), op2 = S16(opm), res = op1 - op2;
			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 16;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQsax(CodeType code, uint32_t addr)
{
	return new OpQsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqasx<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uqasx" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;

		uint16_t const bound = -1;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		{
			U16 op1 = U16(opn), op2 = U16(opm >> 16), res = op1 - op2;
			res32 |= U32(CondMove<U16>(op1 < op2, 0, res)) << 0;
		}
		{
			U16 op1 = U16(opn >> 16), op2 = U16(opm), res = op1 + op2;
			res32 |= U32(CondMove<U16>(op1 > U16(~op2), bound, res)) << 16;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqasx(CodeType code, uint32_t addr)
{
	return new OpUqasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqsax<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uqsax" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;

		uint16_t const bound = -1;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		{
			U16 op1 = U16(opn), op2 = U16(opm >> 16), res = op1 + op2;
			res32 |= U32(CondMove<U16>(op1 > U16(~op2), bound, res)) << 0;
		}
		{
			U16 op1 = U16(opn >> 16), op2 = U16(opm), res = op1 - op2;
			res32 |= U32(CondMove<U16>(op1 < op2, 0, res)) << 16;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqsax(CodeType code, uint32_t addr)
{
	return new OpUqsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSasx<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sasx" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 diff = S32(S16(op1    )) - S32(S16(op2>>16));
		S32 sum  = S32(S16(op1>>16)) + S32(S16(op2    ));

		U32 gev = (U32(sum >= S32(0)) * U32(0xc)) | (U32(diff >= S32(0)) * U32(0x3));
		U32 res = (U32(U16(sum)) << 16) | U32(U16(diff));

		cpu.CPSR().Set( GE, gev );
		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSasx(CodeType code, uint32_t addr)
{
	return new OpSasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsax<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ssax" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 sum  = S32(S16(op1    )) + S32(S16(op2>>16));
		S32 diff = S32(S16(op1>>16)) - S32(S16(op2    ));

		U32 gev = (U32(diff >= S32(0)) * U32(0xc)) | (U32(sum >= S32(0)) * U32(0x3));
		U32 res = (U32(U16(diff)) << 16) | U32(U16(sum));

		cpu.CPSR().Set( GE, gev );
		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsax(CodeType code, uint32_t addr)
{
	return new OpSsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUasx<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uasx" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 diff = S32(U16(op1    )) - S32(U16(op2>>16));
		S32 sum  = S32(U16(op1>>16)) + S32(U16(op2    ));

		U32 gev = (U32(sum >= S32(0x10000)) * U32(0xc)) | (U32(diff >= S32(0)) * U32(0x3));
		U32 res = (U32(U16(sum)) << 16) | U32(U16(diff));

		cpu.CPSR().Set( GE, gev );
		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUasx(CodeType code, uint32_t addr)
{
	return new OpUasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsax<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "usax" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 sum  = S32(U16(op1    )) + S32(U16(op2>>16));
		S32 diff = S32(U16(op1>>16)) - S32(U16(op2    ));

		U32 gev = (U32(diff >= S32(0)) * U32(0xc)) | (U32(sum >= S32(0x10000)) * U32(0x3));
		U32 res = (U32(U16(diff)) << 16) | U32(U16(sum));

		cpu.CPSR().Set( GE, gev );
		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsax(CodeType code, uint32_t addr)
{
	return new OpUsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShasx<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "shasx" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 diff = S32(S16(op1    )) - S32(S16(op2>>16));
		S32 sum  = S32(S16(op1>>16)) + S32(S16(op2    ));

		U32 res = (U32(U16(sum >> 1)) << 16) | U32(U16(diff >> 1));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShasx(CodeType code, uint32_t addr)
{
	return new OpShasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShsax<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "shsax" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 sum  = S32(S16(op1    )) + S32(S16(op2>>16));
		S32 diff = S32(S16(op1>>16)) - S32(S16(op2    ));

		U32 res = (U32(U16(diff >> 1)) << 16) | U32(U16(sum >> 1));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShsax(CodeType code, uint32_t addr)
{
	return new OpShsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhasx<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uhasx" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 diff = S32(U16(op1    )) - S32(U16(op2>>16));
		S32 sum  = S32(U16(op1>>16)) + S32(U16(op2    ));

		U32 res = (U32(U16(sum >> 1)) << 16) | U32(U16(diff >> 1));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhasx(CodeType code, uint32_t addr)
{
	return new OpUhasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhsax<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "uhsax" << DisasmCondition(cond) << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 sum  = S32(U16(op1    )) + S32(U16(op2>>16));
		S32 diff = S32(U16(op1>>16)) - S32(U16(op2    ));

		U32 res = (U32(U16(diff >> 1)) << 16) | U32(U16(sum >> 1));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhsax(CodeType code, uint32_t addr)
{
	return new OpUhsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpNop<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "nop" << DisasmCondition(cond) << "\t{" << idx << "}";
}}
template <	typename	ARCH>
void OpNop<	ARCH>::execute( ARCH & cpu)
{
	{
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpNop(CodeType code, uint32_t addr)
{
	return new OpNop<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpYield<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "yield" << DisasmCondition(cond);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpYield(CodeType code, uint32_t addr)
{
	return new OpYield<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpWfe<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "wfe" << DisasmCondition(cond);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpWfe(CodeType code, uint32_t addr)
{
	return new OpWfe<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpWfi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "wfi" << DisasmCondition(cond);
}}
template <	typename	ARCH>
void OpWfi<	ARCH>::execute( ARCH & cpu)
{
	{
		// if (HaveVirtExt() and not IsSecure() and not CurrentModeIsHyp() and HCR.TWI) {
			//   HSRString = Zeros(25);
			//   HSRString<0> = '0';
			//   WriteHSR('000001', HSRString);
			//   TakeHypTrapException();
			// } else

		cpu.WaitForInterrupt();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpWfi(CodeType code, uint32_t addr)
{
	return new OpWfi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSev<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sev" << DisasmCondition(cond);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSev(CodeType code, uint32_t addr)
{
	return new OpSev<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpDbg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "dbg" << DisasmCondition(cond) << '\t' << DisasmI(idx);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpDbg(CodeType code, uint32_t addr)
{
	return new OpDbg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpB<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "b" << DisasmCondition(cond) << "\t0x" << std::hex << (this->GetAddr() + 8 + imm) << std::dec;
}}
template <	typename	ARCH>
void OpB<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.Branch( cpu.GetGPR( 15 ) + U32(imm), ARCH::B_JMP );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpB(CodeType code, uint32_t addr)
{
	return new OpB<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBl<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bl" << DisasmCondition(cond) << "\t0x" << std::hex << (this->GetAddr() + 8 + imm) << std::dec;
}}
template <	typename	ARCH>
void OpBl<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( 14, cpu.GetNIA() );
		cpu.Branch( cpu.GetGPR( 15 ) + U32(imm), ARCH::B_CALL );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBl(CodeType code, uint32_t addr)
{
	return new OpBl<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBx<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bx" << DisasmCondition(cond) << "\t" << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpBx<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.BranchExchange( cpu.GetGPR(rm), ARCH::B_JMP );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBx(CodeType code, uint32_t addr)
{
	return new OpBx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBxj<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bxj" << DisasmCondition(cond) << '\t' << DisasmRegister(rm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBxj(CodeType code, uint32_t addr)
{
	return new OpBxj<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBlx_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "blx" << DisasmCondition(cond) << "\t" << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpBlx_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rm_value = cpu.GetGPR(rm);
		cpu.SetGPR( 14, cpu.GetNIA() );
		cpu.BranchExchange( rm_value, ARCH::B_CALL );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBlx_reg(CodeType code, uint32_t addr)
{
	return new OpBlx_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "cdp" << DisasmCondition(cond) << '\t' << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmCPR(crd) << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm)
		<< ", {" << std::dec << unsigned( opc2 ) << "}";
}}
template <	typename	ARCH>
void OpCdp<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCdp(CodeType code, uint32_t addr)
{
	return new OpCdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdc<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldc" << (d?"l":"") << DisasmCondition(cond) << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdc(CodeType code, uint32_t addr)
{
	return new OpLdc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdc_unindexed<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldc" << (d?"l":"") << DisasmCondition(cond) << '\t'
		<< unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< "[" << DisasmRegister(rn) << "]"
		<< ", {" << unsigned( option ) << "}";
}}
template <	typename	ARCH>
void OpLdc_unindexed<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdc_unindexed(CodeType code, uint32_t addr)
{
	return new OpLdc_unindexed<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMcr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mcr" << DisasmCondition(cond) << '\t' << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmRegister(rd) << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm) << ", {" << unsigned( opc2 ) << "}";
}}
template <	typename	ARCH>
void OpMcr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMcr(CodeType code, uint32_t addr)
{
	return new OpMcr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrc<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mrc" << DisasmCondition(cond) << '\t' << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", ";
		if (rt == 15) buffer << "APSR_nzcv";
		else          buffer << DisasmRegister(rt);
		buffer << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm) << ", {" << unsigned( opc2 ) << "}";
}}
template <	typename	ARCH>
void OpMrc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrc(CodeType code, uint32_t addr)
{
	return new OpMrc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStc<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "stc" << (d?"l":"") << DisasmCondition(cond) << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStc(CodeType code, uint32_t addr)
{
	return new OpStc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStc_unindexed<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "stc" << (d?"l":"") << DisasmCondition(cond) << '\t'
		<< unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< "[" << DisasmRegister(rn) << "]"
		<< ", {" << unsigned( option ) << "}";
}}
template <	typename	ARCH>
void OpStc_unindexed<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStc_unindexed(CodeType code, uint32_t addr)
{
	return new OpStc_unindexed<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMcrr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mcrr" << DisasmCondition(cond) << '\t'
		<< unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmCPR(crm);
}}
template <	typename	ARCH>
void OpMcrr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMcrr(CodeType code, uint32_t addr)
{
	return new OpMcrr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrrc<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mrrc" << DisasmCondition(cond) << '\t' << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmCPR(crm);
}}
template <	typename	ARCH>
void OpMrrc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrrc(CodeType code, uint32_t addr)
{
	return new OpMrrc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCp15_mcr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mcr" << DisasmCondition(cond) << "\t15, " << unsigned( opc1 ) << ", " << DisasmRegister(rt)
		<< ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm) << ", {" << unsigned( opc2 ) << "}";
		cp15reg->Describe( crn, opc1, crm, opc2, buffer << " ; Write " );
}}
template <	typename	ARCH>
void OpCp15_mcr<	ARCH>::execute( ARCH & cpu)
{
	{
		cp15reg->CheckPermissions(crn, opc1, crm, opc2, cpu, true);

		cp15reg->Write( crn, opc1, crm, opc2, cpu, cpu.GetGPR(rt) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCp15_mcr(CodeType code, uint32_t addr)
{
	return new OpCp15_mcr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCp15_mrc<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mrc" << DisasmCondition(cond) << "\t15, " << unsigned( opc1 ) << ", ";
		if (rt == 15) buffer << "APSR_nzcv";
		else          buffer << DisasmRegister(rt);
		buffer << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm) << ", {" << unsigned( opc2 ) << "}";
		cp15reg->Describe( crn, opc1, crm, opc2, buffer << " ; Read " );
}}
template <	typename	ARCH>
void OpCp15_mrc<	ARCH>::execute( ARCH & cpu)
{
	{
		cp15reg->CheckPermissions(crn, opc1, crm, opc2, cpu, false);

		typename ARCH::U32 value = cp15reg->Read( crn, opc1, crm, opc2, cpu );
		if (rt != 15)
		cpu.SetGPR( rt, value );
		else
		cpu.CPSR().Set( NZCV, value >> 28 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCp15_mrc(CodeType code, uint32_t addr)
{
	return new OpCp15_mrc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSwi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "swi" << DisasmCondition(cond) << "\t" << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSwi<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.CallSupervisor( imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSwi(CodeType code, uint32_t addr)
{
	return new OpSwi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpHvc<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "hvc" << DisasmCondition(cond) << '\t' << std::dec << imm;
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpHvc(CodeType code, uint32_t addr)
{
	return new OpHvc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmc<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "smc" << DisasmCondition(cond) << '\t' << std::dec << imm;
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmc(CodeType code, uint32_t addr)
{
	return new OpSmc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpEret<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "eret" << DisasmCondition(cond);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpEret(CodeType code, uint32_t addr)
{
	return new OpEret<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSubspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "subs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSubspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 - op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSubspc_imm(CodeType code, uint32_t addr)
{
	return new OpSubspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSubspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "subs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpSubspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 - op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSubspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpSubspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMovspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "movs" << DisasmCondition(cond) << "\tpc, " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpMovspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 res = U32(imm);

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMovspc_imm(CodeType code, uint32_t addr)
{
	return new OpMovspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMovspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		uint32_t shift_value = imm;

		if (imm == 0) {
			if (shift == 0 or shift == 3) {
				buffer << (shift ? "rrxs" : "movs") << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rm);
				return;
			}
			shift_value = 32;
		}
		buffer << DisasmShift(shift) << "s" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rm) << ", " << DisasmI(shift_value);
}}
template <	typename	ARCH>
void OpMovspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), res = ComputeImmShift( cpu, rmval, shift, imm );

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMovspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpMovspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAndspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ands" << DisasmCondition(cond) << "\tpc, " << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAndspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 & op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAndspc_imm(CodeType code, uint32_t addr)
{
	return new OpAndspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAndspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ands" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpAndspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 & op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAndspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpAndspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpEorspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "eors" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpEorspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 ^ op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpEorspc_imm(CodeType code, uint32_t addr)
{
	return new OpEorspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpEorspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "eors" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpEorspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 ^ op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpEorspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpEorspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsbspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rsbs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpRsbspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = U32(imm), op2 = cpu.GetGPR( rn ), res = op1 - op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsbspc_imm(CodeType code, uint32_t addr)
{
	return new OpRsbspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsbspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rsbs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpRsbspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR( rn ),
		res = op1 - op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsbspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpRsbspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAddspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "adds" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAddspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 + op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAddspc_imm(CodeType code, uint32_t addr)
{
	return new OpAddspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAddspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "adds" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpAddspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 + op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAddspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpAddspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdcspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "adcs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdcspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), carry = cpu.CPSR().Get( C ), res = op1 + op2 + carry;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdcspc_imm(CodeType code, uint32_t addr)
{
	return new OpAdcspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdcspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "adcs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpAdcspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ), carry = cpu.CPSR().Get( C ),
		res = op1 + op2 + carry;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdcspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpAdcspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbcspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sbcs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSbcspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), borrow = cpu.CPSR().Get( C ) ^ U32(1), res = op1 - op2 - borrow;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbcspc_imm(CodeType code, uint32_t addr)
{
	return new OpSbcspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbcspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "sbcs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpSbcspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ), borrow = cpu.CPSR().Get( C ) ^ U32(1),
		res = op1 - op2 - borrow;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbcspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpSbcspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRscspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rscs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpRscspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = U32(imm), op2 = cpu.GetGPR( rn ), borrow = cpu.CPSR().Get( C ) ^ U32(1), res = op1 - op2 - borrow;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRscspc_imm(CodeType code, uint32_t addr)
{
	return new OpRscspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRscspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rscs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpRscspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR( rn ), borrow = cpu.CPSR().Get( C ) ^ U32(1),
		res = op1 - op2 - borrow;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRscspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpRscspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrrspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "orrs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpOrrspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 | op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrrspc_imm(CodeType code, uint32_t addr)
{
	return new OpOrrspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrrspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "orrs" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpOrrspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 | op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrrspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpOrrspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBicspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bics" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpBicspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 & ~op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBicspc_imm(CodeType code, uint32_t addr)
{
	return new OpBicspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBicspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bics" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpBicspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 & ~op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBicspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpBicspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMvnspc_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mvns" << DisasmCondition(cond) << "\tpc, " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpMvnspc_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 res = U32(~imm);

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMvnspc_imm(CodeType code, uint32_t addr)
{
	return new OpMvnspc_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMvnspc_imm_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mvns" << DisasmCondition(cond) << "\tpc, " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpMvnspc_imm_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), res = ~(ComputeImmShift( cpu, rmval, shift, imm ));

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMvnspc_imm_shift(CodeType code, uint32_t addr)
{
	return new OpMvnspc_imm_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrs<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mrs" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", " << DisasmSpecReg(sr);
}}
template <	typename	ARCH>
void OpMrs<	ARCH>::execute( ARCH & cpu)
{
	{
		switch (sr) {
			default: cpu.UnpredictableInsnBehaviour(); break;
			case 0b0001111: cpu.SetGPR(rd, cpu.GetCPSR()); break;
			case 0b1001111: cpu.SetGPR(rd, cpu.CurrentMode().GetSPSR()); break;

			case 0b0100000: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 8)); break;
			case 0b0100001: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 9)); break;
			case 0b0100010: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 10)); break;
			case 0b0100011: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 11)); break;
			case 0b0100100: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 12)); break;
			case 0b0100101: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 13)); break;
			case 0b0100110: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 14)); break;

			case 0b0101000: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 8)); break;
			case 0b0101001: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 9)); break;
			case 0b0101010: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 10)); break;
			case 0b0101011: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 11)); break;
			case 0b0101100: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 12)); break;
			case 0b0101101: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 13)); break;
			case 0b0101110: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 14)); break;
			case 0b0110000: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::IRQ_MODE, 14)); break;
			case 0b0110001: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::IRQ_MODE, 13)); break;

			case 0b0110010: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::SUPERVISOR_MODE, 14)); break;
			case 0b0110011: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::SUPERVISOR_MODE, 13)); break;

			case 0b0110100: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::ABORT_MODE, 14)); break;
			case 0b0110101: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::ABORT_MODE, 13)); break;

			case 0b0110110: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::UNDEFINED_MODE, 14)); break;
			case 0b0110111: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::UNDEFINED_MODE, 13)); break;

			case 0b0111100: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::MONITOR_MODE, 14)); break;
			case 0b0111101: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::MONITOR_MODE, 13)); break;

			case 0b0111110: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::HYPERVISOR_MODE, 14)); break;
			case 0b0111111: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::HYPERVISOR_MODE, 13)); break;

			case 0b1101110: cpu.SetGPR(rd, cpu.GetMode(PSR::FIQ_MODE).GetSPSR()); break;
			case 0b1110000: cpu.SetGPR(rd, cpu.GetMode(PSR::IRQ_MODE).GetSPSR()); break;
			case 0b1110010: cpu.SetGPR(rd, cpu.GetMode(PSR::SUPERVISOR_MODE).GetSPSR()); break;
			case 0b1110100: cpu.SetGPR(rd, cpu.GetMode(PSR::ABORT_MODE).GetSPSR()); break;
			case 0b1110110: cpu.SetGPR(rd, cpu.GetMode(PSR::UNDEFINED_MODE).GetSPSR()); break;
			case 0b1111100: cpu.SetGPR(rd, cpu.GetMode(PSR::MONITOR_MODE).GetSPSR()); break;
			case 0b1111110: cpu.SetGPR(rd, cpu.GetMode(PSR::HYPERVISOR_MODE).GetSPSR()); break;
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrs(CodeType code, uint32_t addr)
{
	return new OpMrs<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMsr_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "msr" << DisasmCondition(cond) << '\t' << DisasmSpecReg(sr) << ", " << DisasmRegister(rn);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMsr_reg(CodeType code, uint32_t addr)
{
	return new OpMsr_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMsr_reg_psr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "msr" << DisasmCondition(cond) << '\t' << DisasmPSRMask(write_spsr,mask) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpMsr_reg_psr<	ARCH>::execute( ARCH & cpu)
{
	{
		if (write_spsr) {
			SPSRWriteByInstr( cpu, cpu.GetGPR(rn), psr_mask );
			} else {
			CPSRWriteByInstr( cpu, cpu.GetGPR(rn), psr_mask );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMsr_reg_psr(CodeType code, uint32_t addr)
{
	return new OpMsr_reg_psr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabs" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVabs_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vm );

		ARCH::FP::Abs( res );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_f32(CodeType code, uint32_t addr)
{
	return new OpVabs_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabs" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVabs_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vm );

		ARCH::FP::Abs( res );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_f64(CodeType code, uint32_t addr)
{
	return new OpVabs_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vadd" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVadd_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPAdd( res, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_f32(CodeType code, uint32_t addr)
{
	return new OpVadd_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vadd" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVadd_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPAdd( res, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_f64(CodeType code, uint32_t addr)
{
	return new OpVadd_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcmp_f32d<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcmp" << (e?"e":"") << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcmp_f32d<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op1 = cpu.GetVSR( vd ), op2 = cpu.GetVSR( vm );

		FPCompare( op1, op2, e, cpu, cpu.FPSCR );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcmp_f32d(CodeType code, uint32_t addr)
{
	return new OpVcmp_f32d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcmp_f64d<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcmp" << (e?"e":"") << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcmp_f64d<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op1 = cpu.GetVDR( vd ), op2 = cpu.GetVDR( vm );

		FPCompare( op1, op2, e, cpu, cpu.FPSCR );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcmp_f64d(CodeType code, uint32_t addr)
{
	return new OpVcmp_f64d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcmp_f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcmp" << (e?"e":"") << DisasmCondition(cond) << ".f32\ts" << vd << ", #0.0";
}}
template <	typename	ARCH>
void OpVcmp_f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::F32 F32;
		F32 op1 = cpu.GetVSR( vd );
		F32 zero = F32(); /* default constructor is expected to zero-out */

		FPCompare( op1, zero, e, cpu, cpu.FPSCR );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcmp_f32i(CodeType code, uint32_t addr)
{
	return new OpVcmp_f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcmp_f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcmp" << (e?"e":"") << DisasmCondition(cond) << ".f64\td" << vd << ", #0.0";
}}
template <	typename	ARCH>
void OpVcmp_f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::F64 F64;
		F64 op1 = cpu.GetVDR( vd );
		F64 zero = F64(); /* default constructor is expected to zero-out */

		FPCompare( op1, zero, e, cpu, cpu.FPSCR );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcmp_f64i(CodeType code, uint32_t addr)
{
	return new OpVcmp_f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f32.u32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f32u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = cpu.GetVSU( vm );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f64.u32\td" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f64u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = cpu.GetVSU( vm );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64u32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f32.s32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f32s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( cpu.GetVSU( vm ) );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32s32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f64.s32\td" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f64s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( cpu.GetVSU( vm ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64s32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".u32.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_u32f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::U32 res;

		FPToInt( res, op, 0, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtr_u32f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvtr" << DisasmCondition(cond) << ".u32.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvtr_u32f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::U32 res;

		FPToInt( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtr_u32f32(CodeType code, uint32_t addr)
{
	return new OpVcvtr_u32f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".u32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvt_u32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::U32 res;

		FPToInt( res, op, 0, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f64(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtr_u32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvtr" << DisasmCondition(cond) << ".u32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvtr_u32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::U32 res;

		FPToInt( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtr_u32f64(CodeType code, uint32_t addr)
{
	return new OpVcvtr_u32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".s32.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_s32f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::S32 res;

		FPToInt( res, op, 0, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtr_s32f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvtr" << DisasmCondition(cond) << ".s32.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvtr_s32f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::S32 res;

		FPToInt( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtr_s32f32(CodeType code, uint32_t addr)
{
	return new OpVcvtr_s32f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".s32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvt_s32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::S32 res;

		FPToInt( res, op, 0, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f64(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtr_s32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvtr" << DisasmCondition(cond) << ".s32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvtr_s32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::S32 res; // TODO: uninitialized

		FPToInt( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtr_s32f64(CodeType code, uint32_t addr)
{
	return new OpVcvtr_s32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f32.s16\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f32s16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( typename ARCH::S16( cpu.GetVSU( vd ) ) );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32s16i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f32.s32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f32s32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( cpu.GetVSU( vd ) );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32s32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f64.s16\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f64s16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( typename ARCH::S16( cpu.GetVSU( 2*vd ) ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64s16i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f64.s32\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f64s32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( cpu.GetVSU( 2*vd ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64s32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f32.u16\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f32u16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = typename ARCH::U32( typename ARCH::U16( cpu.GetVSU( vd ) ) );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u16i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f32.u32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f32u32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = cpu.GetVSU( vd );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f64.u16\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f64u16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = typename ARCH::U32( typename ARCH::U16( cpu.GetVSU( 2*vd ) ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64u16i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f64.u32\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f64u32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = typename ARCH::U32( cpu.GetVSU( 2*vd ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64u32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s16f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".s16.f32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_s16f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vd );
		typename ARCH::S16 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( typename ARCH::S32( res ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s16f32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_s16f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s16f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".s16.f64\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_s16f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vd );
		typename ARCH::S16 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVDU( vd, typename ARCH::U64( typename ARCH::S64( res ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s16f64i(CodeType code, uint32_t addr)
{
	return new OpVcvt_s16f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".s32.f32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_s32f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vd );
		typename ARCH::S32 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".s32.f64\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_s32f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vd );
		typename ARCH::S32 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVDU( vd, typename ARCH::U64( typename ARCH::S64( res ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f64i(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u16f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".u16.f32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_u16f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vd );
		typename ARCH::U16 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u16f32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_u16f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u16f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".u16.f64\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_u16f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vd );
		typename ARCH::U16 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVDU( vd, typename ARCH::U64( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u16f64i(CodeType code, uint32_t addr)
{
	return new OpVcvt_u16f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".u32.f32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_u32f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vd );
		typename ARCH::U32 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".u32.f64\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_u32f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vd );
		typename ARCH::U32 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVDU( vd, typename ARCH::U64( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f64i(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f64.f32\td" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f64f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::F64 res;

		FPToFP( res, op, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << DisasmCondition(cond) << ".f32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::F32 res;

		FPToFP( res, op, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32f64(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdiv_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vdiv" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVdiv_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPDiv( res, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdiv_f32(CodeType code, uint32_t addr)
{
	return new OpVdiv_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdiv_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vdiv" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVdiv_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPDiv( res, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdiv_f64(CodeType code, uint32_t addr)
{
	return new OpVdiv_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfma_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfma" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVfma_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), op1 = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfma_f32(CodeType code, uint32_t addr)
{
	return new OpVfma_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfma_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfma" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVfma_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), op1 = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfma_f64(CodeType code, uint32_t addr)
{
	return new OpVfma_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfms_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfms" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVfms_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), op1 = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		ARCH::FP::Neg( op1 );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfms_f32(CodeType code, uint32_t addr)
{
	return new OpVfms_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfms_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfms" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVfms_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), op1 = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		ARCH::FP::Neg( op1 );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfms_f64(CodeType code, uint32_t addr)
{
	return new OpVfms_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfnma_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfnma" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVfnma_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), op1 = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		ARCH::FP::Neg( acc );
		ARCH::FP::Neg( op1 );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfnma_f32(CodeType code, uint32_t addr)
{
	return new OpVfnma_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfnma_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfnma" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVfnma_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), op1 = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		ARCH::FP::Neg( acc );
		ARCH::FP::Neg( op1 );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfnma_f64(CodeType code, uint32_t addr)
{
	return new OpVfnma_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfnms_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfnms" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVfnms_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), op1 = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		ARCH::FP::Neg( acc );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfnms_f32(CodeType code, uint32_t addr)
{
	return new OpVfnms_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfnms_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfnms" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVfnms_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), op1 = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		ARCH::FP::Neg( acc );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfnms_f64(CodeType code, uint32_t addr)
{
	return new OpVfnms_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldmdb_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vldmdb" << DisasmCondition(cond) << "\t" << DisasmRegister(rn) << "!, ";
		int32_t send = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << send << "}";
}}
template <	typename	ARCH>
void OpVldmdb_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn ) - U32( regs << 2 );

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.SetVSU( vd + reg, cpu.MemRead32( base_addr + U32(4*reg) ) );
		}

		cpu.SetGPR( rn, base_addr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldmdb_f32(CodeType code, uint32_t addr)
{
	return new OpVldmdb_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldmdb_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		if (not fldm) buffer << "vldmdb";
		else          buffer << "fldmdbx";
		buffer << DisasmCondition(cond) << "\t" << DisasmRegister(rn) << "!, ";
		int32_t dend = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << dend << "}";
}}
template <	typename	ARCH>
void OpVldmdb_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn ) - U32( regs << 3 );

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.SetVSU( 2*(vd+reg) + w0, cpu.MemRead32( base_addr + U32(8*reg + 0) ) );
			cpu.SetVSU( 2*(vd+reg) + w1, cpu.MemRead32( base_addr + U32(8*reg + 4) ) );
		}

		cpu.SetGPR( rn, base_addr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldmdb_f64(CodeType code, uint32_t addr)
{
	return new OpVldmdb_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldmia_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		DisasmCondition cc(cond);
		if ((rn == 13) and w)  buffer << "vpop" << cc << "\t"; /* Syntaxic Sugar */
		else                   buffer << "vldmia" << cc << "\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		int32_t send = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{s" << vd << "}";
		else                buffer << "{s" << vd << "-s" << send << "}";
}}
template <	typename	ARCH>
void OpVldmia_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn );

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.SetVSU( vd + reg, cpu.MemRead32( base_addr + U32(4*reg) ) );
		}

		if (w) cpu.SetGPR( rn, base_addr + U32( regs << 2 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldmia_f32(CodeType code, uint32_t addr)
{
	return new OpVldmia_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldmia_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		DisasmCondition cc(cond);
		if (fldm)                   buffer << "fldmiax" << cc << "\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		else if ((rn == 13) and w)  buffer << "vpop" << cc << "\t"; /* Syntaxic Sugar */
		else                        buffer << "vldmia" << cc << "\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		int32_t dend = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{d" << vd << "}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << dend << "}";
}}
template <	typename	ARCH>
void OpVldmia_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn );

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.SetVSU( 2*(vd+reg) + w0, cpu.MemRead32( base_addr + U32(8*reg + 0) ) );
			cpu.SetVSU( 2*(vd+reg) + w1, cpu.MemRead32( base_addr + U32(8*reg + 4) ) );
		}

		if (w) cpu.SetGPR( rn, base_addr + U32( regs << 3 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldmia_f64(CodeType code, uint32_t addr)
{
	return new OpVldmia_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldr_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vldr" << DisasmCondition(cond) << "\ts" << vd << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpVldr_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32(imm);

		cpu.SetVSU( vd, cpu.MemRead32( addr ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldr_32(CodeType code, uint32_t addr)
{
	return new OpVldr_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldr_64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vldr" << DisasmCondition(cond) << "\td" << vd << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpVldr_64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32(imm);

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		cpu.SetVSU( 2*vd + w0, cpu.MemRead32( addr + U32(0) ) );
		cpu.SetVSU( 2*vd + w1, cpu.MemRead32( addr + U32(4) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldr_64(CodeType code, uint32_t addr)
{
	return new OpVldr_64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmla" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVmla_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), product = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_f32(CodeType code, uint32_t addr)
{
	return new OpVmla_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmla" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmla_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), product = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_f64(CodeType code, uint32_t addr)
{
	return new OpVmla_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmls" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVmls_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), product = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( product );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f32(CodeType code, uint32_t addr)
{
	return new OpVmls_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmls" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmls_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), product = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( product );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f64(CodeType code, uint32_t addr)
{
	return new OpVmls_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmla_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vnmla" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVnmla_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), product = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( product );
		ARCH::FP::Neg( acc );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmla_f32(CodeType code, uint32_t addr)
{
	return new OpVnmla_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmla_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vnmla" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVnmla_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), product = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( product );
		ARCH::FP::Neg( acc );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmla_f64(CodeType code, uint32_t addr)
{
	return new OpVnmla_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmls_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vnmls" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVnmls_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), product = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( acc );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmls_f32(CodeType code, uint32_t addr)
{
	return new OpVnmls_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmls_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vnmls" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVnmls_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), product = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( acc );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmls_f64(CodeType code, uint32_t addr)
{
	return new OpVnmls_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".f32\ts" << vd << ", "
		<< DisasmI((n << 7) | (exp << 4) | man) << "; " << float( VFPExpandImm( n, exp, man ) );
}}
template <	typename	ARCH>
void OpVmov_f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSR( vd, fpimm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f32i(CodeType code, uint32_t addr)
{
	return new OpVmov_f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".f64\td" << vd << ", "
		<< DisasmI((n << 7) | (exp << 4) | man) << "; " << double(VFPExpandImm( n, exp, man ));
}}
template <	typename	ARCH>
void OpVmov_f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDR( vd, fpimm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f64i(CodeType code, uint32_t addr)
{
	return new OpVmov_f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f32s<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVmov_f32s<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSR( vd, cpu.GetVSR( vm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f32s(CodeType code, uint32_t addr)
{
	return new OpVmov_f32s<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f64d<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmov_f64d<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDR( vd, cpu.GetVDR( vm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f64d(CodeType code, uint32_t addr)
{
	return new OpVmov_f64d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_rs<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << "\t" << DisasmRegister(rt) << ", s" << vn;
}}
template <	typename	ARCH>
void OpVmov_rs<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, cpu.GetVSU( vn ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_rs(CodeType code, uint32_t addr)
{
	return new OpVmov_rs<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_sr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << "\ts" << vn << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmov_sr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSU( vn, cpu.GetGPR( rt ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_sr(CodeType code, uint32_t addr)
{
	return new OpVmov_sr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_ssrr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << "\ts" << vm << ", s" << (vm+1) << ", " << DisasmRegister(rt) << ", " << DisasmRegister(rt2);
}}
template <	typename	ARCH>
void OpVmov_ssrr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSU( vm+0, cpu.GetGPR( rt  ) );
		cpu.SetVSU( vm+1, cpu.GetGPR( rt2 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_ssrr(CodeType code, uint32_t addr)
{
	return new OpVmov_ssrr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_rrss<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << "\t" << DisasmRegister(rt) << ", " << DisasmRegister(rt2) << ", s" << vm << ", s" << (vm+1);
}}
template <	typename	ARCH>
void OpVmov_rrss<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt,  cpu.GetVSU( vm+0 ) );
		cpu.SetGPR( rt2, cpu.GetVSU( vm+1 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_rrss(CodeType code, uint32_t addr)
{
	return new OpVmov_rrss<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_rrd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << "\t" << DisasmRegister(rt) << ", " << DisasmRegister(rt2) << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmov_rrd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt,  cpu.GetVSU( 2*vm+0 ) );
		cpu.SetGPR( rt2, cpu.GetVSU( 2*vm+1 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_rrd(CodeType code, uint32_t addr)
{
	return new OpVmov_rrd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_drr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << "\td" << vm << ", " << DisasmRegister(rt) << ", " << DisasmRegister(rt2);
}}
template <	typename	ARCH>
void OpVmov_drr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSU( 2*vm+0, cpu.GetGPR( rt  ) );
		cpu.SetVSU( 2*vm+1, cpu.GetGPR( rt2 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_drr(CodeType code, uint32_t addr)
{
	return new OpVmov_drr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmrs<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmrs" << DisasmCondition(cond) << "\t";
		if ((rt == 15) and (spr == 1)) buffer << "APSR_nzcv";
		else                           buffer << DisasmRegister(rt);
		buffer << ", ";
		switch (spr) {
			default: buffer << "<undefined>"; return;
			case 0b0000:  buffer << "fpsid"; break;
			case 0b0001:  buffer << "fpscr"; break;
			case 0b0110:  buffer << "mvfr1"; break;
			case 0b0111:  buffer << "mvfr0"; break;
			case 0b1000:  buffer << "fpexc"; break;
		}
}}
template <	typename	ARCH>
void OpVmrs<	ARCH>::execute( ARCH & cpu)
{
	{
		if (spr == 1) {
			// cpu.CheckVFPEnabled(TRUE); cpu.SerializeVFP(); cpu.VFPExcBarrier();
			if (rt != 15)
			cpu.SetGPR( rt, cpu.FPSCR );
			else
			cpu.CPSR().Set( NZCV, NZCV.Get( cpu.FPSCR ) );
		}

		else {
			// cpu.CheckVFPEnabled(FALSE);
			typedef typename ARCH::U32 U32;

			if (unlikely( cpu.Test(cpu.CPSR().Get(M) == U32(PSR::USER_MODE)) ))
			cpu.UndefinedInstruction( this );

			switch (spr) {
			default:
				cpu.UndefinedInstruction( this );
				break;
				// case 0b0000: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.FPSID() ); break;
				// case 0b0110: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.MVFR1() ); break;
				// case 0b0111: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.MVFR0() ); break;
				case 0b1000: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.FPEXC ); break;
			}
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmrs(CodeType code, uint32_t addr)
{
	return new OpVmrs<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmsr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmsr" << DisasmCondition(cond) << "\t";
		switch (spr) {
			default: buffer << "<undefined>"; return;
			case 0b0000:  buffer << "fpsid"; break;
			case 0b0001:  buffer << "fpscr"; break;
			case 0b0110:  buffer << "mvfr1"; break;
			case 0b0111:  buffer << "mvfr0"; break;
			case 0b1000:  buffer << "fpexc"; break;
		}
		buffer << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmsr<	ARCH>::execute( ARCH & cpu)
{
	{
		if (spr == 1) {
			// cpu.CheckVFPEnabled(TRUE); cpu.SerializeVFP(); cpu.VFPExcBarrier();
			cpu.FPSCR = cpu.GetGPR( rt );
		}

		else {
			// cpu.CheckVFPEnabled(FALSE);
			typedef typename ARCH::U32 U32;

			if (unlikely( cpu.Test(cpu.CPSR().Get(M) == U32(PSR::USER_MODE)) ))
			cpu.UndefinedInstruction( this );

			switch (spr) {
			default:
				cpu.UndefinedInstruction( this );
				break;

				// case 0b0000: /* cpu.SerializeVFP(); */ /* FPSID is read-only */ break;
				// case 0b0110: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.MVFR1() ); break;
				// case 0b0111: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.MVFR0() ); break;
				case 0b1000: /* cpu.SerializeVFP(); */ cpu.FPEXC = cpu.GetGPR( rt ); break;
			}
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmsr(CodeType code, uint32_t addr)
{
	return new OpVmsr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVmul_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( res, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_f32(CodeType code, uint32_t addr)
{
	return new OpVmul_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmul_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( res, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_f64(CodeType code, uint32_t addr)
{
	return new OpVmul_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmul_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vnmul" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVnmul_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( res, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( res );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmul_f32(CodeType code, uint32_t addr)
{
	return new OpVnmul_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmul_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vnmul" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVnmul_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( res, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( res );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmul_f64(CodeType code, uint32_t addr)
{
	return new OpVnmul_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vneg" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVneg_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vm );

		ARCH::FP::Neg( res );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f32(CodeType code, uint32_t addr)
{
	return new OpVneg_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vneg" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVneg_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vm );

		ARCH::FP::Neg( res );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f64(CodeType code, uint32_t addr)
{
	return new OpVneg_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsqrt_f32s<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsqrt" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVsqrt_f32s<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vm );

		FPSqrt( res, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsqrt_f32s(CodeType code, uint32_t addr)
{
	return new OpVsqrt_f32s<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsqrt_f64d<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsqrt" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVsqrt_f64d<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vm );

		FPSqrt( res, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsqrt_f64d(CodeType code, uint32_t addr)
{
	return new OpVsqrt_f64d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstmdb_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		DisasmCondition cc(cond);
		if (rn == 13) buffer << "vpush" << cc << "\t";
		else          buffer << "vstmdb" << cc << "\t" << DisasmRegister(rn) << "!, ";
		int32_t send = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{s" << vd << "}";
		else                buffer << "{s" << vd << "-s" << send << "}";
}}
template <	typename	ARCH>
void OpVstmdb_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn ) - U32( regs << 2 );

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.MemWrite32( base_addr + U32(4*reg), cpu.GetVSU( vd + reg ) );
		}

		cpu.SetGPR( rn, base_addr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstmdb_f32(CodeType code, uint32_t addr)
{
	return new OpVstmdb_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstmdb_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		DisasmCondition cc(cond);
		if (fstm)          buffer << "fstmdbx" << cc << "\t" << DisasmRegister(rn) << "!, ";
		else if (rn == 13) buffer << "vpush" << cc << "\t";
		else               buffer << "vstmdb" << cc << "\t" << DisasmRegister(rn) << "!, ";
		int32_t dend = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << dend << "}";
}}
template <	typename	ARCH>
void OpVstmdb_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn ) - U32( regs << 3 );

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.MemWrite32( base_addr + U32(8*reg + 0), cpu.GetVSU( 2*(vd+reg) + w0 ) );
			cpu.MemWrite32( base_addr + U32(8*reg + 4), cpu.GetVSU( 2*(vd+reg) + w1 ) );
		}

		cpu.SetGPR( rn, base_addr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstmdb_f64(CodeType code, uint32_t addr)
{
	return new OpVstmdb_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstmia_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vstmia" << DisasmCondition(cond) << "\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		int32_t send = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{s" << vd << "}";
		else                buffer << "{s" << vd << "-s" << send << "}";
}}
template <	typename	ARCH>
void OpVstmia_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn );

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.MemWrite32( base_addr + U32(4*reg), cpu.GetVSU( vd + reg ) );
		}

		if (w) cpu.SetGPR( rn, base_addr + U32( regs << 2 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstmia_f32(CodeType code, uint32_t addr)
{
	return new OpVstmia_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstmia_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		if (fstm) buffer << "fstmiax";
		else      buffer << "vstmia";
		buffer << DisasmCondition(cond) << "\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		int32_t dend = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << dend << "}";
}}
template <	typename	ARCH>
void OpVstmia_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn );

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.MemWrite32( base_addr + U32(8*reg + 0), cpu.GetVSU( 2*(vd+reg) + w0 ) );
			cpu.MemWrite32( base_addr + U32(8*reg + 4), cpu.GetVSU( 2*(vd+reg) + w1 ) );
		}

		if (w) cpu.SetGPR( rn, base_addr + U32( regs << 3 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstmia_f64(CodeType code, uint32_t addr)
{
	return new OpVstmia_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstr_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vstr" << DisasmCondition(cond) << "\ts" << vn << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpVstr_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32(imm);

		cpu.MemWrite32( addr, cpu.GetVSU( vn ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstr_32(CodeType code, uint32_t addr)
{
	return new OpVstr_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstr_64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vstr" << DisasmCondition(cond) << "\td" << vn << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpVstr_64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32(imm);

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		cpu.MemWrite32( addr + U32(0), cpu.GetVSU( 2*vn + w0 ) );
		cpu.MemWrite32( addr + U32(4), cpu.GetVSU( 2*vn + w1 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstr_64(CodeType code, uint32_t addr)
{
	return new OpVstr_64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsub" << DisasmCondition(cond) << ".f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVsub_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPSub( res, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_f32(CodeType code, uint32_t addr)
{
	return new OpVsub_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsub" << DisasmCondition(cond) << ".f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVsub_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPSub( res, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_f64(CodeType code, uint32_t addr)
{
	return new OpVsub_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup8_r<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vdup" << DisasmCondition(cond) << ".8\t" << DisasmV(vd>>q,3+q) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVdup8_r<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		OP element( cpu.GetGPR(rt) );
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup8_r(CodeType code, uint32_t addr)
{
	return new OpVdup8_r<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup16_r<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vdup" << DisasmCondition(cond) << ".16\t" << DisasmV(vd>>q,3+q) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVdup16_r<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		OP element( cpu.GetGPR(rt) );
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup16_r(CodeType code, uint32_t addr)
{
	return new OpVdup16_r<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup32_r<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vdup" << DisasmCondition(cond) << ".32\t" << DisasmV(vd>>q,3+q) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVdup32_r<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		OP element( cpu.GetGPR(rt) );
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup32_r(CodeType code, uint32_t addr)
{
	return new OpVdup32_r<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_8dr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".8\t" << DisasmV(vd, 3) << DisasmVIdx(index) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmov_8dr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDE( vd, index, typename ARCH::U8(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_8dr(CodeType code, uint32_t addr)
{
	return new OpVmov_8dr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_16dr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".16\t" << DisasmV(vd, 3) << DisasmVIdx(index) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmov_16dr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDE( vd, index, typename ARCH::U16(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_16dr(CodeType code, uint32_t addr)
{
	return new OpVmov_16dr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_32dr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".32\t" << DisasmV(vd, 3) << DisasmVIdx(index) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmov_32dr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDE( vd, index, typename ARCH::U32(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_32dr(CodeType code, uint32_t addr)
{
	return new OpVmov_32dr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_s8rd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".s8\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_s8rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, typename ARCH::U32( cpu.GetVDE( vn, index, typename ARCH::S8() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_s8rd(CodeType code, uint32_t addr)
{
	return new OpVmov_s8rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_u8rd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".u8\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_u8rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, typename ARCH::U32( cpu.GetVDE( vn, index, typename ARCH::U8() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_u8rd(CodeType code, uint32_t addr)
{
	return new OpVmov_u8rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_s16rd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".s16\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_s16rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, typename ARCH::U32( cpu.GetVDE( vn, index, typename ARCH::S16() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_s16rd(CodeType code, uint32_t addr)
{
	return new OpVmov_s16rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_u16rd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".u16\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_u16rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, typename ARCH::U32( cpu.GetVDE( vn, index, typename ARCH::U16() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_u16rd(CodeType code, uint32_t addr)
{
	return new OpVmov_u16rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_32rd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov" << DisasmCondition(cond) << ".32\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_32rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, cpu.GetVDE( vn, index, typename ARCH::U32() ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_32rd(CodeType code, uint32_t addr)
{
	return new OpVmov_32rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUnconditional<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "unconditional group\t(" << std::hex << this->GetEncoding() << std::dec << ")";
}}
template <	typename	ARCH>
void OpUnconditional<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UndefinedInstruction( this );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUnconditional(CodeType code, uint32_t addr)
{
	return new OpUnconditional<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshll.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_s8(CodeType code, uint32_t addr)
{
	return new OpVshll_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshll.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_s16(CodeType code, uint32_t addr)
{
	return new OpVshll_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshll.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_s32(CodeType code, uint32_t addr)
{
	return new OpVshll_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshll.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_u8(CodeType code, uint32_t addr)
{
	return new OpVshll_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshll.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_u16(CodeType code, uint32_t addr)
{
	return new OpVshll_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshll.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_u32(CodeType code, uint32_t addr)
{
	return new OpVshll_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSetend<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "setend\t" << (endianness ? "be":"le");
}}
template <	typename	ARCH>
void OpSetend<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.CPSR().Set( E, typename ARCH::U32(endianness) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSetend(CodeType code, uint32_t addr)
{
	return new OpSetend<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPld_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "pld" << (r?"":"w") << "\t" << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpPld_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		/* nop: no architecturally visible changes */
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPld_imm(CodeType code, uint32_t addr)
{
	return new OpPld_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPld_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "pld" << (r?"":"w") << "\t" << DisasmMemoryRRI( rn, rm, shift, imm, true, u, false );
}}
template <	typename	ARCH>
void OpPld_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		/* nop: no architecturally visible changes */
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPld_reg(CodeType code, uint32_t addr)
{
	return new OpPld_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPli_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "pli" << "\t"
		<< DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpPli_imm<	ARCH>::execute( ARCH & cpu)
{
	{ /*ignore for now*/ }}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPli_imm(CodeType code, uint32_t addr)
{
	return new OpPli_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPli_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "pli" << "\t" << DisasmMemoryRRI( rn, rm, shift, imm, true, u, false );
}}
template <	typename	ARCH>
void OpPli_reg<	ARCH>::execute( ARCH & cpu)
{
	{ /*ignore for now*/ }}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPli_reg(CodeType code, uint32_t addr)
{
	return new OpPli_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpClrex<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "clrex";
}}
template <	typename	ARCH>
void OpClrex<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.ClearExclusiveLocal();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpClrex(CodeType code, uint32_t addr)
{
	return new OpClrex<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpDmb<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "dmb\t" << DisasmBarrierOption( opt );
}}
template <	typename	ARCH>
void OpDmb<	ARCH>::execute( ARCH & cpu)
{
	{
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpDmb(CodeType code, uint32_t addr)
{
	return new OpDmb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpDsb<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "dsb\t" << DisasmBarrierOption( opt );
}}
template <	typename	ARCH>
void OpDsb<	ARCH>::execute( ARCH & cpu)
{
	{
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpDsb(CodeType code, uint32_t addr)
{
	return new OpDsb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpIsb<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "isb\t" << DisasmBarrierOption( opt );
}}
template <	typename	ARCH>
void OpIsb<	ARCH>::execute( ARCH & cpu)
{
	{
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpIsb(CodeType code, uint32_t addr)
{
	return new OpIsb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBlx_pcrel<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "blx\t0x" << std::hex << ((this->GetAddr() + 8 + imm) & -2) << std::dec;
}}
template <	typename	ARCH>
void OpBlx_pcrel<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( 14, cpu.GetNIA() );
		cpu.BranchExchange( (cpu.GetGPR( 15 ) + U32(imm)) | U32(1), ARCH::B_CALL );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBlx_pcrel(CodeType code, uint32_t addr)
{
	return new OpBlx_pcrel<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCdp2<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "cdp2\t" << std::dec << unsigned( cp_num ) << ", " << std::dec << unsigned( opc1 )
		<< ", " << DisasmCPR(crd) << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm)
		<< ", {" << unsigned( opc2 ) << "}";
}}
template <	typename	ARCH>
void OpCdp2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCdp2(CodeType code, uint32_t addr)
{
	return new OpCdp2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdc2<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldc2" << (d?"l":"") << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdc2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdc2(CodeType code, uint32_t addr)
{
	return new OpLdc2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdc2_unindexed<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "ldc2" << (d?"l":"") << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< "[" << DisasmRegister(rn) << "]"
		<< ", {" << unsigned( option ) << "}";
}}
template <	typename	ARCH>
void OpLdc2_unindexed<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdc2_unindexed(CodeType code, uint32_t addr)
{
	return new OpLdc2_unindexed<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMcr2<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mcr2\t" << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmRegister(rd) << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm)
		<< ", {" << unsigned( opc2 ) << "}";
}}
template <	typename	ARCH>
void OpMcr2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMcr2(CodeType code, uint32_t addr)
{
	return new OpMcr2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrc2<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mrc2\t" << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmRegister(rt) << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm)
		<< ", {" << unsigned( opc2 ) << "}";
}}
template <	typename	ARCH>
void OpMrc2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrc2(CodeType code, uint32_t addr)
{
	return new OpMrc2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStc2<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "stc2" << (d?"l":"") << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStc2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStc2(CodeType code, uint32_t addr)
{
	return new OpStc2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStc2_unindexed<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "stc2" << (d?"l":"") << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< "[" << DisasmRegister(rn) << "]"
		<< ", {" << unsigned( option ) << "}";
}}
template <	typename	ARCH>
void OpStc2_unindexed<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStc2_unindexed(CodeType code, uint32_t addr)
{
	return new OpStc2_unindexed<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMcrr2<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mcrr2\t" << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmCPR(crm);
}}
template <	typename	ARCH>
void OpMcrr2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMcrr2(CodeType code, uint32_t addr)
{
	return new OpMcrr2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrrc2<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "mrrc2\t" << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmCPR(crm);
}}
template <	typename	ARCH>
void OpMrrc2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrrc2(CodeType code, uint32_t addr)
{
	return new OpMrrc2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBkpt<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "bkpt\t0x" << std::hex << std::setw( 4 ) << std::setfill( '0' ) << imm << std::setw( 0 ) << std::dec;
}}
template <	typename	ARCH>
void OpBkpt<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.BKPT( imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBkpt(CodeType code, uint32_t addr)
{
	return new OpBkpt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCps<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "cps";
		char const* sep = "\t";
		if (chitm) {
			buffer << (dis?"id":"ie") << '\t' << (a?"a":"") << (i?"i":"") << (f?"f":"");
			sep = ", ";
		}
		if (chmod)
		buffer << sep << DisasmI( mode );
}}
template <	typename	ARCH>
void OpCps<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		if (unlikely( cpu.Test(cpu.CPSR().Get(M) == U32(PSR::USER_MODE)) ))
		return;

		// CPSRWriteByInstr() checks for illegal mode changes
		CPSRWriteByInstr( cpu, U32(psr_bits), psr_mask );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCps(CodeType code, uint32_t addr)
{
	return new OpCps<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRfe<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "rfe" << DisasmLSMMode(mod) << '\t' << DisasmRegister(rn) << (w ? "!" : "");
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRfe(CodeType code, uint32_t addr)
{
	return new OpRfe<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSrs<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "srs" << DisasmLSMMode(mod) << '\t' << DisasmRegister(13) << (w ? "!" : "") << ", " << DisasmI(mode);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSrs(CodeType code, uint32_t addr)
{
	return new OpSrs<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtb_f16_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << (t?"t":"b") << DisasmCondition(cond) << ".f16.f32\ts" << vd << ", s" << vm;
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtb_f16_f32(CodeType code, uint32_t addr)
{
	return new OpVcvtb_f16_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtb_f32_f16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt" << (t?"t":"b") << DisasmCondition(cond) << ".f32.f16\ts" << vd << ", s" << vm;
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtb_f32_f16(CodeType code, uint32_t addr)
{
	return new OpVcvtb_f32_f16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaba.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_s8(CodeType code, uint32_t addr)
{
	return new OpVaba_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaba.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_s16(CodeType code, uint32_t addr)
{
	return new OpVaba_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaba.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_s32(CodeType code, uint32_t addr)
{
	return new OpVaba_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaba.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_u8(CodeType code, uint32_t addr)
{
	return new OpVaba_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaba.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_u16(CodeType code, uint32_t addr)
{
	return new OpVaba_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaba.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_u32(CodeType code, uint32_t addr)
{
	return new OpVaba_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_s8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabal.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_s8qd(CodeType code, uint32_t addr)
{
	return new OpVabal_s8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabal.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_s16qd(CodeType code, uint32_t addr)
{
	return new OpVabal_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabal.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_s32qd(CodeType code, uint32_t addr)
{
	return new OpVabal_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_u8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabal.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_u8qd(CodeType code, uint32_t addr)
{
	return new OpVabal_u8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_u16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabal.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_u16qd(CodeType code, uint32_t addr)
{
	return new OpVabal_u16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_u32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabal.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_u32qd(CodeType code, uint32_t addr)
{
	return new OpVabal_u32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabd.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_s8(CodeType code, uint32_t addr)
{
	return new OpVabd_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabd.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_s16(CodeType code, uint32_t addr)
{
	return new OpVabd_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabd.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_s32(CodeType code, uint32_t addr)
{
	return new OpVabd_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabd.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_u8(CodeType code, uint32_t addr)
{
	return new OpVabd_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabd.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_u16(CodeType code, uint32_t addr)
{
	return new OpVabd_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabd.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_u32(CodeType code, uint32_t addr)
{
	return new OpVabd_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_s8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabdl.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_s8qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_s8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabdl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_s16qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabdl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_s32qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_u8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabdl.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_u8qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_u8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_u16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabdl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_u16qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_u16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_u32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabdl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_u32qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_u32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabd.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_f32(CodeType code, uint32_t addr)
{
	return new OpVabd_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabs.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_s8(CodeType code, uint32_t addr)
{
	return new OpVabs_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabs.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_s16(CodeType code, uint32_t addr)
{
	return new OpVabs_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabs.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_s32(CodeType code, uint32_t addr)
{
	return new OpVabs_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vabs.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_f32v(CodeType code, uint32_t addr)
{
	return new OpVabs_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVacge_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vacge.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVacge_f32(CodeType code, uint32_t addr)
{
	return new OpVacge_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVacgt_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vacgt.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVacgt_f32(CodeType code, uint32_t addr)
{
	return new OpVacgt_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vadd.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_f32v(CodeType code, uint32_t addr)
{
	return new OpVadd_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vadd.i" << (64/CFG::elements) << "\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vn>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVadd_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < CFG::elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) + cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_i8(CodeType code, uint32_t addr)
{
	return new OpVadd_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vadd.i" << (64/CFG::elements) << "\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vn>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVadd_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < CFG::elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) + cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_i16(CodeType code, uint32_t addr)
{
	return new OpVadd_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vadd.i" << (64/CFG::elements) << "\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vn>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVadd_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < CFG::elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) + cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_i32(CodeType code, uint32_t addr)
{
	return new OpVadd_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_i64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vadd.i" << (64/CFG::elements) << "\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vn>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVadd_i64<	ARCH>::execute( ARCH & cpu)
{
	{
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < CFG::elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) + cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_i64(CodeType code, uint32_t addr)
{
	return new OpVadd_i64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddhn_i16dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddhn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddhn_i16dq(CodeType code, uint32_t addr)
{
	return new OpVaddhn_i16dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddhn_i32dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddhn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddhn_i32dq(CodeType code, uint32_t addr)
{
	return new OpVaddhn_i32dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddhn_i64dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddhn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddhn_i64dq(CodeType code, uint32_t addr)
{
	return new OpVaddhn_i64dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddl.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_s8(CodeType code, uint32_t addr)
{
	return new OpVaddl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_s16(CodeType code, uint32_t addr)
{
	return new OpVaddl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_s32(CodeType code, uint32_t addr)
{
	return new OpVaddl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddl.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_u8(CodeType code, uint32_t addr)
{
	return new OpVaddl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_u16(CodeType code, uint32_t addr)
{
	return new OpVaddl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_u32(CodeType code, uint32_t addr)
{
	return new OpVaddl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddw.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_s8(CodeType code, uint32_t addr)
{
	return new OpVaddw_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddw.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_s16(CodeType code, uint32_t addr)
{
	return new OpVaddw_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddw.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_s32(CodeType code, uint32_t addr)
{
	return new OpVaddw_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddw.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_u8(CodeType code, uint32_t addr)
{
	return new OpVaddw_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddw.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_u16(CodeType code, uint32_t addr)
{
	return new OpVaddw_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vaddw.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_u32(CodeType code, uint32_t addr)
{
	return new OpVaddw_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVand<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vand\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVand<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) & cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVand(CodeType code, uint32_t addr)
{
	return new OpVand<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbic<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vbic\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVbic<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) & ~cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbic(CodeType code, uint32_t addr)
{
	return new OpVbic<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbic_i16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vbic.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbic_i16i(CodeType code, uint32_t addr)
{
	return new OpVbic_i16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbic_i32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vbic.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbic_i32i(CodeType code, uint32_t addr)
{
	return new OpVbic_i32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbif<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vbif\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVbif<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		{
			U64 sel = cpu.GetVDE( vm+dd, 0, U64() );
			cpu.SetVDE( vd+dd, 0, U64((cpu.GetVDE( vd+dd, 0, U64() ) & sel) | (cpu.GetVDE( vn+dd, 0, U64() ) & ~sel)) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbif(CodeType code, uint32_t addr)
{
	return new OpVbif<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbit<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vbit\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVbit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		{
			U64 sel = cpu.GetVDE( vm+dd, 0, U64() );
			cpu.SetVDE( vd+dd, 0, U64((cpu.GetVDE( vn+dd, 0, U64() ) & sel) | (cpu.GetVDE( vd+dd, 0, U64() ) & ~sel)) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbit(CodeType code, uint32_t addr)
{
	return new OpVbit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbsl<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vbsl\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVbsl<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		{
			U64 sel = cpu.GetVDE( vd+dd, 0, U64() );
			cpu.SetVDE( vd+dd, 0, U64((cpu.GetVDE( vn+dd, 0, U64() ) & sel) | (cpu.GetVDE( vm+dd, 0, U64() ) & ~sel)) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbsl(CodeType code, uint32_t addr)
{
	return new OpVbsl<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_f32(CodeType code, uint32_t addr)
{
	return new OpVceq_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_f8z(CodeType code, uint32_t addr)
{
	return new OpVceq_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_f16z(CodeType code, uint32_t addr)
{
	return new OpVceq_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_f32z(CodeType code, uint32_t addr)
{
	return new OpVceq_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVceq_i8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i8z(CodeType code, uint32_t addr)
{
	return new OpVceq_i8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVceq_i16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i16z(CodeType code, uint32_t addr)
{
	return new OpVceq_i16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVceq_i32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i32z(CodeType code, uint32_t addr)
{
	return new OpVceq_i32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVceq_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i8(CodeType code, uint32_t addr)
{
	return new OpVceq_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVceq_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i16(CodeType code, uint32_t addr)
{
	return new OpVceq_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vceq.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVceq_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i32(CodeType code, uint32_t addr)
{
	return new OpVceq_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_f8z(CodeType code, uint32_t addr)
{
	return new OpVcge_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_f16z(CodeType code, uint32_t addr)
{
	return new OpVcge_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_f32(CodeType code, uint32_t addr)
{
	return new OpVcge_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_f32z(CodeType code, uint32_t addr)
{
	return new OpVcge_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcge_s8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s8z(CodeType code, uint32_t addr)
{
	return new OpVcge_s8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcge_s16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s16z(CodeType code, uint32_t addr)
{
	return new OpVcge_s16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcge_s32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s32z(CodeType code, uint32_t addr)
{
	return new OpVcge_s32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s8(CodeType code, uint32_t addr)
{
	return new OpVcge_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s16(CodeType code, uint32_t addr)
{
	return new OpVcge_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s32(CodeType code, uint32_t addr)
{
	return new OpVcge_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_u8(CodeType code, uint32_t addr)
{
	return new OpVcge_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_u16(CodeType code, uint32_t addr)
{
	return new OpVcge_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcge.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_u32(CodeType code, uint32_t addr)
{
	return new OpVcge_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_f8z(CodeType code, uint32_t addr)
{
	return new OpVcgt_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_f16z(CodeType code, uint32_t addr)
{
	return new OpVcgt_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_f32z(CodeType code, uint32_t addr)
{
	return new OpVcgt_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_f32(CodeType code, uint32_t addr)
{
	return new OpVcgt_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcgt_s8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s8z(CodeType code, uint32_t addr)
{
	return new OpVcgt_s8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcgt_s16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s16z(CodeType code, uint32_t addr)
{
	return new OpVcgt_s16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcgt_s32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s32z(CodeType code, uint32_t addr)
{
	return new OpVcgt_s32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s8(CodeType code, uint32_t addr)
{
	return new OpVcgt_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s16(CodeType code, uint32_t addr)
{
	return new OpVcgt_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s32(CodeType code, uint32_t addr)
{
	return new OpVcgt_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_u8(CodeType code, uint32_t addr)
{
	return new OpVcgt_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_u16(CodeType code, uint32_t addr)
{
	return new OpVcgt_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcgt.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_u32(CodeType code, uint32_t addr)
{
	return new OpVcgt_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcle.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_f8z(CodeType code, uint32_t addr)
{
	return new OpVcle_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcle.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_f16z(CodeType code, uint32_t addr)
{
	return new OpVcle_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcle.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_f32z(CodeType code, uint32_t addr)
{
	return new OpVcle_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_s8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcle.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcle_s8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 <= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_s8z(CodeType code, uint32_t addr)
{
	return new OpVcle_s8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_s16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcle.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcle_s16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 <= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_s16z(CodeType code, uint32_t addr)
{
	return new OpVcle_s16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_s32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcle.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcle_s32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 <= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_s32z(CodeType code, uint32_t addr)
{
	return new OpVcle_s32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcls_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcls.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcls_s8(CodeType code, uint32_t addr)
{
	return new OpVcls_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcls_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcls.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcls_s16(CodeType code, uint32_t addr)
{
	return new OpVcls_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcls_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcls.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcls_s32(CodeType code, uint32_t addr)
{
	return new OpVcls_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vclt.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_f8z(CodeType code, uint32_t addr)
{
	return new OpVclt_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vclt.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_f16z(CodeType code, uint32_t addr)
{
	return new OpVclt_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vclt.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_f32z(CodeType code, uint32_t addr)
{
	return new OpVclt_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_s8z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vclt.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVclt_s8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 < op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_s8z(CodeType code, uint32_t addr)
{
	return new OpVclt_s8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_s16z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vclt.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVclt_s16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 < op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_s16z(CodeType code, uint32_t addr)
{
	return new OpVclt_s16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_s32z<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vclt.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVclt_s32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 < op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_s32z(CodeType code, uint32_t addr)
{
	return new OpVclt_s32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclz_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vclz.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclz_i8(CodeType code, uint32_t addr)
{
	return new OpVclz_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclz_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vclz.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclz_i16(CodeType code, uint32_t addr)
{
	return new OpVclz_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclz_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vclz.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclz_i32(CodeType code, uint32_t addr)
{
	return new OpVclz_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcnt_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcnt.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcnt_8(CodeType code, uint32_t addr)
{
	return new OpVcnt_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f16_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.f16.f32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f16_f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f16_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32_f16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.f32.f16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32_f16(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32_f16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.f32.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32_s32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32s32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.f32.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32s32vi(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32s32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.f32.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u32v(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.f32.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u32vi(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.s32.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32_f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.s32.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f32vi(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.u32.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f32v(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vcvt.u32.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f32vi(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup_8dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vdup.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}
template <	typename	ARCH>
void OpVdup_8dp<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		OP element = cpu.GetVDE(vm, part, OP());
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup_8dp(CodeType code, uint32_t addr)
{
	return new OpVdup_8dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup_16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vdup.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}
template <	typename	ARCH>
void OpVdup_16dp<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		OP element = cpu.GetVDE(vm, part, OP());
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup_16dp(CodeType code, uint32_t addr)
{
	return new OpVdup_16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup_32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vdup.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}
template <	typename	ARCH>
void OpVdup_32dp<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		OP element = cpu.GetVDE(vm, part, OP());
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup_32dp(CodeType code, uint32_t addr)
{
	return new OpVdup_32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVeor<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "veor\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVeor<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) ^ cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVeor(CodeType code, uint32_t addr)
{
	return new OpVeor<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVext_8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vext.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVext_8i(CodeType code, uint32_t addr)
{
	return new OpVext_8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfma_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfma.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfma_f32v(CodeType code, uint32_t addr)
{
	return new OpVfma_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfms_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vfms.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfms_f32v(CodeType code, uint32_t addr)
{
	return new OpVfms_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhadd.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_s8(CodeType code, uint32_t addr)
{
	return new OpVhadd_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhadd.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_s16(CodeType code, uint32_t addr)
{
	return new OpVhadd_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhadd.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_s32(CodeType code, uint32_t addr)
{
	return new OpVhadd_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhadd.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_u8(CodeType code, uint32_t addr)
{
	return new OpVhadd_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhadd.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_u16(CodeType code, uint32_t addr)
{
	return new OpVhadd_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhadd.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_u32(CodeType code, uint32_t addr)
{
	return new OpVhadd_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhsub.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_s8(CodeType code, uint32_t addr)
{
	return new OpVhsub_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhsub.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_s16(CodeType code, uint32_t addr)
{
	return new OpVhsub_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhsub.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_s32(CodeType code, uint32_t addr)
{
	return new OpVhsub_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhsub.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_u8(CodeType code, uint32_t addr)
{
	return new OpVhsub_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhsub.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_u16(CodeType code, uint32_t addr)
{
	return new OpVhsub_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vhsub.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_u32(CodeType code, uint32_t addr)
{
	return new OpVhsub_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << (vms.ses ? 1 : int(vms.regs)) << ".8\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx/elements)%32, idx%elements, U8(cpu.MemRead8(addr + U32(size*idx))));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U8(cpu.MemRead8(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms_8(CodeType code, uint32_t addr)
{
	return new OpVldms_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << (vms.ses ? 1 : int(vms.regs)) << ".16\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx/elements)%32, idx%elements, U16(cpu.MemRead16(addr + U32(size*idx))));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U16(cpu.MemRead16(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms_16(CodeType code, uint32_t addr)
{
	return new OpVldms_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << (vms.ses ? 1 : int(vms.regs)) << ".32\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx/elements)%32, idx%elements, U32(cpu.MemRead32(addr + U32(size*idx))));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U32(cpu.MemRead32(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms_32(CodeType code, uint32_t addr)
{
	return new OpVldms_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms_64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << (vms.ses ? 1 : int(vms.regs)) << ".64\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms_64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;
		unsigned const size = 8;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		U32 endianness = cpu.CPSR().Get(E) * U32(4);

		for (unsigned idx = 0, end = vms.regs; idx < end; ++idx)
		{
			U64 data0( cpu.MemRead32(addr + (U32(size*idx + 0) ^ endianness)) ),
			data1( cpu.MemRead32(addr + (U32(size*idx + 4) ^ endianness)) );
			cpu.SetVDE((vd+idx)%32, 0, U64((data1 << 32) | (data0 << 0)));
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms_64(CodeType code, uint32_t addr)
{
	return new OpVldms_64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms2s_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << int(regs) << ".8\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms2s_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+2*(idx%regs))%32, idx/regs, U8(cpu.MemRead8(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms2s_8(CodeType code, uint32_t addr)
{
	return new OpVldms2s_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms2s_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << int(regs) << ".16\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms2s_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+2*(idx%regs))%32, idx/regs, U16(cpu.MemRead16(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms2s_16(CodeType code, uint32_t addr)
{
	return new OpVldms2s_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms2s_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << int(regs) << ".32\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms2s_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+2*(idx%regs))%32, idx/regs, U32(cpu.MemRead32(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms2s_32(CodeType code, uint32_t addr)
{
	return new OpVldms2s_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVld2_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld2.8\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVld2_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.SetVDE(vd+q+2*reg, idx, U8(cpu.MemRead8(addr))) ;
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVld2_8(CodeType code, uint32_t addr)
{
	return new OpVld2_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVld2_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld2.16\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVld2_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.SetVDE(vd+q+2*reg, idx, U16(cpu.MemRead16(addr))) ;
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVld2_16(CodeType code, uint32_t addr)
{
	return new OpVld2_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVld2_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld2.32\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVld2_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.SetVDE(vd+q+2*reg, idx, U32(cpu.MemRead32(addr))) ;
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVld2_32(CodeType code, uint32_t addr)
{
	return new OpVld2_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldal_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".8\t" << DisasmBunch(vd,regs+1).dspc(ds).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?8:0);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldal_8(CodeType code, uint32_t addr)
{
	return new OpVldal_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldal_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".16\t" << DisasmBunch(vd,regs+1).dspc(ds).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?16:0);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldal_16(CodeType code, uint32_t addr)
{
	return new OpVldal_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldal_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".32\t" << DisasmBunch(vd,regs+1).dspc(ds).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?32:0);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldal_32(CodeType code, uint32_t addr)
{
	return new OpVldal_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldqal_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld1.8\t" << DisasmBunch(vd,2).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?8:0);
}}
template <	typename	ARCH>
void OpVldqal_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(size) : cpu.GetGPR(rm)) );

		U8  data( cpu.MemRead8(addr) );
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0, end = elements; idx < end; ++idx)
		cpu.SetVDE(vd+q, idx, data);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldqal_8(CodeType code, uint32_t addr)
{
	return new OpVldqal_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldqal_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld1.16\t" << DisasmBunch(vd,2).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?16:0);
}}
template <	typename	ARCH>
void OpVldqal_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, align*size);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(size) : cpu.GetGPR(rm)) );

		U16  data( cpu.MemRead16(addr) );
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0, end = elements; idx < end; ++idx)
		cpu.SetVDE(vd+q, idx, data);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldqal_16(CodeType code, uint32_t addr)
{
	return new OpVldqal_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldqal_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld1.32\t" << DisasmBunch(vd,2).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?32:0);
}}
template <	typename	ARCH>
void OpVldqal_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, align*size);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(size) : cpu.GetGPR(rm)) );

		U32  data( cpu.MemRead32(addr) );
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0, end = elements; idx < end; ++idx)
		cpu.SetVDE(vd+q, idx, data);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldqal_32(CodeType code, uint32_t addr)
{
	return new OpVldqal_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldsl_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".8\t" << DisasmBunch(vd, regs+1).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldsl_8(CodeType code, uint32_t addr)
{
	return new OpVldsl_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldsl_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".16\t" << DisasmBunch(vd, regs+1).dspc(ds).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldsl_16(CodeType code, uint32_t addr)
{
	return new OpVldsl_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldsl_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".32\t" << DisasmBunch(vd, regs+1).dspc(ds).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldsl_32(CodeType code, uint32_t addr)
{
	return new OpVldsl_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmax.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_f32(CodeType code, uint32_t addr)
{
	return new OpVmax_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmax.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_s8(CodeType code, uint32_t addr)
{
	return new OpVmax_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmax.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_s16(CodeType code, uint32_t addr)
{
	return new OpVmax_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmax.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_s32(CodeType code, uint32_t addr)
{
	return new OpVmax_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmax.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_u8(CodeType code, uint32_t addr)
{
	return new OpVmax_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmax.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_u16(CodeType code, uint32_t addr)
{
	return new OpVmax_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmax.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_u32(CodeType code, uint32_t addr)
{
	return new OpVmax_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmin.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_f32(CodeType code, uint32_t addr)
{
	return new OpVmin_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmin.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_s8(CodeType code, uint32_t addr)
{
	return new OpVmin_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmin.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_s16(CodeType code, uint32_t addr)
{
	return new OpVmin_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmin.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_s32(CodeType code, uint32_t addr)
{
	return new OpVmin_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmin.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_u8(CodeType code, uint32_t addr)
{
	return new OpVmin_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmin.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_u16(CodeType code, uint32_t addr)
{
	return new OpVmin_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmin.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_u32(CodeType code, uint32_t addr)
{
	return new OpVmin_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmla.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_f32v(CodeType code, uint32_t addr)
{
	return new OpVmla_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_f32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmla.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_f32dp(CodeType code, uint32_t addr)
{
	return new OpVmla_f32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVml_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << ".i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVml_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		OP sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE(vd+dd, idx, OP()) + sign * cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVml_i8(CodeType code, uint32_t addr)
{
	return new OpVml_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVml_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << ".i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVml_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		OP sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE(vd+dd, idx, OP()) + sign * cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVml_i16(CodeType code, uint32_t addr)
{
	return new OpVml_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVml_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << ".i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVml_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		OP sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE(vd+dd, idx, OP()) + sign * cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVml_i32(CodeType code, uint32_t addr)
{
	return new OpVml_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_i16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmla.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_i16dp(CodeType code, uint32_t addr)
{
	return new OpVmla_i16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_i32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmla.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_i32dp(CodeType code, uint32_t addr)
{
	return new OpVmla_i32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_s8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_s8qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_s8qd(CodeType code, uint32_t addr)
{
	return new OpVmll_s8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_s16qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_s16qd(CodeType code, uint32_t addr)
{
	return new OpVmll_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_s32qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_s32qd(CodeType code, uint32_t addr)
{
	return new OpVmll_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_u8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_u8qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_u8qd(CodeType code, uint32_t addr)
{
	return new OpVmll_u8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_u16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_u16qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_u16qd(CodeType code, uint32_t addr)
{
	return new OpVmll_u16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_u32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_u32qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_u32qd(CodeType code, uint32_t addr)
{
	return new OpVmll_u32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlal_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmlal.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlal_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVmlal_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlal_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmlal.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlal_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVmlal_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlal_u16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmlal.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlal_u16qdp(CodeType code, uint32_t addr)
{
	return new OpVmlal_u16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlal_u32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmlal.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlal_u32qdp(CodeType code, uint32_t addr)
{
	return new OpVmlal_u32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmls.f16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f16dp(CodeType code, uint32_t addr)
{
	return new OpVmls_f16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmls.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f32v(CodeType code, uint32_t addr)
{
	return new OpVmls_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmls.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f32dp(CodeType code, uint32_t addr)
{
	return new OpVmls_f32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_i16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmls.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_i16dp(CodeType code, uint32_t addr)
{
	return new OpVmls_i16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_i32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmls.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_i32dp(CodeType code, uint32_t addr)
{
	return new OpVmls_i32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlsl_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmlsl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlsl_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVmlsl_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlsl_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmlsl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlsl_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVmlsl_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlsl_u16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmlsl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlsl_u16qdp(CodeType code, uint32_t addr)
{
	return new OpVmlsl_u16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlsl_u32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmlsl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlsl_u32qdp(CodeType code, uint32_t addr)
{
	return new OpVmlsl_u32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov.f32\t" << DisasmV(vd>>q, 3+q) << ", #" << std::setprecision(10) << fpimm;
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f32vi(CodeType code, uint32_t addr)
{
	return new OpVmov_f32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmov_i8i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i8i(CodeType code, uint32_t addr)
{
	return new OpVmov_i8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmov_i16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i16i(CodeType code, uint32_t addr)
{
	return new OpVmov_i16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmov_i32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i32i(CodeType code, uint32_t addr)
{
	return new OpVmov_i32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov.i64\t" << DisasmV(vd>>q, 3+q) << ", #0x" << std::hex << std::setfill('0') << std::setw(16) << imm;
}}
template <	typename	ARCH>
void OpVmov_i64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 OP;
		unsigned const elements = 1;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i64i(CodeType code, uint32_t addr)
{
	return new OpVmov_i64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i32in<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmov.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmov_i32in<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i32in(CodeType code, uint32_t addr)
{
	return new OpVmov_i32in<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmovl.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		typedef typename ARCH::S16 S16;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, S16( cpu.GetVDE( vm, subs*q+idx, S8() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_s8(CodeType code, uint32_t addr)
{
	return new OpVmovl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmovl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::S32 S32;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, S32( cpu.GetVDE( vm, subs*q+idx, S16() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_s16(CodeType code, uint32_t addr)
{
	return new OpVmovl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmovl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S64 S64;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, S64( cpu.GetVDE( vm, subs*q+idx, S32() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_s32(CodeType code, uint32_t addr)
{
	return new OpVmovl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmovl.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U16 U16;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, U16( cpu.GetVDE( vm, subs*q+idx, U8() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_u8(CodeType code, uint32_t addr)
{
	return new OpVmovl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmovl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, U32( cpu.GetVDE( vm, subs*q+idx, U16() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_u16(CodeType code, uint32_t addr)
{
	return new OpVmovl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmovl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, U64( cpu.GetVDE( vm, subs*q+idx, U32() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_u32(CodeType code, uint32_t addr)
{
	return new OpVmovl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovn_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmovn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}
template <	typename	ARCH>
void OpVmovn_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 UN;
		typedef typename ARCH::U16 UL;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		UN res[2][subs];
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = UN(cpu.GetVDE( vm+q, idx, UL() ));

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd, subs*q+idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovn_i16(CodeType code, uint32_t addr)
{
	return new OpVmovn_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovn_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmovn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}
template <	typename	ARCH>
void OpVmovn_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 UN;
		typedef typename ARCH::U32 UL;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		UN res[2][subs];
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = UN(cpu.GetVDE( vm+q, idx, UL() ));

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd, subs*q+idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovn_i32(CodeType code, uint32_t addr)
{
	return new OpVmovn_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovn_i64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmovn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}
template <	typename	ARCH>
void OpVmovn_i64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 UN;
		typedef typename ARCH::U64 UL;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		UN res[2][subs];
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = UN(cpu.GetVDE( vm+q, idx, UL() ));

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd, subs*q+idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovn_i64(CodeType code, uint32_t addr)
{
	return new OpVmovn_i64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_f32v(CodeType code, uint32_t addr)
{
	return new OpVmul_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_f32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_f32dp(CodeType code, uint32_t addr)
{
	return new OpVmul_f32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmul_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i8(CodeType code, uint32_t addr)
{
	return new OpVmul_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmul_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i16(CodeType code, uint32_t addr)
{
	return new OpVmul_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmul_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i32(CodeType code, uint32_t addr)
{
	return new OpVmul_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i16dp(CodeType code, uint32_t addr)
{
	return new OpVmul_i16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i32dp(CodeType code, uint32_t addr)
{
	return new OpVmul_i32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_p8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.p8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_p8(CodeType code, uint32_t addr)
{
	return new OpVmul_p8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_p16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.p16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_p16(CodeType code, uint32_t addr)
{
	return new OpVmul_p16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_p32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmul.p32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_p32(CodeType code, uint32_t addr)
{
	return new OpVmul_p32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_p8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.p8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_p8qd(CodeType code, uint32_t addr)
{
	return new OpVmull_p8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		typedef typename ARCH::S16 S16;
		unsigned const subs = 4;

		S16 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = S16( cpu.GetVDE( vn, subs*q+idx, S8() ) ) * S16( cpu.GetVDE( vm, subs*q+idx, S8() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s8(CodeType code, uint32_t addr)
{
	return new OpVmull_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::S32 S32;
		unsigned const subs = 2;

		S32 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = S32( cpu.GetVDE( vn, subs*q+idx, S16() ) ) * S32( cpu.GetVDE( vm, subs*q+idx, S16() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s16(CodeType code, uint32_t addr)
{
	return new OpVmull_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S64 S64;
		unsigned const subs = 1;

		S64 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = S64( cpu.GetVDE( vn, subs*q+idx, S32() ) ) * S64( cpu.GetVDE( vm, subs*q+idx, S32() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s32(CodeType code, uint32_t addr)
{
	return new OpVmull_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U16 U16;
		unsigned const subs = 4;

		U16 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = U16( cpu.GetVDE( vn, subs*q+idx, U8() ) ) * U16( cpu.GetVDE( vm, subs*q+idx, U8() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u8(CodeType code, uint32_t addr)
{
	return new OpVmull_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		unsigned const subs = 2;

		U32 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = U32( cpu.GetVDE( vn, subs*q+idx, U16() ) ) * U32( cpu.GetVDE( vm, subs*q+idx, U16() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u16(CodeType code, uint32_t addr)
{
	return new OpVmull_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;
		unsigned const subs = 1;

		U64 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = U64( cpu.GetVDE( vn, subs*q+idx, U32() ) ) * U64( cpu.GetVDE( vm, subs*q+idx, U32() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u32(CodeType code, uint32_t addr)
{
	return new OpVmull_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVmull_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVmull_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u16qdp(CodeType code, uint32_t addr)
{
	return new OpVmull_u16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmull.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u32qdp(CodeType code, uint32_t addr)
{
	return new OpVmull_u32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmvn_i16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmvn.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmvn_i16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(~imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmvn_i16i(CodeType code, uint32_t addr)
{
	return new OpVmvn_i16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmvn_i32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmvn.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmvn_i32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(~imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmvn_i32i(CodeType code, uint32_t addr)
{
	return new OpVmvn_i32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmvn_i32in<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmvn.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmvn_i32in<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(~imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmvn_i32in(CodeType code, uint32_t addr)
{
	return new OpVmvn_i32in<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmvn<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vmvn\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmvn(CodeType code, uint32_t addr)
{
	return new OpVmvn<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vneg.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f8(CodeType code, uint32_t addr)
{
	return new OpVneg_f8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vneg.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f16(CodeType code, uint32_t addr)
{
	return new OpVneg_f16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vneg.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f32v(CodeType code, uint32_t addr)
{
	return new OpVneg_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vneg.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVneg_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(-cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_s8(CodeType code, uint32_t addr)
{
	return new OpVneg_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vneg.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVneg_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(-cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_s16(CodeType code, uint32_t addr)
{
	return new OpVneg_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vneg.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVneg_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(-cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_s32(CodeType code, uint32_t addr)
{
	return new OpVneg_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVorn<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vorn\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVorn<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) | ~cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVorn(CodeType code, uint32_t addr)
{
	return new OpVorn<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVorr<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vorr\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVorr<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) | cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVorr(CodeType code, uint32_t addr)
{
	return new OpVorr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVorr_i16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vorr.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVorr_i16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vd+dd, idx, OP() ) | OP(imm)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVorr_i16i(CodeType code, uint32_t addr)
{
	return new OpVorr_i16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVorr_i32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vorr.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVorr_i32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vd+dd, idx, OP() ) | OP(imm)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVorr_i32i(CodeType code, uint32_t addr)
{
	return new OpVorr_i32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadal.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_s8(CodeType code, uint32_t addr)
{
	return new OpVpadal_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadal.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_s16(CodeType code, uint32_t addr)
{
	return new OpVpadal_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadal.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_s32(CodeType code, uint32_t addr)
{
	return new OpVpadal_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadal.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_u8(CodeType code, uint32_t addr)
{
	return new OpVpadal_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadal.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_u16(CodeType code, uint32_t addr)
{
	return new OpVpadal_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadal.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_u32(CodeType code, uint32_t addr)
{
	return new OpVpadal_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadd_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadd.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadd_f32(CodeType code, uint32_t addr)
{
	return new OpVpadd_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadd_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadd.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVpadd_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8;

		U8 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0, end = elements/2; idx < end; ++idx)
		{
			res[dd][idx+  0] = cpu.GetVDE( vn+dd, 2*idx+0, U8() ) + cpu.GetVDE( vn+dd, 2*idx+1, U8() );
			res[dd][idx+end] = cpu.GetVDE( vm+dd, 2*idx+0, U8() ) + cpu.GetVDE( vm+dd, 2*idx+1, U8() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadd_i8(CodeType code, uint32_t addr)
{
	return new OpVpadd_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadd_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadd.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVpadd_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4;

		U16 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0, end = elements/2; idx < end; ++idx)
		{
			res[dd][idx+  0] = cpu.GetVDE( vn+dd, 2*idx+0, U16() ) + cpu.GetVDE( vn+dd, 2*idx+1, U16() );
			res[dd][idx+end] = cpu.GetVDE( vm+dd, 2*idx+0, U16() ) + cpu.GetVDE( vm+dd, 2*idx+1, U16() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadd_i16(CodeType code, uint32_t addr)
{
	return new OpVpadd_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadd_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpadd.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVpadd_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2;

		U32 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0, end = elements/2; idx < end; ++idx)
		{
			res[dd][idx+  0] = cpu.GetVDE( vn+dd, 2*idx+0, U32() ) + cpu.GetVDE( vn+dd, 2*idx+1, U32() );
			res[dd][idx+end] = cpu.GetVDE( vm+dd, 2*idx+0, U32() ) + cpu.GetVDE( vm+dd, 2*idx+1, U32() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadd_i32(CodeType code, uint32_t addr)
{
	return new OpVpadd_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpaddl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_s8(CodeType code, uint32_t addr)
{
	return new OpVpaddl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpaddl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_s16(CodeType code, uint32_t addr)
{
	return new OpVpaddl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpaddl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_s32(CodeType code, uint32_t addr)
{
	return new OpVpaddl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpaddl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_u8(CodeType code, uint32_t addr)
{
	return new OpVpaddl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpaddl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_u16(CodeType code, uint32_t addr)
{
	return new OpVpaddl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpaddl.u32\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVpaddl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDU( vd+dd, U64(cpu.GetVDE( vm+dd, 0, U32() )) + U64(cpu.GetVDE( vm+dd, 1, U32() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_u32(CodeType code, uint32_t addr)
{
	return new OpVpaddl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmax.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_f32(CodeType code, uint32_t addr)
{
	return new OpVpmax_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmax.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_s8(CodeType code, uint32_t addr)
{
	return new OpVpmax_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmax.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_s16(CodeType code, uint32_t addr)
{
	return new OpVpmax_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmax.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_s32(CodeType code, uint32_t addr)
{
	return new OpVpmax_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmax.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_u8(CodeType code, uint32_t addr)
{
	return new OpVpmax_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmax.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_u16(CodeType code, uint32_t addr)
{
	return new OpVpmax_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmax.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_u32(CodeType code, uint32_t addr)
{
	return new OpVpmax_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmin.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_f32(CodeType code, uint32_t addr)
{
	return new OpVpmin_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmin.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_s8(CodeType code, uint32_t addr)
{
	return new OpVpmin_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmin.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_s16(CodeType code, uint32_t addr)
{
	return new OpVpmin_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmin.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_s32(CodeType code, uint32_t addr)
{
	return new OpVpmin_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmin.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_u8(CodeType code, uint32_t addr)
{
	return new OpVpmin_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmin.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_u16(CodeType code, uint32_t addr)
{
	return new OpVpmin_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vpmin.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_u32(CodeType code, uint32_t addr)
{
	return new OpVpmin_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqabs_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqabs.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqabs_s8(CodeType code, uint32_t addr)
{
	return new OpVqabs_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqabs_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqabs.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqabs_s16(CodeType code, uint32_t addr)
{
	return new OpVqabs_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqabs_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqabs.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqabs_s32(CodeType code, uint32_t addr)
{
	return new OpVqabs_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqadd.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_s8(CodeType code, uint32_t addr)
{
	return new OpVqadd_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqadd.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_s16(CodeType code, uint32_t addr)
{
	return new OpVqadd_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqadd.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_s32(CodeType code, uint32_t addr)
{
	return new OpVqadd_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqadd.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_s64(CodeType code, uint32_t addr)
{
	return new OpVqadd_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqadd.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_u8(CodeType code, uint32_t addr)
{
	return new OpVqadd_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqadd.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_u16(CodeType code, uint32_t addr)
{
	return new OpVqadd_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqadd.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_u32(CodeType code, uint32_t addr)
{
	return new OpVqadd_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqadd.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_u64(CodeType code, uint32_t addr)
{
	return new OpVqadd_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlal_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmlal.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlal_s16qd(CodeType code, uint32_t addr)
{
	return new OpVqdmlal_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlal_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmlal.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlal_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmlal_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlal_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmlal.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlal_s32qd(CodeType code, uint32_t addr)
{
	return new OpVqdmlal_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlal_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmlal.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlal_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmlal_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlsl_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmlsl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlsl_s16qd(CodeType code, uint32_t addr)
{
	return new OpVqdmlsl_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlsl_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmlsl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlsl_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmlsl_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlsl_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmlsl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlsl_s32qd(CodeType code, uint32_t addr)
{
	return new OpVqdmlsl_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlsl_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmlsl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlsl_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmlsl_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmulh_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmulh.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmulh_s16(CodeType code, uint32_t addr)
{
	return new OpVqdmulh_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmulh_s16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmulh.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmulh_s16dp(CodeType code, uint32_t addr)
{
	return new OpVqdmulh_s16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmulh_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmulh.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmulh_s32(CodeType code, uint32_t addr)
{
	return new OpVqdmulh_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmulh_s32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmulh.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmulh_s32dp(CodeType code, uint32_t addr)
{
	return new OpVqdmulh_s32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmull_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmull.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmull_s16qd(CodeType code, uint32_t addr)
{
	return new OpVqdmull_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmull_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmull.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmull_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmull_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmull_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmull.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmull_s32qd(CodeType code, uint32_t addr)
{
	return new OpVqdmull_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmull_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqdmull.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmull_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmull_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqmovn.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_s16(CodeType code, uint32_t addr)
{
	return new OpVqmovn_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqmovn.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_s32(CodeType code, uint32_t addr)
{
	return new OpVqmovn_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqmovn.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_s64(CodeType code, uint32_t addr)
{
	return new OpVqmovn_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqmovn.u16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_u16(CodeType code, uint32_t addr)
{
	return new OpVqmovn_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqmovn.u32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_u32(CodeType code, uint32_t addr)
{
	return new OpVqmovn_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqmovn.u64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_u64(CodeType code, uint32_t addr)
{
	return new OpVqmovn_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovun_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqmovun.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovun_s16(CodeType code, uint32_t addr)
{
	return new OpVqmovun_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovun_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqmovun.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovun_s32(CodeType code, uint32_t addr)
{
	return new OpVqmovun_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovun_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqmovun.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovun_s64(CodeType code, uint32_t addr)
{
	return new OpVqmovun_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqneg_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqneg.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqneg_s8(CodeType code, uint32_t addr)
{
	return new OpVqneg_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqneg_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqneg.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqneg_s16(CodeType code, uint32_t addr)
{
	return new OpVqneg_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqneg_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqneg.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqneg_s32(CodeType code, uint32_t addr)
{
	return new OpVqneg_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrdmulh_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrdmulh.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrdmulh_s16(CodeType code, uint32_t addr)
{
	return new OpVqrdmulh_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrdmulh_s16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrdmulh.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrdmulh_s16dp(CodeType code, uint32_t addr)
{
	return new OpVqrdmulh_s16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrdmulh_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrdmulh.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrdmulh_s32(CodeType code, uint32_t addr)
{
	return new OpVqrdmulh_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrdmulh_s32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrdmulh.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrdmulh_s32dp(CodeType code, uint32_t addr)
{
	return new OpVqrdmulh_s32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_s8(CodeType code, uint32_t addr)
{
	return new OpVqrshl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_s16(CodeType code, uint32_t addr)
{
	return new OpVqrshl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_s32(CodeType code, uint32_t addr)
{
	return new OpVqrshl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_s64(CodeType code, uint32_t addr)
{
	return new OpVqrshl_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_u8(CodeType code, uint32_t addr)
{
	return new OpVqrshl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_u16(CodeType code, uint32_t addr)
{
	return new OpVqrshl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_u32(CodeType code, uint32_t addr)
{
	return new OpVqrshl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_u64(CodeType code, uint32_t addr)
{
	return new OpVqrshl_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_s16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshrn.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_s16dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_s16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_s32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshrn.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_s32dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_s32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_s64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshrn.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_s64dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_s64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_u16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshrn.u16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_u16dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_u16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_u32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshrn.u32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_u32dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_u32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_u64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshrn.u64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_u64dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_u64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrun_s16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshrun.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrun_s16dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrun_s16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrun_s32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshrun.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrun_s32dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrun_s32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrun_s64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqrshrun.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrun_s64dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrun_s64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s8(CodeType code, uint32_t addr)
{
	return new OpVqshl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s8i(CodeType code, uint32_t addr)
{
	return new OpVqshl_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s16(CodeType code, uint32_t addr)
{
	return new OpVqshl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s16i(CodeType code, uint32_t addr)
{
	return new OpVqshl_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s32(CodeType code, uint32_t addr)
{
	return new OpVqshl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s32i(CodeType code, uint32_t addr)
{
	return new OpVqshl_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s64(CodeType code, uint32_t addr)
{
	return new OpVqshl_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s64i(CodeType code, uint32_t addr)
{
	return new OpVqshl_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u8(CodeType code, uint32_t addr)
{
	return new OpVqshl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u8i(CodeType code, uint32_t addr)
{
	return new OpVqshl_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u16(CodeType code, uint32_t addr)
{
	return new OpVqshl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u16i(CodeType code, uint32_t addr)
{
	return new OpVqshl_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u32(CodeType code, uint32_t addr)
{
	return new OpVqshl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u32i(CodeType code, uint32_t addr)
{
	return new OpVqshl_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u64(CodeType code, uint32_t addr)
{
	return new OpVqshl_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u64i(CodeType code, uint32_t addr)
{
	return new OpVqshl_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshlu_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshlu.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshlu_s8i(CodeType code, uint32_t addr)
{
	return new OpVqshlu_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshlu_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshlu.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshlu_s16i(CodeType code, uint32_t addr)
{
	return new OpVqshlu_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshlu_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshlu.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshlu_s32i(CodeType code, uint32_t addr)
{
	return new OpVqshlu_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshlu_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshlu.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshlu_s64i(CodeType code, uint32_t addr)
{
	return new OpVqshlu_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_s16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshrn.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_s16dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_s16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_s32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshrn.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_s32dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_s32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_s64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshrn.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_s64dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_s64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_u16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshrn.u16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_u16dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_u16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_u32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshrn.u32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_u32dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_u32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_u64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshrn.u64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_u64dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_u64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrun_s16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshrun.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrun_s16dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrun_s16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrun_s32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshrun.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrun_s32dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrun_s32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrun_s64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqshrun.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrun_s64dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrun_s64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqsub.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_s8(CodeType code, uint32_t addr)
{
	return new OpVqsub_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqsub.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_s16(CodeType code, uint32_t addr)
{
	return new OpVqsub_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqsub.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_s32(CodeType code, uint32_t addr)
{
	return new OpVqsub_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqsub.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_s64(CodeType code, uint32_t addr)
{
	return new OpVqsub_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqsub.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_u8(CodeType code, uint32_t addr)
{
	return new OpVqsub_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqsub.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_u16(CodeType code, uint32_t addr)
{
	return new OpVqsub_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqsub.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_u32(CodeType code, uint32_t addr)
{
	return new OpVqsub_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vqsub.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_u64(CodeType code, uint32_t addr)
{
	return new OpVqsub_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVraddhn_i16dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vraddhn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVraddhn_i16dq(CodeType code, uint32_t addr)
{
	return new OpVraddhn_i16dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVraddhn_i32dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vraddhn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVraddhn_i32dq(CodeType code, uint32_t addr)
{
	return new OpVraddhn_i32dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVraddhn_i64dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vraddhn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVraddhn_i64dq(CodeType code, uint32_t addr)
{
	return new OpVraddhn_i64dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrecpe_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrecpe.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrecpe_f32(CodeType code, uint32_t addr)
{
	return new OpVrecpe_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrecpe_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrecpe.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrecpe_u32(CodeType code, uint32_t addr)
{
	return new OpVrecpe_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrecps_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrecps.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrecps_f32(CodeType code, uint32_t addr)
{
	return new OpVrecps_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrev_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrev" << (64 >> op) << ".8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVrev_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, reverse_mask = (elements-1) >> op;

		U8 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		res[dd][idx] = cpu.GetVDE( vm+dd, idx ^ reverse_mask, U8() );

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrev_8(CodeType code, uint32_t addr)
{
	return new OpVrev_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrev_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrev" << (64 >> op) << ".16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVrev_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, reverse_mask = (elements-1) >> op;

		U16 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		res[dd][idx] = cpu.GetVDE( vm+dd, idx ^ reverse_mask, U16() );

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrev_16(CodeType code, uint32_t addr)
{
	return new OpVrev_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrev_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrev" << (64 >> op) << ".32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVrev_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, reverse_mask = (elements-1) >> op;

		U32 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		res[dd][idx] = cpu.GetVDE( vm+dd, idx ^ reverse_mask, U32() );

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrev_32(CodeType code, uint32_t addr)
{
	return new OpVrev_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrhadd.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_s8(CodeType code, uint32_t addr)
{
	return new OpVrhadd_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrhadd.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_s16(CodeType code, uint32_t addr)
{
	return new OpVrhadd_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrhadd.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_s32(CodeType code, uint32_t addr)
{
	return new OpVrhadd_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrhadd.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_u8(CodeType code, uint32_t addr)
{
	return new OpVrhadd_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrhadd.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_u16(CodeType code, uint32_t addr)
{
	return new OpVrhadd_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrhadd.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_u32(CodeType code, uint32_t addr)
{
	return new OpVrhadd_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_s8(CodeType code, uint32_t addr)
{
	return new OpVrshl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_s16(CodeType code, uint32_t addr)
{
	return new OpVrshl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_s32(CodeType code, uint32_t addr)
{
	return new OpVrshl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_s64(CodeType code, uint32_t addr)
{
	return new OpVrshl_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_u8(CodeType code, uint32_t addr)
{
	return new OpVrshl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_u16(CodeType code, uint32_t addr)
{
	return new OpVrshl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_u32(CodeType code, uint32_t addr)
{
	return new OpVrshl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_u64(CodeType code, uint32_t addr)
{
	return new OpVrshl_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshr.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_s8i(CodeType code, uint32_t addr)
{
	return new OpVrshr_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshr.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_s16i(CodeType code, uint32_t addr)
{
	return new OpVrshr_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshr.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_s32i(CodeType code, uint32_t addr)
{
	return new OpVrshr_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshr.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_s64i(CodeType code, uint32_t addr)
{
	return new OpVrshr_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshr.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_u8i(CodeType code, uint32_t addr)
{
	return new OpVrshr_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshr.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_u16i(CodeType code, uint32_t addr)
{
	return new OpVrshr_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshr.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_u32i(CodeType code, uint32_t addr)
{
	return new OpVrshr_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshr.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_u64i(CodeType code, uint32_t addr)
{
	return new OpVrshr_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshrn_i16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshrn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshrn_i16dqi(CodeType code, uint32_t addr)
{
	return new OpVrshrn_i16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshrn_i32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshrn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshrn_i32dqi(CodeType code, uint32_t addr)
{
	return new OpVrshrn_i32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshrn_i64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrshrn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshrn_i64dqi(CodeType code, uint32_t addr)
{
	return new OpVrshrn_i64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsqrte_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsqrte.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsqrte_f32(CodeType code, uint32_t addr)
{
	return new OpVrsqrte_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsqrte_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsqrte.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsqrte_u32(CodeType code, uint32_t addr)
{
	return new OpVrsqrte_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsqrts_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsqrts.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsqrts_f32(CodeType code, uint32_t addr)
{
	return new OpVrsqrts_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsra.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_s8i(CodeType code, uint32_t addr)
{
	return new OpVrsra_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsra.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_s16i(CodeType code, uint32_t addr)
{
	return new OpVrsra_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsra.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_s32i(CodeType code, uint32_t addr)
{
	return new OpVrsra_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsra.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_s64i(CodeType code, uint32_t addr)
{
	return new OpVrsra_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsra.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_u8i(CodeType code, uint32_t addr)
{
	return new OpVrsra_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsra.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_u16i(CodeType code, uint32_t addr)
{
	return new OpVrsra_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsra.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_u32i(CodeType code, uint32_t addr)
{
	return new OpVrsra_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsra.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_u64i(CodeType code, uint32_t addr)
{
	return new OpVrsra_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsubhn_i16dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsubhn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsubhn_i16dq(CodeType code, uint32_t addr)
{
	return new OpVrsubhn_i16dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsubhn_i32dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsubhn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsubhn_i32dq(CodeType code, uint32_t addr)
{
	return new OpVrsubhn_i32dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsubhn_i64dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vrsubhn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsubhn_i64dq(CodeType code, uint32_t addr)
{
	return new OpVrsubhn_i64dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshl_s8i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 8; ++idx)
		cpu.SetVDE( vd+dd, idx, U8(cpu.GetVDE( vm+dd, idx, U8() ) << imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s8i(CodeType code, uint32_t addr)
{
	return new OpVshl_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshl_s16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 4; ++idx)
		cpu.SetVDE( vd+dd, idx, U16(cpu.GetVDE( vm+dd, idx, U16() ) << imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s16i(CodeType code, uint32_t addr)
{
	return new OpVshl_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshl_s32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 2; ++idx)
		cpu.SetVDE( vd+dd, idx, U32(cpu.GetVDE( vm+dd, idx, U32() ) << imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s32i(CodeType code, uint32_t addr)
{
	return new OpVshl_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshl_s64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 1; ++idx)
		cpu.SetVDE( vd+dd, idx, U64(cpu.GetVDE( vm+dd, idx, U64() ) << imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s64i(CodeType code, uint32_t addr)
{
	return new OpVshl_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s8(CodeType code, uint32_t addr)
{
	return new OpVshl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s16(CodeType code, uint32_t addr)
{
	return new OpVshl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s32(CodeType code, uint32_t addr)
{
	return new OpVshl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_s64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 OP;
		unsigned const elements = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s64(CodeType code, uint32_t addr)
{
	return new OpVshl_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_u8(CodeType code, uint32_t addr)
{
	return new OpVshl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_u16(CodeType code, uint32_t addr)
{
	return new OpVshl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_u32(CodeType code, uint32_t addr)
{
	return new OpVshl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_u64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 OP;
		unsigned const elements = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_u64(CodeType code, uint32_t addr)
{
	return new OpVshl_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshll.i8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", #8";
}}
template <	typename	ARCH>
void OpVshll_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << 8 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_i8(CodeType code, uint32_t addr)
{
	return new OpVshll_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshll.i16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", #16";
}}
template <	typename	ARCH>
void OpVshll_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << 16 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_i16(CodeType code, uint32_t addr)
{
	return new OpVshll_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshll.i32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", #32";
}}
template <	typename	ARCH>
void OpVshll_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << 32 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_i32(CodeType code, uint32_t addr)
{
	return new OpVshll_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshr.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_s8i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		unsigned const shift = imm > 7 ? 7 : imm;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 8; ++idx)
		cpu.SetVDE( vd+dd, idx, S8(cpu.GetVDE( vm+dd, idx, S8() ) >> shift) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_s8i(CodeType code, uint32_t addr)
{
	return new OpVshr_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshr.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_s16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		unsigned const shift = imm > 15 ? 15 : imm;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 4; ++idx)
		cpu.SetVDE( vd+dd, idx, S16(cpu.GetVDE( vm+dd, idx, S16() ) >> shift) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_s16i(CodeType code, uint32_t addr)
{
	return new OpVshr_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshr.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_s32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 S32;
		unsigned const shift = imm > 31 ? 31 : imm;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 2; ++idx)
		cpu.SetVDE( vd+dd, idx, S32(cpu.GetVDE( vm+dd, idx, S32() ) >> shift) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_s32i(CodeType code, uint32_t addr)
{
	return new OpVshr_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshr.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_s64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		unsigned const shift = imm > 63 ? 63 : imm;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 1; ++idx)
		cpu.SetVDE( vd+dd, idx, S64(cpu.GetVDE( vm+dd, idx, S64() ) >> shift) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_s64i(CodeType code, uint32_t addr)
{
	return new OpVshr_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshr.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_u8i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		U8 mask(~(uint8_t(-1) << imm_));

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 8; ++idx)
		cpu.SetVDE( vd+dd, idx, U8(cpu.GetVDE( vm+dd, idx, U8() ) >> imm & mask) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_u8i(CodeType code, uint32_t addr)
{
	return new OpVshr_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshr.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_u16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		U16 mask(~(uint16_t(-1) << imm_));

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 4; ++idx)
		cpu.SetVDE( vd+dd, idx, U16(cpu.GetVDE( vm+dd, idx, U16() ) >> imm & mask) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_u16i(CodeType code, uint32_t addr)
{
	return new OpVshr_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshr.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_u32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 mask(~(uint32_t(-1) << imm_));

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 2; ++idx)
		cpu.SetVDE( vd+dd, idx, U32(cpu.GetVDE( vm+dd, idx, U32() ) >> imm & mask) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_u32i(CodeType code, uint32_t addr)
{
	return new OpVshr_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshr.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_u64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;
		U64 mask(~(uint64_t(-1) << imm_));

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 1; ++idx)
		cpu.SetVDE( vd+dd, idx, U64(cpu.GetVDE( vm+dd, idx, U64() ) >> imm & mask) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_u64i(CodeType code, uint32_t addr)
{
	return new OpVshr_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshrn_i16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshrn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshrn_i16dqi(CodeType code, uint32_t addr)
{
	return new OpVshrn_i16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshrn_i32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshrn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshrn_i32dqi(CodeType code, uint32_t addr)
{
	return new OpVshrn_i32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshrn_i64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vshrn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshrn_i64dqi(CodeType code, uint32_t addr)
{
	return new OpVshrn_i64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsli_8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsli.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsli_8i(CodeType code, uint32_t addr)
{
	return new OpVsli_8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsli_16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsli.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsli_16i(CodeType code, uint32_t addr)
{
	return new OpVsli_16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsli_32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsli.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsli_32i(CodeType code, uint32_t addr)
{
	return new OpVsli_32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsli_64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsli.64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsli_64i(CodeType code, uint32_t addr)
{
	return new OpVsli_64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsra.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_s8i(CodeType code, uint32_t addr)
{
	return new OpVsra_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsra.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_s16i(CodeType code, uint32_t addr)
{
	return new OpVsra_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsra.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_s32i(CodeType code, uint32_t addr)
{
	return new OpVsra_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsra.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_s64i(CodeType code, uint32_t addr)
{
	return new OpVsra_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsra.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_u8i(CodeType code, uint32_t addr)
{
	return new OpVsra_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsra.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_u16i(CodeType code, uint32_t addr)
{
	return new OpVsra_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsra.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_u32i(CodeType code, uint32_t addr)
{
	return new OpVsra_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsra.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_u64i(CodeType code, uint32_t addr)
{
	return new OpVsra_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsri_8i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsri.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsri_8i(CodeType code, uint32_t addr)
{
	return new OpVsri_8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsri_16i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsri.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsri_16i(CodeType code, uint32_t addr)
{
	return new OpVsri_16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsri_32i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsri.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsri_32i(CodeType code, uint32_t addr)
{
	return new OpVsri_32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsri_64i<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsri.64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsri_64i(CodeType code, uint32_t addr)
{
	return new OpVsri_64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << (vms.ses ? 1 : int(vms.regs)) << ".8\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite8(addr + U32(size*idx), cpu.GetVDE((vd+idx/elements)%32, idx%elements, U8()));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite8(addr + U32(size*idx), cpu.GetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U8()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms_8(CodeType code, uint32_t addr)
{
	return new OpVstms_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << (vms.ses ? 1 : int(vms.regs)) << ".16\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite16(addr + U32(size*idx), cpu.GetVDE((vd+idx/elements)%32, idx%elements, U16()));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite16(addr + U32(size*idx), cpu.GetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U16()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms_16(CodeType code, uint32_t addr)
{
	return new OpVstms_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << (vms.ses ? 1 : int(vms.regs)) << ".32\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite32(addr + U32(size*idx), cpu.GetVDE((vd+idx/elements)%32, idx%elements, U32()));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite32(addr + U32(size*idx), cpu.GetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U32()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms_32(CodeType code, uint32_t addr)
{
	return new OpVstms_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms_64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << (vms.ses ? 1 : int(vms.regs)) << ".64\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms_64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;
		unsigned const size = 8;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		U32 endianness = cpu.CPSR().Get(E) * U32(4);

		for (unsigned idx = 0, end = vms.regs; idx < end; ++idx)
		{
			U64 data = cpu.GetVDE((vd+idx)%32, 0, U64());
			for (unsigned part = 0; part < 2; ++part)
			cpu.MemWrite32(addr + (U32(size*idx + 4*part) ^ endianness), U32(data >> 32*part));
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms_64(CodeType code, uint32_t addr)
{
	return new OpVstms_64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms2s_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << int(regs) << ".8\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms2s_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.MemWrite8(addr + U32(size*idx), cpu.GetVDE((vd+2*(idx%regs))%32, idx/regs, U8()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms2s_8(CodeType code, uint32_t addr)
{
	return new OpVstms2s_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms2s_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << int(regs) << ".16\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms2s_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.MemWrite16(addr + U32(size*idx), cpu.GetVDE((vd+2*(idx%regs))%32, idx/regs, U16()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms2s_16(CodeType code, uint32_t addr)
{
	return new OpVstms2s_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms2s_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << int(regs) << ".32\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms2s_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.MemWrite32(addr + U32(size*idx), cpu.GetVDE((vd+2*(idx%regs))%32, idx/regs, U32()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms2s_32(CodeType code, uint32_t addr)
{
	return new OpVstms2s_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVst2_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst2.8\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVst2_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.MemWrite8(addr, cpu.GetVDE(vd+q+2*reg, idx, U8()));
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVst2_8(CodeType code, uint32_t addr)
{
	return new OpVst2_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVst2_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst2.16\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVst2_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.MemWrite16(addr, cpu.GetVDE(vd+q+2*reg, idx, U16()));
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVst2_16(CodeType code, uint32_t addr)
{
	return new OpVst2_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVst2_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst2.32\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVst2_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.MemWrite32(addr, cpu.GetVDE(vd+q+2*reg, idx, U32()));
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVst2_32(CodeType code, uint32_t addr)
{
	return new OpVst2_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstsl_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << int(regs+1) << ".8\t" << DisasmBunch(vd, regs+1).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstsl_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32((regs+1)*size) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0; idx <= regs; ++idx)
		cpu.MemWrite8(addr + U32(size*idx), cpu.GetVDE((vd+idx)%32, part, U8()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstsl_8(CodeType code, uint32_t addr)
{
	return new OpVstsl_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstsl_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << int(regs+1) << ".16\t" << DisasmBunch(vd, regs+1).dspc(ds).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstsl_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32((regs+1)*size) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0; idx <= regs; ++idx)
		cpu.MemWrite16(addr + U32(size*idx), cpu.GetVDE((vd+(idx<<ds))%32, part, U16()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstsl_16(CodeType code, uint32_t addr)
{
	return new OpVstsl_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstsl_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vst" << int(regs+1) << ".32\t" << DisasmBunch(vd, regs+1).dspc(ds).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstsl_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32((regs+1)*size) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0; idx <= regs; ++idx)
		cpu.MemWrite32(addr + U32(size*idx), cpu.GetVDE((vd+(idx<<ds))%32, part, U32()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstsl_32(CodeType code, uint32_t addr)
{
	return new OpVstsl_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsub.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_f32v(CodeType code, uint32_t addr)
{
	return new OpVsub_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsub.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVsub_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) - cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_i8(CodeType code, uint32_t addr)
{
	return new OpVsub_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsub.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVsub_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) - cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_i16(CodeType code, uint32_t addr)
{
	return new OpVsub_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsub.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVsub_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) - cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_i32(CodeType code, uint32_t addr)
{
	return new OpVsub_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_i64<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsub.i64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVsub_i64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 OP;
		unsigned const elements = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) - cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_i64(CodeType code, uint32_t addr)
{
	return new OpVsub_i64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubhn_i16dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubhn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubhn_i16dq(CodeType code, uint32_t addr)
{
	return new OpVsubhn_i16dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubhn_i32dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubhn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubhn_i32dq(CodeType code, uint32_t addr)
{
	return new OpVsubhn_i32dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubhn_i64dq<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubhn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubhn_i64dq(CodeType code, uint32_t addr)
{
	return new OpVsubhn_i64dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubl.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_s8(CodeType code, uint32_t addr)
{
	return new OpVsubl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_s16(CodeType code, uint32_t addr)
{
	return new OpVsubl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_s32(CodeType code, uint32_t addr)
{
	return new OpVsubl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubl.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_u8(CodeType code, uint32_t addr)
{
	return new OpVsubl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_u16(CodeType code, uint32_t addr)
{
	return new OpVsubl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_u32(CodeType code, uint32_t addr)
{
	return new OpVsubl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubw.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_s8(CodeType code, uint32_t addr)
{
	return new OpVsubw_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubw.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_s16(CodeType code, uint32_t addr)
{
	return new OpVsubw_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubw.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_s32(CodeType code, uint32_t addr)
{
	return new OpVsubw_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubw.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_u8(CodeType code, uint32_t addr)
{
	return new OpVsubw_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubw.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_u16(CodeType code, uint32_t addr)
{
	return new OpVsubw_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vsubw.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_u32(CodeType code, uint32_t addr)
{
	return new OpVsubw_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVswp<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vswp\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVswp(CodeType code, uint32_t addr)
{
	return new OpVswp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtbl_8d<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vtbl.8\t" << DisasmV(vd, 3) << ", {" << DisasmBunch(vn, regs+1) << "}, " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVtbl_8d<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		for (unsigned e=0; e < 8; e += 1)
		cpu.SetVDE(vd, e, cpu.GetTVU8(vn, 8, regs+1, cpu.GetVDE(vm, e, U8()), U8(0)));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtbl_8d(CodeType code, uint32_t addr)
{
	return new OpVtbl_8d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtbx_8d<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vtbx.8\t" << DisasmV(vd, 3) << ", {" << DisasmBunch(vn, regs+1) << "}, " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVtbx_8d<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		for (unsigned e=0; e < 8; e += 1)
		cpu.SetVDE(vd, e, cpu.GetTVU8(vn, 8, regs+1, cpu.GetVDE(vm, e, U8()), cpu.GetVDE(vd, e, U8())));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtbx_8d(CodeType code, uint32_t addr)
{
	return new OpVtbx_8d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtrn_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vtrn.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtrn_8(CodeType code, uint32_t addr)
{
	return new OpVtrn_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtrn_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vtrn.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtrn_16(CodeType code, uint32_t addr)
{
	return new OpVtrn_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtrn_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vtrn.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtrn_32(CodeType code, uint32_t addr)
{
	return new OpVtrn_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtst_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vtst.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtst_i8(CodeType code, uint32_t addr)
{
	return new OpVtst_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtst_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vtst.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtst_16(CodeType code, uint32_t addr)
{
	return new OpVtst_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtst_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vtst.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtst_32(CodeType code, uint32_t addr)
{
	return new OpVtst_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVuzp_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vuzp.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVuzp_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[0*pack+(dd*elements+idx)] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[1*pack+(dd*elements+idx)] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[2*(dd*elements+idx)+0] );
			cpu.SetVDE( vm+dd, idx, zipped[2*(dd*elements+idx)+1] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVuzp_8(CodeType code, uint32_t addr)
{
	return new OpVuzp_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVuzp_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vuzp.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVuzp_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[0*pack+(dd*elements+idx)] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[1*pack+(dd*elements+idx)] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[2*(dd*elements+idx)+0] );
			cpu.SetVDE( vm+dd, idx, zipped[2*(dd*elements+idx)+1] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVuzp_16(CodeType code, uint32_t addr)
{
	return new OpVuzp_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVuzp_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vuzp.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVuzp_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[0*pack+(dd*elements+idx)] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[1*pack+(dd*elements+idx)] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[2*(dd*elements+idx)+0] );
			cpu.SetVDE( vm+dd, idx, zipped[2*(dd*elements+idx)+1] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVuzp_32(CodeType code, uint32_t addr)
{
	return new OpVuzp_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVzip_8<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vzip.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVzip_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[2*(dd*elements+idx)+0] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[2*(dd*elements+idx)+1] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[0*pack+(dd*elements+idx)] );
			cpu.SetVDE( vm+dd, idx, zipped[1*pack+(dd*elements+idx)] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVzip_8(CodeType code, uint32_t addr)
{
	return new OpVzip_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVzip_16<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vzip.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVzip_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[2*(dd*elements+idx)+0] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[2*(dd*elements+idx)+1] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[0*pack+(dd*elements+idx)] );
			cpu.SetVDE( vm+dd, idx, zipped[1*pack+(dd*elements+idx)] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVzip_16(CodeType code, uint32_t addr)
{
	return new OpVzip_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVzip_32<	ARCH>::disasm( ARCH & cpu,
std::ostream& buffer)
{
	{
		buffer << "vzip.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVzip_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[2*(dd*elements+idx)+0] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[2*(dd*elements+idx)+1] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[0*pack+(dd*elements+idx)] );
			cpu.SetVDE( vm+dd, idx, zipped[1*pack+(dd*elements+idx)] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVzip_32(CodeType code, uint32_t addr)
{
	return new OpVzip_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
OpUsada8<	ARCH>::OpUsada8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usada8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	ra = uint8_t((code >> 12) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpMsr_imm_psr<	ARCH>::OpMsr_imm_psr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "msr_imm_psr")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	mask = uint8_t((code >> 16) & 0xf);
	write_spsr = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
	psr_mask = (((mask*0x00204081)&0x01010101)*0xff) &
	(write_spsr ? -1 : ~0x0700fc20) /* Does not affect execution state bits other than E */;
}

template <	typename	ARCH>
OpAnd_32imm<	ARCH>::OpAnd_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "and_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpAnd_imm_shift<	ARCH>::OpAnd_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "and_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpAnd_reg_shift<	ARCH>::OpAnd_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "and_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpEor_32imm<	ARCH>::OpEor_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "eor_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpEor_imm_shift<	ARCH>::OpEor_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "eor_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpEor_reg_shift<	ARCH>::OpEor_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "eor_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpSub_32imm<	ARCH>::OpSub_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sub_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpSub_imm_shift<	ARCH>::OpSub_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sub_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpSub_reg_shift<	ARCH>::OpSub_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sub_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpRsb_32imm<	ARCH>::OpRsb_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsb_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpRsb_imm_shift<	ARCH>::OpRsb_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsb_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpRsb_reg_shift<	ARCH>::OpRsb_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsb_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpAdd_32imm<	ARCH>::OpAdd_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpAdd_imm_shift<	ARCH>::OpAdd_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpAdd_reg_shift<	ARCH>::OpAdd_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpAdc_32imm<	ARCH>::OpAdc_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adc_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpAdc_imm_shift<	ARCH>::OpAdc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpAdc_reg_shift<	ARCH>::OpAdc_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adc_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = ((rd == 15) or (rn == 15) or (rm == 15) or (rs == 15));
}

template <	typename	ARCH>
OpSbc_32imm<	ARCH>::OpSbc_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbc_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpSbc_imm_shift<	ARCH>::OpSbc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpSbc_reg_shift<	ARCH>::OpSbc_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbc_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpRsc_32imm<	ARCH>::OpRsc_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsc_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpRsc_imm_shift<	ARCH>::OpRsc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpRsc_reg_shift<	ARCH>::OpRsc_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsc_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpOrr_32imm<	ARCH>::OpOrr_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orr_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpOrr_imm_shift<	ARCH>::OpOrr_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orr_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpOrr_reg_shift<	ARCH>::OpOrr_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orr_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpBic_32imm<	ARCH>::OpBic_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bic_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpBic_imm_shift<	ARCH>::OpBic_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bic_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpBic_reg_shift<	ARCH>::OpBic_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bic_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpTst_32imm<	ARCH>::OpTst_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "tst_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpTst_imm_shift<	ARCH>::OpTst_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "tst_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpTst_reg_shift<	ARCH>::OpTst_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "tst_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpTeq_32imm<	ARCH>::OpTeq_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "teq_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpTeq_imm_shift<	ARCH>::OpTeq_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "teq_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpTeq_reg_shift<	ARCH>::OpTeq_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "teq_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpCmp_32imm<	ARCH>::OpCmp_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmp_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpCmp_imm_shift<	ARCH>::OpCmp_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmp_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpCmp_reg_shift<	ARCH>::OpCmp_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmp_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpCmn_32imm<	ARCH>::OpCmn_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmn_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpCmn_imm_shift<	ARCH>::OpCmn_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmn_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpCmn_reg_shift<	ARCH>::OpCmn_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmn_reg_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rs = uint8_t((code >> 8) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rm == 15) or (rs == 15);
}

template <	typename	ARCH>
OpMov_32imm<	ARCH>::OpMov_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mov_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpMov_imm_shift<	ARCH>::OpMov_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mov_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMov_reg_shift<	ARCH>::OpMov_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mov_reg_shift")
{
	rn = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpMvn_32imm<	ARCH>::OpMvn_32imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mvn_32imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rd = uint8_t((code >> 12) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpMvn_imm_shift<	ARCH>::OpMvn_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mvn_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMvn_reg_shift<	ARCH>::OpMvn_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mvn_reg_shift")
{
	rn = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpClz<	ARCH>::OpClz(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "clz")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpRbit<	ARCH>::OpRbit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rbit")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpRev<	ARCH>::OpRev(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rev")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpRev16<	ARCH>::OpRev16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rev16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpRevsh<	ARCH>::OpRevsh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "revsh")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpMovw<	ARCH>::OpMovw(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "movw")
{
	imm0 = uint16_t(code & 0xfff);
	rd = uint8_t((code >> 12) & 0xf);
	imm1 = uint16_t((code >> 16) & 0xf) << 12;
	cond = uint8_t((code >> 28) & 0xf);
	imm = imm1|imm0;
}

template <	typename	ARCH>
OpMovt<	ARCH>::OpMovt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "movt")
{
	imm0 = uint16_t(code & 0xfff);
	rd = uint8_t((code >> 12) & 0xf);
	imm1 = uint16_t((code >> 16) & 0xf) << 12;
	cond = uint8_t((code >> 28) & 0xf);
	imm = imm1|imm0;
}

template <	typename	ARCH>
OpLdr_imm<	ARCH>::OpLdr_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_imm")
{
	offset = uint16_t(code & 0xfff);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p and w) or ((not p or w) and ((rn == 15) or (rn == rt)));
}

template <	typename	ARCH>
OpLdr_reg<	ARCH>::OpLdr_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w) or (rm == 15) or
	((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpLdrh_imm<	ARCH>::OpLdrh_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrh_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)));
}

template <	typename	ARCH>
OpLdrh_reg<	ARCH>::OpLdrh_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrh_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w) or (rm == 15) or (rt == 15) or
	((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpLdrsh_imm<	ARCH>::OpLdrsh_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsh_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)));
}

template <	typename	ARCH>
OpLdrsh_reg<	ARCH>::OpLdrsh_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsh_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w) or (rm == 15) or (rt == 15) or
	((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpLdrb_imm<	ARCH>::OpLdrb_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrb_imm")
{
	offset = uint16_t(code & 0xfff);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)));
}

template <	typename	ARCH>
OpLdrb_reg<	ARCH>::OpLdrb_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrb_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w) or (rm == 15) or (rt == 15) or
	((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpLdrsb_imm<	ARCH>::OpLdrsb_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsb_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)));
}

template <	typename	ARCH>
OpLdrsb_reg<	ARCH>::OpLdrsb_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsb_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w) or (rm == 15) or (rt == 15) or
	((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpLdrd_imm<	ARCH>::OpLdrd_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrd_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (not p and w) or (rt & 1) or (rt == 14) or
	((not p or w) and ((rn == 15) or ((rn & 0xe) == rt)));
}

template <	typename	ARCH>
OpLdrd_reg<	ARCH>::OpLdrd_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrd_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w) or (rt & 1) or (rt == 14) or (rm == 15) or ((rm & 0xe) == rt) or
	((not p or w) and ((rn == 15) or ((rn & 0xe) == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpStr_imm<	ARCH>::OpStr_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "str_imm")
{
	offset = uint16_t(code & 0xfff);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p and w) or ((not p or w) and ((rn == 15) or (rn == rt)));
}

template <	typename	ARCH>
OpStr_reg<	ARCH>::OpStr_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "str_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w)or (rm == 15) or
	((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpStrh_imm<	ARCH>::OpStrh_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strh_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)));
}

template <	typename	ARCH>
OpStrh_reg<	ARCH>::OpStrh_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strh_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w)or (rm == 15) or (rt == 15) or
	((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpStrb_imm<	ARCH>::OpStrb_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strb_imm")
{
	offset = uint16_t(code & 0xfff);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)));
}

template <	typename	ARCH>
OpStrb_reg<	ARCH>::OpStrb_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strb_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w)or (rm == 15) or (rt == 15) or
	((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpStrd_imm<	ARCH>::OpStrd_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strd_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (not p and w) or (rt & 1) or (rt == 14) or
	((not p or w) and ((rn == 15) or ((rn & 0xe) == rt)));
}

template <	typename	ARCH>
OpStrd_reg<	ARCH>::OpStrd_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strd_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (not p and w) or (rt & 1) or (rt == 14) or (rm == 15) or
	((not p or w) and ((rn == 15) or ((rn & 0xe) == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))));
}

template <	typename	ARCH>
OpLdrt_imm<	ARCH>::OpLdrt_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrt_imm")
{
	offset = uint16_t(code & 0xfff);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (rt == 15) or (rn == 15) or (rn == rt);
}

template <	typename	ARCH>
OpLdrt_reg<	ARCH>::OpLdrt_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrt_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15) or (rn == rt) or (rm == 15);
}

template <	typename	ARCH>
OpLdrht_imm<	ARCH>::OpLdrht_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrht_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (rt == 15) or (rn == 15) or (rn == rt);
}

template <	typename	ARCH>
OpLdrht_reg<	ARCH>::OpLdrht_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrht_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15) or (rn == rt) or (rm == 15);
}

template <	typename	ARCH>
OpLdrsht_imm<	ARCH>::OpLdrsht_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsht_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (rt == 15) or (rn == 15) or (rn == rt);
}

template <	typename	ARCH>
OpLdrsht_reg<	ARCH>::OpLdrsht_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsht_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15) or (rn == rt) or (rm == 15);
}

template <	typename	ARCH>
OpLdrbt_imm<	ARCH>::OpLdrbt_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrbt_imm")
{
	offset = uint16_t(code & 0xfff);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (rt == 15) or (rn == 15) or (rn == rt);
}

template <	typename	ARCH>
OpLdrbt_reg<	ARCH>::OpLdrbt_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrbt_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15) or (rn == rt) or (rm == 15);
}

template <	typename	ARCH>
OpLdrsbt_imm<	ARCH>::OpLdrsbt_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsbt_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (rt == 15) or (rn == 15) or (rn == rt);
}

template <	typename	ARCH>
OpLdrsbt_reg<	ARCH>::OpLdrsbt_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsbt_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15) or (rn == rt) or (rm == 15);
}

template <	typename	ARCH>
OpStrt_imm<	ARCH>::OpStrt_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strt_imm")
{
	offset = uint16_t(code & 0xfff);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (rn == 15) or (rn == rt);
}

template <	typename	ARCH>
OpStrt_reg<	ARCH>::OpStrt_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strt_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rn == rt) or (rm == 15);
}

template <	typename	ARCH>
OpStrht_imm<	ARCH>::OpStrht_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strht_imm")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint8_t((code >> 8) & 0xf) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?(im1|im0):-(im1|im0);
	reject = (rt == 15) or (rn == 15) or (rn == rt);
}

template <	typename	ARCH>
OpStrht_reg<	ARCH>::OpStrht_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strht_reg")
{
	rm = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15) or (rn == rt) or (rm == 15);
}

template <	typename	ARCH>
OpStrbt_imm<	ARCH>::OpStrbt_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strbt_imm")
{
	offset = uint16_t(code & 0xfff);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (rt == 15) or (rn == 15) or (rn == rt);
}

template <	typename	ARCH>
OpStrbt_reg<	ARCH>::OpStrbt_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strbt_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15) or (rn == rt) or (rm == 15);
}

template <	typename	ARCH>
OpLdm<	ARCH>::OpLdm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldm")
{
	reglist = uint16_t(code & 0xffff);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	mod = uint8_t((code >> 23) & 0x3);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (reglist == 0) or (reglist >> rn & w);
}

template <	typename	ARCH>
OpStm<	ARCH>::OpStm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stm")
{
	reglist = uint16_t(code & 0xffff);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	mod = uint8_t((code >> 23) & 0x3);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (reglist == 0) or (w and (((reglist & (reglist-1)) >> rn) & 1));
}

template <	typename	ARCH>
OpLdm_usr<	ARCH>::OpLdm_usr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldm_usr")
{
	reglist = uint16_t(code & 0x7fff);
	rn = uint8_t((code >> 16) & 0xf);
	mod = uint8_t((code >> 23) & 0x3);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (reglist == 0);
}

template <	typename	ARCH>
OpLdm_rfe<	ARCH>::OpLdm_rfe(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldm_rfe")
{
	regnpclist = uint16_t(code & 0x7fff);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	mod = uint8_t((code >> 23) & 0x3);
	cond = uint8_t((code >> 28) & 0xf);
	reglist = regnpclist | 0x8000;
	reject = (rn == 15) or ((reglist >> rn) & w);
}

template <	typename	ARCH>
OpStm_usr<	ARCH>::OpStm_usr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stm_usr")
{
	reglist = uint16_t(code & 0xffff);
	rn = uint8_t((code >> 16) & 0xf);
	mod = uint8_t((code >> 23) & 0x3);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (reglist == 0);
}

template <	typename	ARCH>
OpSwp<	ARCH>::OpSwp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "swp")
{
	rt2 = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rt2 == 15) or (rn == 15) or (rn == rt) or (rn == rt2);
}

template <	typename	ARCH>
OpSwpb<	ARCH>::OpSwpb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "swpb")
{
	rt2 = uint8_t(code & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rt2 == 15) or (rn == 15) or (rn == rt) or (rn == rt2);
}

template <	typename	ARCH>
OpLdrex<	ARCH>::OpLdrex(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrex")
{
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15);
}

template <	typename	ARCH>
OpLdrexh<	ARCH>::OpLdrexh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrexh")
{
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15);
}

template <	typename	ARCH>
OpLdrexb<	ARCH>::OpLdrexb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrexb")
{
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15) or (rn == 15);
}

template <	typename	ARCH>
OpLdrexd<	ARCH>::OpLdrexd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrexd")
{
	rt = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt & 1) or (rt == 14) or (rn == 15);
}

template <	typename	ARCH>
OpStrex<	ARCH>::OpStrex(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strex")
{
	rt = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rt == 15) or (rn == 15) or (rd == rn) or (rd == rt);
}

template <	typename	ARCH>
OpStrexh<	ARCH>::OpStrexh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strexh")
{
	rt = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rt == 15) or (rn == 15) or (rd == rn) or (rd == rt);
}

template <	typename	ARCH>
OpStrexb<	ARCH>::OpStrexb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strexb")
{
	rt = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rt == 15) or (rn == 15) or (rd == rn) or (rd == rt);
}

template <	typename	ARCH>
OpStrexd<	ARCH>::OpStrexd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strexd")
{
	rt = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rt & 1) or (rt == 14) or (rn == 15) or
	(rd == rn) or ((rd & 0xe) == rt);
}

template <	typename	ARCH>
OpMla<	ARCH>::OpMla(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mla")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	ra = uint8_t((code >> 12) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (ra == 15);
}

template <	typename	ARCH>
OpMls<	ARCH>::OpMls(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mls")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	ra = uint8_t((code >> 12) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (ra == 15);
}

template <	typename	ARCH>
OpMul<	ARCH>::OpMul(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mul")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or ((ARCH::Config::model < ARMV6) and (rd == rn));
}

template <	typename	ARCH>
OpSmlal<	ARCH>::OpSmlal(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlal")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	rdlo = uint8_t((code >> 12) & 0xf);
	rdhi = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
	(rdhi == rdlo) or
	((ARCH::Config::model < ARMV6) and ((rdhi == rn) or (rdlo == rn)));
}

template <	typename	ARCH>
OpSmull<	ARCH>::OpSmull(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smull")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	rdlo = uint8_t((code >> 12) & 0xf);
	rdhi = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
	(rdhi == rdlo) or
	((ARCH::Config::model < ARMV6) and ((rdhi == rn) or (rdlo == rn)));
}

template <	typename	ARCH>
OpUmlal<	ARCH>::OpUmlal(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "umlal")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	rdlo = uint8_t((code >> 12) & 0xf);
	rdhi = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
	(rdhi == rdlo) or
	((ARCH::Config::model < ARMV6) and ((rdhi == rn) or (rdlo == rn)));
}

template <	typename	ARCH>
OpUmaal<	ARCH>::OpUmaal(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "umaal")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	rdlo = uint8_t((code >> 12) & 0xf);
	rdhi = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
	(rdhi == rdlo) or
	((ARCH::Config::model < ARMV6) and ((rdhi == rn) or (rdlo == rn)));
}

template <	typename	ARCH>
OpUmull<	ARCH>::OpUmull(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "umull")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	rdlo = uint8_t((code >> 12) & 0xf);
	rdhi = uint8_t((code >> 16) & 0xf);
	s = uint8_t((code >> 20) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or
	(rdhi == rdlo) or
	((ARCH::Config::model < ARMV6) and ((rdhi == rn) or (rdlo == rn)));
}

template <	typename	ARCH>
OpSmlaxy<	ARCH>::OpSmlaxy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlaxy")
{
	rn = uint8_t(code & 0xf);
	n = uint8_t((code >> 5) & 0x1);
	m = uint8_t((code >> 6) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	ra = uint8_t((code >> 12) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (ra == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSmlalxy<	ARCH>::OpSmlalxy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlalxy")
{
	rn = uint8_t(code & 0xf);
	n = uint8_t((code >> 5) & 0x1);
	m = uint8_t((code >> 6) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	rdlo = uint8_t((code >> 12) & 0xf);
	rdhi = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 15) or (rdlo == 15) or (rn == 15) or (rm == 15) or (rdhi == rdlo);
}

template <	typename	ARCH>
OpSmlawy<	ARCH>::OpSmlawy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlawy")
{
	rn = uint8_t(code & 0xf);
	m = uint8_t((code >> 6) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	ra = uint8_t((code >> 12) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (ra == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSmulxy<	ARCH>::OpSmulxy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smulxy")
{
	rn = uint8_t(code & 0xf);
	n = uint8_t((code >> 5) & 0x1);
	m = uint8_t((code >> 6) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSmulwy<	ARCH>::OpSmulwy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smulwy")
{
	rn = uint8_t(code & 0xf);
	m = uint8_t((code >> 6) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSdiv<	ARCH>::OpSdiv(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sdiv")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpUdiv<	ARCH>::OpUdiv(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "udiv")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpSmlad<	ARCH>::OpSmlad(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlad")
{
	rn = uint8_t(code & 0xf);
	swap = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	ra = uint8_t((code >> 12) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (ra == 15);
}

template <	typename	ARCH>
OpSmlald<	ARCH>::OpSmlald(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlald")
{
	rn = uint8_t(code & 0xf);
	swap = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	rdlo = uint8_t((code >> 12) & 0xf);
	rdhi = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rdlo == 15) or (rdhi == 15) or (rn == 15) or (rm == 15) or (rdhi == rdlo);
}

template <	typename	ARCH>
OpSmlsd<	ARCH>::OpSmlsd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlsd")
{
	rn = uint8_t(code & 0xf);
	swap = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	ra = uint8_t((code >> 12) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (ra == 15);
}

template <	typename	ARCH>
OpSmlsld<	ARCH>::OpSmlsld(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlsld")
{
	rn = uint8_t(code & 0xf);
	swap = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	rdlo = uint8_t((code >> 12) & 0xf);
	rdhi = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rdlo == 15) or (rdhi == 15) or (rn == 15) or (rm == 15) or (rdlo == rdhi);
}

template <	typename	ARCH>
OpSmmla<	ARCH>::OpSmmla(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smmla")
{
	rn = uint8_t(code & 0xf);
	round = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	ra = uint8_t((code >> 12) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (ra == 15);
}

template <	typename	ARCH>
OpSmmls<	ARCH>::OpSmmls(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smmls")
{
	rn = uint8_t(code & 0xf);
	round = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	ra = uint8_t((code >> 12) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15) or (ra == 15);
}

template <	typename	ARCH>
OpSmmul<	ARCH>::OpSmmul(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smmul")
{
	rn = uint8_t(code & 0xf);
	round = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSmuad<	ARCH>::OpSmuad(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smuad")
{
	rn = uint8_t(code & 0xf);
	swap = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSmusd<	ARCH>::OpSmusd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smusd")
{
	rn = uint8_t(code & 0xf);
	swap = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpQadd<	ARCH>::OpQadd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qadd")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15) or (rn == 15);
}

template <	typename	ARCH>
OpQadd16<	ARCH>::OpQadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qadd16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15) or (rn == 15);
}

template <	typename	ARCH>
OpQadd8<	ARCH>::OpQadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qadd8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15) or (rn == 15);
}

template <	typename	ARCH>
OpQsub<	ARCH>::OpQsub(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qsub")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15) or (rn == 15);
}

template <	typename	ARCH>
OpQsub16<	ARCH>::OpQsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qsub16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15) or (rn == 15);
}

template <	typename	ARCH>
OpQsub8<	ARCH>::OpQsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qsub8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15) or (rn == 15);
}

template <	typename	ARCH>
OpQdadd<	ARCH>::OpQdadd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qdadd")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15) or (rn == 15);
}

template <	typename	ARCH>
OpQdsub<	ARCH>::OpQdsub(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qdsub")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15) or (rn == 15);
}

template <	typename	ARCH>
OpPkh<	ARCH>::OpPkh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pkh")
{
	rm = uint8_t(code & 0xf);
	tb = uint8_t((code >> 6) & 0x1) << 1;
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rm == 15) or (rn == 15);
}

template <	typename	ARCH>
OpSxtab16<	ARCH>::OpSxtab16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtab16")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSxtb16<	ARCH>::OpSxtb16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtb16")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUxtab16<	ARCH>::OpUxtab16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtab16")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUxtb16<	ARCH>::OpUxtb16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtb16")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSel<	ARCH>::OpSel(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sel")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSsat<	ARCH>::OpSsat(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssat")
{
	rn = uint8_t(code & 0xf);
	sh = uint8_t((code >> 6) & 0x1) << 1;
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	sat_imm = uint8_t((code >> 16) & 0x1f);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15);
}

template <	typename	ARCH>
OpSsat16<	ARCH>::OpSsat16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssat16")
{
	rn = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	sat_imm = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15);
}

template <	typename	ARCH>
OpUsat<	ARCH>::OpUsat(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usat")
{
	rn = uint8_t(code & 0xf);
	sh = uint8_t((code >> 6) & 0x1) << 1;
	imm = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	sat_imm = uint8_t((code >> 16) & 0x1f);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15);
}

template <	typename	ARCH>
OpUsat16<	ARCH>::OpUsat16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usat16")
{
	rn = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	sat_imm = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15);
}

template <	typename	ARCH>
OpSxtab<	ARCH>::OpSxtab(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtab")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSxtb<	ARCH>::OpSxtb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtb")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = rotate << 3;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSxtah<	ARCH>::OpSxtah(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtah")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSxth<	ARCH>::OpSxth(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxth")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUxtab<	ARCH>::OpUxtab(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtab")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUxtb<	ARCH>::OpUxtb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtb")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = rotate<<3;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUxtah<	ARCH>::OpUxtah(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtah")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUxth<	ARCH>::OpUxth(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxth")
{
	rm = uint8_t(code & 0xf);
	rotate = uint8_t((code >> 10) & 0x3);
	rd = uint8_t((code >> 12) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	ror = 8*rotate;
	reject = (rd == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUsad8<	ARCH>::OpUsad8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usad8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSbfx<	ARCH>::OpSbfx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbfx")
{
	rn = uint8_t(code & 0xf);
	lsb = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	widthm1 = uint8_t((code >> 16) & 0x1f);
	cond = uint8_t((code >> 28) & 0xf);
	width = widthm1+1;
	reject = (rd == 15) or (rn == 15) or (lsb + widthm1) > 31;
}

template <	typename	ARCH>
OpBfi<	ARCH>::OpBfi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bfi")
{
	rn = uint8_t(code & 0xf);
	lsb = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	msb = uint8_t((code >> 16) & 0x1f);
	cond = uint8_t((code >> 28) & 0xf);
	width = msb-lsb+1;
	clear = ~(((uint64_t(1) << width)-1) << lsb);
	reject = msb < lsb;
}

template <	typename	ARCH>
OpBfc<	ARCH>::OpBfc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bfc")
{
	lsb = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	msb = uint8_t((code >> 16) & 0x1f);
	cond = uint8_t((code >> 28) & 0xf);
	width = msb-lsb+1;
	clear = ~(((uint64_t(1) << width)-1) << lsb);
	reject = msb < lsb;
}

template <	typename	ARCH>
OpUbfx<	ARCH>::OpUbfx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ubfx")
{
	rn = uint8_t(code & 0xf);
	lsb = uint8_t((code >> 7) & 0x1f);
	rd = uint8_t((code >> 12) & 0xf);
	widthm1 = uint8_t((code >> 16) & 0x1f);
	cond = uint8_t((code >> 28) & 0xf);
	width = widthm1+1;
	reject = (rd == 15) or (rn == 15) or (lsb + widthm1) > 31;
}

template <	typename	ARCH>
OpUadd16<	ARCH>::OpUadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uadd16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUadd8<	ARCH>::OpUadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uadd8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUsub16<	ARCH>::OpUsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usub16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUsub8<	ARCH>::OpUsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usub8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSadd16<	ARCH>::OpSadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sadd16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSadd8<	ARCH>::OpSadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sadd8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSsub16<	ARCH>::OpSsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssub16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSsub8<	ARCH>::OpSsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssub8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUqadd16<	ARCH>::OpUqadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqadd16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUqadd8<	ARCH>::OpUqadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqadd8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUqsub16<	ARCH>::OpUqsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqsub16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUqsub8<	ARCH>::OpUqsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqsub8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUhadd16<	ARCH>::OpUhadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhadd16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUhadd8<	ARCH>::OpUhadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhadd8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpShadd16<	ARCH>::OpShadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shadd16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpShadd8<	ARCH>::OpShadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shadd8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUhsub16<	ARCH>::OpUhsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhsub16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUhsub8<	ARCH>::OpUhsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhsub8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpShsub16<	ARCH>::OpShsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shsub16")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpShsub8<	ARCH>::OpShsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shsub8")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpQasx<	ARCH>::OpQasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qasx")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpQsax<	ARCH>::OpQsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qsax")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUqasx<	ARCH>::OpUqasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqasx")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUqsax<	ARCH>::OpUqsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqsax")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSasx<	ARCH>::OpSasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sasx")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpSsax<	ARCH>::OpSsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssax")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUasx<	ARCH>::OpUasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uasx")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUsax<	ARCH>::OpUsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usax")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpShasx<	ARCH>::OpShasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shasx")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpShsax<	ARCH>::OpShsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shsax")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUhasx<	ARCH>::OpUhasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhasx")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpUhsax<	ARCH>::OpUhsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhsax")
{
	rm = uint8_t(code & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rd == 15) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpNop<	ARCH>::OpNop(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "nop")
{
	idx = uint8_t(code & 0xff);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpYield<	ARCH>::OpYield(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "yield")
{
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpWfe<	ARCH>::OpWfe(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "wfe")
{
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpWfi<	ARCH>::OpWfi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "wfi")
{
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpSev<	ARCH>::OpSev(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sev")
{
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpDbg<	ARCH>::OpDbg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "dbg")
{
	idx = uint8_t(code & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpB<	ARCH>::OpB(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "b")
{
	imm = ((int32_t)((code & 0xffffff) << 8) >> 8) << 2;
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpBl<	ARCH>::OpBl(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bl")
{
	imm = ((int32_t)((code & 0xffffff) << 8) >> 8) << 2;
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpBx<	ARCH>::OpBx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bx")
{
	rm = uint8_t(code & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpBxj<	ARCH>::OpBxj(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bxj")
{
	rm = uint8_t(code & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpBlx_reg<	ARCH>::OpBlx_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "blx_reg")
{
	rm = uint8_t(code & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpCdp<	ARCH>::OpCdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cdp")
{
	crm = uint8_t(code & 0xf);
	opc2 = uint8_t((code >> 5) & 0x7);
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	crn = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 20) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpLdc<	ARCH>::OpLdc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldc")
{
	offset = uint16_t(code & 0xff) << 2;
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	d = uint8_t((code >> 22) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p) and (not u) and (not d) and (not w);
}

template <	typename	ARCH>
OpLdc_unindexed<	ARCH>::OpLdc_unindexed(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldc_unindexed")
{
	option = uint8_t(code & 0xff);
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	d = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMcr<	ARCH>::OpMcr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mcr")
{
	crm = uint8_t(code & 0xf);
	opc2 = uint8_t((code >> 5) & 0x7);
	cp_num = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	crn = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 21) & 0x7);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMrc<	ARCH>::OpMrc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrc")
{
	crm = uint8_t(code & 0xf);
	opc2 = uint8_t((code >> 5) & 0x7);
	cp_num = uint8_t((code >> 8) & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	crn = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 21) & 0x7);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpStc<	ARCH>::OpStc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stc")
{
	offset = uint16_t(code & 0xff) << 2;
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	d = uint8_t((code >> 22) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p) and (not u) and (not d) and (not w);
}

template <	typename	ARCH>
OpStc_unindexed<	ARCH>::OpStc_unindexed(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stc_unindexed")
{
	option = uint8_t(code & 0xff);
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	d = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMcrr<	ARCH>::OpMcrr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mcrr")
{
	crm = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 4) & 0xf);
	cp_num = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMrrc<	ARCH>::OpMrrc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrrc")
{
	crm = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 4) & 0xf);
	cp_num = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpCp15_mcr<	ARCH>::OpCp15_mcr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cp15_mcr")
{
	crm = uint8_t(code & 0xf);
	opc2 = uint8_t((code >> 5) & 0x7);
	rt = uint8_t((code >> 12) & 0xf);
	crn = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 21) & 0x7);
	cond = uint8_t((code >> 28) & 0xf);
	cp15reg = ARCH::CP15GetRegister(crn, opc1, crm, opc2);
	reject = (rt == 15);
}

template <	typename	ARCH>
OpCp15_mrc<	ARCH>::OpCp15_mrc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cp15_mrc")
{
	crm = uint8_t(code & 0xf);
	opc2 = uint8_t((code >> 5) & 0x7);
	rt = uint8_t((code >> 12) & 0xf);
	crn = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 21) & 0x7);
	cond = uint8_t((code >> 28) & 0xf);
	cp15reg = ARCH::CP15GetRegister(crn, opc1, crm, opc2);
}

template <	typename	ARCH>
OpSwi<	ARCH>::OpSwi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "swi")
{
	imm = uint32_t(code & 0xffffff);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpHvc<	ARCH>::OpHvc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "hvc")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint16_t((code >> 8) & 0xfff) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = im1|im0;
}

template <	typename	ARCH>
OpSmc<	ARCH>::OpSmc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smc")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint16_t((code >> 8) & 0xfff) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = im1|im0;
}

template <	typename	ARCH>
OpEret<	ARCH>::OpEret(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "eret")
{
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpSubspc_imm<	ARCH>::OpSubspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "subspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpSubspc_imm_shift<	ARCH>::OpSubspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "subspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMovspc_imm<	ARCH>::OpMovspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "movspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpMovspc_imm_shift<	ARCH>::OpMovspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "movspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpAndspc_imm<	ARCH>::OpAndspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "andspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpAndspc_imm_shift<	ARCH>::OpAndspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "andspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpEorspc_imm<	ARCH>::OpEorspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "eorspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpEorspc_imm_shift<	ARCH>::OpEorspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "eorspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpRsbspc_imm<	ARCH>::OpRsbspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsbspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpRsbspc_imm_shift<	ARCH>::OpRsbspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsbspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpAddspc_imm<	ARCH>::OpAddspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "addspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpAddspc_imm_shift<	ARCH>::OpAddspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "addspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpAdcspc_imm<	ARCH>::OpAdcspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adcspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpAdcspc_imm_shift<	ARCH>::OpAdcspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adcspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpSbcspc_imm<	ARCH>::OpSbcspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbcspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpSbcspc_imm_shift<	ARCH>::OpSbcspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbcspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpRscspc_imm<	ARCH>::OpRscspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rscspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpRscspc_imm_shift<	ARCH>::OpRscspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rscspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpOrrspc_imm<	ARCH>::OpOrrspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orrspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpOrrspc_imm_shift<	ARCH>::OpOrrspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orrspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpBicspc_imm<	ARCH>::OpBicspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bicspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpBicspc_imm_shift<	ARCH>::OpBicspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bicspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMvnspc_imm<	ARCH>::OpMvnspc_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mvnspc_imm")
{
	imb = uint8_t(code & 0xff);
	imr = uint8_t((code >> 8) & 0xf) << 1;
	cond = uint8_t((code >> 28) & 0xf);
	imm = unisim::util::arithmetic::RotateRight( uint32_t( imb ), imr );
}

template <	typename	ARCH>
OpMvnspc_imm_shift<	ARCH>::OpMvnspc_imm_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mvnspc_imm_shift")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	cond = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMrs<	ARCH>::OpMrs(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrs")
{
	sr1 = uint8_t((code >> 8) & 0x3) << 4;
	rd = uint8_t((code >> 12) & 0xf);
	sr0 = uint8_t((code >> 16) & 0xf);
	sr2 = uint8_t((code >> 22) & 0x1) << 6;
	cond = uint8_t((code >> 28) & 0xf);
	sr = sr2|sr1|sr0;
	reject = (rd == 15);
}

template <	typename	ARCH>
OpMsr_reg<	ARCH>::OpMsr_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "msr_reg")
{
	rn = uint8_t(code & 0xf);
	sr1 = uint8_t((code >> 8) & 0x3) << 4;
	sr0 = uint8_t((code >> 16) & 0xf);
	sr2 = uint8_t((code >> 22) & 0x1) << 6;
	cond = uint8_t((code >> 28) & 0xf);
	sr = sr2|sr1|sr0;
}

template <	typename	ARCH>
OpMsr_reg_psr<	ARCH>::OpMsr_reg_psr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "msr_reg_psr")
{
	rn = uint8_t(code & 0xf);
	mask = uint8_t((code >> 16) & 0xf);
	write_spsr = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	psr_mask = (((mask*0x00204081)&0x01010101)*0xff) &
	(write_spsr ? -1 : ~0x0700fc20) /* Does not affect execution state bits other than E */;
}

template <	typename	ARCH>
OpVabs_f32<	ARCH>::OpVabs_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVabs_f64<	ARCH>::OpVabs_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVadd_f32<	ARCH>::OpVadd_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVadd_f64<	ARCH>::OpVadd_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVcmp_f32d<	ARCH>::OpVcmp_f32d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcmp_f32d")
{
	vm0 = uint8_t(code & 0xf) << 1;
	vm1 = uint8_t((code >> 5) & 0x1);
	e = uint8_t((code >> 7) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf) << 1;
	vd1 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcmp_f64d<	ARCH>::OpVcmp_f64d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcmp_f64d")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	e = uint8_t((code >> 7) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcmp_f32i<	ARCH>::OpVcmp_f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcmp_f32i")
{
	e = uint8_t((code >> 7) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf) << 1;
	vd1 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcmp_f64i<	ARCH>::OpVcmp_f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcmp_f64i")
{
	e = uint8_t((code >> 7) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32u32<	ARCH>::OpVcvt_f32u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64u32<	ARCH>::OpVcvt_f64u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64u32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32s32<	ARCH>::OpVcvt_f32s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32s32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64s32<	ARCH>::OpVcvt_f64s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64s32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u32f32<	ARCH>::OpVcvt_u32f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtr_u32f32<	ARCH>::OpVcvtr_u32f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtr_u32f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u32f64<	ARCH>::OpVcvt_u32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtr_u32f64<	ARCH>::OpVcvtr_u32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtr_u32f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s32f32<	ARCH>::OpVcvt_s32f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtr_s32f32<	ARCH>::OpVcvtr_s32f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtr_s32f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s32f64<	ARCH>::OpVcvt_s32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtr_s32f64<	ARCH>::OpVcvtr_s32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtr_s32f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32s16i<	ARCH>::OpVcvt_f32s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32s16i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32s32i<	ARCH>::OpVcvt_f32s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32s32i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64s16i<	ARCH>::OpVcvt_f64s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64s16i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64s32i<	ARCH>::OpVcvt_f64s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64s32i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32u16i<	ARCH>::OpVcvt_f32u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u16i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32u32i<	ARCH>::OpVcvt_f32u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u32i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64u16i<	ARCH>::OpVcvt_f64u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64u16i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64u32i<	ARCH>::OpVcvt_f64u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64u32i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s16f32i<	ARCH>::OpVcvt_s16f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s16f32i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s16f64i<	ARCH>::OpVcvt_s16f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s16f64i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s32f32i<	ARCH>::OpVcvt_s32f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f32i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s32f64i<	ARCH>::OpVcvt_s32f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f64i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u16f32i<	ARCH>::OpVcvt_u16f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u16f32i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u16f64i<	ARCH>::OpVcvt_u16f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u16f64i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u32f32i<	ARCH>::OpVcvt_u32f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f32i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u32f64i<	ARCH>::OpVcvt_u32f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f64i")
{
	imm1 = uint8_t(code & 0xf) << 1;
	imm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64f32<	ARCH>::OpVcvt_f64f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32f64<	ARCH>::OpVcvt_f32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVdiv_f32<	ARCH>::OpVdiv_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdiv_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVdiv_f64<	ARCH>::OpVdiv_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdiv_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfma_f32<	ARCH>::OpVfma_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfma_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfma_f64<	ARCH>::OpVfma_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfma_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfms_f32<	ARCH>::OpVfms_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfms_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfms_f64<	ARCH>::OpVfms_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfms_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfnma_f32<	ARCH>::OpVfnma_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfnma_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfnma_f64<	ARCH>::OpVfnma_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfnma_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfnms_f32<	ARCH>::OpVfnms_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfnms_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfnms_f64<	ARCH>::OpVfnms_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfnms_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVldmdb_f32<	ARCH>::OpVldmdb_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldmdb_f32")
{
	regs = uint8_t(code & 0xff);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldmdb_f64<	ARCH>::OpVldmdb_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldmdb_f64")
{
	fldm = uint8_t(code & 0x1);
	regs = uint8_t((code >> 1) & 0x7f);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldmia_f32<	ARCH>::OpVldmia_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldmia_f32")
{
	regs = uint8_t(code & 0xff);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldmia_f64<	ARCH>::OpVldmia_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldmia_f64")
{
	fldm = uint8_t(code & 0x1);
	regs = uint8_t((code >> 1) & 0x7f);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldr_32<	ARCH>::OpVldr_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldr_32")
{
	offset = uint16_t(code & 0xff) << 2;
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	vd0 = uint8_t((code >> 22) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpVldr_64<	ARCH>::OpVldr_64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldr_64")
{
	offset = uint16_t(code & 0xff) << 2;
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpVmla_f32<	ARCH>::OpVmla_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmla_f64<	ARCH>::OpVmla_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd0|vd1;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmls_f32<	ARCH>::OpVmls_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmls_f64<	ARCH>::OpVmls_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd0|vd1;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmla_f32<	ARCH>::OpVnmla_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmla_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmla_f64<	ARCH>::OpVnmla_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmla_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmls_f32<	ARCH>::OpVnmls_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmls_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmls_f64<	ARCH>::OpVnmls_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmls_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmov_f32i<	ARCH>::OpVmov_f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f32i")
{
	man = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	exp = uint8_t((code >> 16) & 0x7);
	n = uint8_t((code >> 19) & 0x1);
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	fpimm = typename ARCH::F32(VFPExpandImm( n, exp, man ));
}

template <	typename	ARCH>
OpVmov_f64i<	ARCH>::OpVmov_f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f64i")
{
	man = uint8_t(code & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	exp = uint8_t((code >> 16) & 0x7);
	n = uint8_t((code >> 19) & 0x1);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	fpimm = typename ARCH::F64(VFPExpandImm( n, exp, man ));
}

template <	typename	ARCH>
OpVmov_f32s<	ARCH>::OpVmov_f32s(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f32s")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVmov_f64d<	ARCH>::OpVmov_f64d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f64d")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVmov_rs<	ARCH>::OpVmov_rs(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_rs")
{
	vn0 = uint8_t((code >> 7) & 0x1);
	rt = uint8_t((code >> 12) & 0xf);
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	cond = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmov_sr<	ARCH>::OpVmov_sr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_sr")
{
	vn0 = uint8_t((code >> 7) & 0x1);
	rt = uint8_t((code >> 12) & 0xf);
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	cond = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmov_ssrr<	ARCH>::OpVmov_ssrr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_ssrr")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	rt = uint8_t((code >> 12) & 0xf);
	rt2 = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
}

template <	typename	ARCH>
OpVmov_rrss<	ARCH>::OpVmov_rrss(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_rrss")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	rt = uint8_t((code >> 12) & 0xf);
	rt2 = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
}

template <	typename	ARCH>
OpVmov_rrd<	ARCH>::OpVmov_rrd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_rrd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rt2 = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm0|vm1;
}

template <	typename	ARCH>
OpVmov_drr<	ARCH>::OpVmov_drr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_drr")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	rt2 = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm0|vm1;
}

template <	typename	ARCH>
OpVmrs<	ARCH>::OpVmrs(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmrs")
{
	rt = uint8_t((code >> 12) & 0xf);
	spr = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = ((rt == 15) and (spr != 1));
}

template <	typename	ARCH>
OpVmsr<	ARCH>::OpVmsr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmsr")
{
	rt = uint8_t((code >> 12) & 0xf);
	spr = uint8_t((code >> 16) & 0xf);
	cond = uint8_t((code >> 28) & 0xf);
	reject = (rt == 15);
}

template <	typename	ARCH>
OpVmul_f32<	ARCH>::OpVmul_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmul_f64<	ARCH>::OpVmul_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmul_f32<	ARCH>::OpVnmul_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmul_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmul_f64<	ARCH>::OpVnmul_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmul_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVneg_f32<	ARCH>::OpVneg_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVneg_f64<	ARCH>::OpVneg_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVsqrt_f32s<	ARCH>::OpVsqrt_f32s(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsqrt_f32s")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVsqrt_f64d<	ARCH>::OpVsqrt_f64d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsqrt_f64d")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstmdb_f32<	ARCH>::OpVstmdb_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstmdb_f32")
{
	regs = uint8_t(code & 0xff);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstmdb_f64<	ARCH>::OpVstmdb_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstmdb_f64")
{
	fstm = uint8_t(code & 0x1);
	regs = uint8_t((code >> 1) & 0x7f);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstmia_f32<	ARCH>::OpVstmia_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstmia_f32")
{
	regs = uint8_t(code & 0xff);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstmia_f64<	ARCH>::OpVstmia_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstmia_f64")
{
	fstm = uint8_t(code & 0x1);
	regs = uint8_t((code >> 1) & 0x7f);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstr_32<	ARCH>::OpVstr_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstr_32")
{
	offset = uint16_t(code & 0xff) << 2;
	vn1 = uint8_t((code >> 12) & 0xf) << 1;
	rn = uint8_t((code >> 16) & 0xf);
	vn0 = uint8_t((code >> 22) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpVstr_64<	ARCH>::OpVstr_64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstr_64")
{
	offset = uint16_t(code & 0xff) << 2;
	vn0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vn1 = uint8_t((code >> 22) & 0x1) << 4;
	u = uint8_t((code >> 23) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpVsub_f32<	ARCH>::OpVsub_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	vn0 = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vn1 = uint8_t((code >> 16) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVsub_f64<	ARCH>::OpVsub_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_f64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVdup8_r<	ARCH>::OpVdup8_r(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup8_r")
{
	vd1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vd0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 21) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	reject = vd0 & q or rt == 15;
}

template <	typename	ARCH>
OpVdup16_r<	ARCH>::OpVdup16_r(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup16_r")
{
	vd1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vd0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 21) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	reject = vd0 & q or rt == 15;
}

template <	typename	ARCH>
OpVdup32_r<	ARCH>::OpVdup32_r(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup32_r")
{
	vd1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vd0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 21) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	reject = vd0 & q or rt == 15;
}

template <	typename	ARCH>
OpVmov_8dr<	ARCH>::OpVmov_8dr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_8dr")
{
	index0 = uint8_t((code >> 5) & 0x3);
	vd1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vd0 = uint8_t((code >> 16) & 0xf);
	index1 = uint8_t((code >> 21) & 0x1) << 2;
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_16dr<	ARCH>::OpVmov_16dr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_16dr")
{
	index0 = uint8_t((code >> 6) & 0x1);
	vd1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vd0 = uint8_t((code >> 16) & 0xf);
	index1 = uint8_t((code >> 21) & 0x1) << 1;
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_32dr<	ARCH>::OpVmov_32dr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_32dr")
{
	vd1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vd0 = uint8_t((code >> 16) & 0xf);
	index = uint8_t((code >> 21) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVmov_s8rd<	ARCH>::OpVmov_s8rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_s8rd")
{
	index0 = uint8_t((code >> 5) & 0x3);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	index1 = uint8_t((code >> 21) & 0x1) << 2;
	cond = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_u8rd<	ARCH>::OpVmov_u8rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_u8rd")
{
	index0 = uint8_t((code >> 5) & 0x3);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	index1 = uint8_t((code >> 21) & 0x1) << 2;
	cond = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_s16rd<	ARCH>::OpVmov_s16rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_s16rd")
{
	index0 = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	index1 = uint8_t((code >> 21) & 0x1) << 1;
	cond = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_u16rd<	ARCH>::OpVmov_u16rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_u16rd")
{
	index0 = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	index1 = uint8_t((code >> 21) & 0x1) << 1;
	cond = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_32rd<	ARCH>::OpVmov_32rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_32rd")
{
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	rt = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	index = uint8_t((code >> 21) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpUnconditional<	ARCH>::OpUnconditional(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "unconditional")
{
}

template <	typename	ARCH>
OpVshll_s8<	ARCH>::OpVshll_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_s16<	ARCH>::OpVshll_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_s32<	ARCH>::OpVshll_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_u8<	ARCH>::OpVshll_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_u16<	ARCH>::OpVshll_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_u32<	ARCH>::OpVshll_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpSetend<	ARCH>::OpSetend(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "setend")
{
	endianness = uint8_t((code >> 9) & 0x1);
}

template <	typename	ARCH>
OpPld_imm<	ARCH>::OpPld_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pld_imm")
{
	offset = uint16_t(code & 0xfff);
	rn = uint8_t((code >> 16) & 0xf);
	r = uint8_t((code >> 22) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpPld_reg<	ARCH>::OpPld_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pld_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	r = uint8_t((code >> 22) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
}

template <	typename	ARCH>
OpPli_imm<	ARCH>::OpPli_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pli_imm")
{
	offset = uint16_t(code & 0xfff);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpPli_reg<	ARCH>::OpPli_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pli_reg")
{
	rm = uint8_t(code & 0xf);
	shift = uint8_t((code >> 5) & 0x3);
	imm = uint8_t((code >> 7) & 0x1f);
	rn = uint8_t((code >> 16) & 0xf);
	u = uint8_t((code >> 23) & 0x1);
}

template <	typename	ARCH>
OpClrex<	ARCH>::OpClrex(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "clrex")
{
}

template <	typename	ARCH>
OpDmb<	ARCH>::OpDmb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "dmb")
{
	opt = uint8_t(code & 0xf);
	reject = (opt & 2) == 0;
}

template <	typename	ARCH>
OpDsb<	ARCH>::OpDsb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "dsb")
{
	opt = uint8_t(code & 0xf);
	reject = (opt & 2) == 0;
}

template <	typename	ARCH>
OpIsb<	ARCH>::OpIsb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "isb")
{
	opt = uint8_t(code & 0xf);
	reject = opt != 15;
}

template <	typename	ARCH>
OpBlx_pcrel<	ARCH>::OpBlx_pcrel(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "blx_pcrel")
{
	im1 = ((int32_t)((code & 0xffffff) << 8) >> 8) << 2;
	im0 = uint8_t((code >> 24) & 0x1) << 1;
	imm = im1|im0;
}

template <	typename	ARCH>
OpCdp2<	ARCH>::OpCdp2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cdp2")
{
	crm = uint8_t(code & 0xf);
	opc2 = uint8_t((code >> 5) & 0x7);
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	crn = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 20) & 0xf);
}

template <	typename	ARCH>
OpLdc2<	ARCH>::OpLdc2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldc2")
{
	offset = uint16_t(code & 0xff) << 2;
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	d = uint8_t((code >> 22) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	imm = u?offset:-offset;
	reject = (not p) and (not u) and (not d) and (not w);
}

template <	typename	ARCH>
OpLdc2_unindexed<	ARCH>::OpLdc2_unindexed(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldc2_unindexed")
{
	option = uint8_t(code & 0xff);
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	d = uint8_t((code >> 22) & 0x1);
}

template <	typename	ARCH>
OpMcr2<	ARCH>::OpMcr2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mcr2")
{
	crm = uint8_t(code & 0xf);
	opc2 = uint8_t((code >> 5) & 0x7);
	cp_num = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	crn = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 21) & 0x7);
}

template <	typename	ARCH>
OpMrc2<	ARCH>::OpMrc2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrc2")
{
	crm = uint8_t(code & 0xf);
	opc2 = uint8_t((code >> 5) & 0x7);
	cp_num = uint8_t((code >> 8) & 0xf);
	rt = uint8_t((code >> 12) & 0xf);
	crn = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 21) & 0x7);
}

template <	typename	ARCH>
OpStc2<	ARCH>::OpStc2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stc2")
{
	offset = uint16_t(code & 0xff) << 2;
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	d = uint8_t((code >> 22) & 0x1);
	u = uint8_t((code >> 23) & 0x1);
	p = uint8_t((code >> 24) & 0x1);
	imm = u?offset:-offset;
	reject = (not p) and (not u) and (not d) and (not w);
}

template <	typename	ARCH>
OpStc2_unindexed<	ARCH>::OpStc2_unindexed(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stc2_unindexed")
{
	option = uint8_t(code & 0xff);
	cp_num = uint8_t((code >> 8) & 0xf);
	crd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	d = uint8_t((code >> 22) & 0x1);
}

template <	typename	ARCH>
OpMcrr2<	ARCH>::OpMcrr2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mcrr2")
{
	crm = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 4) & 0xf);
	cp_num = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
}

template <	typename	ARCH>
OpMrrc2<	ARCH>::OpMrrc2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrrc2")
{
	crm = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 4) & 0xf);
	cp_num = uint8_t((code >> 8) & 0xf);
	rd = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
}

template <	typename	ARCH>
OpBkpt<	ARCH>::OpBkpt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bkpt")
{
	im0 = uint8_t(code & 0xf);
	im1 = uint16_t((code >> 8) & 0xfff) << 4;
	imm = im1|im0;
}

template <	typename	ARCH>
OpCps<	ARCH>::OpCps(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cps")
{
	mode = uint8_t(code & 0x1f);
	f = uint8_t((code >> 6) & 0x1);
	i = uint8_t((code >> 7) & 0x1);
	a = uint8_t((code >> 8) & 0x1);
	chmod = uint8_t((code >> 17) & 0x1);
	dis = uint8_t((code >> 18) & 0x1);
	chitm = uint8_t((code >> 19) & 0x1);
	reject = (not chmod and (mode != 0)) or
	(chitm xor (a or i or f)) or
	(not (chmod or chitm)) or
	(not chitm and dis);
	psr_mask = a*A.getmask<uint32_t>()|i*I.getmask<uint32_t>()|f*F.getmask<uint32_t>()|chmod*M.getmask<uint32_t>();
	psr_bits = dis*(A.getmask<uint32_t>()|I.getmask<uint32_t>()|F.getmask<uint32_t>())|mode;
}

template <	typename	ARCH>
OpRfe<	ARCH>::OpRfe(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rfe")
{
	rn = uint8_t((code >> 16) & 0xf);
	w = uint8_t((code >> 21) & 0x1);
	mod = uint8_t((code >> 23) & 0x3);
}

template <	typename	ARCH>
OpSrs<	ARCH>::OpSrs(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "srs")
{
	mode = uint8_t(code & 0x1f);
	w = uint8_t((code >> 21) & 0x1);
	mod = uint8_t((code >> 23) & 0x3);
}

template <	typename	ARCH>
OpVcvtb_f16_f32<	ARCH>::OpVcvtb_f16_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtb_f16_f32")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	t = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtb_f32_f16<	ARCH>::OpVcvtb_f32_f16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtb_f32_f16")
{
	vm1 = uint8_t(code & 0xf) << 1;
	vm0 = uint8_t((code >> 5) & 0x1);
	t = uint8_t((code >> 7) & 0x1);
	vd1 = uint8_t((code >> 12) & 0xf) << 1;
	vd0 = uint8_t((code >> 22) & 0x1);
	cond = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVaba_s8<	ARCH>::OpVaba_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_s16<	ARCH>::OpVaba_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_s32<	ARCH>::OpVaba_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_u8<	ARCH>::OpVaba_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_u16<	ARCH>::OpVaba_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_u32<	ARCH>::OpVaba_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabal_s8qd<	ARCH>::OpVabal_s8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_s8qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_s16qd<	ARCH>::OpVabal_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_s16qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_s32qd<	ARCH>::OpVabal_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_s32qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_u8qd<	ARCH>::OpVabal_u8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_u8qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_u16qd<	ARCH>::OpVabal_u16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_u16qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_u32qd<	ARCH>::OpVabal_u32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_u32qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabd_s8<	ARCH>::OpVabd_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_s16<	ARCH>::OpVabd_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_s32<	ARCH>::OpVabd_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_u8<	ARCH>::OpVabd_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_u16<	ARCH>::OpVabd_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_u32<	ARCH>::OpVabd_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabdl_s8qd<	ARCH>::OpVabdl_s8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_s8qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_s16qd<	ARCH>::OpVabdl_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_s16qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_s32qd<	ARCH>::OpVabdl_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_s32qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_u8qd<	ARCH>::OpVabdl_u8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_u8qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_u16qd<	ARCH>::OpVabdl_u16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_u16qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_u32qd<	ARCH>::OpVabdl_u32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_u32qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabd_f32<	ARCH>::OpVabd_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabs_s8<	ARCH>::OpVabs_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVabs_s16<	ARCH>::OpVabs_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVabs_s32<	ARCH>::OpVabs_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVabs_f32v<	ARCH>::OpVabs_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVacge_f32<	ARCH>::OpVacge_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vacge_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVacgt_f32<	ARCH>::OpVacgt_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vacgt_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_f32v<	ARCH>::OpVadd_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_i8<	ARCH>::OpVadd_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_i8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_i16<	ARCH>::OpVadd_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_i16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_i32<	ARCH>::OpVadd_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_i32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_i64<	ARCH>::OpVadd_i64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_i64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaddhn_i16dq<	ARCH>::OpVaddhn_i16dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddhn_i16dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vm0 | vn0) & 1;
}

template <	typename	ARCH>
OpVaddhn_i32dq<	ARCH>::OpVaddhn_i32dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddhn_i32dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vm0 | vn0) & 1;
}

template <	typename	ARCH>
OpVaddhn_i64dq<	ARCH>::OpVaddhn_i64dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddhn_i64dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vm0 | vn0) & 1;
}

template <	typename	ARCH>
OpVaddl_s8<	ARCH>::OpVaddl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_s16<	ARCH>::OpVaddl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_s32<	ARCH>::OpVaddl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_u8<	ARCH>::OpVaddl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_u16<	ARCH>::OpVaddl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_u32<	ARCH>::OpVaddl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddw_s8<	ARCH>::OpVaddw_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_s16<	ARCH>::OpVaddw_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_s32<	ARCH>::OpVaddw_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_u8<	ARCH>::OpVaddw_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_u16<	ARCH>::OpVaddw_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_u32<	ARCH>::OpVaddw_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVand<	ARCH>::OpVand(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vand")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVbic<	ARCH>::OpVbic(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbic")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVbic_i16i<	ARCH>::OpVbic_i16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbic_i16i")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 9) & 0x1) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVbic_i32i<	ARCH>::OpVbic_i32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbic_i32i")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 9) & 0x3) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVbif<	ARCH>::OpVbif(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbif")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVbit<	ARCH>::OpVbit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbit")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVbsl<	ARCH>::OpVbsl(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbsl")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVceq_f32<	ARCH>::OpVceq_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVceq_f8z<	ARCH>::OpVceq_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_f8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_f16z<	ARCH>::OpVceq_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_f16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_f32z<	ARCH>::OpVceq_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_f32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_i8z<	ARCH>::OpVceq_i8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_i16z<	ARCH>::OpVceq_i16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_i32z<	ARCH>::OpVceq_i32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_i8<	ARCH>::OpVceq_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVceq_i16<	ARCH>::OpVceq_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVceq_i32<	ARCH>::OpVceq_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_f8z<	ARCH>::OpVcge_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_f8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_f16z<	ARCH>::OpVcge_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_f16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_f32<	ARCH>::OpVcge_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_f32z<	ARCH>::OpVcge_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_f32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_s8z<	ARCH>::OpVcge_s8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_s16z<	ARCH>::OpVcge_s16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_s32z<	ARCH>::OpVcge_s32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_s8<	ARCH>::OpVcge_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_s16<	ARCH>::OpVcge_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_s32<	ARCH>::OpVcge_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_u8<	ARCH>::OpVcge_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_u16<	ARCH>::OpVcge_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_u32<	ARCH>::OpVcge_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_f8z<	ARCH>::OpVcgt_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_f8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_f16z<	ARCH>::OpVcgt_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_f16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_f32z<	ARCH>::OpVcgt_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_f32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_f32<	ARCH>::OpVcgt_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_s8z<	ARCH>::OpVcgt_s8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_s16z<	ARCH>::OpVcgt_s16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_s32z<	ARCH>::OpVcgt_s32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_s8<	ARCH>::OpVcgt_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_s16<	ARCH>::OpVcgt_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_s32<	ARCH>::OpVcgt_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_u8<	ARCH>::OpVcgt_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_u16<	ARCH>::OpVcgt_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_u32<	ARCH>::OpVcgt_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcle_f8z<	ARCH>::OpVcle_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_f8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_f16z<	ARCH>::OpVcle_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_f16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_f32z<	ARCH>::OpVcle_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_f32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_s8z<	ARCH>::OpVcle_s8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_s8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_s16z<	ARCH>::OpVcle_s16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_s16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_s32z<	ARCH>::OpVcle_s32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_s32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcls_s8<	ARCH>::OpVcls_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcls_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcls_s16<	ARCH>::OpVcls_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcls_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcls_s32<	ARCH>::OpVcls_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcls_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_f8z<	ARCH>::OpVclt_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_f8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_f16z<	ARCH>::OpVclt_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_f16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_f32z<	ARCH>::OpVclt_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_f32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_s8z<	ARCH>::OpVclt_s8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_s8z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_s16z<	ARCH>::OpVclt_s16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_s16z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_s32z<	ARCH>::OpVclt_s32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_s32z")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclz_i8<	ARCH>::OpVclz_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclz_i8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclz_i16<	ARCH>::OpVclz_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclz_i16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclz_i32<	ARCH>::OpVclz_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclz_i32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcnt_8<	ARCH>::OpVcnt_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcnt_8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_f16_f32<	ARCH>::OpVcvt_f16_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f16_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVcvt_f32_f16<	ARCH>::OpVcvt_f32_f16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32_f16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVcvt_f32_s32<	ARCH>::OpVcvt_f32_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_f32s32vi<	ARCH>::OpVcvt_f32s32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32s32vi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm = 32-imm_;
	vd = vd1|vd0;
	vm = vm1|vm0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_f32u32v<	ARCH>::OpVcvt_f32u32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_f32u32vi<	ARCH>::OpVcvt_f32u32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u32vi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_s32_f32<	ARCH>::OpVcvt_s32_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_s32f32vi<	ARCH>::OpVcvt_s32f32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f32vi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm = 32-imm_;
	vd = vd1|vd0;
	vm = vm1|vm0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_u32f32v<	ARCH>::OpVcvt_u32f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_u32f32vi<	ARCH>::OpVcvt_u32f32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f32vi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVdup_8dp<	ARCH>::OpVdup_8dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup_8dp")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	part = uint8_t((code >> 17) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVdup_16dp<	ARCH>::OpVdup_16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup_16dp")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	part = uint8_t((code >> 18) & 0x3);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVdup_32dp<	ARCH>::OpVdup_32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup_32dp")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	part = uint8_t((code >> 19) & 0x1);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVeor<	ARCH>::OpVeor(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "veor")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVext_8i<	ARCH>::OpVext_8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vext_8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	imm = uint8_t((code >> 8) & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q or imm>>3 & ~q;
}

template <	typename	ARCH>
OpVfma_f32v<	ARCH>::OpVfma_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfma_f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVfms_f32v<	ARCH>::OpVfms_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfms_f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_s8<	ARCH>::OpVhadd_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_s16<	ARCH>::OpVhadd_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_s32<	ARCH>::OpVhadd_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_u8<	ARCH>::OpVhadd_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_u16<	ARCH>::OpVhadd_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_u32<	ARCH>::OpVhadd_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_s8<	ARCH>::OpVhsub_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_s16<	ARCH>::OpVhsub_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_s32<	ARCH>::OpVhsub_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_u8<	ARCH>::OpVhsub_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_u16<	ARCH>::OpVhsub_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_u32<	ARCH>::OpVhsub_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVldms_8<	ARCH>::OpVldms_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	opcode = uint8_t((code >> 8) & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVldms_16<	ARCH>::OpVldms_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	opcode = uint8_t((code >> 8) & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVldms_32<	ARCH>::OpVldms_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	opcode = uint8_t((code >> 8) & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVldms_64<	ARCH>::OpVldms_64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms_64")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	opcode = uint8_t((code >> 8) & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = not vms.ses or align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVldms2s_8<	ARCH>::OpVldms2s_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms2s_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	rlist = uint8_t((code >> 10) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVldms2s_16<	ARCH>::OpVldms2s_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms2s_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	rlist = uint8_t((code >> 10) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVldms2s_32<	ARCH>::OpVldms2s_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms2s_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	rlist = uint8_t((code >> 10) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVld2_8<	ARCH>::OpVld2_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vld2_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVld2_16<	ARCH>::OpVld2_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vld2_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVld2_32<	ARCH>::OpVld2_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vld2_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVldal_8<	ARCH>::OpVldal_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldal_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	ds = uint8_t((code >> 5) & 0x1);
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldal_16<	ARCH>::OpVldal_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldal_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	ds = uint8_t((code >> 5) & 0x1);
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldal_32<	ARCH>::OpVldal_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldal_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	ds = uint8_t((code >> 5) & 0x1);
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldqal_8<	ARCH>::OpVldqal_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldqal_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	reject = align or vd > 30;
}

template <	typename	ARCH>
OpVldqal_16<	ARCH>::OpVldqal_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldqal_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	reject = vd > 30;
}

template <	typename	ARCH>
OpVldqal_32<	ARCH>::OpVldqal_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldqal_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	reject = vd > 30;
}

template <	typename	ARCH>
OpVldsl_8<	ARCH>::OpVldsl_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldsl_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	part = uint8_t((code >> 5) & 0x7);
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = align*(regs+1);
	reject = alignment & (alignment-1);
}

template <	typename	ARCH>
OpVldsl_16<	ARCH>::OpVldsl_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldsl_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	ds = uint8_t((code >> 5) & 0x1);
	part = uint8_t((code >> 6) & 0x3);
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = align*2*(regs+1);
	reject = (ds and regs == 0) or (alignment & (alignment-1));
}

template <	typename	ARCH>
OpVldsl_32<	ARCH>::OpVldsl_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldsl_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	ds = uint8_t((code >> 6) & 0x1);
	part = uint8_t((code >> 7) & 0x1);
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = align==3 ? 4 : align==2 ? 16 : align==1 ? 8 : 0;
	reject = (ds and regs == 0) or ((0x8ec6 >> 4*regs >> align) & 1);
}

template <	typename	ARCH>
OpVmax_f32<	ARCH>::OpVmax_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_s8<	ARCH>::OpVmax_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_s16<	ARCH>::OpVmax_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_s32<	ARCH>::OpVmax_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_u8<	ARCH>::OpVmax_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_u16<	ARCH>::OpVmax_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_u32<	ARCH>::OpVmax_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_f32<	ARCH>::OpVmin_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_s8<	ARCH>::OpVmin_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_s16<	ARCH>::OpVmin_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_s32<	ARCH>::OpVmin_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_u8<	ARCH>::OpVmin_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_u16<	ARCH>::OpVmin_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_u32<	ARCH>::OpVmin_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmla_f32v<	ARCH>::OpVmla_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmla_f32dp<	ARCH>::OpVmla_f32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_f32dp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVml_i8<	ARCH>::OpVml_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vml_i8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	sub = uint8_t((code >> 24) & 0x1);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVml_i16<	ARCH>::OpVml_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vml_i16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	sub = uint8_t((code >> 24) & 0x1);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVml_i32<	ARCH>::OpVml_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vml_i32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	sub = uint8_t((code >> 24) & 0x1);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmla_i16dp<	ARCH>::OpVmla_i16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_i16dp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmla_i32dp<	ARCH>::OpVmla_i32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_i32dp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmll_s8qd<	ARCH>::OpVmll_s8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_s8qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	sub = uint8_t((code >> 9) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_s16qd<	ARCH>::OpVmll_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_s16qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	sub = uint8_t((code >> 9) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_s32qd<	ARCH>::OpVmll_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_s32qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	sub = uint8_t((code >> 9) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_u8qd<	ARCH>::OpVmll_u8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_u8qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	sub = uint8_t((code >> 9) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_u16qd<	ARCH>::OpVmll_u16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_u16qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	sub = uint8_t((code >> 9) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_u32qd<	ARCH>::OpVmll_u32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_u32qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	sub = uint8_t((code >> 9) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlal_s16qdp<	ARCH>::OpVmlal_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlal_s16qdp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlal_s32qdp<	ARCH>::OpVmlal_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlal_s32qdp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlal_u16qdp<	ARCH>::OpVmlal_u16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlal_u16qdp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlal_u32qdp<	ARCH>::OpVmlal_u32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlal_u32qdp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmls_f16dp<	ARCH>::OpVmls_f16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f16dp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmls_f32v<	ARCH>::OpVmls_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmls_f32dp<	ARCH>::OpVmls_f32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f32dp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmls_i16dp<	ARCH>::OpVmls_i16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_i16dp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmls_i32dp<	ARCH>::OpVmls_i32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_i32dp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmlsl_s16qdp<	ARCH>::OpVmlsl_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlsl_s16qdp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlsl_s32qdp<	ARCH>::OpVmlsl_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlsl_s32qdp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlsl_u16qdp<	ARCH>::OpVmlsl_u16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlsl_u16qdp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlsl_u32qdp<	ARCH>::OpVmlsl_u32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlsl_u32qdp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmov_f32vi<	ARCH>::OpVmov_f32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f32vi")
{
	man = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	exp = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	n = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	fpimm = (n?-1:1)*(float((0x10+man)<<(exp^4))/128);
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i8i<	ARCH>::OpVmov_i8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i8i")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = imm2|imm1|imm0;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i16i<	ARCH>::OpVmov_i16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i16i")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 9) & 0x1) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i32i<	ARCH>::OpVmov_i32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i32i")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 9) & 0x3) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i64i<	ARCH>::OpVmov_i64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i64i")
{
	h = uint8_t(code & 0x1);
	g = uint8_t((code >> 1) & 0x1);
	f = uint8_t((code >> 2) & 0x1);
	e = uint8_t((code >> 3) & 0x1);
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	d = uint8_t((code >> 16) & 0x1);
	c = uint8_t((code >> 17) & 0x1);
	b = uint8_t((code >> 18) & 0x1);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	a = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	imm = ((uint64_t(a)<<56)|(uint64_t(b)<<48)|(uint64_t(c)<<40)|(uint64_t(d)<<32)|(uint64_t(e)<<24)|(uint64_t(f)<<16)|(uint64_t(g)<<8)|(uint64_t(h)<<0))*0xff;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i32in<	ARCH>::OpVmov_i32in(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i32in")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 8) & 0x1) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (((imm2|imm1|imm0)+1) << (shift+8))-1;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmovl_s8<	ARCH>::OpVmovl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_s16<	ARCH>::OpVmovl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_s32<	ARCH>::OpVmovl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_u8<	ARCH>::OpVmovl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_u16<	ARCH>::OpVmovl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_u32<	ARCH>::OpVmovl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovn_i16<	ARCH>::OpVmovn_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovn_i16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVmovn_i32<	ARCH>::OpVmovn_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovn_i32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVmovn_i64<	ARCH>::OpVmovn_i64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovn_i64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVmul_f32v<	ARCH>::OpVmul_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_f32dp<	ARCH>::OpVmul_f32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_f32dp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmul_i8<	ARCH>::OpVmul_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_i16<	ARCH>::OpVmul_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_i32<	ARCH>::OpVmul_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_i16dp<	ARCH>::OpVmul_i16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i16dp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmul_i32dp<	ARCH>::OpVmul_i32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i32dp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmul_p8<	ARCH>::OpVmul_p8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_p8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_p16<	ARCH>::OpVmul_p16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_p16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_p32<	ARCH>::OpVmul_p32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_p32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmull_p8qd<	ARCH>::OpVmull_p8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_p8qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s8<	ARCH>::OpVmull_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s16<	ARCH>::OpVmull_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s32<	ARCH>::OpVmull_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u8<	ARCH>::OpVmull_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u16<	ARCH>::OpVmull_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u32<	ARCH>::OpVmull_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s16qdp<	ARCH>::OpVmull_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s16qdp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s32qdp<	ARCH>::OpVmull_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s32qdp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u16qdp<	ARCH>::OpVmull_u16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u16qdp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u32qdp<	ARCH>::OpVmull_u32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u32qdp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmvn_i16i<	ARCH>::OpVmvn_i16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmvn_i16i")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 9) & 0x1) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmvn_i32i<	ARCH>::OpVmvn_i32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmvn_i32i")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 9) & 0x3) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmvn_i32in<	ARCH>::OpVmvn_i32in(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmvn_i32in")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 8) & 0x1) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (((imm2|imm1|imm0)+1) << (shift+8))-1;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmvn<	ARCH>::OpVmvn(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmvn")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_f8<	ARCH>::OpVneg_f8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_f16<	ARCH>::OpVneg_f16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_f32v<	ARCH>::OpVneg_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_s8<	ARCH>::OpVneg_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_s16<	ARCH>::OpVneg_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_s32<	ARCH>::OpVneg_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVorn<	ARCH>::OpVorn(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vorn")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVorr<	ARCH>::OpVorr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vorr")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVorr_i16i<	ARCH>::OpVorr_i16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vorr_i16i")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 9) & 0x1) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVorr_i32i<	ARCH>::OpVorr_i32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vorr_i32i")
{
	imm0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 6) & 0x1);
	shift = uint8_t((code >> 9) & 0x3) << 3;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm1 = uint8_t((code >> 16) & 0x7) << 4;
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	imm2 = uint8_t((code >> 24) & 0x1) << 7;
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVpadal_s8<	ARCH>::OpVpadal_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_s16<	ARCH>::OpVpadal_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_s32<	ARCH>::OpVpadal_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_u8<	ARCH>::OpVpadal_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_u16<	ARCH>::OpVpadal_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_u32<	ARCH>::OpVpadal_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadd_f32<	ARCH>::OpVpadd_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadd_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpadd_i8<	ARCH>::OpVpadd_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadd_i8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q or q;
}

template <	typename	ARCH>
OpVpadd_i16<	ARCH>::OpVpadd_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadd_i16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q or q;
}

template <	typename	ARCH>
OpVpadd_i32<	ARCH>::OpVpadd_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadd_i32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q or q;
}

template <	typename	ARCH>
OpVpaddl_s8<	ARCH>::OpVpaddl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_s16<	ARCH>::OpVpaddl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_s32<	ARCH>::OpVpaddl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_u8<	ARCH>::OpVpaddl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_u16<	ARCH>::OpVpaddl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_u32<	ARCH>::OpVpaddl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpmax_f32<	ARCH>::OpVpmax_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_s8<	ARCH>::OpVpmax_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_s16<	ARCH>::OpVpmax_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_s32<	ARCH>::OpVpmax_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_u8<	ARCH>::OpVpmax_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_u16<	ARCH>::OpVpmax_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_u32<	ARCH>::OpVpmax_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_f32<	ARCH>::OpVpmin_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_s8<	ARCH>::OpVpmin_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_s16<	ARCH>::OpVpmin_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_s32<	ARCH>::OpVpmin_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_u8<	ARCH>::OpVpmin_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_u16<	ARCH>::OpVpmin_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_u32<	ARCH>::OpVpmin_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqabs_s8<	ARCH>::OpVqabs_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqabs_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqabs_s16<	ARCH>::OpVqabs_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqabs_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqabs_s32<	ARCH>::OpVqabs_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqabs_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqadd_s8<	ARCH>::OpVqadd_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_s16<	ARCH>::OpVqadd_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_s32<	ARCH>::OpVqadd_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_s64<	ARCH>::OpVqadd_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_s64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_u8<	ARCH>::OpVqadd_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_u16<	ARCH>::OpVqadd_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_u32<	ARCH>::OpVqadd_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_u64<	ARCH>::OpVqadd_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_u64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqdmlal_s16qd<	ARCH>::OpVqdmlal_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlal_s16qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlal_s16qdp<	ARCH>::OpVqdmlal_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlal_s16qdp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlal_s32qd<	ARCH>::OpVqdmlal_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlal_s32qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlal_s32qdp<	ARCH>::OpVqdmlal_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlal_s32qdp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlsl_s16qd<	ARCH>::OpVqdmlsl_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlsl_s16qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlsl_s16qdp<	ARCH>::OpVqdmlsl_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlsl_s16qdp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlsl_s32qd<	ARCH>::OpVqdmlsl_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlsl_s32qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlsl_s32qdp<	ARCH>::OpVqdmlsl_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlsl_s32qdp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmulh_s16<	ARCH>::OpVqdmulh_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmulh_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqdmulh_s16dp<	ARCH>::OpVqdmulh_s16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmulh_s16dp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVqdmulh_s32<	ARCH>::OpVqdmulh_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmulh_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqdmulh_s32dp<	ARCH>::OpVqdmulh_s32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmulh_s32dp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVqdmull_s16qd<	ARCH>::OpVqdmull_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmull_s16qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmull_s16qdp<	ARCH>::OpVqdmull_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmull_s16qdp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmull_s32qd<	ARCH>::OpVqdmull_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmull_s32qd")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmull_s32qdp<	ARCH>::OpVqdmull_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmull_s32qdp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqmovn_s16<	ARCH>::OpVqmovn_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_s32<	ARCH>::OpVqmovn_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_s64<	ARCH>::OpVqmovn_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_s64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_u16<	ARCH>::OpVqmovn_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_u32<	ARCH>::OpVqmovn_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_u64<	ARCH>::OpVqmovn_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_u64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovun_s16<	ARCH>::OpVqmovun_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovun_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovun_s32<	ARCH>::OpVqmovun_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovun_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovun_s64<	ARCH>::OpVqmovun_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovun_s64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqneg_s8<	ARCH>::OpVqneg_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqneg_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqneg_s16<	ARCH>::OpVqneg_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqneg_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqneg_s32<	ARCH>::OpVqneg_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqneg_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqrdmulh_s16<	ARCH>::OpVqrdmulh_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrdmulh_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrdmulh_s16dp<	ARCH>::OpVqrdmulh_s16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrdmulh_s16dp")
{
	vm = uint8_t(code & 0x7);
	part0 = uint8_t((code >> 3) & 0x1);
	part1 = uint8_t((code >> 5) & 0x1) << 1;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVqrdmulh_s32<	ARCH>::OpVqrdmulh_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrdmulh_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrdmulh_s32dp<	ARCH>::OpVqrdmulh_s32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrdmulh_s32dp")
{
	vm = uint8_t(code & 0xf);
	part = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	q = uint8_t((code >> 24) & 0x1);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_s8<	ARCH>::OpVqrshl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_s16<	ARCH>::OpVqrshl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_s32<	ARCH>::OpVqrshl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_s64<	ARCH>::OpVqrshl_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_s64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_u8<	ARCH>::OpVqrshl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_u16<	ARCH>::OpVqrshl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_u32<	ARCH>::OpVqrshl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_u64<	ARCH>::OpVqrshl_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_u64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshrn_s16dqi<	ARCH>::OpVqrshrn_s16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_s16dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_s32dqi<	ARCH>::OpVqrshrn_s32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_s32dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_s64dqi<	ARCH>::OpVqrshrn_s64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_s64dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_u16dqi<	ARCH>::OpVqrshrn_u16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_u16dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_u32dqi<	ARCH>::OpVqrshrn_u32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_u32dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_u64dqi<	ARCH>::OpVqrshrn_u64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_u64dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrun_s16dqi<	ARCH>::OpVqrshrun_s16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrun_s16dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrun_s32dqi<	ARCH>::OpVqrshrun_s32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrun_s32dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrun_s64dqi<	ARCH>::OpVqrshrun_s64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrun_s64dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshl_s8<	ARCH>::OpVqshl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_s8i<	ARCH>::OpVqshl_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_s16<	ARCH>::OpVqshl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_s16i<	ARCH>::OpVqshl_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_s32<	ARCH>::OpVqshl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_s32i<	ARCH>::OpVqshl_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_s64<	ARCH>::OpVqshl_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_s64i<	ARCH>::OpVqshl_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_u8<	ARCH>::OpVqshl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_u8i<	ARCH>::OpVqshl_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_u16<	ARCH>::OpVqshl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_u16i<	ARCH>::OpVqshl_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_u32<	ARCH>::OpVqshl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_u32i<	ARCH>::OpVqshl_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_u64<	ARCH>::OpVqshl_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_u64i<	ARCH>::OpVqshl_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshlu_s8i<	ARCH>::OpVqshlu_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshlu_s8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshlu_s16i<	ARCH>::OpVqshlu_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshlu_s16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshlu_s32i<	ARCH>::OpVqshlu_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshlu_s32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshlu_s64i<	ARCH>::OpVqshlu_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshlu_s64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshrn_s16dqi<	ARCH>::OpVqshrn_s16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_s16dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_s32dqi<	ARCH>::OpVqshrn_s32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_s32dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_s64dqi<	ARCH>::OpVqshrn_s64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_s64dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_u16dqi<	ARCH>::OpVqshrn_u16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_u16dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_u32dqi<	ARCH>::OpVqshrn_u32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_u32dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_u64dqi<	ARCH>::OpVqshrn_u64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_u64dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrun_s16dqi<	ARCH>::OpVqshrun_s16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrun_s16dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrun_s32dqi<	ARCH>::OpVqshrun_s32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrun_s32dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrun_s64dqi<	ARCH>::OpVqshrun_s64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrun_s64dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqsub_s8<	ARCH>::OpVqsub_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_s16<	ARCH>::OpVqsub_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_s32<	ARCH>::OpVqsub_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_s64<	ARCH>::OpVqsub_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_s64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_u8<	ARCH>::OpVqsub_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_u16<	ARCH>::OpVqsub_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_u32<	ARCH>::OpVqsub_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_u64<	ARCH>::OpVqsub_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_u64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVraddhn_i16dq<	ARCH>::OpVraddhn_i16dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vraddhn_i16dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVraddhn_i32dq<	ARCH>::OpVraddhn_i32dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vraddhn_i32dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVraddhn_i64dq<	ARCH>::OpVraddhn_i64dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vraddhn_i64dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVrecpe_f32<	ARCH>::OpVrecpe_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrecpe_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrecpe_u32<	ARCH>::OpVrecpe_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrecpe_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrecps_f32<	ARCH>::OpVrecps_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrecps_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrev_8<	ARCH>::OpVrev_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrev_8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	op = uint8_t((code >> 7) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or op > 2;
}

template <	typename	ARCH>
OpVrev_16<	ARCH>::OpVrev_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrev_16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	op = uint8_t((code >> 7) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or op > 1;
}

template <	typename	ARCH>
OpVrev_32<	ARCH>::OpVrev_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrev_32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	op = uint8_t((code >> 7) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or op > 0;
}

template <	typename	ARCH>
OpVrhadd_s8<	ARCH>::OpVrhadd_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_s16<	ARCH>::OpVrhadd_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_s32<	ARCH>::OpVrhadd_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_u8<	ARCH>::OpVrhadd_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_u16<	ARCH>::OpVrhadd_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_u32<	ARCH>::OpVrhadd_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_s8<	ARCH>::OpVrshl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_s16<	ARCH>::OpVrshl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_s32<	ARCH>::OpVrshl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_s64<	ARCH>::OpVrshl_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_s64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_u8<	ARCH>::OpVrshl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_u16<	ARCH>::OpVrshl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_u32<	ARCH>::OpVrshl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_u64<	ARCH>::OpVrshl_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_u64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshr_s8i<	ARCH>::OpVrshr_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_s8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_s16i<	ARCH>::OpVrshr_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_s16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_s32i<	ARCH>::OpVrshr_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_s32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrshr_s64i<	ARCH>::OpVrshr_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_s64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_u8i<	ARCH>::OpVrshr_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_u8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_u16i<	ARCH>::OpVrshr_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_u16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_u32i<	ARCH>::OpVrshr_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_u32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrshr_u64i<	ARCH>::OpVrshr_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_u64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshrn_i16dqi<	ARCH>::OpVrshrn_i16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshrn_i16dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVrshrn_i32dqi<	ARCH>::OpVrshrn_i32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshrn_i32dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVrshrn_i64dqi<	ARCH>::OpVrshrn_i64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshrn_i64dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVrsqrte_f32<	ARCH>::OpVrsqrte_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsqrte_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrsqrte_u32<	ARCH>::OpVrsqrte_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsqrte_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrsqrts_f32<	ARCH>::OpVrsqrts_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsqrts_f32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrsra_s8i<	ARCH>::OpVrsra_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_s8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_s16i<	ARCH>::OpVrsra_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_s16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_s32i<	ARCH>::OpVrsra_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_s32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrsra_s64i<	ARCH>::OpVrsra_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_s64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_u8i<	ARCH>::OpVrsra_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_u8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_u16i<	ARCH>::OpVrsra_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_u16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_u32i<	ARCH>::OpVrsra_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_u32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrsra_u64i<	ARCH>::OpVrsra_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_u64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsubhn_i16dq<	ARCH>::OpVrsubhn_i16dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsubhn_i16dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVrsubhn_i32dq<	ARCH>::OpVrsubhn_i32dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsubhn_i32dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVrsubhn_i64dq<	ARCH>::OpVrsubhn_i64dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsubhn_i64dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVshl_s8i<	ARCH>::OpVshl_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshl_s16i<	ARCH>::OpVshl_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshl_s32i<	ARCH>::OpVshl_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshl_s64i<	ARCH>::OpVshl_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshl_s8<	ARCH>::OpVshl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_s16<	ARCH>::OpVshl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_s32<	ARCH>::OpVshl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_s64<	ARCH>::OpVshl_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_u8<	ARCH>::OpVshl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_u16<	ARCH>::OpVshl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_u32<	ARCH>::OpVshl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_u64<	ARCH>::OpVshl_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_u64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshll_i8<	ARCH>::OpVshll_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_i8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_i16<	ARCH>::OpVshll_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_i16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_i32<	ARCH>::OpVshll_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_i32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshr_s8i<	ARCH>::OpVshr_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_s8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_s16i<	ARCH>::OpVshr_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_s16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_s32i<	ARCH>::OpVshr_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_s32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVshr_s64i<	ARCH>::OpVshr_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_s64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_u8i<	ARCH>::OpVshr_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_u8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_u16i<	ARCH>::OpVshr_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_u16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_u32i<	ARCH>::OpVshr_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_u32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVshr_u64i<	ARCH>::OpVshr_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_u64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshrn_i16dqi<	ARCH>::OpVshrn_i16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshrn_i16dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVshrn_i32dqi<	ARCH>::OpVshrn_i32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshrn_i32dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVshrn_i64dqi<	ARCH>::OpVshrn_i64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshrn_i64dqi")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVsli_8i<	ARCH>::OpVsli_8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsli_8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsli_16i<	ARCH>::OpVsli_16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsli_16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsli_32i<	ARCH>::OpVsli_32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsli_32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsli_64i<	ARCH>::OpVsli_64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsli_64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_s8i<	ARCH>::OpVsra_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_s8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_s16i<	ARCH>::OpVsra_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_s16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_s32i<	ARCH>::OpVsra_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_s32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVsra_s64i<	ARCH>::OpVsra_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_s64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_u8i<	ARCH>::OpVsra_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_u8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_u16i<	ARCH>::OpVsra_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_u16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_u32i<	ARCH>::OpVsra_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_u32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVsra_u64i<	ARCH>::OpVsra_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_u64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsri_8i<	ARCH>::OpVsri_8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsri_8i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x7);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsri_16i<	ARCH>::OpVsri_16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsri_16i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsri_32i<	ARCH>::OpVsri_32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsri_32i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x1f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVsri_64i<	ARCH>::OpVsri_64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsri_64i")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	imm_ = uint8_t((code >> 16) & 0x3f);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVstms_8<	ARCH>::OpVstms_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	opcode = uint8_t((code >> 8) & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVstms_16<	ARCH>::OpVstms_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	opcode = uint8_t((code >> 8) & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVstms_32<	ARCH>::OpVstms_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	opcode = uint8_t((code >> 8) & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVstms_64<	ARCH>::OpVstms_64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms_64")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	opcode = uint8_t((code >> 8) & 0xf);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = not vms.ses or align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVstms2s_8<	ARCH>::OpVstms2s_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms2s_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	rlist = uint8_t((code >> 10) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVstms2s_16<	ARCH>::OpVstms2s_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms2s_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	rlist = uint8_t((code >> 10) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVstms2s_32<	ARCH>::OpVstms2s_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms2s_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	rlist = uint8_t((code >> 10) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVst2_8<	ARCH>::OpVst2_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vst2_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVst2_16<	ARCH>::OpVst2_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vst2_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVst2_32<	ARCH>::OpVst2_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vst2_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVstsl_8<	ARCH>::OpVstsl_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstsl_8")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	part = uint8_t((code >> 5) & 0x7);
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = align*(regs+1);
	reject = alignment & (alignment-1) or alignment == 1 or (vd+regs) >= 32;
}

template <	typename	ARCH>
OpVstsl_16<	ARCH>::OpVstsl_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstsl_16")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x1);
	ds = uint8_t((code >> 5) & 0x1);
	part = uint8_t((code >> 6) & 0x3);
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = align*2*(regs+1);
	reject = (ds and regs == 0) or (alignment & (alignment-1)) or (vd+(regs<<ds)) >= 32;
}

template <	typename	ARCH>
OpVstsl_32<	ARCH>::OpVstsl_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstsl_32")
{
	rm = uint8_t(code & 0xf);
	align = uint8_t((code >> 4) & 0x3);
	ds = uint8_t((code >> 6) & 0x1);
	part = uint8_t((code >> 7) & 0x1);
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	rn = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vd = vd1|vd0;
	alignment = align==3 ? 4 : align==2 ? 16 : align==1 ? 8 : 0;
	reject = (ds and regs == 0) or ((0x8ec6 >> 4*regs >> align) & 1) or (vd+(regs<<ds)) >= 32;
}

template <	typename	ARCH>
OpVsub_f32v<	ARCH>::OpVsub_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_f32v")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsub_i8<	ARCH>::OpVsub_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_i8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsub_i16<	ARCH>::OpVsub_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_i16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsub_i32<	ARCH>::OpVsub_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_i32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsub_i64<	ARCH>::OpVsub_i64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_i64")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsubhn_i16dq<	ARCH>::OpVsubhn_i16dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubhn_i16dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVsubhn_i32dq<	ARCH>::OpVsubhn_i32dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubhn_i32dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVsubhn_i64dq<	ARCH>::OpVsubhn_i64dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubhn_i64dq")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVsubl_s8<	ARCH>::OpVsubl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_s16<	ARCH>::OpVsubl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_s32<	ARCH>::OpVsubl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_u8<	ARCH>::OpVsubl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_u16<	ARCH>::OpVsubl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_u32<	ARCH>::OpVsubl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubw_s8<	ARCH>::OpVsubw_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_s8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_s16<	ARCH>::OpVsubw_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_s16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_s32<	ARCH>::OpVsubw_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_s32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_u8<	ARCH>::OpVsubw_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_u8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_u16<	ARCH>::OpVsubw_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_u16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_u32<	ARCH>::OpVsubw_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_u32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVswp<	ARCH>::OpVswp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vswp")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVtbl_8d<	ARCH>::OpVtbl_8d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtbl_8d")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vn+regs >= 32;
}

template <	typename	ARCH>
OpVtbx_8d<	ARCH>::OpVtbx_8d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtbx_8d")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	regs = uint8_t((code >> 8) & 0x3);
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vn+regs >= 32;
}

template <	typename	ARCH>
OpVtrn_8<	ARCH>::OpVtrn_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtrn_8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVtrn_16<	ARCH>::OpVtrn_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtrn_16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVtrn_32<	ARCH>::OpVtrn_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtrn_32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVtst_i8<	ARCH>::OpVtst_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtst_i8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVtst_16<	ARCH>::OpVtst_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtst_16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVtst_32<	ARCH>::OpVtst_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtst_32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vn1 = uint8_t((code >> 7) & 0x1) << 4;
	vd0 = uint8_t((code >> 12) & 0xf);
	vn0 = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVuzp_8<	ARCH>::OpVuzp_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vuzp_8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVuzp_16<	ARCH>::OpVuzp_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vuzp_16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVuzp_32<	ARCH>::OpVuzp_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vuzp_32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = not q or (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVzip_8<	ARCH>::OpVzip_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vzip_8")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVzip_16<	ARCH>::OpVzip_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vzip_16")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVzip_32<	ARCH>::OpVzip_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vzip_32")
{
	vm0 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 5) & 0x1) << 4;
	q = uint8_t((code >> 6) & 0x1);
	vd0 = uint8_t((code >> 12) & 0xf);
	vd1 = uint8_t((code >> 22) & 0x1) << 4;
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = not q or (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
DecodeTableEntry<	ARCH>::DecodeTableEntry(CodeType opcode, CodeType opcode_mask, Operation<	ARCH> *(*decode)(CodeType, uint32_t))
{
	this->opcode = opcode;
	this->opcode_mask = opcode_mask;
	this->decode = decode;
}

template <	typename	ARCH>
Decoder<	ARCH>::Decoder()

{
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3ba0180UL, 0xffbf0f90UL, DecodeOpVzip_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b60180UL, 0xffbf0f90UL, DecodeOpVzip_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b20180UL, 0xffbf0f90UL, DecodeOpVzip_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3ba0100UL, 0xffbf0f90UL, DecodeOpVuzp_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b60100UL, 0xffbf0f90UL, DecodeOpVuzp_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b20100UL, 0xffbf0f90UL, DecodeOpVuzp_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200810UL, 0xffb00f10UL, DecodeOpVtst_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100810UL, 0xffb00f10UL, DecodeOpVtst_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000810UL, 0xffb00f10UL, DecodeOpVtst_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3ba0080UL, 0xffbf0f90UL, DecodeOpVtrn_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b60080UL, 0xffbf0f90UL, DecodeOpVtrn_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b20080UL, 0xffbf0f90UL, DecodeOpVtrn_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00840UL, 0xffb00c50UL, DecodeOpVtbx_8d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00800UL, 0xffb00c50UL, DecodeOpVtbl_8d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b20000UL, 0xffbf0f90UL, DecodeOpVswp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00300UL, 0xffb00f50UL, DecodeOpVsubw_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900300UL, 0xffb00f50UL, DecodeOpVsubw_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800300UL, 0xffb00f50UL, DecodeOpVsubw_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00300UL, 0xffb00f50UL, DecodeOpVsubw_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900300UL, 0xffb00f50UL, DecodeOpVsubw_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800300UL, 0xffb00f50UL, DecodeOpVsubw_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00200UL, 0xffb00f50UL, DecodeOpVsubl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900200UL, 0xffb00f50UL, DecodeOpVsubl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800200UL, 0xffb00f50UL, DecodeOpVsubl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00200UL, 0xffb00f50UL, DecodeOpVsubl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900200UL, 0xffb00f50UL, DecodeOpVsubl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800200UL, 0xffb00f50UL, DecodeOpVsubl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00600UL, 0xffb00f50UL, DecodeOpVsubhn_i64dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900600UL, 0xffb00f50UL, DecodeOpVsubhn_i32dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800600UL, 0xffb00f50UL, DecodeOpVsubhn_i16dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3300800UL, 0xffb00f10UL, DecodeOpVsub_i64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200800UL, 0xffb00f10UL, DecodeOpVsub_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100800UL, 0xffb00f10UL, DecodeOpVsub_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000800UL, 0xffb00f10UL, DecodeOpVsub_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200d00UL, 0xffb00f10UL, DecodeOpVsub_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4800800UL, 0xffb00c00UL, DecodeOpVstsl_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4800400UL, 0xffb00c00UL, DecodeOpVstsl_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4800000UL, 0xffb00c00UL, DecodeOpVstsl_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4000380UL, 0xffb00fc0UL, DecodeOpVst2_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4000340UL, 0xffb00fc0UL, DecodeOpVst2_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4000300UL, 0xffb00fc0UL, DecodeOpVst2_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4000180UL, 0xffb003c0UL, DecodeOpVstms2s_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4000140UL, 0xffb003c0UL, DecodeOpVstms2s_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4000100UL, 0xffb003c0UL, DecodeOpVstms2s_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf40000c0UL, 0xffb000c0UL, DecodeOpVstms_64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4000080UL, 0xffb000c0UL, DecodeOpVstms_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4000040UL, 0xffb000c0UL, DecodeOpVstms_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4000000UL, 0xffb000c0UL, DecodeOpVstms_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800490UL, 0xff800f90UL, DecodeOpVsri_64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00410UL, 0xffa00f90UL, DecodeOpVsri_32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900410UL, 0xffb00f90UL, DecodeOpVsri_16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880410UL, 0xffb80f90UL, DecodeOpVsri_8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800190UL, 0xff800f90UL, DecodeOpVsra_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00110UL, 0xffa00f90UL, DecodeOpVsra_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900110UL, 0xffb00f90UL, DecodeOpVsra_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880110UL, 0xffb80f90UL, DecodeOpVsra_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800190UL, 0xff800f90UL, DecodeOpVsra_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00110UL, 0xffa00f90UL, DecodeOpVsra_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900110UL, 0xffb00f90UL, DecodeOpVsra_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880110UL, 0xffb80f90UL, DecodeOpVsra_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800590UL, 0xff800f90UL, DecodeOpVsli_64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00510UL, 0xffa00f90UL, DecodeOpVsli_32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900510UL, 0xffb00f90UL, DecodeOpVsli_16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880510UL, 0xffb80f90UL, DecodeOpVsli_8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00810UL, 0xffa00fd0UL, DecodeOpVshrn_i64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900810UL, 0xffb00fd0UL, DecodeOpVshrn_i32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880810UL, 0xffb80fd0UL, DecodeOpVshrn_i16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800090UL, 0xff800f90UL, DecodeOpVshr_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00010UL, 0xffa00f90UL, DecodeOpVshr_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900010UL, 0xffb00f90UL, DecodeOpVshr_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880010UL, 0xffb80f90UL, DecodeOpVshr_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800090UL, 0xff800f90UL, DecodeOpVshr_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00010UL, 0xffa00f90UL, DecodeOpVshr_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900010UL, 0xffb00f90UL, DecodeOpVshr_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880010UL, 0xffb80f90UL, DecodeOpVshr_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3ba0300UL, 0xffbf0fd0UL, DecodeOpVshll_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b60300UL, 0xffbf0fd0UL, DecodeOpVshll_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b20300UL, 0xffbf0fd0UL, DecodeOpVshll_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3300400UL, 0xffb00f10UL, DecodeOpVshl_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200400UL, 0xffb00f10UL, DecodeOpVshl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100400UL, 0xffb00f10UL, DecodeOpVshl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000400UL, 0xffb00f10UL, DecodeOpVshl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2300400UL, 0xffb00f10UL, DecodeOpVshl_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200400UL, 0xffb00f10UL, DecodeOpVshl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100400UL, 0xffb00f10UL, DecodeOpVshl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000400UL, 0xffb00f10UL, DecodeOpVshl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800590UL, 0xff800f90UL, DecodeOpVshl_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00510UL, 0xffa00f90UL, DecodeOpVshl_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900510UL, 0xffb00f90UL, DecodeOpVshl_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880510UL, 0xffb80f90UL, DecodeOpVshl_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00600UL, 0xffb00f50UL, DecodeOpVrsubhn_i64dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900600UL, 0xffb00f50UL, DecodeOpVrsubhn_i32dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800600UL, 0xffb00f50UL, DecodeOpVrsubhn_i16dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800390UL, 0xff800f90UL, DecodeOpVrsra_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00310UL, 0xffa00f90UL, DecodeOpVrsra_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900310UL, 0xffb00f90UL, DecodeOpVrsra_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880310UL, 0xffb80f90UL, DecodeOpVrsra_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800390UL, 0xff800f90UL, DecodeOpVrsra_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00310UL, 0xffa00f90UL, DecodeOpVrsra_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900310UL, 0xffb00f90UL, DecodeOpVrsra_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880310UL, 0xffb80f90UL, DecodeOpVrsra_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200f10UL, 0xffb00f10UL, DecodeOpVrsqrts_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3bb0480UL, 0xffbf0f90UL, DecodeOpVrsqrte_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3bb0580UL, 0xffbf0f90UL, DecodeOpVrsqrte_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00850UL, 0xffa00fd0UL, DecodeOpVrshrn_i64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900850UL, 0xffb00fd0UL, DecodeOpVrshrn_i32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880850UL, 0xffb80fd0UL, DecodeOpVrshrn_i16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800290UL, 0xff800f90UL, DecodeOpVrshr_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00210UL, 0xffa00f90UL, DecodeOpVrshr_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900210UL, 0xffb00f90UL, DecodeOpVrshr_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880210UL, 0xffb80f90UL, DecodeOpVrshr_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800290UL, 0xff800f90UL, DecodeOpVrshr_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00210UL, 0xffa00f90UL, DecodeOpVrshr_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900210UL, 0xffb00f90UL, DecodeOpVrshr_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880210UL, 0xffb80f90UL, DecodeOpVrshr_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3300500UL, 0xffb00f10UL, DecodeOpVrshl_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200500UL, 0xffb00f10UL, DecodeOpVrshl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100500UL, 0xffb00f10UL, DecodeOpVrshl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000500UL, 0xffb00f10UL, DecodeOpVrshl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2300500UL, 0xffb00f10UL, DecodeOpVrshl_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200500UL, 0xffb00f10UL, DecodeOpVrshl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100500UL, 0xffb00f10UL, DecodeOpVrshl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000500UL, 0xffb00f10UL, DecodeOpVrshl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200100UL, 0xffb00f10UL, DecodeOpVrhadd_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100100UL, 0xffb00f10UL, DecodeOpVrhadd_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000100UL, 0xffb00f10UL, DecodeOpVrhadd_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200100UL, 0xffb00f10UL, DecodeOpVrhadd_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100100UL, 0xffb00f10UL, DecodeOpVrhadd_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000100UL, 0xffb00f10UL, DecodeOpVrhadd_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b80000UL, 0xffbf0e10UL, DecodeOpVrev_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40000UL, 0xffbf0e10UL, DecodeOpVrev_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00000UL, 0xffbf0e10UL, DecodeOpVrev_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000f10UL, 0xffb00f10UL, DecodeOpVrecps_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3bb0400UL, 0xffbf0f90UL, DecodeOpVrecpe_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3bb0500UL, 0xffbf0f90UL, DecodeOpVrecpe_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00400UL, 0xffb00f50UL, DecodeOpVraddhn_i64dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900400UL, 0xffb00f50UL, DecodeOpVraddhn_i32dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800400UL, 0xffb00f50UL, DecodeOpVraddhn_i16dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3300210UL, 0xffb00f10UL, DecodeOpVqsub_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200210UL, 0xffb00f10UL, DecodeOpVqsub_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100210UL, 0xffb00f10UL, DecodeOpVqsub_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000210UL, 0xffb00f10UL, DecodeOpVqsub_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2300210UL, 0xffb00f10UL, DecodeOpVqsub_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200210UL, 0xffb00f10UL, DecodeOpVqsub_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100210UL, 0xffb00f10UL, DecodeOpVqsub_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000210UL, 0xffb00f10UL, DecodeOpVqsub_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00810UL, 0xffa00fd0UL, DecodeOpVqshrun_s64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900810UL, 0xffb00fd0UL, DecodeOpVqshrun_s32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880810UL, 0xffb80fd0UL, DecodeOpVqshrun_s16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00910UL, 0xffa00fd0UL, DecodeOpVqshrn_u64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900910UL, 0xffb00fd0UL, DecodeOpVqshrn_u32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880910UL, 0xffb80fd0UL, DecodeOpVqshrn_u16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00910UL, 0xffa00fd0UL, DecodeOpVqshrn_s64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900910UL, 0xffb00fd0UL, DecodeOpVqshrn_s32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880910UL, 0xffb80fd0UL, DecodeOpVqshrn_s16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800690UL, 0xff800f90UL, DecodeOpVqshlu_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00610UL, 0xffa00f90UL, DecodeOpVqshlu_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900610UL, 0xffb00f90UL, DecodeOpVqshlu_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880610UL, 0xffb80f90UL, DecodeOpVqshlu_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800790UL, 0xff800f90UL, DecodeOpVqshl_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3300410UL, 0xffb00f10UL, DecodeOpVqshl_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00710UL, 0xffa00f90UL, DecodeOpVqshl_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200410UL, 0xffb00f10UL, DecodeOpVqshl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900710UL, 0xffb00f90UL, DecodeOpVqshl_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100410UL, 0xffb00f10UL, DecodeOpVqshl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880710UL, 0xffb80f90UL, DecodeOpVqshl_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000410UL, 0xffb00f10UL, DecodeOpVqshl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800790UL, 0xff800f90UL, DecodeOpVqshl_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2300410UL, 0xffb00f10UL, DecodeOpVqshl_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00710UL, 0xffa00f90UL, DecodeOpVqshl_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200410UL, 0xffb00f10UL, DecodeOpVqshl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900710UL, 0xffb00f90UL, DecodeOpVqshl_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100410UL, 0xffb00f10UL, DecodeOpVqshl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880710UL, 0xffb80f90UL, DecodeOpVqshl_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000410UL, 0xffb00f10UL, DecodeOpVqshl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00850UL, 0xffa00fd0UL, DecodeOpVqrshrun_s64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900850UL, 0xffb00fd0UL, DecodeOpVqrshrun_s32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880850UL, 0xffb80fd0UL, DecodeOpVqrshrun_s16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00950UL, 0xffa00fd0UL, DecodeOpVqrshrn_u64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900950UL, 0xffb00fd0UL, DecodeOpVqrshrn_u32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880950UL, 0xffb80fd0UL, DecodeOpVqrshrn_u16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00950UL, 0xffa00fd0UL, DecodeOpVqrshrn_s64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900950UL, 0xffb00fd0UL, DecodeOpVqrshrn_s32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880950UL, 0xffb80fd0UL, DecodeOpVqrshrn_s16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3300510UL, 0xffb00f10UL, DecodeOpVqrshl_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200510UL, 0xffb00f10UL, DecodeOpVqrshl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100510UL, 0xffb00f10UL, DecodeOpVqrshl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000510UL, 0xffb00f10UL, DecodeOpVqrshl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2300510UL, 0xffb00f10UL, DecodeOpVqrshl_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200510UL, 0xffb00f10UL, DecodeOpVqrshl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100510UL, 0xffb00f10UL, DecodeOpVqrshl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000510UL, 0xffb00f10UL, DecodeOpVqrshl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00d40UL, 0xfeb00f50UL, DecodeOpVqrdmulh_s32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200b00UL, 0xffb00f10UL, DecodeOpVqrdmulh_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900d40UL, 0xfeb00f50UL, DecodeOpVqrdmulh_s16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100b00UL, 0xffb00f10UL, DecodeOpVqrdmulh_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b80780UL, 0xffbf0f90UL, DecodeOpVqneg_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40780UL, 0xffbf0f90UL, DecodeOpVqneg_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00780UL, 0xffbf0f90UL, DecodeOpVqneg_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3ba0240UL, 0xffbf0fd0UL, DecodeOpVqmovun_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b60240UL, 0xffbf0fd0UL, DecodeOpVqmovun_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b20240UL, 0xffbf0fd0UL, DecodeOpVqmovun_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3ba02c0UL, 0xffbf0fd0UL, DecodeOpVqmovn_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b602c0UL, 0xffbf0fd0UL, DecodeOpVqmovn_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b202c0UL, 0xffbf0fd0UL, DecodeOpVqmovn_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3ba0280UL, 0xffbf0fd0UL, DecodeOpVqmovn_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b60280UL, 0xffbf0fd0UL, DecodeOpVqmovn_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b20280UL, 0xffbf0fd0UL, DecodeOpVqmovn_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00b40UL, 0xffb00f50UL, DecodeOpVqdmull_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00d00UL, 0xffb00f50UL, DecodeOpVqdmull_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900b40UL, 0xffb00f50UL, DecodeOpVqdmull_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900d00UL, 0xffb00f50UL, DecodeOpVqdmull_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00c40UL, 0xfeb00f50UL, DecodeOpVqdmulh_s32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200b00UL, 0xffb00f10UL, DecodeOpVqdmulh_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900c40UL, 0xfeb00f50UL, DecodeOpVqdmulh_s16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100b00UL, 0xffb00f10UL, DecodeOpVqdmulh_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00740UL, 0xffb00f50UL, DecodeOpVqdmlsl_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00b00UL, 0xffb00f50UL, DecodeOpVqdmlsl_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900740UL, 0xffb00f50UL, DecodeOpVqdmlsl_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900b00UL, 0xffb00f50UL, DecodeOpVqdmlsl_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00340UL, 0xffb00f50UL, DecodeOpVqdmlal_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00900UL, 0xffb00f50UL, DecodeOpVqdmlal_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900340UL, 0xffb00f50UL, DecodeOpVqdmlal_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900900UL, 0xffb00f50UL, DecodeOpVqdmlal_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3300010UL, 0xffb00f10UL, DecodeOpVqadd_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200010UL, 0xffb00f10UL, DecodeOpVqadd_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100010UL, 0xffb00f10UL, DecodeOpVqadd_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000010UL, 0xffb00f10UL, DecodeOpVqadd_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2300010UL, 0xffb00f10UL, DecodeOpVqadd_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200010UL, 0xffb00f10UL, DecodeOpVqadd_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100010UL, 0xffb00f10UL, DecodeOpVqadd_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000010UL, 0xffb00f10UL, DecodeOpVqadd_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b80700UL, 0xffbf0f90UL, DecodeOpVqabs_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40700UL, 0xffbf0f90UL, DecodeOpVqabs_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00700UL, 0xffbf0f90UL, DecodeOpVqabs_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200a10UL, 0xffb00f10UL, DecodeOpVpmin_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100a10UL, 0xffb00f10UL, DecodeOpVpmin_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000a10UL, 0xffb00f10UL, DecodeOpVpmin_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200a10UL, 0xffb00f10UL, DecodeOpVpmin_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100a10UL, 0xffb00f10UL, DecodeOpVpmin_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000a10UL, 0xffb00f10UL, DecodeOpVpmin_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200f00UL, 0xffb00f10UL, DecodeOpVpmin_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200a00UL, 0xffb00f10UL, DecodeOpVpmax_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100a00UL, 0xffb00f10UL, DecodeOpVpmax_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000a00UL, 0xffb00f10UL, DecodeOpVpmax_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200a00UL, 0xffb00f10UL, DecodeOpVpmax_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100a00UL, 0xffb00f10UL, DecodeOpVpmax_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000a00UL, 0xffb00f10UL, DecodeOpVpmax_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000f00UL, 0xffb00f10UL, DecodeOpVpmax_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b80280UL, 0xffbf0f90UL, DecodeOpVpaddl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40280UL, 0xffbf0f90UL, DecodeOpVpaddl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00280UL, 0xffbf0f90UL, DecodeOpVpaddl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b80200UL, 0xffbf0f90UL, DecodeOpVpaddl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40200UL, 0xffbf0f90UL, DecodeOpVpaddl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00200UL, 0xffbf0f90UL, DecodeOpVpaddl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200b10UL, 0xffb00f10UL, DecodeOpVpadd_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100b10UL, 0xffb00f10UL, DecodeOpVpadd_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000b10UL, 0xffb00f10UL, DecodeOpVpadd_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000d00UL, 0xffb00f10UL, DecodeOpVpadd_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b80680UL, 0xffbf0f90UL, DecodeOpVpadal_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40680UL, 0xffbf0f90UL, DecodeOpVpadal_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00680UL, 0xffbf0f90UL, DecodeOpVpadal_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b80600UL, 0xffbf0f90UL, DecodeOpVpadal_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40600UL, 0xffbf0f90UL, DecodeOpVpadal_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00600UL, 0xffbf0f90UL, DecodeOpVpadal_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800110UL, 0xfeb809b0UL, DecodeOpVorr_i32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800910UL, 0xfeb80db0UL, DecodeOpVorr_i16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200110UL, 0xffb00f10UL, DecodeOpVorr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2300110UL, 0xffb00f10UL, DecodeOpVorn<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90380UL, 0xffbf0f90UL, DecodeOpVneg_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50380UL, 0xffbf0f90UL, DecodeOpVneg_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10380UL, 0xffbf0f90UL, DecodeOpVneg_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90780UL, 0xffbf0f90UL, DecodeOpVneg_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50780UL, 0xffbf0f90UL, DecodeOpVneg_f16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10780UL, 0xffbf0f90UL, DecodeOpVneg_f8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00580UL, 0xffbf0f90UL, DecodeOpVmvn<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800c30UL, 0xfeb80eb0UL, DecodeOpVmvn_i32in<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800030UL, 0xfeb809b0UL, DecodeOpVmvn_i32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800830UL, 0xfeb80db0UL, DecodeOpVmvn_i16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00a40UL, 0xffb00f50UL, DecodeOpVmull_u32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900a40UL, 0xffb00f50UL, DecodeOpVmull_u16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00a40UL, 0xffb00f50UL, DecodeOpVmull_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900a40UL, 0xffb00f50UL, DecodeOpVmull_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00c00UL, 0xffb00f50UL, DecodeOpVmull_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900c00UL, 0xffb00f50UL, DecodeOpVmull_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800c00UL, 0xffb00f50UL, DecodeOpVmull_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00c00UL, 0xffb00f50UL, DecodeOpVmull_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900c00UL, 0xffb00f50UL, DecodeOpVmull_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800c00UL, 0xffb00f50UL, DecodeOpVmull_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800e00UL, 0xffb00f50UL, DecodeOpVmull_p8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200910UL, 0xffb00f10UL, DecodeOpVmul_p32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100910UL, 0xffb00f10UL, DecodeOpVmul_p16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000910UL, 0xffb00f10UL, DecodeOpVmul_p8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00840UL, 0xfeb00f50UL, DecodeOpVmul_i32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900840UL, 0xfeb00f50UL, DecodeOpVmul_i16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200910UL, 0xffb00f10UL, DecodeOpVmul_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100910UL, 0xffb00f10UL, DecodeOpVmul_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000910UL, 0xffb00f10UL, DecodeOpVmul_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00940UL, 0xfeb00f50UL, DecodeOpVmul_f32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000d10UL, 0xffb00f10UL, DecodeOpVmul_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3ba0200UL, 0xffbf0fd0UL, DecodeOpVmovn_i64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b60200UL, 0xffbf0fd0UL, DecodeOpVmovn_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b20200UL, 0xffbf0fd0UL, DecodeOpVmovn_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00a10UL, 0xffbf0fd0UL, DecodeOpVmovl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900a10UL, 0xffbf0fd0UL, DecodeOpVmovl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880a10UL, 0xffbf0fd0UL, DecodeOpVmovl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00a10UL, 0xffbf0fd0UL, DecodeOpVmovl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900a10UL, 0xffbf0fd0UL, DecodeOpVmovl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880a10UL, 0xffbf0fd0UL, DecodeOpVmovl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800c10UL, 0xfeb80eb0UL, DecodeOpVmov_i32in<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800e30UL, 0xfeb80fb0UL, DecodeOpVmov_i64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800010UL, 0xfeb809b0UL, DecodeOpVmov_i32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800810UL, 0xfeb80db0UL, DecodeOpVmov_i16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800e10UL, 0xfeb80fb0UL, DecodeOpVmov_i8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800f10UL, 0xfeb80fb0UL, DecodeOpVmov_f32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00640UL, 0xffb00f50UL, DecodeOpVmlsl_u32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900640UL, 0xffb00f50UL, DecodeOpVmlsl_u16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00640UL, 0xffb00f50UL, DecodeOpVmlsl_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900640UL, 0xffb00f50UL, DecodeOpVmlsl_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00440UL, 0xfeb00f50UL, DecodeOpVmls_i32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900440UL, 0xfeb00f50UL, DecodeOpVmls_i16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00540UL, 0xfeb00f50UL, DecodeOpVmls_f32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200d10UL, 0xffb00f10UL, DecodeOpVmls_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900540UL, 0xffb00f50UL, DecodeOpVmls_f16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00240UL, 0xffb00f50UL, DecodeOpVmlal_u32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900240UL, 0xffb00f50UL, DecodeOpVmlal_u16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00240UL, 0xffb00f50UL, DecodeOpVmlal_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900240UL, 0xffb00f50UL, DecodeOpVmlal_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00800UL, 0xffb00d50UL, DecodeOpVmll_u32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900800UL, 0xffb00d50UL, DecodeOpVmll_u16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800800UL, 0xffb00d50UL, DecodeOpVmll_u8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00800UL, 0xffb00d50UL, DecodeOpVmll_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900800UL, 0xffb00d50UL, DecodeOpVmll_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800800UL, 0xffb00d50UL, DecodeOpVmll_s8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00040UL, 0xfeb00f50UL, DecodeOpVmla_i32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900040UL, 0xfeb00f50UL, DecodeOpVmla_i16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200900UL, 0xfeb00f10UL, DecodeOpVml_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100900UL, 0xfeb00f10UL, DecodeOpVml_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000900UL, 0xfeb00f10UL, DecodeOpVml_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00140UL, 0xfeb00f50UL, DecodeOpVmla_f32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000d10UL, 0xffb00f10UL, DecodeOpVmla_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200610UL, 0xffb00f10UL, DecodeOpVmin_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100610UL, 0xffb00f10UL, DecodeOpVmin_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000610UL, 0xffb00f10UL, DecodeOpVmin_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200610UL, 0xffb00f10UL, DecodeOpVmin_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100610UL, 0xffb00f10UL, DecodeOpVmin_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000610UL, 0xffb00f10UL, DecodeOpVmin_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200f00UL, 0xffb00f10UL, DecodeOpVmin_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200600UL, 0xffb00f10UL, DecodeOpVmax_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100600UL, 0xffb00f10UL, DecodeOpVmax_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000600UL, 0xffb00f10UL, DecodeOpVmax_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200600UL, 0xffb00f10UL, DecodeOpVmax_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100600UL, 0xffb00f10UL, DecodeOpVmax_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000600UL, 0xffb00f10UL, DecodeOpVmax_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000f00UL, 0xffb00f10UL, DecodeOpVmax_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4a00800UL, 0xffb00c00UL, DecodeOpVldsl_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4a00400UL, 0xffb00c00UL, DecodeOpVldsl_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4a00000UL, 0xffb00c00UL, DecodeOpVldsl_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4a00ca0UL, 0xffb00fe0UL, DecodeOpVldqal_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4a00c60UL, 0xffb00fe0UL, DecodeOpVldqal_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4a00c20UL, 0xffb00fe0UL, DecodeOpVldqal_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4a00c80UL, 0xffb00cc0UL, DecodeOpVldal_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4a00c40UL, 0xffb00cc0UL, DecodeOpVldal_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4a00c00UL, 0xffb00cc0UL, DecodeOpVldal_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4200380UL, 0xffb00fc0UL, DecodeOpVld2_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4200340UL, 0xffb00fc0UL, DecodeOpVld2_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4200300UL, 0xffb00fc0UL, DecodeOpVld2_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4200180UL, 0xffb003c0UL, DecodeOpVldms2s_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4200140UL, 0xffb003c0UL, DecodeOpVldms2s_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4200100UL, 0xffb003c0UL, DecodeOpVldms2s_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf42000c0UL, 0xffb000c0UL, DecodeOpVldms_64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4200080UL, 0xffb000c0UL, DecodeOpVldms_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4200040UL, 0xffb000c0UL, DecodeOpVldms_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4200000UL, 0xffb000c0UL, DecodeOpVldms_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200200UL, 0xffb00f10UL, DecodeOpVhsub_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100200UL, 0xffb00f10UL, DecodeOpVhsub_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000200UL, 0xffb00f10UL, DecodeOpVhsub_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200200UL, 0xffb00f10UL, DecodeOpVhsub_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100200UL, 0xffb00f10UL, DecodeOpVhsub_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000200UL, 0xffb00f10UL, DecodeOpVhsub_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200000UL, 0xffb00f10UL, DecodeOpVhadd_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100000UL, 0xffb00f10UL, DecodeOpVhadd_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000000UL, 0xffb00f10UL, DecodeOpVhadd_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200000UL, 0xffb00f10UL, DecodeOpVhadd_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100000UL, 0xffb00f10UL, DecodeOpVhadd_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000000UL, 0xffb00f10UL, DecodeOpVhadd_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200c10UL, 0xffb00f10UL, DecodeOpVfms_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000c10UL, 0xffb00f10UL, DecodeOpVfma_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2b00000UL, 0xffb00010UL, DecodeOpVext_8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000110UL, 0xffb00f10UL, DecodeOpVeor<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40c00UL, 0xffb70f90UL, DecodeOpVdup_32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b20c00UL, 0xffb30f90UL, DecodeOpVdup_16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10c00UL, 0xffb10f90UL, DecodeOpVdup_8dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00f10UL, 0xffa00f90UL, DecodeOpVcvt_u32f32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3bb0780UL, 0xffbf0f90UL, DecodeOpVcvt_u32f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00f10UL, 0xffa00f90UL, DecodeOpVcvt_s32f32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3bb0700UL, 0xffbf0f90UL, DecodeOpVcvt_s32_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00e10UL, 0xffa00f90UL, DecodeOpVcvt_f32u32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3bb0680UL, 0xffbf0f90UL, DecodeOpVcvt_f32u32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00e10UL, 0xffa00f90UL, DecodeOpVcvt_f32s32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3bb0600UL, 0xffbf0f90UL, DecodeOpVcvt_f32_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b60700UL, 0xffbf0fd0UL, DecodeOpVcvt_f32_f16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b60600UL, 0xffbf0fd0UL, DecodeOpVcvt_f16_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00500UL, 0xffbf0f90UL, DecodeOpVcnt_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b80480UL, 0xffbf0f90UL, DecodeOpVclz_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40480UL, 0xffbf0f90UL, DecodeOpVclz_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00480UL, 0xffbf0f90UL, DecodeOpVclz_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90200UL, 0xffbf0f90UL, DecodeOpVclt_s32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50200UL, 0xffbf0f90UL, DecodeOpVclt_s16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10200UL, 0xffbf0f90UL, DecodeOpVclt_s8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90600UL, 0xffbf0f90UL, DecodeOpVclt_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50600UL, 0xffbf0f90UL, DecodeOpVclt_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10600UL, 0xffbf0f90UL, DecodeOpVclt_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b80400UL, 0xffbf0f90UL, DecodeOpVcls_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b40400UL, 0xffbf0f90UL, DecodeOpVcls_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b00400UL, 0xffbf0f90UL, DecodeOpVcls_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90180UL, 0xffbf0f90UL, DecodeOpVcle_s32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50180UL, 0xffbf0f90UL, DecodeOpVcle_s16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10180UL, 0xffbf0f90UL, DecodeOpVcle_s8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90580UL, 0xffbf0f90UL, DecodeOpVcle_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50580UL, 0xffbf0f90UL, DecodeOpVcle_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10580UL, 0xffbf0f90UL, DecodeOpVcle_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200300UL, 0xffb00f10UL, DecodeOpVcgt_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100300UL, 0xffb00f10UL, DecodeOpVcgt_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000300UL, 0xffb00f10UL, DecodeOpVcgt_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200300UL, 0xffb00f10UL, DecodeOpVcgt_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100300UL, 0xffb00f10UL, DecodeOpVcgt_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000300UL, 0xffb00f10UL, DecodeOpVcgt_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90000UL, 0xffbf0f90UL, DecodeOpVcgt_s32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50000UL, 0xffbf0f90UL, DecodeOpVcgt_s16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10000UL, 0xffbf0f90UL, DecodeOpVcgt_s8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200e00UL, 0xffb00f10UL, DecodeOpVcgt_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90400UL, 0xffbf0f90UL, DecodeOpVcgt_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50400UL, 0xffbf0f90UL, DecodeOpVcgt_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10400UL, 0xffbf0f90UL, DecodeOpVcgt_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200310UL, 0xffb00f10UL, DecodeOpVcge_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100310UL, 0xffb00f10UL, DecodeOpVcge_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000310UL, 0xffb00f10UL, DecodeOpVcge_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200310UL, 0xffb00f10UL, DecodeOpVcge_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100310UL, 0xffb00f10UL, DecodeOpVcge_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000310UL, 0xffb00f10UL, DecodeOpVcge_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90080UL, 0xffbf0f90UL, DecodeOpVcge_s32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50080UL, 0xffbf0f90UL, DecodeOpVcge_s16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10080UL, 0xffbf0f90UL, DecodeOpVcge_s8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90480UL, 0xffbf0f90UL, DecodeOpVcge_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000e00UL, 0xffb00f10UL, DecodeOpVcge_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50480UL, 0xffbf0f90UL, DecodeOpVcge_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10480UL, 0xffbf0f90UL, DecodeOpVcge_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200810UL, 0xffb00f10UL, DecodeOpVceq_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100810UL, 0xffb00f10UL, DecodeOpVceq_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000810UL, 0xffb00f10UL, DecodeOpVceq_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90100UL, 0xffbf0f90UL, DecodeOpVceq_i32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50100UL, 0xffbf0f90UL, DecodeOpVceq_i16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10100UL, 0xffbf0f90UL, DecodeOpVceq_i8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90500UL, 0xffbf0f90UL, DecodeOpVceq_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50500UL, 0xffbf0f90UL, DecodeOpVceq_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10500UL, 0xffbf0f90UL, DecodeOpVceq_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000e00UL, 0xffb00f10UL, DecodeOpVceq_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100110UL, 0xffb00f10UL, DecodeOpVbsl<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200110UL, 0xffb00f10UL, DecodeOpVbit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3300110UL, 0xffb00f10UL, DecodeOpVbif<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800130UL, 0xfeb809b0UL, DecodeOpVbic_i32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800930UL, 0xfeb80db0UL, DecodeOpVbic_i16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100110UL, 0xffb00f10UL, DecodeOpVbic<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000110UL, 0xffb00f10UL, DecodeOpVand<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00100UL, 0xffb00f50UL, DecodeOpVaddw_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900100UL, 0xffb00f50UL, DecodeOpVaddw_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800100UL, 0xffb00f50UL, DecodeOpVaddw_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00100UL, 0xffb00f50UL, DecodeOpVaddw_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900100UL, 0xffb00f50UL, DecodeOpVaddw_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800100UL, 0xffb00f50UL, DecodeOpVaddw_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00000UL, 0xffb00f50UL, DecodeOpVaddl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900000UL, 0xffb00f50UL, DecodeOpVaddl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800000UL, 0xffb00f50UL, DecodeOpVaddl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00000UL, 0xffb00f50UL, DecodeOpVaddl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900000UL, 0xffb00f50UL, DecodeOpVaddl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800000UL, 0xffb00f50UL, DecodeOpVaddl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00400UL, 0xffb00f50UL, DecodeOpVaddhn_i64dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900400UL, 0xffb00f50UL, DecodeOpVaddhn_i32dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800400UL, 0xffb00f50UL, DecodeOpVaddhn_i16dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2300800UL, 0xffb00f10UL, DecodeOpVadd_i64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200800UL, 0xffb00f10UL, DecodeOpVadd_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100800UL, 0xffb00f10UL, DecodeOpVadd_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000800UL, 0xffb00f10UL, DecodeOpVadd_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000d00UL, 0xffb00f10UL, DecodeOpVadd_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200e10UL, 0xffb00f10UL, DecodeOpVacgt_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000e10UL, 0xffb00f10UL, DecodeOpVacge_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90700UL, 0xffbf0f90UL, DecodeOpVabs_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b90300UL, 0xffbf0f90UL, DecodeOpVabs_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b50300UL, 0xffbf0f90UL, DecodeOpVabs_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3b10300UL, 0xffbf0f90UL, DecodeOpVabs_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200d00UL, 0xffb00f10UL, DecodeOpVabd_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00700UL, 0xffb00f50UL, DecodeOpVabdl_u32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900700UL, 0xffb00f50UL, DecodeOpVabdl_u16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800700UL, 0xffb00f50UL, DecodeOpVabdl_u8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00700UL, 0xffb00f50UL, DecodeOpVabdl_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900700UL, 0xffb00f50UL, DecodeOpVabdl_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800700UL, 0xffb00f50UL, DecodeOpVabdl_s8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200700UL, 0xffb00f10UL, DecodeOpVabd_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100700UL, 0xffb00f10UL, DecodeOpVabd_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000700UL, 0xffb00f10UL, DecodeOpVabd_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200700UL, 0xffb00f10UL, DecodeOpVabd_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100700UL, 0xffb00f10UL, DecodeOpVabd_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000700UL, 0xffb00f10UL, DecodeOpVabd_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00500UL, 0xffb00f50UL, DecodeOpVabal_u32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900500UL, 0xffb00f50UL, DecodeOpVabal_u16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3800500UL, 0xffb00f50UL, DecodeOpVabal_u8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00500UL, 0xffb00f50UL, DecodeOpVabal_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900500UL, 0xffb00f50UL, DecodeOpVabal_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2800500UL, 0xffb00f50UL, DecodeOpVabal_s8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3200710UL, 0xffb00f10UL, DecodeOpVaba_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3100710UL, 0xffb00f10UL, DecodeOpVaba_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3000710UL, 0xffb00f10UL, DecodeOpVaba_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2200710UL, 0xffb00f10UL, DecodeOpVaba_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2100710UL, 0xffb00f10UL, DecodeOpVaba_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2000710UL, 0xffb00f10UL, DecodeOpVaba_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb20a40UL, 0xfbf0f50UL, DecodeOpVcvtb_f32_f16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb30a40UL, 0xfbf0f50UL, DecodeOpVcvtb_f16_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf84d0500UL, 0xfe5fffe0UL, DecodeOpSrs<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf8100a00UL, 0xfe50ffffUL, DecodeOpRfe<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf1000000UL, 0xfff1fe20UL, DecodeOpCps<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe1200070UL, 0xfff000f0UL, DecodeOpBkpt<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc500000UL, 0xfff00000UL, DecodeOpMrrc2<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc400000UL, 0xfff00000UL, DecodeOpMcrr2<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc800000UL, 0xffb00000UL, DecodeOpStc2_unindexed<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc000000UL, 0xfe100000UL, DecodeOpStc2<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfe100010UL, 0xff100010UL, DecodeOpMrc2<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfe000010UL, 0xff100010UL, DecodeOpMcr2<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc900000UL, 0xffb00000UL, DecodeOpLdc2_unindexed<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc100000UL, 0xfe100000UL, DecodeOpLdc2<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfe000000UL, 0xff000010UL, DecodeOpCdp2<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfa000000UL, 0xfe000000UL, DecodeOpBlx_pcrel<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf57ff060UL, 0xfffffff0UL, DecodeOpIsb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf57ff040UL, 0xfffffff0UL, DecodeOpDsb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf57ff050UL, 0xfffffff0UL, DecodeOpDmb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf57ff01fUL, 0xffffffffUL, DecodeOpClrex<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf650f000UL, 0xff70f010UL, DecodeOpPli_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf450f000UL, 0xff70f000UL, DecodeOpPli_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf710f000UL, 0xff30f010UL, DecodeOpPld_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf510f000UL, 0xff30f000UL, DecodeOpPld_imm<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf1010000UL, 0xfffffdffUL, DecodeOpSetend<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a00a10UL, 0xffa00fd0UL, DecodeOpVshll_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3900a10UL, 0xffb00fd0UL, DecodeOpVshll_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3880a10UL, 0xffb80fd0UL, DecodeOpVshll_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a00a10UL, 0xffa00fd0UL, DecodeOpVshll_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2900a10UL, 0xffb00fd0UL, DecodeOpVshll_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2880a10UL, 0xffb80fd0UL, DecodeOpVshll_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf0000000UL, 0xf0000000UL, DecodeOpUnconditional<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe100b10UL, 0xfd00f7fUL, DecodeOpVmov_32rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe900b30UL, 0xfd00f3fUL, DecodeOpVmov_u16rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe100b30UL, 0xfd00f3fUL, DecodeOpVmov_s16rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xed00b10UL, 0xfd00f1fUL, DecodeOpVmov_u8rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe500b10UL, 0xfd00f1fUL, DecodeOpVmov_s8rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000b10UL, 0xfd00f7fUL, DecodeOpVmov_32dr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000b30UL, 0xfd00f3fUL, DecodeOpVmov_16dr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe400b10UL, 0xfd00f1fUL, DecodeOpVmov_8dr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe800b10UL, 0xfd00f7fUL, DecodeOpVdup32_r<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe800b30UL, 0xfd00f7fUL, DecodeOpVdup16_r<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xec00b10UL, 0xfd00f7fUL, DecodeOpVdup8_r<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe300b40UL, 0xfb00f50UL, DecodeOpVsub_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe300a40UL, 0xfb00f50UL, DecodeOpVsub_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd000b00UL, 0xf300f00UL, DecodeOpVstr_64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd000a00UL, 0xf300f00UL, DecodeOpVstr_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc800b00UL, 0xf900f00UL, DecodeOpVstmia_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc800a00UL, 0xf900f00UL, DecodeOpVstmia_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd200b00UL, 0xfb00f00UL, DecodeOpVstmdb_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd200a00UL, 0xfb00f00UL, DecodeOpVstmdb_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb10bc0UL, 0xfbf0fd0UL, DecodeOpVsqrt_f64d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb10ac0UL, 0xfbf0fd0UL, DecodeOpVsqrt_f32s<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb10b40UL, 0xfbf0fd0UL, DecodeOpVneg_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb10a40UL, 0xfbf0fd0UL, DecodeOpVneg_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe200b40UL, 0xfb00f50UL, DecodeOpVnmul_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe200a40UL, 0xfb00f50UL, DecodeOpVnmul_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe200b00UL, 0xfb00f50UL, DecodeOpVmul_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe200a00UL, 0xfb00f50UL, DecodeOpVmul_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xee00a10UL, 0xff00fffUL, DecodeOpVmsr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xef00a10UL, 0xff00fffUL, DecodeOpVmrs<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc400b10UL, 0xff00fd0UL, DecodeOpVmov_drr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc500b10UL, 0xff00fd0UL, DecodeOpVmov_rrd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc500a10UL, 0xff00fd0UL, DecodeOpVmov_rrss<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc400a10UL, 0xff00fd0UL, DecodeOpVmov_ssrr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000a10UL, 0xff00f7fUL, DecodeOpVmov_sr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe100a10UL, 0xff00f7fUL, DecodeOpVmov_rs<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb00b40UL, 0xfbf0fd0UL, DecodeOpVmov_f64d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb00a40UL, 0xfbf0fd0UL, DecodeOpVmov_f32s<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb00b00UL, 0xfb00ff0UL, DecodeOpVmov_f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb00a00UL, 0xfb00ff0UL, DecodeOpVmov_f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe100b00UL, 0xfb00f50UL, DecodeOpVnmls_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe100a00UL, 0xfb00f50UL, DecodeOpVnmls_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe100b40UL, 0xfb00f50UL, DecodeOpVnmla_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe100a40UL, 0xfb00f50UL, DecodeOpVnmla_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000b40UL, 0xfb00f50UL, DecodeOpVmls_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000a40UL, 0xfb00f50UL, DecodeOpVmls_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000b00UL, 0xfb00f50UL, DecodeOpVmla_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000a00UL, 0xfb00f50UL, DecodeOpVmla_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd100b00UL, 0xf300f00UL, DecodeOpVldr_64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd100a00UL, 0xf300f00UL, DecodeOpVldr_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc900b00UL, 0xf900f00UL, DecodeOpVldmia_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc900a00UL, 0xf900f00UL, DecodeOpVldmia_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd300b00UL, 0xfb00f00UL, DecodeOpVldmdb_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd300a00UL, 0xfb00f00UL, DecodeOpVldmdb_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe900b00UL, 0xfb00f50UL, DecodeOpVfnms_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe900a00UL, 0xfb00f50UL, DecodeOpVfnms_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe900b40UL, 0xfb00f50UL, DecodeOpVfnma_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe900a40UL, 0xfb00f50UL, DecodeOpVfnma_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea00b40UL, 0xfb00f50UL, DecodeOpVfms_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea00a40UL, 0xfb00f50UL, DecodeOpVfms_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea00b00UL, 0xfb00f50UL, DecodeOpVfma_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea00a00UL, 0xfb00f50UL, DecodeOpVfma_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe800b00UL, 0xfb00f50UL, DecodeOpVdiv_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe800a00UL, 0xfb00f50UL, DecodeOpVdiv_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb70bc0UL, 0xfbf0fd0UL, DecodeOpVcvt_f32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb70ac0UL, 0xfbf0fd0UL, DecodeOpVcvt_f64f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebf0bc0UL, 0xfbf0fd0UL, DecodeOpVcvt_u32f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebf0ac0UL, 0xfbf0fd0UL, DecodeOpVcvt_u32f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebf0b40UL, 0xfbf0fd0UL, DecodeOpVcvt_u16f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebf0a40UL, 0xfbf0fd0UL, DecodeOpVcvt_u16f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebe0bc0UL, 0xfbf0fd0UL, DecodeOpVcvt_s32f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebe0ac0UL, 0xfbf0fd0UL, DecodeOpVcvt_s32f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebe0b40UL, 0xfbf0fd0UL, DecodeOpVcvt_s16f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebe0a40UL, 0xfbf0fd0UL, DecodeOpVcvt_s16f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebb0bc0UL, 0xfbf0fd0UL, DecodeOpVcvt_f64u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebb0b40UL, 0xfbf0fd0UL, DecodeOpVcvt_f64u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebb0ac0UL, 0xfbf0fd0UL, DecodeOpVcvt_f32u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebb0a40UL, 0xfbf0fd0UL, DecodeOpVcvt_f32u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeba0bc0UL, 0xfbf0fd0UL, DecodeOpVcvt_f64s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeba0b40UL, 0xfbf0fd0UL, DecodeOpVcvt_f64s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeba0ac0UL, 0xfbf0fd0UL, DecodeOpVcvt_f32s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeba0a40UL, 0xfbf0fd0UL, DecodeOpVcvt_f32s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebd0b40UL, 0xfbf0fd0UL, DecodeOpVcvtr_s32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebd0bc0UL, 0xfbf0fd0UL, DecodeOpVcvt_s32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebd0a40UL, 0xfbf0fd0UL, DecodeOpVcvtr_s32f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebd0ac0UL, 0xfbf0fd0UL, DecodeOpVcvt_s32f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebc0b40UL, 0xfbf0fd0UL, DecodeOpVcvtr_u32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebc0bc0UL, 0xfbf0fd0UL, DecodeOpVcvt_u32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebc0a40UL, 0xfbf0fd0UL, DecodeOpVcvtr_u32f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebc0ac0UL, 0xfbf0fd0UL, DecodeOpVcvt_u32f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb80bc0UL, 0xfbf0fd0UL, DecodeOpVcvt_f64s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb80ac0UL, 0xfbf0fd0UL, DecodeOpVcvt_f32s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb80b40UL, 0xfbf0fd0UL, DecodeOpVcvt_f64u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb80a40UL, 0xfbf0fd0UL, DecodeOpVcvt_f32u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb50b40UL, 0xfbf0f7fUL, DecodeOpVcmp_f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb50a40UL, 0xfbf0f7fUL, DecodeOpVcmp_f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb40b40UL, 0xfbf0f50UL, DecodeOpVcmp_f64d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb40a40UL, 0xfbf0f50UL, DecodeOpVcmp_f32d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe300b00UL, 0xfb00f50UL, DecodeOpVadd_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe300a00UL, 0xfb00f50UL, DecodeOpVadd_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb00bc0UL, 0xfbf0fd0UL, DecodeOpVabs_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb00ac0UL, 0xfbf0fd0UL, DecodeOpVabs_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x120f000UL, 0xfb0fff0UL, DecodeOpMsr_reg_psr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x120f000UL, 0xfb0fcf0UL, DecodeOpMsr_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1000000UL, 0xfb00cffUL, DecodeOpMrs<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1f0f000UL, 0xffff010UL, DecodeOpMvnspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3f0f000UL, 0xffff000UL, DecodeOpMvnspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1d0f000UL, 0xff0f010UL, DecodeOpBicspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3d0f000UL, 0xff0f000UL, DecodeOpBicspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x190f000UL, 0xff0f010UL, DecodeOpOrrspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x390f000UL, 0xff0f000UL, DecodeOpOrrspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf0f000UL, 0xff0f010UL, DecodeOpRscspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2f0f000UL, 0xff0f000UL, DecodeOpRscspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd0f000UL, 0xff0f010UL, DecodeOpSbcspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2d0f000UL, 0xff0f000UL, DecodeOpSbcspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb0f000UL, 0xff0f010UL, DecodeOpAdcspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2b0f000UL, 0xff0f000UL, DecodeOpAdcspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x90f000UL, 0xff0f010UL, DecodeOpAddspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x290f000UL, 0xff0f000UL, DecodeOpAddspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x70f000UL, 0xff0f010UL, DecodeOpRsbspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x270f000UL, 0xff0f000UL, DecodeOpRsbspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x30f000UL, 0xff0f010UL, DecodeOpEorspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x230f000UL, 0xff0f000UL, DecodeOpEorspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10f000UL, 0xff0f010UL, DecodeOpAndspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210f000UL, 0xff0f000UL, DecodeOpAndspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1b0f000UL, 0xffff010UL, DecodeOpMovspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3b0f000UL, 0xffff000UL, DecodeOpMovspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x50f000UL, 0xff0f010UL, DecodeOpSubspc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x250f000UL, 0xff0f000UL, DecodeOpSubspc_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x160006eUL, 0xfffffffUL, DecodeOpEret<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1600070UL, 0xff000f0UL, DecodeOpSmc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1400070UL, 0xff000f0UL, DecodeOpHvc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000000UL, 0xf000000UL, DecodeOpSwi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe100f10UL, 0xf100f10UL, DecodeOpCp15_mrc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000f10UL, 0xf100f10UL, DecodeOpCp15_mcr<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xc500000UL, 0xff00000UL, DecodeOpMrrc<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xc400000UL, 0xff00000UL, DecodeOpMcrr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc800000UL, 0xfb00000UL, DecodeOpStc_unindexed<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc000000UL, 0xe100000UL, DecodeOpStc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe100010UL, 0xf100010UL, DecodeOpMrc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000010UL, 0xf100010UL, DecodeOpMcr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc900000UL, 0xfb00000UL, DecodeOpLdc_unindexed<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc100000UL, 0xe100000UL, DecodeOpLdc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000000UL, 0xf000010UL, DecodeOpCdp<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x12fff30UL, 0xffffff0UL, DecodeOpBlx_reg<	ARCH>));
	if( ARCH::Config::insns5J ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x12fff20UL, 0xffffff0UL, DecodeOpBxj<	ARCH>));
	if( ARCH::Config::insns4T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x12fff10UL, 0xffffff0UL, DecodeOpBx<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb000000UL, 0xf000000UL, DecodeOpBl<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa000000UL, 0xf000000UL, DecodeOpB<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x320f0f0UL, 0xffffff0UL, DecodeOpDbg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x320f004UL, 0xfffffffUL, DecodeOpSev<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x320f003UL, 0xfffffffUL, DecodeOpWfi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x320f002UL, 0xfffffffUL, DecodeOpWfe<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x320f001UL, 0xfffffffUL, DecodeOpYield<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x320f000UL, 0xfffff00UL, DecodeOpNop<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6700f50UL, 0xff00ff0UL, DecodeOpUhsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6700f30UL, 0xff00ff0UL, DecodeOpUhasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6300f50UL, 0xff00ff0UL, DecodeOpShsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6300f30UL, 0xff00ff0UL, DecodeOpShasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6500f50UL, 0xff00ff0UL, DecodeOpUsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6500f30UL, 0xff00ff0UL, DecodeOpUasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6100f50UL, 0xff00ff0UL, DecodeOpSsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6100f30UL, 0xff00ff0UL, DecodeOpSasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6600f50UL, 0xff00ff0UL, DecodeOpUqsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6600f30UL, 0xff00ff0UL, DecodeOpUqasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6200f50UL, 0xff00ff0UL, DecodeOpQsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6200f30UL, 0xff00ff0UL, DecodeOpQasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6300ff0UL, 0xff00ff0UL, DecodeOpShsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6300f70UL, 0xff00ff0UL, DecodeOpShsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6700ff0UL, 0xff00ff0UL, DecodeOpUhsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6700f70UL, 0xff00ff0UL, DecodeOpUhsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6300f90UL, 0xff00ff0UL, DecodeOpShadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6300f10UL, 0xff00ff0UL, DecodeOpShadd16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6700f90UL, 0xff00ff0UL, DecodeOpUhadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6700f10UL, 0xff00ff0UL, DecodeOpUhadd16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6600ff0UL, 0xff00ff0UL, DecodeOpUqsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6600f70UL, 0xff00ff0UL, DecodeOpUqsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6600f90UL, 0xff00ff0UL, DecodeOpUqadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6600f10UL, 0xff00ff0UL, DecodeOpUqadd16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6100ff0UL, 0xff00ff0UL, DecodeOpSsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6100f70UL, 0xff00ff0UL, DecodeOpSsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6100f90UL, 0xff00ff0UL, DecodeOpSadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6100f10UL, 0xff00ff0UL, DecodeOpSadd16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6500ff0UL, 0xff00ff0UL, DecodeOpUsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6500f70UL, 0xff00ff0UL, DecodeOpUsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6500f90UL, 0xff00ff0UL, DecodeOpUadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6500f10UL, 0xff00ff0UL, DecodeOpUadd16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7e00050UL, 0xfe00070UL, DecodeOpUbfx<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7c0001fUL, 0xfe0007fUL, DecodeOpBfc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7c00010UL, 0xfe00070UL, DecodeOpBfi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7a00050UL, 0xfe00070UL, DecodeOpSbfx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x780f010UL, 0xff0f0f0UL, DecodeOpUsad8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6ff0070UL, 0xfff03f0UL, DecodeOpUxth<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6f00070UL, 0xff003f0UL, DecodeOpUxtah<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6ef0070UL, 0xfff03f0UL, DecodeOpUxtb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6e00070UL, 0xff003f0UL, DecodeOpUxtab<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6bf0070UL, 0xfff03f0UL, DecodeOpSxth<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6b00070UL, 0xff003f0UL, DecodeOpSxtah<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6af0070UL, 0xfff03f0UL, DecodeOpSxtb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6a00070UL, 0xff003f0UL, DecodeOpSxtab<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6e00f30UL, 0xff00ff0UL, DecodeOpUsat16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6e00010UL, 0xfe00030UL, DecodeOpUsat<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6a00f30UL, 0xff00ff0UL, DecodeOpSsat16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6a00010UL, 0xfe00030UL, DecodeOpSsat<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6800fb0UL, 0xff00ff0UL, DecodeOpSel<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6cf0070UL, 0xfff03f0UL, DecodeOpUxtb16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6c00070UL, 0xff003f0UL, DecodeOpUxtab16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x68f0070UL, 0xfff03f0UL, DecodeOpSxtb16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6800070UL, 0xff003f0UL, DecodeOpSxtab16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6800010UL, 0xff00030UL, DecodeOpPkh<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x1600050UL, 0xff00ff0UL, DecodeOpQdsub<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x1400050UL, 0xff00ff0UL, DecodeOpQdadd<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6200ff0UL, 0xff00ff0UL, DecodeOpQsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6200f70UL, 0xff00ff0UL, DecodeOpQsub16<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x1200050UL, 0xff00ff0UL, DecodeOpQsub<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6200f90UL, 0xff00ff0UL, DecodeOpQadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6200f10UL, 0xff00ff0UL, DecodeOpQadd16<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x1000050UL, 0xff00ff0UL, DecodeOpQadd<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x700f050UL, 0xff0f0d0UL, DecodeOpSmusd<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x700f010UL, 0xff0f0d0UL, DecodeOpSmuad<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x750f010UL, 0xff0f0d0UL, DecodeOpSmmul<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x75000d0UL, 0xff000d0UL, DecodeOpSmmls<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x7500010UL, 0xff000d0UL, DecodeOpSmmla<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x7400050UL, 0xff000d0UL, DecodeOpSmlsld<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x7000050UL, 0xff000d0UL, DecodeOpSmlsd<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x7400010UL, 0xff000d0UL, DecodeOpSmlald<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x7000010UL, 0xff000d0UL, DecodeOpSmlad<	ARCH>));
	if( ARCH::Config::insnsRM ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x730f010UL, 0xff0f0f0UL, DecodeOpUdiv<	ARCH>));
	if( ARCH::Config::insnsRM ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x710f010UL, 0xff0f0f0UL, DecodeOpSdiv<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x12000a0UL, 0xff0f0b0UL, DecodeOpSmulwy<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x1600080UL, 0xff0f090UL, DecodeOpSmulxy<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x1200080UL, 0xff000b0UL, DecodeOpSmlawy<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x1400080UL, 0xff00090UL, DecodeOpSmlalxy<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x1000080UL, 0xff00090UL, DecodeOpSmlaxy<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800090UL, 0xfe000f0UL, DecodeOpUmull<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x400090UL, 0xff000f0UL, DecodeOpUmaal<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00090UL, 0xfe000f0UL, DecodeOpUmlal<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00090UL, 0xfe000f0UL, DecodeOpSmull<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00090UL, 0xfe000f0UL, DecodeOpSmlal<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x90UL, 0xfe0f0f0UL, DecodeOpMul<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600090UL, 0xff000f0UL, DecodeOpMls<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200090UL, 0xfe000f0UL, DecodeOpMla<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1a00f90UL, 0xff00ff0UL, DecodeOpStrexd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1c00f90UL, 0xff00ff0UL, DecodeOpStrexb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1e00f90UL, 0xff00ff0UL, DecodeOpStrexh<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1800f90UL, 0xff00ff0UL, DecodeOpStrex<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1b00f9fUL, 0xff00fffUL, DecodeOpLdrexd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1d00f9fUL, 0xff00fffUL, DecodeOpLdrexb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1f00f9fUL, 0xff00fffUL, DecodeOpLdrexh<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1900f9fUL, 0xff00fffUL, DecodeOpLdrex<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1400090UL, 0xff00ff0UL, DecodeOpSwpb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1000090UL, 0xff00ff0UL, DecodeOpSwp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8400000UL, 0xe700000UL, DecodeOpStm_usr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8508000UL, 0xe508000UL, DecodeOpLdm_rfe<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8500000UL, 0xe708000UL, DecodeOpLdm_usr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000000UL, 0xe500000UL, DecodeOpStm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8100000UL, 0xe500000UL, DecodeOpLdm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6600000UL, 0xf700010UL, DecodeOpStrbt_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4600000UL, 0xf700000UL, DecodeOpStrbt_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2000b0UL, 0xf700ff0UL, DecodeOpStrht_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6000b0UL, 0xf7000f0UL, DecodeOpStrht_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6200000UL, 0xf700010UL, DecodeOpStrt_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4200000UL, 0xf700000UL, DecodeOpStrt_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3000d0UL, 0xf700ff0UL, DecodeOpLdrsbt_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7000d0UL, 0xf7000f0UL, DecodeOpLdrsbt_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6700000UL, 0xf700010UL, DecodeOpLdrbt_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4700000UL, 0xf700000UL, DecodeOpLdrbt_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3000f0UL, 0xf700ff0UL, DecodeOpLdrsht_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7000f0UL, 0xf7000f0UL, DecodeOpLdrsht_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3000b0UL, 0xf700ff0UL, DecodeOpLdrht_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7000b0UL, 0xf7000f0UL, DecodeOpLdrht_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6300000UL, 0xf700010UL, DecodeOpLdrt_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4300000UL, 0xf700000UL, DecodeOpLdrt_imm<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf0UL, 0xe500ff0UL, DecodeOpStrd_reg<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x4000f0UL, 0xe5000f0UL, DecodeOpStrd_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6400000UL, 0xe500010UL, DecodeOpStrb_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4400000UL, 0xe500000UL, DecodeOpStrb_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb0UL, 0xe500ff0UL, DecodeOpStrh_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4000b0UL, 0xe5000f0UL, DecodeOpStrh_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6000000UL, 0xe500010UL, DecodeOpStr_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4000000UL, 0xe500000UL, DecodeOpStr_imm<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xd0UL, 0xe500ff0UL, DecodeOpLdrd_reg<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x4000d0UL, 0xe5000f0UL, DecodeOpLdrd_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1000d0UL, 0xe500ff0UL, DecodeOpLdrsb_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5000d0UL, 0xe5000f0UL, DecodeOpLdrsb_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6500000UL, 0xe500010UL, DecodeOpLdrb_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4500000UL, 0xe500000UL, DecodeOpLdrb_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1000f0UL, 0xe500ff0UL, DecodeOpLdrsh_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5000f0UL, 0xe5000f0UL, DecodeOpLdrsh_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1000b0UL, 0xe500ff0UL, DecodeOpLdrh_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5000b0UL, 0xe5000f0UL, DecodeOpLdrh_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6100000UL, 0xe500010UL, DecodeOpLdr_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4100000UL, 0xe500000UL, DecodeOpLdr_imm<	ARCH>));
	if( ARCH::Config::insnsT2 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x3400000UL, 0xff00000UL, DecodeOpMovt<	ARCH>));
	if( ARCH::Config::insnsT2 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x3000000UL, 0xff00000UL, DecodeOpMovw<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6ff0fb0UL, 0xfff0ff0UL, DecodeOpRevsh<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6bf0fb0UL, 0xfff0ff0UL, DecodeOpRev16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6bf0f30UL, 0xfff0ff0UL, DecodeOpRev<	ARCH>));
	if( ARCH::Config::insnsT2 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x6ff0f30UL, 0xfff0ff0UL, DecodeOpRbit<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x16f0f10UL, 0xfff0ff0UL, DecodeOpClz<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1e00010UL, 0xfef0090UL, DecodeOpMvn_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1e00000UL, 0xfef0010UL, DecodeOpMvn_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3e00000UL, 0xfef0000UL, DecodeOpMvn_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1a00010UL, 0xfef0090UL, DecodeOpMov_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1a00000UL, 0xfef0010UL, DecodeOpMov_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3a00000UL, 0xfef0000UL, DecodeOpMov_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1700010UL, 0xff0f090UL, DecodeOpCmn_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1700000UL, 0xff0f010UL, DecodeOpCmn_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3700000UL, 0xff0f000UL, DecodeOpCmn_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1500010UL, 0xff0f090UL, DecodeOpCmp_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1500000UL, 0xff0f010UL, DecodeOpCmp_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3500000UL, 0xff0f000UL, DecodeOpCmp_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1300010UL, 0xff0f090UL, DecodeOpTeq_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1300000UL, 0xff0f010UL, DecodeOpTeq_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3300000UL, 0xff0f000UL, DecodeOpTeq_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1100010UL, 0xff0f090UL, DecodeOpTst_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1100000UL, 0xff0f010UL, DecodeOpTst_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3100000UL, 0xff0f000UL, DecodeOpTst_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1c00010UL, 0xfe00090UL, DecodeOpBic_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1c00000UL, 0xfe00010UL, DecodeOpBic_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3c00000UL, 0xfe00000UL, DecodeOpBic_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1800010UL, 0xfe00090UL, DecodeOpOrr_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1800000UL, 0xfe00010UL, DecodeOpOrr_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3800000UL, 0xfe00000UL, DecodeOpOrr_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00010UL, 0xfe00090UL, DecodeOpRsc_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00000UL, 0xfe00010UL, DecodeOpRsc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2e00000UL, 0xfe00000UL, DecodeOpRsc_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00010UL, 0xfe00090UL, DecodeOpSbc_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00000UL, 0xfe00010UL, DecodeOpSbc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2c00000UL, 0xfe00000UL, DecodeOpSbc_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00010UL, 0xfe00090UL, DecodeOpAdc_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00000UL, 0xfe00010UL, DecodeOpAdc_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2a00000UL, 0xfe00000UL, DecodeOpAdc_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800010UL, 0xfe00090UL, DecodeOpAdd_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800000UL, 0xfe00010UL, DecodeOpAdd_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2800000UL, 0xfe00000UL, DecodeOpAdd_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600010UL, 0xfe00090UL, DecodeOpRsb_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600000UL, 0xfe00010UL, DecodeOpRsb_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2600000UL, 0xfe00000UL, DecodeOpRsb_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400010UL, 0xfe00090UL, DecodeOpSub_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400000UL, 0xfe00010UL, DecodeOpSub_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2400000UL, 0xfe00000UL, DecodeOpSub_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200010UL, 0xfe00090UL, DecodeOpEor_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200000UL, 0xfe00010UL, DecodeOpEor_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2200000UL, 0xfe00000UL, DecodeOpEor_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10UL, 0xfe00090UL, DecodeOpAnd_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x0UL, 0xfe00010UL, DecodeOpAnd_imm_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2000000UL, 0xfe00000UL, DecodeOpAnd_32imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x320f000UL, 0xfb0f000UL, DecodeOpMsr_imm_psr<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x7800010UL, 0xff000f0UL, DecodeOpUsada8<	ARCH>));
}

template <	typename	ARCH>
Decoder<	ARCH>::~Decoder()
{
}

template <	typename	ARCH>
Operation<	ARCH> *Decoder<	ARCH>::NCDecode(uint32_t addr, CodeType code)
{
	Operation<	ARCH> *operation;
	unsigned int count = decode_table.size();
	unsigned int idx;
	for(idx = 0; idx < count; idx++)
	{
		if((code & decode_table[idx].opcode_mask) == decode_table[idx].opcode)
		{
			operation = decode_table[idx].decode(code, addr);
			return operation;
		}
	}
	operation = new Operation<	ARCH>(code, addr, "???");
	return operation;
}

} } } } } } }
