#include "aarch32/top_thumb.hh"

#include <unisim/component/cxx/processor/arm/isa/decode.hh>
#include <unisim/component/cxx/processor/arm/disasm.hh>
#include <unisim/component/cxx/processor/arm/models.hh>
#include <unisim/component/cxx/processor/arm/exception.hh>
#include <unisim/util/arithmetic/arithmetic.hh>
#include <unisim/util/endian/endian.hh>
#include <iostream>
#include <iomanip>

using unisim::util::arithmetic::BitScanReverse;
using unisim::util::endian::ByteSwap;
using unisim::util::arithmetic::RotateRight;
// using unisim::util::arithmetic::UnsignedAdd8;
// using unisim::util::arithmetic::SignedSatAdd32;
// using unisim::util::arithmetic::SignedSatSub32;
// using unisim::util::arithmetic::SignExtend;
// using unisim::util::arithmetic::UnsignedSatSub8;
// using unisim::util::arithmetic::RotateRight;
// using unisim::util::arithmetic::UnsignedSub8;

#include <unisim/component/cxx/processor/arm/execute.hh>


namespace unisim {
	namespace component {
		namespace cxx {
			namespace processor {
				namespace arm {
					namespace isa {
						namespace thumb {
							/* decoding method for imm[1:3:8] */
							static
							uint32_t
							ThumbExpandImm( uint32_t code ) /* code: i:imm3:abcdefgh*/
							{
								if        (code >= 0x400)
								return ((code & 0x7f) | 0x80) << ((32 - (code >> 7))  & 0x1f);
								else if (code >= 0x300)
								return 0x1010101 * (code & 0xff);
								else if (code >= 0x200)
								return 0x1000100 * (code & 0xff);
								else if (code >= 0x100)
								return 0x0010001 * (code & 0xff);
								else /* if (code < 0x100) */
								return code & 0xff;
							}

						} // end of namespace thumb2
					} // end of namespace isa
				} // end of namespace arm
			} // end of namespace processor
		} // end of namespace cxx
	} // end of namespace component
} // end of namespace unisim

namespace unisim { namespace component { namespace cxx { namespace processor { namespace arm { namespace isa { namespace thumb {
template <	typename	ARCH>
Operation<	ARCH>::Operation(CodeType _code, uint32_t _addr, const char *_name)
:
encoding(_code),
addr(_addr),
name(_name)
{
}

template <	typename	ARCH>
Operation<	ARCH>::~Operation()
{
}

template <	typename	ARCH>
void Operation<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "; Unknown THUMB instruction";
}}
template <	typename	ARCH>
void Operation<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UndefinedInstruction( this );
}}
template <	typename	ARCH>
class OpLdrh_imm : public Operation<	ARCH>
{
public:
	OpLdrh_imm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t offset;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrh_reg : public Operation<	ARCH>
{
public:
	OpLdrh_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrb_imm : public Operation<	ARCH>
{
public:
	OpLdrb_imm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t offset;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrb_reg : public Operation<	ARCH>
{
public:
	OpLdrb_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsb_imm : public Operation<	ARCH>
{
public:
	OpLdrsb_imm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t offset;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsb_reg : public Operation<	ARCH>
{
public:
	OpLdrsb_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrht : public Operation<	ARCH>
{
public:
	OpLdrht(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrbt : public Operation<	ARCH>
{
public:
	OpLdrbt(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsbt : public Operation<	ARCH>
{
public:
	OpLdrsbt(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMov_reg_shift : public Operation<	ARCH>
{
public:
	OpMov_reg_shift(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	uint8_t imm;
	uint8_t shift;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrn : public Operation<	ARCH>
{
public:
	OpOrn(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrn_rri : public Operation<	ARCH>
{
public:
	OpOrn_rri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   bool cfim;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrr_w : public Operation<	ARCH>
{
public:
	OpOrr_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrr_wrri : public Operation<	ARCH>
{
public:
	OpOrr_wrri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   bool cfim;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_imm : public Operation<	ARCH>
{
public:
	OpLdr_imm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t offset;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_reg : public Operation<	ARCH>
{
public:
	OpLdr_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrh_imm12 : public Operation<	ARCH>
{
public:
	OpLdrh_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrh_lit : public Operation<	ARCH>
{
public:
	OpLdrh_lit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t u;
	uint16_t offset;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsh_imm : public Operation<	ARCH>
{
public:
	OpLdrsh_imm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t offset;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsh_reg : public Operation<	ARCH>
{
public:
	OpLdrsh_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrb_imm12 : public Operation<	ARCH>
{
public:
	OpLdrb_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrb_lit : public Operation<	ARCH>
{
public:
	OpLdrb_lit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t u;
	uint16_t offset;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsb_imm12 : public Operation<	ARCH>
{
public:
	OpLdrsb_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsb_lit : public Operation<	ARCH>
{
public:
	OpLdrsb_lit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t u;
	uint16_t offset;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrt : public Operation<	ARCH>
{
public:
	OpLdrt(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsht : public Operation<	ARCH>
{
public:
	OpLdrsht(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPld_reg : public Operation<	ARCH>
{
public:
	OpPld_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t rm;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPli_reg : public Operation<	ARCH>
{
public:
	OpPli_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpUsada8 : public Operation<	ARCH>
{
public:
	OpUsada8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	uint8_t ra;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBcc_w : public Operation<	ARCH>
{
public:
	OpBcc_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint32_t imm1;
	uint8_t cond;
	int32_t imm4;
	uint16_t imm0;
	uint32_t imm3;
	uint32_t imm2;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMla : public Operation<	ARCH>
{
public:
	OpMla(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	uint8_t ra;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStc : public Operation<	ARCH>
{
public:
	OpStc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t d;
	uint8_t u;
	uint8_t p;
	uint16_t offset;
	uint8_t cp_num;
	uint8_t crd;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStc2 : public Operation<	ARCH>
{
public:
	OpStc2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t d;
	uint8_t u;
	uint8_t p;
	uint16_t offset;
	uint8_t cp_num;
	uint8_t crd;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdc : public Operation<	ARCH>
{
public:
	OpLdc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t d;
	uint8_t u;
	uint8_t p;
	uint16_t offset;
	uint8_t cp_num;
	uint8_t crd;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdc2 : public Operation<	ARCH>
{
public:
	OpLdc2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t d;
	uint8_t u;
	uint8_t p;
	uint16_t offset;
	uint8_t cp_num;
	uint8_t crd;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCps : public Operation<	ARCH>
{
public:
	OpCps(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t mode;
	uint8_t f;
	uint8_t i;
	uint8_t a;
	uint8_t chmod;
	uint8_t dis;
	uint8_t chitm;
	Reject reject;   uint32_t psr_mask;   uint32_t psr_bits; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_s8 : public Operation<	ARCH>
{
public:
	OpVshll_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_s16 : public Operation<	ARCH>
{
public:
	OpVshll_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_s32 : public Operation<	ARCH>
{
public:
	OpVshll_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_u8 : public Operation<	ARCH>
{
public:
	OpVshll_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_u16 : public Operation<	ARCH>
{
public:
	OpVshll_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_u32 : public Operation<	ARCH>
{
public:
	OpVshll_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdc : public Operation<	ARCH>
{
public:
	OpAdc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_1 : public Operation<	ARCH>
{
public:
	OpAdd_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rn;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_2 : public Operation<	ARCH>
{
public:
	OpAdd_2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t imm;
	uint8_t rdn;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_3 : public Operation<	ARCH>
{
public:
	OpAdd_3(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_4 : public Operation<	ARCH>
{
public:
	OpAdd_4(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn0;
	uint8_t rm;
	uint8_t rdn1;
	uint8_t rdn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_4_pc : public Operation<	ARCH>
{
public:
	OpAdd_4_pc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdr : public Operation<	ARCH>
{
public:
	OpAdr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint16_t imm;
	uint8_t rd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_6 : public Operation<	ARCH>
{
public:
	OpAdd_6(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint16_t imm;
	uint8_t rd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_7 : public Operation<	ARCH>
{
public:
	OpAdd_7(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint16_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAnd : public Operation<	ARCH>
{
public:
	OpAnd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAsr_reg : public Operation<	ARCH>
{
public:
	OpAsr_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBic : public Operation<	ARCH>
{
public:
	OpBic(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmn : public Operation<	ARCH>
{
public:
	OpCmn(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmp_1 : public Operation<	ARCH>
{
public:
	OpCmp_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t imm;
	uint8_t rn;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmp_2 : public Operation<	ARCH>
{
public:
	OpCmp_2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmp_3 : public Operation<	ARCH>
{
public:
	OpCmp_3(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rn0;
	uint8_t rm;
	uint8_t rn1;
	uint8_t rn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpEor : public Operation<	ARCH>
{
public:
	OpEor(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLsl_reg : public Operation<	ARCH>
{
public:
	OpLsl_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLsr_reg : public Operation<	ARCH>
{
public:
	OpLsr_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMov_1 : public Operation<	ARCH>
{
public:
	OpMov_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t imm;
	uint8_t rd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMov_3 : public Operation<	ARCH>
{
public:
	OpMov_3(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd0;
	uint8_t rm;
	uint8_t rd1;
	uint8_t rd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMov_3_pc : public Operation<	ARCH>
{
public:
	OpMov_3_pc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMvn : public Operation<	ARCH>
{
public:
	OpMvn(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpNeg : public Operation<	ARCH>
{
public:
	OpNeg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpOrr : public Operation<	ARCH>
{
public:
	OpOrr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRor_reg : public Operation<	ARCH>
{
public:
	OpRor_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbc : public Operation<	ARCH>
{
public:
	OpSbc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rdn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSub_1 : public Operation<	ARCH>
{
public:
	OpSub_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rn;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSub_2 : public Operation<	ARCH>
{
public:
	OpSub_2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t imm;
	uint8_t rdn;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSub_3 : public Operation<	ARCH>
{
public:
	OpSub_3(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSub_4 : public Operation<	ARCH>
{
public:
	OpSub_4(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint16_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTst : public Operation<	ARCH>
{
public:
	OpTst(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRev : public Operation<	ARCH>
{
public:
	OpRev(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRev16 : public Operation<	ARCH>
{
public:
	OpRev16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRevsh : public Operation<	ARCH>
{
public:
	OpRevsh(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSetend : public Operation<	ARCH>
{
public:
	OpSetend(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t endianness;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_1 : public Operation<	ARCH>
{
public:
	OpLdr_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_2 : public Operation<	ARCH>
{
public:
	OpLdr_2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_lit_s : public Operation<	ARCH>
{
public:
	OpLdr_lit_s(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint16_t imm;
	uint8_t rt;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_4 : public Operation<	ARCH>
{
public:
	OpLdr_4(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint16_t imm;
	uint8_t rt;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrb_1 : public Operation<	ARCH>
{
public:
	OpLdrb_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrb_2 : public Operation<	ARCH>
{
public:
	OpLdrb_2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrh_1 : public Operation<	ARCH>
{
public:
	OpLdrh_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrh_2 : public Operation<	ARCH>
{
public:
	OpLdrh_2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsb : public Operation<	ARCH>
{
public:
	OpLdrsb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsh : public Operation<	ARCH>
{
public:
	OpLdrsh(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStr_1 : public Operation<	ARCH>
{
public:
	OpStr_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStr_2 : public Operation<	ARCH>
{
public:
	OpStr_2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStr_3 : public Operation<	ARCH>
{
public:
	OpStr_3(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint16_t imm;
	uint8_t rt;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrb_1 : public Operation<	ARCH>
{
public:
	OpStrb_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrb_2 : public Operation<	ARCH>
{
public:
	OpStrb_2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrh_1 : public Operation<	ARCH>
{
public:
	OpStrh_1(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrh_2 : public Operation<	ARCH>
{
public:
	OpStrh_2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rt;
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdmia : public Operation<	ARCH>
{
public:
	OpLdmia(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint32_t reglist;
	uint8_t rn;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPop : public Operation<	ARCH>
{
public:
	OpPop(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t reglist0;
	uint16_t reglist1;
	uint32_t reglist;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPush : public Operation<	ARCH>
{
public:
	OpPush(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t reglist0;
	uint16_t reglist1;
	uint32_t reglist;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStmia : public Operation<	ARCH>
{
public:
	OpStmia(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t reglist;
	uint8_t rn;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMul : public Operation<	ARCH>
{
public:
	OpMul(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtb : public Operation<	ARCH>
{
public:
	OpSxtb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxth : public Operation<	ARCH>
{
public:
	OpSxth(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtb : public Operation<	ARCH>
{
public:
	OpUxtb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxth : public Operation<	ARCH>
{
public:
	OpUxth(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rd;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBcc : public Operation<	ARCH>
{
public:
	OpBcc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	int32_t imm;
	uint8_t cond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpB : public Operation<	ARCH>
{
public:
	OpB(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	int32_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBx : public Operation<	ARCH>
{
public:
	OpBx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBlx : public Operation<	ARCH>
{
public:
	OpBlx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSwi : public Operation<	ARCH>
{
public:
	OpSwi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBkpt : public Operation<	ARCH>
{
public:
	OpBkpt(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCpsi : public Operation<	ARCH>
{
public:
	OpCpsi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t f;
	uint8_t i;
	uint8_t a;
	uint8_t dis;
	Reject reject;   uint32_t psr_mask;   uint32_t psr_bits; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMov_wri : public Operation<	ARCH>
{
public:
	OpMov_wri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   bool cfim;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMov_w : public Operation<	ARCH>
{
public:
	OpMov_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMovt : public Operation<	ARCH>
{
public:
	OpMovt(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint16_t imm3;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rsd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMovw : public Operation<	ARCH>
{
public:
	OpMovw(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint16_t imm3;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMvn_w : public Operation<	ARCH>
{
public:
	OpMvn_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMvn_wri : public Operation<	ARCH>
{
public:
	OpMvn_wri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   bool cfim;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShift_w : public Operation<	ARCH>
{
public:
	OpShift_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t shift;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSub_w : public Operation<	ARCH>
{
public:
	OpSub_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSub_wrri : public Operation<	ARCH>
{
public:
	OpSub_wrri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSubw : public Operation<	ARCH>
{
public:
	OpSubw(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdr_subw : public Operation<	ARCH>
{
public:
	OpAdr_subw(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbc_w : public Operation<	ARCH>
{
public:
	OpSbc_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbc_wrri : public Operation<	ARCH>
{
public:
	OpSbc_wrri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsb : public Operation<	ARCH>
{
public:
	OpRsb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRsb_rri : public Operation<	ARCH>
{
public:
	OpRsb_rri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_w : public Operation<	ARCH>
{
public:
	OpAdd_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdd_wrri : public Operation<	ARCH>
{
public:
	OpAdd_wrri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAddw : public Operation<	ARCH>
{
public:
	OpAddw(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdr_addw : public Operation<	ARCH>
{
public:
	OpAdr_addw(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdc_w : public Operation<	ARCH>
{
public:
	OpAdc_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAdc_wrri : public Operation<	ARCH>
{
public:
	OpAdc_wrri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpEor_w : public Operation<	ARCH>
{
public:
	OpEor_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpEor_wrri : public Operation<	ARCH>
{
public:
	OpEor_wrri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   bool cfim;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBic_w : public Operation<	ARCH>
{
public:
	OpBic_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBic_wrri : public Operation<	ARCH>
{
public:
	OpBic_wrri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   bool cfim;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAnd_w : public Operation<	ARCH>
{
public:
	OpAnd_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpAnd_wrri : public Operation<	ARCH>
{
public:
	OpAnd_wrri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t s;
	uint16_t imm2;
	uint8_t imm0;
	uint8_t rd;
	uint16_t imm1;
	uint32_t imm;   bool cfim;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmp_w : public Operation<	ARCH>
{
public:
	OpCmp_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmp_wri : public Operation<	ARCH>
{
public:
	OpCmp_wri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm2;
	uint8_t imm0;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmn_w : public Operation<	ARCH>
{
public:
	OpCmn_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCmn_wri : public Operation<	ARCH>
{
public:
	OpCmn_wri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm2;
	uint8_t imm0;
	uint16_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTeq : public Operation<	ARCH>
{
public:
	OpTeq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTeq_wri : public Operation<	ARCH>
{
public:
	OpTeq_wri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm2;
	uint8_t imm0;
	uint16_t imm1;
	uint32_t imm;   bool cfim;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTst_w : public Operation<	ARCH>
{
public:
	OpTst_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t shift;
	uint8_t imm0;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTst_wri : public Operation<	ARCH>
{
public:
	OpTst_wri(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm2;
	uint8_t imm0;
	uint16_t imm1;
	uint32_t imm;   bool cfim;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpClz : public Operation<	ARCH>
{
public:
	OpClz(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rm_;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtab16 : public Operation<	ARCH>
{
public:
	OpUxtab16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtab : public Operation<	ARCH>
{
public:
	OpUxtab(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtah : public Operation<	ARCH>
{
public:
	OpUxtah(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtb16 : public Operation<	ARCH>
{
public:
	OpUxtb16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxtb_w : public Operation<	ARCH>
{
public:
	OpUxtb_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUxth_w : public Operation<	ARCH>
{
public:
	OpUxth_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtab16 : public Operation<	ARCH>
{
public:
	OpSxtab16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtab : public Operation<	ARCH>
{
public:
	OpSxtab(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtah : public Operation<	ARCH>
{
public:
	OpSxtah(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtb16 : public Operation<	ARCH>
{
public:
	OpSxtb16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxtb_w : public Operation<	ARCH>
{
public:
	OpSxtb_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSxth_w : public Operation<	ARCH>
{
public:
	OpSxth_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rotate;
	uint8_t rd;
	uint8_t ror;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUbfx : public Operation<	ARCH>
{
public:
	OpUbfx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t widthm1;
	uint8_t lsb0;
	uint8_t rd;
	uint8_t lsb1;
	uint32_t lsb;   uint32_t width;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSbfx : public Operation<	ARCH>
{
public:
	OpSbfx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t widthm1;
	uint8_t lsb0;
	uint8_t rd;
	uint8_t lsb1;
	uint32_t lsb;   uint32_t width;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBfi : public Operation<	ARCH>
{
public:
	OpBfi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t msb;
	uint8_t lsb0;
	uint8_t rd;
	uint8_t lsb1;
	uint8_t lsb;   uint32_t width;   uint32_t clear;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBfc : public Operation<	ARCH>
{
public:
	OpBfc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t msb;
	uint8_t lsb0;
	uint8_t rd;
	uint8_t lsb1;
	uint32_t lsb;   uint32_t width;   uint32_t clear;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRbit : public Operation<	ARCH>
{
public:
	OpRbit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rm_;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRev_w : public Operation<	ARCH>
{
public:
	OpRev_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rm_;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRev16_w : public Operation<	ARCH>
{
public:
	OpRev16_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rm_;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpRevsh_w : public Operation<	ARCH>
{
public:
	OpRevsh_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rm;
	uint8_t rm_;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_imm12 : public Operation<	ARCH>
{
public:
	OpLdr_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdr_lit : public Operation<	ARCH>
{
public:
	OpLdr_lit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t u;
	uint16_t offset;
	uint8_t rt;
	int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsh_imm12 : public Operation<	ARCH>
{
public:
	OpLdrsh_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrsh_lit : public Operation<	ARCH>
{
public:
	OpLdrsh_lit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t u;
	uint16_t offset;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrd : public Operation<	ARCH>
{
public:
	OpLdrd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint16_t offset;
	uint8_t rt2;
	uint8_t rt1;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrd_lit : public Operation<	ARCH>
{
public:
	OpLdrd_lit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t u;
	uint16_t offset;
	uint8_t rt2;
	uint8_t rt1;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStr_imm12 : public Operation<	ARCH>
{
public:
	OpStr_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStr_imm : public Operation<	ARCH>
{
public:
	OpStr_imm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t offset;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStr_reg : public Operation<	ARCH>
{
public:
	OpStr_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrh_imm12 : public Operation<	ARCH>
{
public:
	OpStrh_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrh_imm : public Operation<	ARCH>
{
public:
	OpStrh_imm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t offset;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrh_reg : public Operation<	ARCH>
{
public:
	OpStrh_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrb_imm12 : public Operation<	ARCH>
{
public:
	OpStrb_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrb_imm : public Operation<	ARCH>
{
public:
	OpStrb_imm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t offset;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint8_t rt;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrb_reg : public Operation<	ARCH>
{
public:
	OpStrb_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrd : public Operation<	ARCH>
{
public:
	OpStrd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t u;
	uint8_t p;
	uint16_t offset;
	uint8_t rt2;
	uint8_t rt1;
	int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrt : public Operation<	ARCH>
{
public:
	OpStrt(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrht : public Operation<	ARCH>
{
public:
	OpStrht(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrbt : public Operation<	ARCH>
{
public:
	OpStrbt(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPld_imm12 : public Operation<	ARCH>
{
public:
	OpPld_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint16_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPld_nimm : public Operation<	ARCH>
{
public:
	OpPld_nimm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t offset;
	int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPld_lit : public Operation<	ARCH>
{
public:
	OpPld_lit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t w;
	uint8_t u;
	uint16_t offset;
	int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPli_imm12 : public Operation<	ARCH>
{
public:
	OpPli_imm12(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpPli_nimm : public Operation<	ARCH>
{
public:
	OpPli_nimm(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t offset;
	int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpPli_lit : public Operation<	ARCH>
{
public:
	OpPli_lit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t u;
	uint16_t offset;
	int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpLdmdb : public Operation<	ARCH>
{
public:
	OpLdmdb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint16_t reglist;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdmia_w : public Operation<	ARCH>
{
public:
	OpLdmia_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint16_t reglist;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStmdb : public Operation<	ARCH>
{
public:
	OpStmdb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint16_t reglist;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStmia_w : public Operation<	ARCH>
{
public:
	OpStmia_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint16_t reglist;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrex : public Operation<	ARCH>
{
public:
	OpLdrex(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrexh : public Operation<	ARCH>
{
public:
	OpLdrexh(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrexb : public Operation<	ARCH>
{
public:
	OpLdrexb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdrexd : public Operation<	ARCH>
{
public:
	OpLdrexd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rt2;
	uint8_t rt1;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrex : public Operation<	ARCH>
{
public:
	OpStrex(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint16_t imm;
	uint8_t rd;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrexh : public Operation<	ARCH>
{
public:
	OpStrexh(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rd;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrexb : public Operation<	ARCH>
{
public:
	OpStrexb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rd;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStrexd : public Operation<	ARCH>
{
public:
	OpStrexd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rd;
	uint8_t rt2;
	uint8_t rt1;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpClrex : public Operation<	ARCH>
{
public:
	OpClrex(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQadd : public Operation<	ARCH>
{
public:
	OpQadd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQadd16 : public Operation<	ARCH>
{
public:
	OpQadd16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQadd8 : public Operation<	ARCH>
{
public:
	OpQadd8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQsub : public Operation<	ARCH>
{
public:
	OpQsub(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQsub16 : public Operation<	ARCH>
{
public:
	OpQsub16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQsub8 : public Operation<	ARCH>
{
public:
	OpQsub8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQdadd : public Operation<	ARCH>
{
public:
	OpQdadd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQdsub : public Operation<	ARCH>
{
public:
	OpQdsub(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpPkh : public Operation<	ARCH>
{
public:
	OpPkh(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t tb;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSel : public Operation<	ARCH>
{
public:
	OpSel(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsat : public Operation<	ARCH>
{
public:
	OpSsat(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t sh;
	uint8_t sat_imm;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsat16 : public Operation<	ARCH>
{
public:
	OpSsat16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t sat_imm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsat : public Operation<	ARCH>
{
public:
	OpUsat(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t sh;
	uint8_t sat_imm;
	uint8_t imm0;
	uint8_t rd;
	uint8_t imm1;
	uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsat16 : public Operation<	ARCH>
{
public:
	OpUsat16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t sat_imm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUadd16 : public Operation<	ARCH>
{
public:
	OpUadd16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUadd8 : public Operation<	ARCH>
{
public:
	OpUadd8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsub16 : public Operation<	ARCH>
{
public:
	OpUsub16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsub8 : public Operation<	ARCH>
{
public:
	OpUsub8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSadd16 : public Operation<	ARCH>
{
public:
	OpSadd16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSadd8 : public Operation<	ARCH>
{
public:
	OpSadd8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsub16 : public Operation<	ARCH>
{
public:
	OpSsub16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsub8 : public Operation<	ARCH>
{
public:
	OpSsub8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqadd16 : public Operation<	ARCH>
{
public:
	OpUqadd16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqadd8 : public Operation<	ARCH>
{
public:
	OpUqadd8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqsub16 : public Operation<	ARCH>
{
public:
	OpUqsub16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqsub8 : public Operation<	ARCH>
{
public:
	OpUqsub8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsad8 : public Operation<	ARCH>
{
public:
	OpUsad8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhadd16 : public Operation<	ARCH>
{
public:
	OpUhadd16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhadd8 : public Operation<	ARCH>
{
public:
	OpUhadd8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShadd16 : public Operation<	ARCH>
{
public:
	OpShadd16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShadd8 : public Operation<	ARCH>
{
public:
	OpShadd8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhsub16 : public Operation<	ARCH>
{
public:
	OpUhsub16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhsub8 : public Operation<	ARCH>
{
public:
	OpUhsub8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShsub16 : public Operation<	ARCH>
{
public:
	OpShsub16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShsub8 : public Operation<	ARCH>
{
public:
	OpShsub8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQasx : public Operation<	ARCH>
{
public:
	OpQasx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpQsax : public Operation<	ARCH>
{
public:
	OpQsax(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqasx : public Operation<	ARCH>
{
public:
	OpUqasx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUqsax : public Operation<	ARCH>
{
public:
	OpUqsax(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSasx : public Operation<	ARCH>
{
public:
	OpSasx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSsax : public Operation<	ARCH>
{
public:
	OpSsax(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUasx : public Operation<	ARCH>
{
public:
	OpUasx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUsax : public Operation<	ARCH>
{
public:
	OpUsax(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShasx : public Operation<	ARCH>
{
public:
	OpShasx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpShsax : public Operation<	ARCH>
{
public:
	OpShsax(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhasx : public Operation<	ARCH>
{
public:
	OpUhasx(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUhsax : public Operation<	ARCH>
{
public:
	OpUhsax(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBl_w : public Operation<	ARCH>
{
public:
	OpBl_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	int32_t imm1;
	uint16_t imm0;
	uint32_t j2;
	uint32_t j1;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBlx_w : public Operation<	ARCH>
{
public:
	OpBlx_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	int32_t imm1;
	uint16_t imm0;
	uint32_t j2;
	uint32_t j1;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCbnz : public Operation<	ARCH>
{
public:
	OpCbnz(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t rn;
	uint8_t imm0;
	uint8_t imm1;
	uint8_t nz;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpB_w : public Operation<	ARCH>
{
public:
	OpB_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint32_t imm1;
	int32_t imm4;
	uint16_t imm0;
	uint32_t imm2;
	uint32_t imm3;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpBxj : public Operation<	ARCH>
{
public:
	OpBxj(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t ra;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpIt : public Operation<	ARCH>
{
public:
	OpIt(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t mask;
	uint8_t firstcond;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpNop : public Operation<	ARCH>
{
public:
	OpNop(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	uint8_t idx;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTbb : public Operation<	ARCH>
{
public:
	OpTbb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpTbh : public Operation<	ARCH>
{
public:
	OpTbh(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMul_w : public Operation<	ARCH>
{
public:
	OpMul_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMls : public Operation<	ARCH>
{
public:
	OpMls(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	uint8_t ra;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUmull : public Operation<	ARCH>
{
public:
	OpUmull(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rdhi;
	uint8_t rdlo;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUmlal : public Operation<	ARCH>
{
public:
	OpUmlal(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rdhi;
	uint8_t rdlo;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUmaal : public Operation<	ARCH>
{
public:
	OpUmaal(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rdhi;
	uint8_t rdlo;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmull : public Operation<	ARCH>
{
public:
	OpSmull(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rdhi;
	uint8_t rdlo;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSdiv : public Operation<	ARCH>
{
public:
	OpSdiv(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpUdiv : public Operation<	ARCH>
{
public:
	OpUdiv(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlalxy : public Operation<	ARCH>
{
public:
	OpSmlalxy(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t m;
	uint8_t n;
	uint8_t rdhi;
	uint8_t rdlo;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlal : public Operation<	ARCH>
{
public:
	OpSmlal(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t rdhi;
	uint8_t rdlo;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlaxy : public Operation<	ARCH>
{
public:
	OpSmlaxy(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t m;
	uint8_t n;
	uint8_t rd;
	uint8_t ra;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmulxy : public Operation<	ARCH>
{
public:
	OpSmulxy(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t m;
	uint8_t n;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlawy : public Operation<	ARCH>
{
public:
	OpSmlawy(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t m;
	uint8_t rd;
	uint8_t ra;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmulwy : public Operation<	ARCH>
{
public:
	OpSmulwy(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t m;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlad : public Operation<	ARCH>
{
public:
	OpSmlad(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t swap;
	uint8_t rd;
	uint8_t ra;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlald : public Operation<	ARCH>
{
public:
	OpSmlald(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t swap;
	uint8_t rdhi;
	uint8_t rdlo;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlsd : public Operation<	ARCH>
{
public:
	OpSmlsd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t swap;
	uint8_t rd;
	uint8_t ra;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmlsld : public Operation<	ARCH>
{
public:
	OpSmlsld(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t swap;
	uint8_t rdhi;
	uint8_t rdlo;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmmla : public Operation<	ARCH>
{
public:
	OpSmmla(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t round;
	uint8_t rd;
	uint8_t ra;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmmls : public Operation<	ARCH>
{
public:
	OpSmmls(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t round;
	uint8_t rd;
	uint8_t ra;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmmul : public Operation<	ARCH>
{
public:
	OpSmmul(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t round;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmuad : public Operation<	ARCH>
{
public:
	OpSmuad(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t swap;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSmusd : public Operation<	ARCH>
{
public:
	OpSmusd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t rm;
	uint8_t swap;
	uint8_t rd;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrc : public Operation<	ARCH>
{
public:
	OpMrc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t crn;
	uint8_t opc1;
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t rt;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrc2 : public Operation<	ARCH>
{
public:
	OpMrc2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t crn;
	uint8_t opc1;
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t rt;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMcr : public Operation<	ARCH>
{
public:
	OpMcr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t crn;
	uint8_t opc1;
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t rt;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMcr2 : public Operation<	ARCH>
{
public:
	OpMcr2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t crn;
	uint8_t opc1;
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t rt;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCdp : public Operation<	ARCH>
{
public:
	OpCdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t cr2;
	uint8_t opc1;
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t cr1;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCdp2 : public Operation<	ARCH>
{
public:
	OpCdp2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t cr2;
	uint8_t opc1;
	uint8_t crm;
	uint8_t opc2;
	uint8_t cp_num;
	uint8_t cr1;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrrc : public Operation<	ARCH>
{
public:
	OpMrrc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t crm;
	uint8_t opc1;
	uint8_t cp_num;
	uint8_t rd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrrc2 : public Operation<	ARCH>
{
public:
	OpMrrc2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t crm;
	uint8_t opc1;
	uint8_t cp_num;
	uint8_t rd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMcrr : public Operation<	ARCH>
{
public:
	OpMcrr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t r1;
	uint8_t cr;
	uint8_t x;
	uint8_t cp_num;
	uint8_t r0;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMcrr2 : public Operation<	ARCH>
{
public:
	OpMcrr2(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t r1;
	uint8_t cr;
	uint8_t x;
	uint8_t cp_num;
	uint8_t r0;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStc_unindexed : public Operation<	ARCH>
{
public:
	OpStc_unindexed(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t d;
	uint8_t option;
	uint8_t cp_num;
	uint8_t crd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpStc2_unindexed : public Operation<	ARCH>
{
public:
	OpStc2_unindexed(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t d;
	uint8_t option;
	uint8_t cp_num;
	uint8_t crd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdc_unindexed : public Operation<	ARCH>
{
public:
	OpLdc_unindexed(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t d;
	uint8_t option;
	uint8_t cp_num;
	uint8_t crd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpLdc2_unindexed : public Operation<	ARCH>
{
public:
	OpLdc2_unindexed(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t d;
	uint8_t option;
	uint8_t cp_num;
	uint8_t crd;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCp15_mcr : public Operation<	ARCH>
{
public:
	OpCp15_mcr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t crn;
	uint8_t opc1;
	uint8_t crm;
	uint8_t opc2;
	uint8_t rt;
	typename ARCH::CP15Reg const* cp15reg;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpCp15_mrc : public Operation<	ARCH>
{
public:
	OpCp15_mrc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t crn;
	uint8_t opc1;
	uint8_t crm;
	uint8_t opc2;
	uint8_t rt;
	typename ARCH::CP15Reg const* cp15reg;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpNopw : public Operation<	ARCH>
{
public:
	OpNopw(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpYield : public Operation<	ARCH>
{
public:
	OpYield(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpYield_w : public Operation<	ARCH>
{
public:
	OpYield_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpDbg_i : public Operation<	ARCH>
{
public:
	OpDbg_i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpDmb : public Operation<	ARCH>
{
public:
	OpDmb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t opt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpDsb : public Operation<	ARCH>
{
public:
	OpDsb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t opt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpIsb : public Operation<	ARCH>
{
public:
	OpIsb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t opt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpWfe : public Operation<	ARCH>
{
public:
	OpWfe(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpWfi : public Operation<	ARCH>
{
public:
	OpWfi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSev : public Operation<	ARCH>
{
public:
	OpSev(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 16; }
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpWfe_w : public Operation<	ARCH>
{
public:
	OpWfe_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpWfi_w : public Operation<	ARCH>
{
public:
	OpWfi_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpSev_w : public Operation<	ARCH>
{
public:
	OpSev_w(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpRfedb : public Operation<	ARCH>
{
public:
	OpRfedb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t r0;
	uint8_t x;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpRfeia : public Operation<	ARCH>
{
public:
	OpRfeia(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t r0;
	uint8_t x;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpSrsdb : public Operation<	ARCH>
{
public:
	OpSrsdb(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t r0;
	uint8_t x;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpSrsia : public Operation<	ARCH>
{
public:
	OpSrsia(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t r0;
	uint8_t x;
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpSmc_i : public Operation<	ARCH>
{
public:
	OpSmc_i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm0;
	uint16_t imm2;
	uint16_t imm1;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpHvc_i : public Operation<	ARCH>
{
public:
	OpHvc_i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint16_t imm1;
	uint16_t imm0;
	uint32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpSubspc : public Operation<	ARCH>
{
public:
	OpSubspc(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMrs : public Operation<	ARCH>
{
public:
	OpMrs(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t sr0;
	uint8_t sr2;
	uint8_t sr1;
	uint8_t rd;
	uint32_t sr; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpMsr_reg : public Operation<	ARCH>
{
public:
	OpMsr_reg(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t sr2;
	uint8_t sr1;
	uint8_t sr0;
	uint32_t sr; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpMsr_reg_psr : public Operation<	ARCH>
{
public:
	OpMsr_reg_psr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t write_spsr;
	uint8_t mask;
	uint32_t psr_mask; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVabs_f32 : public Operation<	ARCH>
{
public:
	OpVabs_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVabs_f64 : public Operation<	ARCH>
{
public:
	OpVabs_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_f32 : public Operation<	ARCH>
{
public:
	OpVadd_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_f64 : public Operation<	ARCH>
{
public:
	OpVadd_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcmp_f32d : public Operation<	ARCH>
{
public:
	OpVcmp_f32d(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t e;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcmp_f64d : public Operation<	ARCH>
{
public:
	OpVcmp_f64d(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t e;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcmp_f32i : public Operation<	ARCH>
{
public:
	OpVcmp_f32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t e;
	uint8_t vd0;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcmp_f64i : public Operation<	ARCH>
{
public:
	OpVcmp_f64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t e;
	uint8_t vd0;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvtb_f16_f32 : public Operation<	ARCH>
{
public:
	OpVcvtb_f16_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t t;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvtb_f32_f16 : public Operation<	ARCH>
{
public:
	OpVcvtb_f32_f16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t t;
	uint8_t vd1;
	uint8_t vm;   uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u32 : public Operation<	ARCH>
{
public:
	OpVcvt_f32u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64u32 : public Operation<	ARCH>
{
public:
	OpVcvt_f64u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32s32 : public Operation<	ARCH>
{
public:
	OpVcvt_f32s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64s32 : public Operation<	ARCH>
{
public:
	OpVcvt_f64s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f32 : public Operation<	ARCH>
{
public:
	OpVcvt_u32f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvtr_u32f32 : public Operation<	ARCH>
{
public:
	OpVcvtr_u32f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f64 : public Operation<	ARCH>
{
public:
	OpVcvt_u32f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvtr_u32f64 : public Operation<	ARCH>
{
public:
	OpVcvtr_u32f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f32 : public Operation<	ARCH>
{
public:
	OpVcvt_s32f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvtr_s32f32 : public Operation<	ARCH>
{
public:
	OpVcvtr_s32f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f64 : public Operation<	ARCH>
{
public:
	OpVcvt_s32f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvtr_s32f64 : public Operation<	ARCH>
{
public:
	OpVcvtr_s32f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32s16i : public Operation<	ARCH>
{
public:
	OpVcvt_f32s16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32s32i : public Operation<	ARCH>
{
public:
	OpVcvt_f32s32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64s16i : public Operation<	ARCH>
{
public:
	OpVcvt_f64s16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64s32i : public Operation<	ARCH>
{
public:
	OpVcvt_f64s32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u16i : public Operation<	ARCH>
{
public:
	OpVcvt_f32u16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u32i : public Operation<	ARCH>
{
public:
	OpVcvt_f32u32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64u16i : public Operation<	ARCH>
{
public:
	OpVcvt_f64u16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64u32i : public Operation<	ARCH>
{
public:
	OpVcvt_f64u32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s16f32i : public Operation<	ARCH>
{
public:
	OpVcvt_s16f32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s16f64i : public Operation<	ARCH>
{
public:
	OpVcvt_s16f64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f32i : public Operation<	ARCH>
{
public:
	OpVcvt_s32f32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f64i : public Operation<	ARCH>
{
public:
	OpVcvt_s32f64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u16f32i : public Operation<	ARCH>
{
public:
	OpVcvt_u16f32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u16f64i : public Operation<	ARCH>
{
public:
	OpVcvt_u16f64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f32i : public Operation<	ARCH>
{
public:
	OpVcvt_u32f32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd1;
	int32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f64i : public Operation<	ARCH>
{
public:
	OpVcvt_u32f64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t imm1;
	uint8_t imm0;
	uint8_t vd0;
	uint32_t imm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f64f32 : public Operation<	ARCH>
{
public:
	OpVcvt_f64f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcvt_f32f64 : public Operation<	ARCH>
{
public:
	OpVcvt_f32f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdiv_f32 : public Operation<	ARCH>
{
public:
	OpVdiv_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdiv_f64 : public Operation<	ARCH>
{
public:
	OpVdiv_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfma_f32 : public Operation<	ARCH>
{
public:
	OpVfma_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfma_f64 : public Operation<	ARCH>
{
public:
	OpVfma_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfms_f32 : public Operation<	ARCH>
{
public:
	OpVfms_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfms_f64 : public Operation<	ARCH>
{
public:
	OpVfms_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfnma_f32 : public Operation<	ARCH>
{
public:
	OpVfnma_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfnma_f64 : public Operation<	ARCH>
{
public:
	OpVfnma_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfnms_f32 : public Operation<	ARCH>
{
public:
	OpVfnms_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVfnms_f64 : public Operation<	ARCH>
{
public:
	OpVfnms_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldmdb_f32 : public Operation<	ARCH>
{
public:
	OpVldmdb_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd0;
	uint8_t regs;
	uint8_t vd1;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldmdb_f64 : public Operation<	ARCH>
{
public:
	OpVldmdb_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t fldm;
	uint8_t regs;
	uint8_t vd0;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldmia_f32 : public Operation<	ARCH>
{
public:
	OpVldmia_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t vd0;
	uint8_t regs;
	uint8_t vd1;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldmia_f64 : public Operation<	ARCH>
{
public:
	OpVldmia_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t vd1;
	uint8_t fldm;
	uint8_t regs;
	uint8_t vd0;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldr_32 : public Operation<	ARCH>
{
public:
	OpVldr_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd0;
	uint8_t u;
	uint16_t offset;
	uint8_t vd1;
	uint32_t vd;   int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldr_literal_32 : public Operation<	ARCH>
{
public:
	OpVldr_literal_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t u;
	uint16_t offset;
	uint8_t vd1;
	uint32_t vd;   int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldr_64 : public Operation<	ARCH>
{
public:
	OpVldr_64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t u;
	uint16_t offset;
	uint8_t vd0;
	uint32_t vd;   int32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldr_literal_64 : public Operation<	ARCH>
{
public:
	OpVldr_literal_64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t u;
	uint16_t offset;
	uint8_t vd0;
	uint32_t vd;   int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmla_f32 : public Operation<	ARCH>
{
public:
	OpVmla_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmla_f64 : public Operation<	ARCH>
{
public:
	OpVmla_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmls_f32 : public Operation<	ARCH>
{
public:
	OpVmls_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmls_f64 : public Operation<	ARCH>
{
public:
	OpVmls_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmla_f32 : public Operation<	ARCH>
{
public:
	OpVnmla_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmla_f64 : public Operation<	ARCH>
{
public:
	OpVnmla_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmls_f32 : public Operation<	ARCH>
{
public:
	OpVnmls_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmls_f64 : public Operation<	ARCH>
{
public:
	OpVnmls_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_f32i : public Operation<	ARCH>
{
public:
	OpVmov_f32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t exp;
	uint8_t n;
	uint8_t vd0;
	uint8_t man;
	uint8_t vd1;
	uint32_t vd;   typename ARCH::F32 fpimm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_f64i : public Operation<	ARCH>
{
public:
	OpVmov_f64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t exp;
	uint8_t n;
	uint8_t vd1;
	uint8_t man;
	uint8_t vd0;
	uint32_t vd;   typename ARCH::F64 fpimm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_f32s : public Operation<	ARCH>
{
public:
	OpVmov_f32s(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_f64d : public Operation<	ARCH>
{
public:
	OpVmov_f64d(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_rs : public Operation<	ARCH>
{
public:
	OpVmov_rs(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vn0;
	uint8_t rt;
	uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_sr : public Operation<	ARCH>
{
public:
	OpVmov_sr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vn0;
	uint8_t rt;
	uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_ssrr : public Operation<	ARCH>
{
public:
	OpVmov_ssrr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rt2;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t rt;
	uint32_t vm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_rrss : public Operation<	ARCH>
{
public:
	OpVmov_rrss(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rt2;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t rt;
	uint32_t vm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_rrd : public Operation<	ARCH>
{
public:
	OpVmov_rrd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rt2;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t rt;
	uint32_t vm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_drr : public Operation<	ARCH>
{
public:
	OpVmov_drr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rt2;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t rt;
	uint32_t vm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmrs : public Operation<	ARCH>
{
public:
	OpVmrs(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t spr;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmsr : public Operation<	ARCH>
{
public:
	OpVmsr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t spr;
	uint8_t rt;
	Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_f32 : public Operation<	ARCH>
{
public:
	OpVmul_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_f64 : public Operation<	ARCH>
{
public:
	OpVmul_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmul_f32 : public Operation<	ARCH>
{
public:
	OpVnmul_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVnmul_f64 : public Operation<	ARCH>
{
public:
	OpVnmul_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVneg_f32 : public Operation<	ARCH>
{
public:
	OpVneg_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVneg_f64 : public Operation<	ARCH>
{
public:
	OpVneg_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsqrt_f32s : public Operation<	ARCH>
{
public:
	OpVsqrt_f32s(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsqrt_f64d : public Operation<	ARCH>
{
public:
	OpVsqrt_f64d(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstmdb_f32 : public Operation<	ARCH>
{
public:
	OpVstmdb_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd0;
	uint8_t regs;
	uint8_t vd1;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstmdb_f64 : public Operation<	ARCH>
{
public:
	OpVstmdb_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t fstm;
	uint8_t regs;
	uint8_t vd0;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstmia_f32 : public Operation<	ARCH>
{
public:
	OpVstmia_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t vd0;
	uint8_t regs;
	uint8_t vd1;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstmia_f64 : public Operation<	ARCH>
{
public:
	OpVstmia_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t w;
	uint8_t vd1;
	uint8_t fstm;
	uint8_t regs;
	uint8_t vd0;
	uint32_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstr_32 : public Operation<	ARCH>
{
public:
	OpVstr_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vn0;
	uint8_t u;
	uint16_t offset;
	uint8_t vn1;
	uint32_t vn;   int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstr_64 : public Operation<	ARCH>
{
public:
	OpVstr_64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vn1;
	uint8_t u;
	uint16_t offset;
	uint8_t vn0;
	uint32_t vn;   int32_t imm; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_f32 : public Operation<	ARCH>
{
public:
	OpVsub_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm1;
	uint8_t vm0;
	uint8_t vn0;
	uint8_t vd1;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_f64 : public Operation<	ARCH>
{
public:
	OpVsub_f64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t vm;   uint32_t vd;   uint32_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaba_s8 : public Operation<	ARCH>
{
public:
	OpVaba_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVaba_s16 : public Operation<	ARCH>
{
public:
	OpVaba_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVaba_s32 : public Operation<	ARCH>
{
public:
	OpVaba_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVaba_u8 : public Operation<	ARCH>
{
public:
	OpVaba_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVaba_u16 : public Operation<	ARCH>
{
public:
	OpVaba_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVaba_u32 : public Operation<	ARCH>
{
public:
	OpVaba_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabal_s8qd : public Operation<	ARCH>
{
public:
	OpVabal_s8qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabal_s16qd : public Operation<	ARCH>
{
public:
	OpVabal_s16qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabal_s32qd : public Operation<	ARCH>
{
public:
	OpVabal_s32qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabal_u8qd : public Operation<	ARCH>
{
public:
	OpVabal_u8qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabal_u16qd : public Operation<	ARCH>
{
public:
	OpVabal_u16qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabal_u32qd : public Operation<	ARCH>
{
public:
	OpVabal_u32qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabd_s8 : public Operation<	ARCH>
{
public:
	OpVabd_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabd_s16 : public Operation<	ARCH>
{
public:
	OpVabd_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabd_s32 : public Operation<	ARCH>
{
public:
	OpVabd_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabd_u8 : public Operation<	ARCH>
{
public:
	OpVabd_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabd_u16 : public Operation<	ARCH>
{
public:
	OpVabd_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabd_u32 : public Operation<	ARCH>
{
public:
	OpVabd_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_s8qd : public Operation<	ARCH>
{
public:
	OpVabdl_s8qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_s16qd : public Operation<	ARCH>
{
public:
	OpVabdl_s16qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_s32qd : public Operation<	ARCH>
{
public:
	OpVabdl_s32qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_u8qd : public Operation<	ARCH>
{
public:
	OpVabdl_u8qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_u16qd : public Operation<	ARCH>
{
public:
	OpVabdl_u16qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabdl_u32qd : public Operation<	ARCH>
{
public:
	OpVabdl_u32qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabd_f32 : public Operation<	ARCH>
{
public:
	OpVabd_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabs_s8 : public Operation<	ARCH>
{
public:
	OpVabs_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabs_s16 : public Operation<	ARCH>
{
public:
	OpVabs_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabs_s32 : public Operation<	ARCH>
{
public:
	OpVabs_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVabs_f32v : public Operation<	ARCH>
{
public:
	OpVabs_f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVacge_f32 : public Operation<	ARCH>
{
public:
	OpVacge_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVacgt_f32 : public Operation<	ARCH>
{
public:
	OpVacgt_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVadd_f32v : public Operation<	ARCH>
{
public:
	OpVadd_f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVadd_i8 : public Operation<	ARCH>
{
public:
	OpVadd_i8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	typedef struct { enum { elements=8 }; } CFG;   typedef typename ARCH::U8 OP;   uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_i16 : public Operation<	ARCH>
{
public:
	OpVadd_i16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	typedef struct { enum { elements=4 }; } CFG;   typedef typename ARCH::U16 OP;   uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_i32 : public Operation<	ARCH>
{
public:
	OpVadd_i32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	typedef struct { enum { elements=2 }; } CFG;   typedef typename ARCH::U32 OP;   uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVadd_i64 : public Operation<	ARCH>
{
public:
	OpVadd_i64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	typedef struct { enum { elements=1 }; } CFG;   typedef typename ARCH::U64 OP;   uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddhn_i16dq : public Operation<	ARCH>
{
public:
	OpVaddhn_i16dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVaddhn_i32dq : public Operation<	ARCH>
{
public:
	OpVaddhn_i32dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVaddhn_i64dq : public Operation<	ARCH>
{
public:
	OpVaddhn_i64dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVaddl_s8 : public Operation<	ARCH>
{
public:
	OpVaddl_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_s16 : public Operation<	ARCH>
{
public:
	OpVaddl_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_s32 : public Operation<	ARCH>
{
public:
	OpVaddl_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_u8 : public Operation<	ARCH>
{
public:
	OpVaddl_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_u16 : public Operation<	ARCH>
{
public:
	OpVaddl_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddl_u32 : public Operation<	ARCH>
{
public:
	OpVaddl_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_s8 : public Operation<	ARCH>
{
public:
	OpVaddw_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_s16 : public Operation<	ARCH>
{
public:
	OpVaddw_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_s32 : public Operation<	ARCH>
{
public:
	OpVaddw_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_u8 : public Operation<	ARCH>
{
public:
	OpVaddw_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_u16 : public Operation<	ARCH>
{
public:
	OpVaddw_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVaddw_u32 : public Operation<	ARCH>
{
public:
	OpVaddw_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVand : public Operation<	ARCH>
{
public:
	OpVand(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVbic : public Operation<	ARCH>
{
public:
	OpVbic(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVbic_i16i : public Operation<	ARCH>
{
public:
	OpVbic_i16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVbic_i32i : public Operation<	ARCH>
{
public:
	OpVbic_i32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVbif : public Operation<	ARCH>
{
public:
	OpVbif(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVbit : public Operation<	ARCH>
{
public:
	OpVbit(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVbsl : public Operation<	ARCH>
{
public:
	OpVbsl(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_f32 : public Operation<	ARCH>
{
public:
	OpVceq_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVceq_f8z : public Operation<	ARCH>
{
public:
	OpVceq_f8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVceq_f16z : public Operation<	ARCH>
{
public:
	OpVceq_f16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVceq_f32z : public Operation<	ARCH>
{
public:
	OpVceq_f32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVceq_i8z : public Operation<	ARCH>
{
public:
	OpVceq_i8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i16z : public Operation<	ARCH>
{
public:
	OpVceq_i16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i32z : public Operation<	ARCH>
{
public:
	OpVceq_i32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i8 : public Operation<	ARCH>
{
public:
	OpVceq_i8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i16 : public Operation<	ARCH>
{
public:
	OpVceq_i16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVceq_i32 : public Operation<	ARCH>
{
public:
	OpVceq_i32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_f8z : public Operation<	ARCH>
{
public:
	OpVcge_f8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcge_f16z : public Operation<	ARCH>
{
public:
	OpVcge_f16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcge_f32 : public Operation<	ARCH>
{
public:
	OpVcge_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcge_f32z : public Operation<	ARCH>
{
public:
	OpVcge_f32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcge_s8z : public Operation<	ARCH>
{
public:
	OpVcge_s8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s16z : public Operation<	ARCH>
{
public:
	OpVcge_s16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s32z : public Operation<	ARCH>
{
public:
	OpVcge_s32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s8 : public Operation<	ARCH>
{
public:
	OpVcge_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s16 : public Operation<	ARCH>
{
public:
	OpVcge_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_s32 : public Operation<	ARCH>
{
public:
	OpVcge_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_u8 : public Operation<	ARCH>
{
public:
	OpVcge_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_u16 : public Operation<	ARCH>
{
public:
	OpVcge_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcge_u32 : public Operation<	ARCH>
{
public:
	OpVcge_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_f8z : public Operation<	ARCH>
{
public:
	OpVcgt_f8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcgt_f16z : public Operation<	ARCH>
{
public:
	OpVcgt_f16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcgt_f32z : public Operation<	ARCH>
{
public:
	OpVcgt_f32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcgt_f32 : public Operation<	ARCH>
{
public:
	OpVcgt_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcgt_s8z : public Operation<	ARCH>
{
public:
	OpVcgt_s8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s16z : public Operation<	ARCH>
{
public:
	OpVcgt_s16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s32z : public Operation<	ARCH>
{
public:
	OpVcgt_s32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s8 : public Operation<	ARCH>
{
public:
	OpVcgt_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s16 : public Operation<	ARCH>
{
public:
	OpVcgt_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_s32 : public Operation<	ARCH>
{
public:
	OpVcgt_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_u8 : public Operation<	ARCH>
{
public:
	OpVcgt_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_u16 : public Operation<	ARCH>
{
public:
	OpVcgt_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcgt_u32 : public Operation<	ARCH>
{
public:
	OpVcgt_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcle_f8z : public Operation<	ARCH>
{
public:
	OpVcle_f8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcle_f16z : public Operation<	ARCH>
{
public:
	OpVcle_f16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcle_f32z : public Operation<	ARCH>
{
public:
	OpVcle_f32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcle_s8z : public Operation<	ARCH>
{
public:
	OpVcle_s8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcle_s16z : public Operation<	ARCH>
{
public:
	OpVcle_s16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcle_s32z : public Operation<	ARCH>
{
public:
	OpVcle_s32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVcls_s8 : public Operation<	ARCH>
{
public:
	OpVcls_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcls_s16 : public Operation<	ARCH>
{
public:
	OpVcls_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcls_s32 : public Operation<	ARCH>
{
public:
	OpVcls_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVclt_f8z : public Operation<	ARCH>
{
public:
	OpVclt_f8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVclt_f16z : public Operation<	ARCH>
{
public:
	OpVclt_f16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVclt_f32z : public Operation<	ARCH>
{
public:
	OpVclt_f32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVclt_s8z : public Operation<	ARCH>
{
public:
	OpVclt_s8z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVclt_s16z : public Operation<	ARCH>
{
public:
	OpVclt_s16z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVclt_s32z : public Operation<	ARCH>
{
public:
	OpVclt_s32z(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVclz_i8 : public Operation<	ARCH>
{
public:
	OpVclz_i8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVclz_i16 : public Operation<	ARCH>
{
public:
	OpVclz_i16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVclz_i32 : public Operation<	ARCH>
{
public:
	OpVclz_i32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcnt_8 : public Operation<	ARCH>
{
public:
	OpVcnt_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f16_f32 : public Operation<	ARCH>
{
public:
	OpVcvt_f16_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32_f16 : public Operation<	ARCH>
{
public:
	OpVcvt_f32_f16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32_s32 : public Operation<	ARCH>
{
public:
	OpVcvt_f32_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32s32vi : public Operation<	ARCH>
{
public:
	OpVcvt_f32s32vi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	int32_t imm;   uint8_t vd;   uint8_t vm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u32v : public Operation<	ARCH>
{
public:
	OpVcvt_f32u32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_f32u32vi : public Operation<	ARCH>
{
public:
	OpVcvt_f32u32vi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_s32_f32 : public Operation<	ARCH>
{
public:
	OpVcvt_s32_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_s32f32vi : public Operation<	ARCH>
{
public:
	OpVcvt_s32f32vi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	int32_t imm;   uint8_t vd;   uint8_t vm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f32v : public Operation<	ARCH>
{
public:
	OpVcvt_u32f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVcvt_u32f32vi : public Operation<	ARCH>
{
public:
	OpVcvt_u32f32vi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVdup_8dp : public Operation<	ARCH>
{
public:
	OpVdup_8dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t part;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup_16dp : public Operation<	ARCH>
{
public:
	OpVdup_16dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t part;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup_32dp : public Operation<	ARCH>
{
public:
	OpVdup_32dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t part;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup8_r : public Operation<	ARCH>
{
public:
	OpVdup8_r(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t q;
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup16_r : public Operation<	ARCH>
{
public:
	OpVdup16_r(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t q;
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVdup32_r : public Operation<	ARCH>
{
public:
	OpVdup32_r(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t q;
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVeor : public Operation<	ARCH>
{
public:
	OpVeor(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVext_8i : public Operation<	ARCH>
{
public:
	OpVext_8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t imm;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVfma_f32v : public Operation<	ARCH>
{
public:
	OpVfma_f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVfms_f32v : public Operation<	ARCH>
{
public:
	OpVfms_f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_s8 : public Operation<	ARCH>
{
public:
	OpVhadd_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_s16 : public Operation<	ARCH>
{
public:
	OpVhadd_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_s32 : public Operation<	ARCH>
{
public:
	OpVhadd_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_u8 : public Operation<	ARCH>
{
public:
	OpVhadd_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_u16 : public Operation<	ARCH>
{
public:
	OpVhadd_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhadd_u32 : public Operation<	ARCH>
{
public:
	OpVhadd_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_s8 : public Operation<	ARCH>
{
public:
	OpVhsub_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_s16 : public Operation<	ARCH>
{
public:
	OpVhsub_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_s32 : public Operation<	ARCH>
{
public:
	OpVhsub_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_u8 : public Operation<	ARCH>
{
public:
	OpVhsub_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_u16 : public Operation<	ARCH>
{
public:
	OpVhsub_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVhsub_u32 : public Operation<	ARCH>
{
public:
	OpVhsub_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVldms_8 : public Operation<	ARCH>
{
public:
	OpVldms_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms_16 : public Operation<	ARCH>
{
public:
	OpVldms_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms_32 : public Operation<	ARCH>
{
public:
	OpVldms_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms_64 : public Operation<	ARCH>
{
public:
	OpVldms_64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms2s_8 : public Operation<	ARCH>
{
public:
	OpVldms2s_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms2s_16 : public Operation<	ARCH>
{
public:
	OpVldms2s_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldms2s_32 : public Operation<	ARCH>
{
public:
	OpVldms2s_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVld2_8 : public Operation<	ARCH>
{
public:
	OpVld2_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVld2_16 : public Operation<	ARCH>
{
public:
	OpVld2_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVld2_32 : public Operation<	ARCH>
{
public:
	OpVld2_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldal_8 : public Operation<	ARCH>
{
public:
	OpVldal_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVldal_16 : public Operation<	ARCH>
{
public:
	OpVldal_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVldal_32 : public Operation<	ARCH>
{
public:
	OpVldal_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVldqal_8 : public Operation<	ARCH>
{
public:
	OpVldqal_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldqal_16 : public Operation<	ARCH>
{
public:
	OpVldqal_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldqal_32 : public Operation<	ARCH>
{
public:
	OpVldqal_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVldsl_8 : public Operation<	ARCH>
{
public:
	OpVldsl_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVldsl_16 : public Operation<	ARCH>
{
public:
	OpVldsl_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVldsl_32 : public Operation<	ARCH>
{
public:
	OpVldsl_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmax_f32 : public Operation<	ARCH>
{
public:
	OpVmax_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmax_s8 : public Operation<	ARCH>
{
public:
	OpVmax_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_s16 : public Operation<	ARCH>
{
public:
	OpVmax_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_s32 : public Operation<	ARCH>
{
public:
	OpVmax_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_u8 : public Operation<	ARCH>
{
public:
	OpVmax_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_u16 : public Operation<	ARCH>
{
public:
	OpVmax_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmax_u32 : public Operation<	ARCH>
{
public:
	OpVmax_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_f32 : public Operation<	ARCH>
{
public:
	OpVmin_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmin_s8 : public Operation<	ARCH>
{
public:
	OpVmin_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_s16 : public Operation<	ARCH>
{
public:
	OpVmin_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_s32 : public Operation<	ARCH>
{
public:
	OpVmin_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_u8 : public Operation<	ARCH>
{
public:
	OpVmin_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_u16 : public Operation<	ARCH>
{
public:
	OpVmin_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmin_u32 : public Operation<	ARCH>
{
public:
	OpVmin_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmla_f32v : public Operation<	ARCH>
{
public:
	OpVmla_f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmla_f32dp : public Operation<	ARCH>
{
public:
	OpVmla_f32dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVml_i8 : public Operation<	ARCH>
{
public:
	OpVml_i8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t sub;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVml_i16 : public Operation<	ARCH>
{
public:
	OpVml_i16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t sub;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVml_i32 : public Operation<	ARCH>
{
public:
	OpVml_i32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t sub;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmla_i16dp : public Operation<	ARCH>
{
public:
	OpVmla_i16dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmla_i32dp : public Operation<	ARCH>
{
public:
	OpVmla_i32dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmll_s8qd : public Operation<	ARCH>
{
public:
	OpVmll_s8qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_s16qd : public Operation<	ARCH>
{
public:
	OpVmll_s16qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_s32qd : public Operation<	ARCH>
{
public:
	OpVmll_s32qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_u8qd : public Operation<	ARCH>
{
public:
	OpVmll_u8qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_u16qd : public Operation<	ARCH>
{
public:
	OpVmll_u16qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmll_u32qd : public Operation<	ARCH>
{
public:
	OpVmll_u32qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t sub;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmlal_s16qdp : public Operation<	ARCH>
{
public:
	OpVmlal_s16qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmlal_s32qdp : public Operation<	ARCH>
{
public:
	OpVmlal_s32qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmlal_u16qdp : public Operation<	ARCH>
{
public:
	OpVmlal_u16qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmlal_u32qdp : public Operation<	ARCH>
{
public:
	OpVmlal_u32qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmls_f16dp : public Operation<	ARCH>
{
public:
	OpVmls_f16dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmls_f32v : public Operation<	ARCH>
{
public:
	OpVmls_f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmls_f32dp : public Operation<	ARCH>
{
public:
	OpVmls_f32dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmls_i16dp : public Operation<	ARCH>
{
public:
	OpVmls_i16dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmls_i32dp : public Operation<	ARCH>
{
public:
	OpVmls_i32dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmlsl_s16qdp : public Operation<	ARCH>
{
public:
	OpVmlsl_s16qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmlsl_s32qdp : public Operation<	ARCH>
{
public:
	OpVmlsl_s32qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmlsl_u16qdp : public Operation<	ARCH>
{
public:
	OpVmlsl_u16qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmlsl_u32qdp : public Operation<	ARCH>
{
public:
	OpVmlsl_u32qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmov_f32vi : public Operation<	ARCH>
{
public:
	OpVmov_f32vi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t exp;
	uint8_t vd1;
	uint8_t n;
	uint8_t man;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd;   float fpimm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmov_i8i : public Operation<	ARCH>
{
public:
	OpVmov_i8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t vd0;
	unsigned vd;   uint8_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_i16i : public Operation<	ARCH>
{
public:
	OpVmov_i16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint16_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_i32i : public Operation<	ARCH>
{
public:
	OpVmov_i32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_i64i : public Operation<	ARCH>
{
public:
	OpVmov_i64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t d;
	uint8_t c;
	uint8_t b;
	uint8_t vd1;
	uint8_t a;
	uint8_t h;
	uint8_t g;
	uint8_t f;
	uint8_t e;
	uint8_t q;
	uint8_t vd0;
	uint8_t vd;   uint64_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_i32in : public Operation<	ARCH>
{
public:
	OpVmov_i32in(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_s8 : public Operation<	ARCH>
{
public:
	OpVmovl_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_s16 : public Operation<	ARCH>
{
public:
	OpVmovl_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_s32 : public Operation<	ARCH>
{
public:
	OpVmovl_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_u8 : public Operation<	ARCH>
{
public:
	OpVmovl_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_u16 : public Operation<	ARCH>
{
public:
	OpVmovl_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovl_u32 : public Operation<	ARCH>
{
public:
	OpVmovl_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovn_i16 : public Operation<	ARCH>
{
public:
	OpVmovn_i16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovn_i32 : public Operation<	ARCH>
{
public:
	OpVmovn_i32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmovn_i64 : public Operation<	ARCH>
{
public:
	OpVmovn_i64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_8dr : public Operation<	ARCH>
{
public:
	OpVmov_8dr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t index1;
	uint8_t index0;
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_16dr : public Operation<	ARCH>
{
public:
	OpVmov_16dr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t index1;
	uint8_t index0;
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_32dr : public Operation<	ARCH>
{
public:
	OpVmov_32dr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd0;
	uint8_t index;
	uint8_t vd1;
	uint8_t rt;
	uint8_t vd; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_s8rd : public Operation<	ARCH>
{
public:
	OpVmov_s8rd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t index1;
	uint8_t index0;
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_u8rd : public Operation<	ARCH>
{
public:
	OpVmov_u8rd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t index1;
	uint8_t index0;
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_s16rd : public Operation<	ARCH>
{
public:
	OpVmov_s16rd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t index1;
	uint8_t index0;
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_u16rd : public Operation<	ARCH>
{
public:
	OpVmov_u16rd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t index1;
	uint8_t index0;
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn;   uint32_t index; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmov_32rd : public Operation<	ARCH>
{
public:
	OpVmov_32rd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t index;
	uint8_t vn1;
	uint8_t rt;
	uint8_t vn; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_f32v : public Operation<	ARCH>
{
public:
	OpVmul_f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmul_f32dp : public Operation<	ARCH>
{
public:
	OpVmul_f32dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmul_i8 : public Operation<	ARCH>
{
public:
	OpVmul_i8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_i16 : public Operation<	ARCH>
{
public:
	OpVmul_i16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_i32 : public Operation<	ARCH>
{
public:
	OpVmul_i32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmul_i16dp : public Operation<	ARCH>
{
public:
	OpVmul_i16dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmul_i32dp : public Operation<	ARCH>
{
public:
	OpVmul_i32dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmul_p8 : public Operation<	ARCH>
{
public:
	OpVmul_p8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmul_p16 : public Operation<	ARCH>
{
public:
	OpVmul_p16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmul_p32 : public Operation<	ARCH>
{
public:
	OpVmul_p32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmull_p8qd : public Operation<	ARCH>
{
public:
	OpVmull_p8qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmull_s8 : public Operation<	ARCH>
{
public:
	OpVmull_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_s16 : public Operation<	ARCH>
{
public:
	OpVmull_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_s32 : public Operation<	ARCH>
{
public:
	OpVmull_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_u8 : public Operation<	ARCH>
{
public:
	OpVmull_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_u16 : public Operation<	ARCH>
{
public:
	OpVmull_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_u32 : public Operation<	ARCH>
{
public:
	OpVmull_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmull_s16qdp : public Operation<	ARCH>
{
public:
	OpVmull_s16qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmull_s32qdp : public Operation<	ARCH>
{
public:
	OpVmull_s32qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmull_u16qdp : public Operation<	ARCH>
{
public:
	OpVmull_u16qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmull_u32qdp : public Operation<	ARCH>
{
public:
	OpVmull_u32qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVmvn_i16i : public Operation<	ARCH>
{
public:
	OpVmvn_i16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmvn_i32i : public Operation<	ARCH>
{
public:
	OpVmvn_i32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmvn_i32in : public Operation<	ARCH>
{
public:
	OpVmvn_i32in(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVmvn : public Operation<	ARCH>
{
public:
	OpVmvn(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVneg_f8 : public Operation<	ARCH>
{
public:
	OpVneg_f8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVneg_f16 : public Operation<	ARCH>
{
public:
	OpVneg_f16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVneg_f32v : public Operation<	ARCH>
{
public:
	OpVneg_f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVneg_s8 : public Operation<	ARCH>
{
public:
	OpVneg_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVneg_s16 : public Operation<	ARCH>
{
public:
	OpVneg_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVneg_s32 : public Operation<	ARCH>
{
public:
	OpVneg_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVorn : public Operation<	ARCH>
{
public:
	OpVorn(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVorr : public Operation<	ARCH>
{
public:
	OpVorr(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVorr_i16i : public Operation<	ARCH>
{
public:
	OpVorr_i16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint16_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVorr_i32i : public Operation<	ARCH>
{
public:
	OpVorr_i32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm1;
	uint8_t vd1;
	uint8_t imm2;
	uint8_t imm0;
	uint8_t q;
	uint8_t shift;
	uint8_t vd0;
	uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpadal_s8 : public Operation<	ARCH>
{
public:
	OpVpadal_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_s16 : public Operation<	ARCH>
{
public:
	OpVpadal_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_s32 : public Operation<	ARCH>
{
public:
	OpVpadal_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_u8 : public Operation<	ARCH>
{
public:
	OpVpadal_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_u16 : public Operation<	ARCH>
{
public:
	OpVpadal_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpadal_u32 : public Operation<	ARCH>
{
public:
	OpVpadal_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpadd_f32 : public Operation<	ARCH>
{
public:
	OpVpadd_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpadd_i8 : public Operation<	ARCH>
{
public:
	OpVpadd_i8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpadd_i16 : public Operation<	ARCH>
{
public:
	OpVpadd_i16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpadd_i32 : public Operation<	ARCH>
{
public:
	OpVpadd_i32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpaddl_s8 : public Operation<	ARCH>
{
public:
	OpVpaddl_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_s16 : public Operation<	ARCH>
{
public:
	OpVpaddl_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_s32 : public Operation<	ARCH>
{
public:
	OpVpaddl_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_u8 : public Operation<	ARCH>
{
public:
	OpVpaddl_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_u16 : public Operation<	ARCH>
{
public:
	OpVpaddl_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpaddl_u32 : public Operation<	ARCH>
{
public:
	OpVpaddl_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVpmax_f32 : public Operation<	ARCH>
{
public:
	OpVpmax_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_s8 : public Operation<	ARCH>
{
public:
	OpVpmax_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_s16 : public Operation<	ARCH>
{
public:
	OpVpmax_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_s32 : public Operation<	ARCH>
{
public:
	OpVpmax_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_u8 : public Operation<	ARCH>
{
public:
	OpVpmax_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_u16 : public Operation<	ARCH>
{
public:
	OpVpmax_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmax_u32 : public Operation<	ARCH>
{
public:
	OpVpmax_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_f32 : public Operation<	ARCH>
{
public:
	OpVpmin_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_s8 : public Operation<	ARCH>
{
public:
	OpVpmin_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_s16 : public Operation<	ARCH>
{
public:
	OpVpmin_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_s32 : public Operation<	ARCH>
{
public:
	OpVpmin_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_u8 : public Operation<	ARCH>
{
public:
	OpVpmin_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_u16 : public Operation<	ARCH>
{
public:
	OpVpmin_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVpmin_u32 : public Operation<	ARCH>
{
public:
	OpVpmin_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqabs_s8 : public Operation<	ARCH>
{
public:
	OpVqabs_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqabs_s16 : public Operation<	ARCH>
{
public:
	OpVqabs_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqabs_s32 : public Operation<	ARCH>
{
public:
	OpVqabs_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_s8 : public Operation<	ARCH>
{
public:
	OpVqadd_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_s16 : public Operation<	ARCH>
{
public:
	OpVqadd_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_s32 : public Operation<	ARCH>
{
public:
	OpVqadd_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_s64 : public Operation<	ARCH>
{
public:
	OpVqadd_s64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_u8 : public Operation<	ARCH>
{
public:
	OpVqadd_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_u16 : public Operation<	ARCH>
{
public:
	OpVqadd_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_u32 : public Operation<	ARCH>
{
public:
	OpVqadd_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqadd_u64 : public Operation<	ARCH>
{
public:
	OpVqadd_u64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlal_s16qd : public Operation<	ARCH>
{
public:
	OpVqdmlal_s16qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlal_s16qdp : public Operation<	ARCH>
{
public:
	OpVqdmlal_s16qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlal_s32qd : public Operation<	ARCH>
{
public:
	OpVqdmlal_s32qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlal_s32qdp : public Operation<	ARCH>
{
public:
	OpVqdmlal_s32qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlsl_s16qd : public Operation<	ARCH>
{
public:
	OpVqdmlsl_s16qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlsl_s16qdp : public Operation<	ARCH>
{
public:
	OpVqdmlsl_s16qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlsl_s32qd : public Operation<	ARCH>
{
public:
	OpVqdmlsl_s32qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmlsl_s32qdp : public Operation<	ARCH>
{
public:
	OpVqdmlsl_s32qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmulh_s16 : public Operation<	ARCH>
{
public:
	OpVqdmulh_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmulh_s16dp : public Operation<	ARCH>
{
public:
	OpVqdmulh_s16dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmulh_s32 : public Operation<	ARCH>
{
public:
	OpVqdmulh_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmulh_s32dp : public Operation<	ARCH>
{
public:
	OpVqdmulh_s32dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmull_s16qd : public Operation<	ARCH>
{
public:
	OpVqdmull_s16qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmull_s16qdp : public Operation<	ARCH>
{
public:
	OpVqdmull_s16qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmull_s32qd : public Operation<	ARCH>
{
public:
	OpVqdmull_s32qd(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqdmull_s32qdp : public Operation<	ARCH>
{
public:
	OpVqdmull_s32qdp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_s16 : public Operation<	ARCH>
{
public:
	OpVqmovn_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_s32 : public Operation<	ARCH>
{
public:
	OpVqmovn_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_s64 : public Operation<	ARCH>
{
public:
	OpVqmovn_s64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_u16 : public Operation<	ARCH>
{
public:
	OpVqmovn_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_u32 : public Operation<	ARCH>
{
public:
	OpVqmovn_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqmovn_u64 : public Operation<	ARCH>
{
public:
	OpVqmovn_u64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqmovun_s16 : public Operation<	ARCH>
{
public:
	OpVqmovun_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqmovun_s32 : public Operation<	ARCH>
{
public:
	OpVqmovun_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqmovun_s64 : public Operation<	ARCH>
{
public:
	OpVqmovun_s64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqneg_s8 : public Operation<	ARCH>
{
public:
	OpVqneg_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqneg_s16 : public Operation<	ARCH>
{
public:
	OpVqneg_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqneg_s32 : public Operation<	ARCH>
{
public:
	OpVqneg_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrdmulh_s16 : public Operation<	ARCH>
{
public:
	OpVqrdmulh_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrdmulh_s16dp : public Operation<	ARCH>
{
public:
	OpVqrdmulh_s16dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part0;
	uint8_t part1;
	uint8_t vn1;
	uint8_t vd0;
	uint32_t part;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrdmulh_s32 : public Operation<	ARCH>
{
public:
	OpVqrdmulh_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrdmulh_s32dp : public Operation<	ARCH>
{
public:
	OpVqrdmulh_s32dp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t q;
	uint8_t vm;
	uint8_t part;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_s8 : public Operation<	ARCH>
{
public:
	OpVqrshl_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_s16 : public Operation<	ARCH>
{
public:
	OpVqrshl_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_s32 : public Operation<	ARCH>
{
public:
	OpVqrshl_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_s64 : public Operation<	ARCH>
{
public:
	OpVqrshl_s64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_u8 : public Operation<	ARCH>
{
public:
	OpVqrshl_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_u16 : public Operation<	ARCH>
{
public:
	OpVqrshl_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_u32 : public Operation<	ARCH>
{
public:
	OpVqrshl_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshl_u64 : public Operation<	ARCH>
{
public:
	OpVqrshl_u64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_s16dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_s16dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_s32dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_s32dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_s64dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_s64dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_u16dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_u16dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_u32dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_u32dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrn_u64dqi : public Operation<	ARCH>
{
public:
	OpVqrshrn_u64dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrun_s16dqi : public Operation<	ARCH>
{
public:
	OpVqrshrun_s16dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrun_s32dqi : public Operation<	ARCH>
{
public:
	OpVqrshrun_s32dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqrshrun_s64dqi : public Operation<	ARCH>
{
public:
	OpVqrshrun_s64dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s8 : public Operation<	ARCH>
{
public:
	OpVqshl_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s8i : public Operation<	ARCH>
{
public:
	OpVqshl_s8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s16 : public Operation<	ARCH>
{
public:
	OpVqshl_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s16i : public Operation<	ARCH>
{
public:
	OpVqshl_s16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s32 : public Operation<	ARCH>
{
public:
	OpVqshl_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s32i : public Operation<	ARCH>
{
public:
	OpVqshl_s32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s64 : public Operation<	ARCH>
{
public:
	OpVqshl_s64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_s64i : public Operation<	ARCH>
{
public:
	OpVqshl_s64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u8 : public Operation<	ARCH>
{
public:
	OpVqshl_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u8i : public Operation<	ARCH>
{
public:
	OpVqshl_u8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u16 : public Operation<	ARCH>
{
public:
	OpVqshl_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u16i : public Operation<	ARCH>
{
public:
	OpVqshl_u16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u32 : public Operation<	ARCH>
{
public:
	OpVqshl_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u32i : public Operation<	ARCH>
{
public:
	OpVqshl_u32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u64 : public Operation<	ARCH>
{
public:
	OpVqshl_u64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshl_u64i : public Operation<	ARCH>
{
public:
	OpVqshl_u64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshlu_s8i : public Operation<	ARCH>
{
public:
	OpVqshlu_s8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshlu_s16i : public Operation<	ARCH>
{
public:
	OpVqshlu_s16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshlu_s32i : public Operation<	ARCH>
{
public:
	OpVqshlu_s32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshlu_s64i : public Operation<	ARCH>
{
public:
	OpVqshlu_s64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_s16dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_s16dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_s32dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_s32dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_s64dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_s64dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_u16dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_u16dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_u32dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_u32dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshrn_u64dqi : public Operation<	ARCH>
{
public:
	OpVqshrn_u64dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshrun_s16dqi : public Operation<	ARCH>
{
public:
	OpVqshrun_s16dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshrun_s32dqi : public Operation<	ARCH>
{
public:
	OpVqshrun_s32dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqshrun_s64dqi : public Operation<	ARCH>
{
public:
	OpVqshrun_s64dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_s8 : public Operation<	ARCH>
{
public:
	OpVqsub_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_s16 : public Operation<	ARCH>
{
public:
	OpVqsub_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_s32 : public Operation<	ARCH>
{
public:
	OpVqsub_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_s64 : public Operation<	ARCH>
{
public:
	OpVqsub_s64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_u8 : public Operation<	ARCH>
{
public:
	OpVqsub_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_u16 : public Operation<	ARCH>
{
public:
	OpVqsub_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_u32 : public Operation<	ARCH>
{
public:
	OpVqsub_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVqsub_u64 : public Operation<	ARCH>
{
public:
	OpVqsub_u64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVraddhn_i16dq : public Operation<	ARCH>
{
public:
	OpVraddhn_i16dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVraddhn_i32dq : public Operation<	ARCH>
{
public:
	OpVraddhn_i32dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVraddhn_i64dq : public Operation<	ARCH>
{
public:
	OpVraddhn_i64dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrecpe_f32 : public Operation<	ARCH>
{
public:
	OpVrecpe_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrecpe_u32 : public Operation<	ARCH>
{
public:
	OpVrecpe_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrecps_f32 : public Operation<	ARCH>
{
public:
	OpVrecps_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrev_8 : public Operation<	ARCH>
{
public:
	OpVrev_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t op;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVrev_16 : public Operation<	ARCH>
{
public:
	OpVrev_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t op;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVrev_32 : public Operation<	ARCH>
{
public:
	OpVrev_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t op;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVrhadd_s8 : public Operation<	ARCH>
{
public:
	OpVrhadd_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_s16 : public Operation<	ARCH>
{
public:
	OpVrhadd_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_s32 : public Operation<	ARCH>
{
public:
	OpVrhadd_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_u8 : public Operation<	ARCH>
{
public:
	OpVrhadd_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_u16 : public Operation<	ARCH>
{
public:
	OpVrhadd_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrhadd_u32 : public Operation<	ARCH>
{
public:
	OpVrhadd_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_s8 : public Operation<	ARCH>
{
public:
	OpVrshl_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_s16 : public Operation<	ARCH>
{
public:
	OpVrshl_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_s32 : public Operation<	ARCH>
{
public:
	OpVrshl_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_s64 : public Operation<	ARCH>
{
public:
	OpVrshl_s64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_u8 : public Operation<	ARCH>
{
public:
	OpVrshl_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_u16 : public Operation<	ARCH>
{
public:
	OpVrshl_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_u32 : public Operation<	ARCH>
{
public:
	OpVrshl_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshl_u64 : public Operation<	ARCH>
{
public:
	OpVrshl_u64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_s8i : public Operation<	ARCH>
{
public:
	OpVrshr_s8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_s16i : public Operation<	ARCH>
{
public:
	OpVrshr_s16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_s32i : public Operation<	ARCH>
{
public:
	OpVrshr_s32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_s64i : public Operation<	ARCH>
{
public:
	OpVrshr_s64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_u8i : public Operation<	ARCH>
{
public:
	OpVrshr_u8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_u16i : public Operation<	ARCH>
{
public:
	OpVrshr_u16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_u32i : public Operation<	ARCH>
{
public:
	OpVrshr_u32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshr_u64i : public Operation<	ARCH>
{
public:
	OpVrshr_u64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshrn_i16dqi : public Operation<	ARCH>
{
public:
	OpVrshrn_i16dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshrn_i32dqi : public Operation<	ARCH>
{
public:
	OpVrshrn_i32dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrshrn_i64dqi : public Operation<	ARCH>
{
public:
	OpVrshrn_i64dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsqrte_f32 : public Operation<	ARCH>
{
public:
	OpVrsqrte_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsqrte_u32 : public Operation<	ARCH>
{
public:
	OpVrsqrte_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsqrts_f32 : public Operation<	ARCH>
{
public:
	OpVrsqrts_f32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_s8i : public Operation<	ARCH>
{
public:
	OpVrsra_s8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_s16i : public Operation<	ARCH>
{
public:
	OpVrsra_s16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_s32i : public Operation<	ARCH>
{
public:
	OpVrsra_s32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_s64i : public Operation<	ARCH>
{
public:
	OpVrsra_s64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_u8i : public Operation<	ARCH>
{
public:
	OpVrsra_u8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_u16i : public Operation<	ARCH>
{
public:
	OpVrsra_u16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_u32i : public Operation<	ARCH>
{
public:
	OpVrsra_u32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsra_u64i : public Operation<	ARCH>
{
public:
	OpVrsra_u64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsubhn_i16dq : public Operation<	ARCH>
{
public:
	OpVrsubhn_i16dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsubhn_i32dq : public Operation<	ARCH>
{
public:
	OpVrsubhn_i32dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVrsubhn_i64dq : public Operation<	ARCH>
{
public:
	OpVrsubhn_i64dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVshl_s8i : public Operation<	ARCH>
{
public:
	OpVshl_s8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s16i : public Operation<	ARCH>
{
public:
	OpVshl_s16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s32i : public Operation<	ARCH>
{
public:
	OpVshl_s32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s64i : public Operation<	ARCH>
{
public:
	OpVshl_s64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s8 : public Operation<	ARCH>
{
public:
	OpVshl_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s16 : public Operation<	ARCH>
{
public:
	OpVshl_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s32 : public Operation<	ARCH>
{
public:
	OpVshl_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_s64 : public Operation<	ARCH>
{
public:
	OpVshl_s64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_u8 : public Operation<	ARCH>
{
public:
	OpVshl_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_u16 : public Operation<	ARCH>
{
public:
	OpVshl_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_u32 : public Operation<	ARCH>
{
public:
	OpVshl_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshl_u64 : public Operation<	ARCH>
{
public:
	OpVshl_u64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_i8 : public Operation<	ARCH>
{
public:
	OpVshll_i8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_i16 : public Operation<	ARCH>
{
public:
	OpVshll_i16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshll_i32 : public Operation<	ARCH>
{
public:
	OpVshll_i32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_s8i : public Operation<	ARCH>
{
public:
	OpVshr_s8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_s16i : public Operation<	ARCH>
{
public:
	OpVshr_s16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_s32i : public Operation<	ARCH>
{
public:
	OpVshr_s32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_s64i : public Operation<	ARCH>
{
public:
	OpVshr_s64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_u8i : public Operation<	ARCH>
{
public:
	OpVshr_u8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_u16i : public Operation<	ARCH>
{
public:
	OpVshr_u16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_u32i : public Operation<	ARCH>
{
public:
	OpVshr_u32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshr_u64i : public Operation<	ARCH>
{
public:
	OpVshr_u64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVshrn_i16dqi : public Operation<	ARCH>
{
public:
	OpVshrn_i16dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVshrn_i32dqi : public Operation<	ARCH>
{
public:
	OpVshrn_i32dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVshrn_i64dqi : public Operation<	ARCH>
{
public:
	OpVshrn_i64dqi(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsli_8i : public Operation<	ARCH>
{
public:
	OpVsli_8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsli_16i : public Operation<	ARCH>
{
public:
	OpVsli_16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsli_32i : public Operation<	ARCH>
{
public:
	OpVsli_32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsli_64i : public Operation<	ARCH>
{
public:
	OpVsli_64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsra_s8i : public Operation<	ARCH>
{
public:
	OpVsra_s8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsra_s16i : public Operation<	ARCH>
{
public:
	OpVsra_s16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsra_s32i : public Operation<	ARCH>
{
public:
	OpVsra_s32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsra_s64i : public Operation<	ARCH>
{
public:
	OpVsra_s64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsra_u8i : public Operation<	ARCH>
{
public:
	OpVsra_u8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsra_u16i : public Operation<	ARCH>
{
public:
	OpVsra_u16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsra_u32i : public Operation<	ARCH>
{
public:
	OpVsra_u32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsra_u64i : public Operation<	ARCH>
{
public:
	OpVsra_u64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsri_8i : public Operation<	ARCH>
{
public:
	OpVsri_8i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsri_16i : public Operation<	ARCH>
{
public:
	OpVsri_16i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsri_32i : public Operation<	ARCH>
{
public:
	OpVsri_32i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsri_64i : public Operation<	ARCH>
{
public:
	OpVsri_64i(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t imm_;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint32_t imm;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVstms_8 : public Operation<	ARCH>
{
public:
	OpVstms_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms_16 : public Operation<	ARCH>
{
public:
	OpVstms_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms_32 : public Operation<	ARCH>
{
public:
	OpVstms_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms_64 : public Operation<	ARCH>
{
public:
	OpVstms_64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t opcode;
	uint8_t vd0;
	Vms vms;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms2s_8 : public Operation<	ARCH>
{
public:
	OpVstms2s_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms2s_16 : public Operation<	ARCH>
{
public:
	OpVstms2s_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstms2s_32 : public Operation<	ARCH>
{
public:
	OpVstms2s_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t rlist;
	uint8_t vd0;
	unsigned regs;   uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVst2_8 : public Operation<	ARCH>
{
public:
	OpVst2_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVst2_16 : public Operation<	ARCH>
{
public:
	OpVst2_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVst2_32 : public Operation<	ARCH>
{
public:
	OpVst2_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstsl_8 : public Operation<	ARCH>
{
public:
	OpVstsl_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstsl_16 : public Operation<	ARCH>
{
public:
	OpVstsl_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVstsl_32 : public Operation<	ARCH>
{
public:
	OpVstsl_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t rn;
	uint8_t vd1;
	uint8_t rm;
	uint8_t align;
	uint8_t ds;
	uint8_t part;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vd;   unsigned alignment;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_f32v : public Operation<	ARCH>
{
public:
	OpVsub_f32v(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsub_i8 : public Operation<	ARCH>
{
public:
	OpVsub_i8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_i16 : public Operation<	ARCH>
{
public:
	OpVsub_i16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_i32 : public Operation<	ARCH>
{
public:
	OpVsub_i32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsub_i64 : public Operation<	ARCH>
{
public:
	OpVsub_i64(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubhn_i16dq : public Operation<	ARCH>
{
public:
	OpVsubhn_i16dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsubhn_i32dq : public Operation<	ARCH>
{
public:
	OpVsubhn_i32dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsubhn_i64dq : public Operation<	ARCH>
{
public:
	OpVsubhn_i64dq(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVsubl_s8 : public Operation<	ARCH>
{
public:
	OpVsubl_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_s16 : public Operation<	ARCH>
{
public:
	OpVsubl_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_s32 : public Operation<	ARCH>
{
public:
	OpVsubl_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_u8 : public Operation<	ARCH>
{
public:
	OpVsubl_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_u16 : public Operation<	ARCH>
{
public:
	OpVsubl_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubl_u32 : public Operation<	ARCH>
{
public:
	OpVsubl_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_s8 : public Operation<	ARCH>
{
public:
	OpVsubw_s8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_s16 : public Operation<	ARCH>
{
public:
	OpVsubw_s16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_s32 : public Operation<	ARCH>
{
public:
	OpVsubw_s32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_u8 : public Operation<	ARCH>
{
public:
	OpVsubw_u8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_u16 : public Operation<	ARCH>
{
public:
	OpVsubw_u16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVsubw_u32 : public Operation<	ARCH>
{
public:
	OpVsubw_u32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVswp : public Operation<	ARCH>
{
public:
	OpVswp(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVtbl_8d : public Operation<	ARCH>
{
public:
	OpVtbl_8d(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVtbx_8d : public Operation<	ARCH>
{
public:
	OpVtbx_8d(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t vn1;
	uint8_t regs;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVtrn_8 : public Operation<	ARCH>
{
public:
	OpVtrn_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVtrn_16 : public Operation<	ARCH>
{
public:
	OpVtrn_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVtrn_32 : public Operation<	ARCH>
{
public:
	OpVtrn_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVtst_i8 : public Operation<	ARCH>
{
public:
	OpVtst_i8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVtst_16 : public Operation<	ARCH>
{
public:
	OpVtst_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVtst_32 : public Operation<	ARCH>
{
public:
	OpVtst_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vn0;
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vn1;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   uint8_t vn;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
private:
};

template <	typename	ARCH>
class OpVuzp_8 : public Operation<	ARCH>
{
public:
	OpVuzp_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVuzp_16 : public Operation<	ARCH>
{
public:
	OpVuzp_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVuzp_32 : public Operation<	ARCH>
{
public:
	OpVuzp_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVzip_8 : public Operation<	ARCH>
{
public:
	OpVzip_8(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVzip_16 : public Operation<	ARCH>
{
public:
	OpVzip_16(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
class OpVzip_32 : public Operation<	ARCH>
{
public:
	OpVzip_32(CodeType code, uint32_t addr);
	unsigned int GetLength() const { return 32; }
	uint8_t vd1;
	uint8_t vm0;
	uint8_t vm1;
	uint8_t q;
	uint8_t vd0;
	uint8_t vm;   uint8_t vd;   Reject reject; virtual
	void disasm( ARCH & cpu,
	std::ostream & buffer );
	virtual
	void execute( ARCH & cpu );
private:
};

template <	typename	ARCH>
void OpLdrh_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrh.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrh_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.SetGPR_mem( rt, U32(cpu.MemURead16( p?oaddr:addr )) );
		if (w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrh_imm(CodeType code, uint32_t addr)
{
	return new OpLdrh_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrh_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrh.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,0,imm,true,true,false);
}}
template <	typename	ARCH>
void OpLdrh_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), 0, imm );
		cpu.SetGPR_mem( rt, U32( cpu.MemURead16( cpu.GetGPR( rn ) + isval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrh_reg(CodeType code, uint32_t addr)
{
	return new OpLdrh_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrb_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrb.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrb_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( p?oaddr:addr ) ) );
		if (w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrb_imm(CodeType code, uint32_t addr)
{
	return new OpLdrb_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrb_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrb.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,0,imm,true,true,false);
}}
template <	typename	ARCH>
void OpLdrb_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), 0, imm );
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( cpu.GetGPR( rn ) + isval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrb_reg(CodeType code, uint32_t addr)
{
	return new OpLdrb_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsb_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsb.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrsb_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( p?oaddr:addr ) ) ) ) );
		if (w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsb_imm(CodeType code, uint32_t addr)
{
	return new OpLdrsb_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsb_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsb.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,0,imm,true,true,false);
}}
template <	typename	ARCH>
void OpLdrsb_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), 0, imm );
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( cpu.GetGPR( rn ) + isval ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsb_reg(CodeType code, uint32_t addr)
{
	return new OpLdrsb_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrht<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrht\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrht<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, U32( cpu.MemURead16( addr ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrht(CodeType code, uint32_t addr)
{
	return new OpLdrht<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrbt<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrbt\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrbt<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( addr ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrbt(CodeType code, uint32_t addr)
{
	return new OpLdrbt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsbt<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsbt\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrsbt<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( addr ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsbt(CodeType code, uint32_t addr)
{
	return new OpLdrsbt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMov_reg_shift<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		if (imm == 0 and shift == 0) buffer << "movs\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
		else buffer << DisasmShift(shift) << "s\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << ", " << DisasmI(imm?imm:32);
}}
template <	typename	ARCH>
void OpMov_reg_shift<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 rmval = cpu.GetGPR( rm ), res = ComputeImmShift( cpu, rmval, shift, imm );
		cpu.SetGPR( rd, res );
		if (not cpu.itblock()) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMov_reg_shift(CodeType code, uint32_t addr)
{
	return new OpMov_reg_shift<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrn<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "orn" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpOrn<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32
		rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 | ~op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrn(CodeType code, uint32_t addr)
{
	return new OpOrn<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrn_rri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "orn" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpOrn_rri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 | ~op2;
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (cfim)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrn_rri(CodeType code, uint32_t addr)
{
	return new OpOrn_rri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrr_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "orr" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpOrr_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32
		rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 | op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrr_w(CodeType code, uint32_t addr)
{
	return new OpOrr_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrr_wrri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "orr" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpOrr_wrri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 | op2;
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (cfim)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrr_wrri(CodeType code, uint32_t addr)
{
	return new OpOrr_wrri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldr.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdr_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.SetGPR_mem( rt, cpu.MemURead32( p?oaddr:addr ) );
		if (w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_imm(CodeType code, uint32_t addr)
{
	return new OpLdr_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldr.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,0,imm,true,true,false);
}}
template <	typename	ARCH>
void OpLdr_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), 0, imm );
		cpu.SetGPR_mem( rt, cpu.MemURead32( cpu.GetGPR( rn ) + isval ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_reg(CodeType code, uint32_t addr)
{
	return new OpLdr_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrh_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrh.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrh_imm12<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, U32( cpu.MemURead16( addr ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrh_imm12(CodeType code, uint32_t addr)
{
	return new OpLdrh_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrh_lit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrh.w\t" << DisasmRegister(rt) << ", [pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpLdrh_lit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR_mem( rt, U32( cpu.MemURead16( (cpu.GetGPR( 15 ) & U32( -4 )) + U32( imm ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrh_lit(CodeType code, uint32_t addr)
{
	return new OpLdrh_lit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsh_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsh.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrsh_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( p?oaddr:addr ) ) ) ) );
		if (w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsh_imm(CodeType code, uint32_t addr)
{
	return new OpLdrsh_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsh_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsh.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,0,imm,true,true,false);
}}
template <	typename	ARCH>
void OpLdrsh_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), 0, imm );
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( cpu.GetGPR( rn ) + isval ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsh_reg(CodeType code, uint32_t addr)
{
	return new OpLdrsh_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrb_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrb.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrb_imm12<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( addr ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrb_imm12(CodeType code, uint32_t addr)
{
	return new OpLdrb_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrb_lit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrb.w\t" << DisasmRegister(rt) << ", [pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpLdrb_lit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( (cpu.GetGPR( 15 ) & U32( -4 )) + U32( imm ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrb_lit(CodeType code, uint32_t addr)
{
	return new OpLdrb_lit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsb_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsb.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrsb_imm12<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( addr ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsb_imm12(CodeType code, uint32_t addr)
{
	return new OpLdrsb_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsb_lit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsb.w\t" << DisasmRegister(rt) << ", [pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpLdrsb_lit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( (cpu.GetGPR( 15 ) & U32( -4 )) + U32( imm ) ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsb_lit(CodeType code, uint32_t addr)
{
	return new OpLdrsb_lit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrt<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrt\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrt<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, cpu.MemURead32( addr ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrt(CodeType code, uint32_t addr)
{
	return new OpLdrt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsht<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsht\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrsht<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( addr ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsht(CodeType code, uint32_t addr)
{
	return new OpLdrsht<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPld_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pld" << (w?"w":"") << "\t" << DisasmMemoryRRI(rn, rm, 0, imm, true, true, false );
}}
template <	typename	ARCH>
void OpPld_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		/* nop: no architecturally visible changes */
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPld_reg(CodeType code, uint32_t addr)
{
	return new OpPld_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPli_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pli\t" << DisasmMemoryRRI(rn,rm,0,imm,true,true,false);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPli_reg(CodeType code, uint32_t addr)
{
	return new OpPli_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsada8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "usada8\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn)
		<< ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpUsada8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm), res = cpu.GetGPR(ra);

		for (unsigned byte = 0; byte < 4; byte++) {
			U32 a = (op1 >> (8*byte)) & U32(0xff), b = (op2 >> (8*byte)) & U32(0xff), d = a - b;
			// Compute abs by arithetic means
			U32 neg( S32(d) >> 8 );
			res += ((d ^ neg) + (neg & U32(1)));
		}

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsada8(CodeType code, uint32_t addr)
{
	return new OpUsada8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBcc_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "b" << DisasmCondition(cond) << ".w\t0x" << std::hex << ((this->GetAddr() + 4 + imm) & -2) << std::dec;
}}
template <	typename	ARCH>
void OpBcc_w<	ARCH>::execute( ARCH & cpu)
{
	{
		if (cpu.itblock())
		cpu.UnpredictableInsnBehaviour();

		typedef typename ARCH::U32 U32;

		if (CheckCondition(cpu, cond ))
		cpu.Branch( cpu.GetGPR( 15 ) + U32( imm ), ARCH::B_JMP );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBcc_w(CodeType code, uint32_t addr)
{
	return new OpBcc_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMla<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mla\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpMla<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rd, cpu.GetGPR( ra ) + (cpu.GetGPR( rn ) * cpu.GetGPR( rm )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMla(CodeType code, uint32_t addr)
{
	return new OpMla<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "stc" << (d?"l":"") << '\t'
		<< unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStc(CodeType code, uint32_t addr)
{
	return new OpStc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStc2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "stc2" << (d?"l":"") << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStc2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStc2(CodeType code, uint32_t addr)
{
	return new OpStc2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldc" << (d?"l":"") << '\t'
		<< unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdc(CodeType code, uint32_t addr)
{
	return new OpLdc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdc2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldc2" << (d?"l":"") << '\t'
		<< unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdc2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdc2(CodeType code, uint32_t addr)
{
	return new OpLdc2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCps<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cps";
		char const* sep = "\t";
		if (chitm) {
			buffer << (dis?"id":"ie") << '\t' << (a?"a":"") << (i?"i":"") << (f?"f":"");
			sep = ", ";
		}
		if (chmod)
		buffer << sep << DisasmI( mode );
}}
template <	typename	ARCH>
void OpCps<	ARCH>::execute( ARCH & cpu)
{
	{
		if (cpu.itblock())
		cpu.UnpredictableInsnBehaviour();

		typedef typename ARCH::U32 U32;

		if (cpu.Test(cpu.CPSR().Get(M) == U32(PSR::USER_MODE)))
		return;

		// CPSRWriteByInstr() checks for illegal mode changes
		CPSRWriteByInstr( cpu, U32(psr_bits), psr_mask );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCps(CodeType code, uint32_t addr)
{
	return new OpCps<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshll.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_s8(CodeType code, uint32_t addr)
{
	return new OpVshll_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshll.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_s16(CodeType code, uint32_t addr)
{
	return new OpVshll_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshll.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_s32(CodeType code, uint32_t addr)
{
	return new OpVshll_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshll.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_u8(CodeType code, uint32_t addr)
{
	return new OpVshll_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshll.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_u16(CodeType code, uint32_t addr)
{
	return new OpVshll_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshll.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshll_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_u32(CodeType code, uint32_t addr)
{
	return new OpVshll_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "adcs\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpAdc<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rdn ), op2 = cpu.GetGPR( rm ), carry = cpu.CPSR().Get( C ), res = op1 + op2 + carry;
		cpu.SetGPR( rdn, res );
		if (not cpu.itblock()) UpdateStatusAddWithCarry( cpu, res, op1, op2, carry );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdc(CodeType code, uint32_t addr)
{
	return new OpAdc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "adds\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdd_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32( imm ), res = op1 + op2;
		cpu.SetGPR( rd, res );
		if (not cpu.itblock()) UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_1(CodeType code, uint32_t addr)
{
	return new OpAdd_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "adds\t" << DisasmRegister(rdn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdd_2<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rdn ), op2 = U32( imm ), res = op1 + op2;
		cpu.SetGPR( rdn, res );
		if (not cpu.itblock()) UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_2(CodeType code, uint32_t addr)
{
	return new OpAdd_2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_3<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "adds\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpAdd_3<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = cpu.GetGPR( rm ), res = op1 + op2;
		cpu.SetGPR( rd, res );
		if (not cpu.itblock()) UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_3(CodeType code, uint32_t addr)
{
	return new OpAdd_3<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_4<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "add\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpAdd_4<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rdn, cpu.GetGPR( rdn ) + cpu.GetGPR( rm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_4(CodeType code, uint32_t addr)
{
	return new OpAdd_4<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_4_pc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "add\tpc, " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpAdd_4_pc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( 15, cpu.GetGPR( 15 ) + cpu.GetGPR( rm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_4_pc(CodeType code, uint32_t addr)
{
	return new OpAdd_4_pc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "add\t" << DisasmRegister(rd) << ", pc, " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdr<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, (cpu.GetGPR( 15 ) & U32(-4)) + U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdr(CodeType code, uint32_t addr)
{
	return new OpAdr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_6<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "add\t" << DisasmRegister(rd) << ", sp, " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdd_6<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, cpu.GetGPR(13) + U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_6(CodeType code, uint32_t addr)
{
	return new OpAdd_6<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_7<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "add\tsp, " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdd_7<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( 13, cpu.GetGPR(13) + U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_7(CodeType code, uint32_t addr)
{
	return new OpAdd_7<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAnd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ands\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpAnd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rdn ), op2 = cpu.GetGPR( rm ), res = op1 & op2;
		cpu.SetGPR( rdn, res );

		if (not cpu.itblock())
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAnd(CodeType code, uint32_t addr)
{
	return new OpAnd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAsr_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "asrs\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpAsr_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR(rdn), op2 = cpu.GetGPR(rm), res = ComputeRegShift( cpu, op1, /*asr*/2, op2 );
		cpu.SetGPR( rdn, res );
		if (not cpu.itblock()) UpdateStatusRegShift( cpu, res, op1, /*asr*/2, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAsr_reg(CodeType code, uint32_t addr)
{
	return new OpAsr_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBic<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "bics\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpBic<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rdn ), op2 = cpu.GetGPR( rm ), res = op1 & ~op2;
		cpu.SetGPR( rdn, res );

		if (not cpu.itblock())
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBic(CodeType code, uint32_t addr)
{
	return new OpBic<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmn<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cmn\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpCmn<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = cpu.GetGPR( rm ), res = op1 + op2;
		UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmn(CodeType code, uint32_t addr)
{
	return new OpCmn<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmp_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cmp\t" << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpCmp_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 - op2;
		UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmp_1(CodeType code, uint32_t addr)
{
	return new OpCmp_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmp_2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cmp\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpCmp_2<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = cpu.GetGPR( rm ), res = op1 - op2;
		UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmp_2(CodeType code, uint32_t addr)
{
	return new OpCmp_2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmp_3<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cmp\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpCmp_3<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = cpu.GetGPR( rm ), res = op1 - op2;
		UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmp_3(CodeType code, uint32_t addr)
{
	return new OpCmp_3<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpEor<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "eors\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpEor<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rdn ), op2 = cpu.GetGPR( rm ), res = op1 ^ op2;
		cpu.SetGPR( rdn, res );

		if (not cpu.itblock())
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpEor(CodeType code, uint32_t addr)
{
	return new OpEor<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLsl_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "lsls\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpLsl_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR(rdn), op2 = cpu.GetGPR(rm),
		res = ComputeRegShift( cpu, op1, /*lsl*/0, op2 );
		cpu.SetGPR( rdn, res );
		if (not cpu.itblock()) UpdateStatusRegShift( cpu, res, op1, /*lsl*/0, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLsl_reg(CodeType code, uint32_t addr)
{
	return new OpLsl_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLsr_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "lsrs\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpLsr_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR(rdn), op2 = cpu.GetGPR(rm),
		res = ComputeRegShift( cpu, op1, /*lsr*/1, op2 );
		cpu.SetGPR( rdn, res );
		if (not cpu.itblock()) UpdateStatusRegShift( cpu, res, op1, /*lsr*/1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLsr_reg(CodeType code, uint32_t addr)
{
	return new OpLsr_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMov_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "movs\t" << DisasmRegister(rd) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpMov_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 res = U32(imm);
		cpu.SetGPR( rd, res );

		if (not cpu.itblock())
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMov_1(CodeType code, uint32_t addr)
{
	return new OpMov_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMov_3<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mov\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpMov_3<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rd, cpu.GetGPR(rm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMov_3(CodeType code, uint32_t addr)
{
	return new OpMov_3<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMov_3_pc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mov\tpc, " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpMov_3_pc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.Branch( cpu.GetGPR( rm ), ARCH::B_JMP );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMov_3_pc(CodeType code, uint32_t addr)
{
	return new OpMov_3_pc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMvn<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mvns\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpMvn<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 res = ~(cpu.GetGPR( rm ));
		cpu.SetGPR( rd, res );

		if (not cpu.itblock())
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMvn(CodeType code, uint32_t addr)
{
	return new OpMvn<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpNeg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "negs\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpNeg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = U32(0), op2 = cpu.GetGPR( rm ), res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (not cpu.itblock()) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpNeg(CodeType code, uint32_t addr)
{
	return new OpNeg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpOrr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "orrs\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpOrr<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rdn ), op2 = cpu.GetGPR( rm ), res = op1 | op2;
		cpu.SetGPR( rdn, res );

		if (not cpu.itblock())
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpOrr(CodeType code, uint32_t addr)
{
	return new OpOrr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRor_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "rors\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRor_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR(rdn), op2 = cpu.GetGPR(rm),
		res = ComputeRegShift( cpu, op1, /*ror*/3, op2 );
		cpu.SetGPR( rdn, res );
		if (not cpu.itblock()) UpdateStatusRegShift( cpu, res, op1, /*ror*/3, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRor_reg(CodeType code, uint32_t addr)
{
	return new OpRor_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sbcs\t" << DisasmRegister(rdn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSbc<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rdn ), op2 = cpu.GetGPR( rm ), borrow = cpu.CPSR().Get( C ) ^ U32(1), res = op1 - op2 - borrow;
		cpu.SetGPR( rdn, res );
		if (not cpu.itblock()) UpdateStatusSubWithBorrow( cpu, res, op1, op2, borrow );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbc(CodeType code, uint32_t addr)
{
	return new OpSbc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSub_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "subs\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSub_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (not cpu.itblock()) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSub_1(CodeType code, uint32_t addr)
{
	return new OpSub_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSub_2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "subs\t" << DisasmRegister(rdn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSub_2<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rdn ), op2 = U32(imm), res = op1 - op2;
		cpu.SetGPR( rdn, res );
		if (not cpu.itblock()) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSub_2(CodeType code, uint32_t addr)
{
	return new OpSub_2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSub_3<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "subs\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSub_3<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = cpu.GetGPR( rm ), res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (not cpu.itblock()) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSub_3(CodeType code, uint32_t addr)
{
	return new OpSub_3<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSub_4<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sub\tsp, " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSub_4<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( 13, cpu.GetGPR( 13 ) - U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSub_4(CodeType code, uint32_t addr)
{
	return new OpSub_4<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTst<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "tst\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpTst<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm), res = op1 & op2;

		cpu.CPSR().Set( N, S32(res) < S32(0) );
		cpu.CPSR().Set( Z,     res == U32(0) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTst(CodeType code, uint32_t addr)
{
	return new OpTst<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRev<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "rev\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRev<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR(rm), rdval = ByteSwap( rmval );

		cpu.SetGPR( rd, rdval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRev(CodeType code, uint32_t addr)
{
	return new OpRev<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRev16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "rev16\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRev16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rdval = ByteSwap( RotateRight( rmval, 16 ) );
		cpu.SetGPR( rd, rdval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRev16(CodeType code, uint32_t addr)
{
	return new OpRev16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRevsh<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "revsh\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRevsh<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U16 src( cpu.GetGPR(rm) );
		cpu.SetGPR( rd, U32(S32(S16((src >> 8) | (src << 8)))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRevsh(CodeType code, uint32_t addr)
{
	return new OpRevsh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSetend<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "setend\t" << (endianness ? "be":"le");
}}
template <	typename	ARCH>
void OpSetend<	ARCH>::execute( ARCH & cpu)
{
	{
		if (cpu.itblock())
		cpu.UnpredictableInsnBehaviour();

		cpu.CPSR().Set( E, typename ARCH::U32(endianness) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSetend(CodeType code, uint32_t addr)
{
	return new OpSetend<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldr\t" << DisasmRegister(rt) << ", "
		<< DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdr_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR_mem( rt, cpu.MemURead32( cpu.GetGPR(rn) + U32(imm) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_1(CodeType code, uint32_t addr)
{
	return new OpLdr_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldr\t" << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,true,true,false);
}}
template <	typename	ARCH>
void OpLdr_2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR_mem( rt, cpu.MemURead32( cpu.GetGPR(rn) + cpu.GetGPR(rm) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_2(CodeType code, uint32_t addr)
{
	return new OpLdr_2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_lit_s<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldr\t" << DisasmRegister(rt) << ", [pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpLdr_lit_s<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR_mem( rt, cpu.MemURead32( (cpu.GetGPR( 15 ) & U32(-4)) + U32(imm) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_lit_s(CodeType code, uint32_t addr)
{
	return new OpLdr_lit_s<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_4<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldr\t" << DisasmRegister(rt) << ", [sp, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpLdr_4<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR_mem( rt, cpu.MemURead32( cpu.GetGPR( 13 ) + U32(imm) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_4(CodeType code, uint32_t addr)
{
	return new OpLdr_4<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrb_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrb\t" << DisasmRegister(rt) << ", "
		<< DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrb_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( cpu.GetGPR(rn) + U32(imm) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrb_1(CodeType code, uint32_t addr)
{
	return new OpLdrb_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrb_2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrb\t" << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,true,true,false);
}}
template <	typename	ARCH>
void OpLdrb_2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR_mem( rt, typename ARCH::U32( cpu.MemRead8( cpu.GetGPR(rn) + cpu.GetGPR(rm) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrb_2(CodeType code, uint32_t addr)
{
	return new OpLdrb_2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrh_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrh\t" << DisasmRegister(rt) << ", "
		<< DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrh_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR_mem( rt, U32( cpu.MemURead16( cpu.GetGPR(rn) + U32(imm) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrh_1(CodeType code, uint32_t addr)
{
	return new OpLdrh_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrh_2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrh\t" << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,true,true,false);
}}
template <	typename	ARCH>
void OpLdrh_2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR_mem( rt, typename ARCH::U32( cpu.MemURead16( cpu.GetGPR(rn) + cpu.GetGPR(rm) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrh_2(CodeType code, uint32_t addr)
{
	return new OpLdrh_2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsb\t" << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,true,true,false);
}}
template <	typename	ARCH>
void OpLdrsb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( cpu.GetGPR(rn) + cpu.GetGPR(rm) ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsb(CodeType code, uint32_t addr)
{
	return new OpLdrsb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsh<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsh\t" << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,true,true,false);
}}
template <	typename	ARCH>
void OpLdrsh<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( cpu.GetGPR( rn ) + cpu.GetGPR( rm ) ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsh(CodeType code, uint32_t addr)
{
	return new OpLdrsh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStr_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "str\t" << DisasmRegister(rt) << ", "
		<< DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStr_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.MemUWrite32(cpu.GetGPR(rn) + U32(imm), cpu.GetGPR(rt));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStr_1(CodeType code, uint32_t addr)
{
	return new OpStr_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStr_2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "str\t" << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,true,true,false);
}}
template <	typename	ARCH>
void OpStr_2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.MemUWrite32( cpu.GetGPR(rn) + cpu.GetGPR(rm), cpu.GetGPR(rt) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStr_2(CodeType code, uint32_t addr)
{
	return new OpStr_2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStr_3<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "str\t" << DisasmRegister(rt) << ", [sp, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpStr_3<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.MemUWrite32(cpu.GetGPR(13) + U32(imm), cpu.GetGPR(rt));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStr_3(CodeType code, uint32_t addr)
{
	return new OpStr_3<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrb_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strb\t" << DisasmRegister(rt) << ", "
		<< DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStrb_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		cpu.MemWrite8( cpu.GetGPR(rn) + U32(imm), U8(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrb_1(CodeType code, uint32_t addr)
{
	return new OpStrb_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrb_2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strb\t" << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,true,true,false);
}}
template <	typename	ARCH>
void OpStrb_2<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8  U8;
		cpu.MemWrite8( cpu.GetGPR(rn) + cpu.GetGPR(rm), U8(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrb_2(CodeType code, uint32_t addr)
{
	return new OpStrb_2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrh_1<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strh\t" << DisasmRegister(rt) << ", "
		<< DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStrh_1<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		cpu.MemUWrite16( cpu.GetGPR(rn) + U32(imm), U16(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrh_1(CodeType code, uint32_t addr)
{
	return new OpStrh_1<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrh_2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strh\t" << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,true,true,false);
}}
template <	typename	ARCH>
void OpStrh_2<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		cpu.MemUWrite16( cpu.GetGPR(rn) + cpu.GetGPR(rm), U16(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrh_2(CodeType code, uint32_t addr)
{
	return new OpStrh_2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdmia<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		if ((reglist >> rn) & 1)
		buffer << "ldmia\t" << DisasmRegister(rn) << ", {" << DisasmRegList( reglist ) << "}";
		else
		buffer << "ldmia\t" << DisasmRegister(rn) << "!, {" << DisasmRegList( reglist ) << "}";
}}
template <	typename	ARCH>
void OpLdmia<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( rn );
		LSMIter itr(LSMIter::IA, reglist);
		while (itr.next()) {
			cpu.SetGPR_mem( itr.reg(), cpu.MemRead32( base + U32(itr.offset()) ) );
		}

		bool overwritten = (reglist >> rn) & 1;
		if (not overwritten) cpu.SetGPR( rn, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdmia(CodeType code, uint32_t addr)
{
	return new OpLdmia<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPop<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pop\t{" << DisasmRegList(reglist) << "}";
}}
template <	typename	ARCH>
void OpPop<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( 13 );
		LSMIter itr(LSMIter::IA, reglist);
		while (itr.next()) {
			cpu.SetGPR_mem( itr.reg(), cpu.MemRead32( base + U32(itr.offset()) ) );
		}

		bool overwritten = (reglist >> 13) & 1;
		if (not overwritten) cpu.SetGPR( 13, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPop(CodeType code, uint32_t addr)
{
	return new OpPop<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPush<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "push\t{" << DisasmRegList(reglist) << "}";
}}
template <	typename	ARCH>
void OpPush<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( 13 );
		LSMIter itr(LSMIter::DB, reglist);
		while (itr.next()) {
			cpu.MemWrite32( base + U32(itr.offset()), cpu.GetGPR( itr.reg() ) );
		}

		cpu.SetGPR( 13, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPush(CodeType code, uint32_t addr)
{
	return new OpPush<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStmia<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "stmia\t" << DisasmRegister(rn) << "!, {" << DisasmRegList(reglist) << "}";
}}
template <	typename	ARCH>
void OpStmia<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( rn );
		LSMIter itr(LSMIter::IA, reglist);
		while (itr.next()) {
			cpu.MemWrite32( base + U32(itr.offset()), cpu.GetGPR( itr.reg() ) );
		}

		cpu.SetGPR( rn, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStmia(CodeType code, uint32_t addr)
{
	return new OpStmia<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMul<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "muls\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpMul<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 res = cpu.GetGPR(rd) * cpu.GetGPR(rm);
		cpu.SetGPR(rd, res);

		if (not cpu.itblock())
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMul(CodeType code, uint32_t addr)
{
	return new OpMul<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sxtb\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSxtb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		cpu.SetGPR( rd, U32( S32( S8( cpu.GetGPR( rm ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtb(CodeType code, uint32_t addr)
{
	return new OpSxtb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxth<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sxth\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSxth<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		cpu.SetGPR( rd, U32( S32( S16( cpu.GetGPR( rm ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxth(CodeType code, uint32_t addr)
{
	return new OpSxth<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uxtb\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUxtb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		cpu.SetGPR( rd, U32( U8( cpu.GetGPR( rm ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtb(CodeType code, uint32_t addr)
{
	return new OpUxtb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxth<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uxth\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUxth<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		cpu.SetGPR( rd, U32( U16( cpu.GetGPR( rm ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxth(CodeType code, uint32_t addr)
{
	return new OpUxth<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBcc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "b" << DisasmCondition(cond) << ".n\t0x" << std::hex << ((this->GetAddr() + 4 + imm) & -2) << std::dec;
}}
template <	typename	ARCH>
void OpBcc<	ARCH>::execute( ARCH & cpu)
{
	{
		if (cpu.itblock())
		cpu.UnpredictableInsnBehaviour();

		if (unlikely( not CheckCondition(cpu, cond) )) return;

		typedef typename ARCH::U32 U32;
		cpu.Branch(cpu.GetGPR( 15 ) + U32(imm), ARCH::B_JMP);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBcc(CodeType code, uint32_t addr)
{
	return new OpBcc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpB<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "b.n\t0x" << std::hex << ((this->GetAddr() + 4 + imm) & -2) << std::dec;
}}
template <	typename	ARCH>
void OpB<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		cpu.Branch(cpu.GetGPR( 15 ) + U32(imm), ARCH::B_JMP);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpB(CodeType code, uint32_t addr)
{
	return new OpB<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "bx\t" << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpBx<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.BranchExchange( cpu.GetGPR(rm), ARCH::B_JMP );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBx(CodeType code, uint32_t addr)
{
	return new OpBx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBlx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "blx\t" << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpBlx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 address = cpu.GetGPR(rm);
		cpu.SetGPR( 14, cpu.GetNIA() | U32(1) );
		cpu.BranchExchange( address, ARCH::B_CALL );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBlx(CodeType code, uint32_t addr)
{
	return new OpBlx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSwi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "swi\t" << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSwi<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.CallSupervisor( imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSwi(CodeType code, uint32_t addr)
{
	return new OpSwi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBkpt<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "bkpt\t0x"
		<< std::hex << std::setfill('0') << std::setw(4) << imm
		<< std::setw(0) << std::setfill(' ') << std::dec;
}}
template <	typename	ARCH>
void OpBkpt<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.BKPT( imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBkpt(CodeType code, uint32_t addr)
{
	return new OpBkpt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCpsi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cps" << (dis?"id":"ie") << '\t' << (a?"a":"") << (i?"i":"") << (f?"f":"");
}}
template <	typename	ARCH>
void OpCpsi<	ARCH>::execute( ARCH & cpu)
{
	{
		if (cpu.itblock())
		cpu.UnpredictableInsnBehaviour();

		typedef typename ARCH::U32 U32;

		if (unlikely( cpu.Test(cpu.CPSR().Get(M) == U32(PSR::USER_MODE)) ))
		return;

		// CPSRWriteByInstr() checks for illegal mode changes
		CPSRWriteByInstr( cpu, U32(psr_bits), psr_mask );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCpsi(CodeType code, uint32_t addr)
{
	return new OpCpsi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMov_wri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "mov" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpMov_wri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 res = U32(imm);
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (cfim)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMov_wri(CodeType code, uint32_t addr)
{
	return new OpMov_wri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMov_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mov" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpMov_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), res = ComputeImmShift( cpu, rmval, shift, imm );
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMov_w(CodeType code, uint32_t addr)
{
	return new OpMov_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMovt<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "movt\t" << DisasmRegister(rsd) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpMovt<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rsd, (cpu.GetGPR( rsd ) & U32(0xffff)) | (U32(imm << 16)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMovt(CodeType code, uint32_t addr)
{
	return new OpMovt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMovw<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "movw\t" << DisasmRegister(rd) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpMovw<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMovw(CodeType code, uint32_t addr)
{
	return new OpMovw<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMvn_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mvn" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpMvn_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), res = ~(ComputeImmShift( cpu, rmval, shift, imm ));
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMvn_w(CodeType code, uint32_t addr)
{
	return new OpMvn_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMvn_wri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "mvn" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpMvn_wri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 res = U32(~imm);
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (cfim)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMvn_wri(CodeType code, uint32_t addr)
{
	return new OpMvn_wri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShift_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << DisasmShift(shift) << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShift_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rnval = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		res = ComputeRegShift( cpu, rnval, shift, rmval );
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusRegShift( cpu, res, rnval, shift, rmval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShift_w(CodeType code, uint32_t addr)
{
	return new OpShift_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSub_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sub" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpSub_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32
		op1 = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSub_w(CodeType code, uint32_t addr)
{
	return new OpSub_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSub_wrri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "sub" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpSub_wrri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSub_wrri(CodeType code, uint32_t addr)
{
	return new OpSub_wrri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSubw<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "subw\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSubw<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, cpu.GetGPR(rn) - U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSubw(CodeType code, uint32_t addr)
{
	return new OpSubw<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdr_subw<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "subw\t" << DisasmRegister(rd) << ", pc, " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdr_subw<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, (cpu.GetGPR( 15 ) & U32(-4)) - U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdr_subw(CodeType code, uint32_t addr)
{
	return new OpAdr_subw<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbc_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sbc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpSbc_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32
		op1 = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		borrow = cpu.CPSR().Get( C ) ^ U32(1),
		res = op1 - op2 - borrow;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSubWithBorrow( cpu, res, op1, op2, borrow );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbc_w(CodeType code, uint32_t addr)
{
	return new OpSbc_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbc_wrri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "sbc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpSbc_wrri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), borrow = cpu.CPSR().Get( C ) ^ U32(1), res = op1 - op2 - borrow;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSubWithBorrow( cpu, res, op1, op2, borrow );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbc_wrri(CodeType code, uint32_t addr)
{
	return new OpSbc_wrri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "rsb" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpRsb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = ComputeImmShift( cpu, rmval, shift, imm ), op2 = cpu.GetGPR( rn ),
		res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsb(CodeType code, uint32_t addr)
{
	return new OpRsb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRsb_rri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "rsb" << (s?"s":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpRsb_rri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = U32(imm), op2 = cpu.GetGPR( rn ), res = op1 - op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRsb_rri(CodeType code, uint32_t addr)
{
	return new OpRsb_rri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "add" << (s?"s":"") << ".w\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpAdd_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32
		op1 = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 + op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_w(CodeType code, uint32_t addr)
{
	return new OpAdd_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdd_wrri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "add" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpAdd_wrri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 + op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdd_wrri(CodeType code, uint32_t addr)
{
	return new OpAdd_wrri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAddw<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "addw\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAddw<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, cpu.GetGPR(rn) + U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAddw(CodeType code, uint32_t addr)
{
	return new OpAddw<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdr_addw<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "addw\t" << DisasmRegister(rd) << ", pc, " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAdr_addw<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, (cpu.GetGPR( 15 ) & U32(-4)) + U32(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdr_addw(CodeType code, uint32_t addr)
{
	return new OpAdr_addw<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdc_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "adc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpAdc_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ), carry = cpu.CPSR().Get( C ),
		res = op1 + op2 + carry;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAddWithCarry( cpu, res, op1, op2, carry );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdc_w(CodeType code, uint32_t addr)
{
	return new OpAdc_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAdc_wrri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "adc" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpAdc_wrri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), carry = cpu.CPSR().Get( C ), res = op1 + op2 + carry;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusAddWithCarry( cpu, res, op1, op2, carry );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAdc_wrri(CodeType code, uint32_t addr)
{
	return new OpAdc_wrri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpEor_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "eor" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpEor_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 ^ op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpEor_w(CodeType code, uint32_t addr)
{
	return new OpEor_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpEor_wrri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "eor" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpEor_wrri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 ^ op2;
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (cfim)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpEor_wrri(CodeType code, uint32_t addr)
{
	return new OpEor_wrri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBic_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "bic" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpBic_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 & ~op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBic_w(CodeType code, uint32_t addr)
{
	return new OpBic_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBic_wrri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "bic" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpBic_wrri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 & ~op2;
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (cfim)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBic_wrri(CodeType code, uint32_t addr)
{
	return new OpBic_wrri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAnd_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "and" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
		buffer << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpAnd_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 & op2;
		cpu.SetGPR( rd, res );
		if (s) UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAnd_w(CodeType code, uint32_t addr)
{
	return new OpAnd_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpAnd_wrri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "and" << (s?"s":"") << ".w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpAnd_wrri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 & op2;
		cpu.SetGPR( rd, res );

		if (s)
		{
			cpu.CPSR().Set( N, S32(res) < S32(0) );
			cpu.CPSR().Set( Z,     res == U32(0) );
			if (cfim)
			cpu.CPSR().Set( C, S32(imm) < S32(0) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpAnd_wrri(CodeType code, uint32_t addr)
{
	return new OpAnd_wrri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmp_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cmp.w\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpCmp_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32
		op1 = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 - op2;
		UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmp_w(CodeType code, uint32_t addr)
{
	return new OpCmp_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmp_wri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cmp.w\t" << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpCmp_wri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 - op2;
		UpdateStatusSub( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmp_wri(CodeType code, uint32_t addr)
{
	return new OpCmp_wri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmn_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cmn.w\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpCmn_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32
		op1 = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 + op2;
		UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmn_w(CodeType code, uint32_t addr)
{
	return new OpCmn_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCmn_wri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cmn.w\t" << DisasmRegister(rn) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpCmn_wri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 + op2;
		UpdateStatusAdd( cpu, res, op1, op2 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCmn_wri(CodeType code, uint32_t addr)
{
	return new OpCmn_wri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTeq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "teq\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpTeq<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ),
		op1 = cpu.GetGPR( rn ), op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 ^ op2;
		UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTeq(CodeType code, uint32_t addr)
{
	return new OpTeq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTeq_wri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "teq\t" << DisasmRegister(rn) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpTeq_wri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 ^ op2;

		cpu.CPSR().Set( N, S32(res) < S32(0) );
		cpu.CPSR().Set( Z,     res == U32(0) );
		if (cfim)
		cpu.CPSR().Set( C, S32(imm) < S32(0) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTeq_wri(CodeType code, uint32_t addr)
{
	return new OpTeq_wri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTst_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "tst.w\t" << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( shift, imm );
}}
template <	typename	ARCH>
void OpTst_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm ),
		op2 = ComputeImmShift( cpu, rmval, shift, imm ),
		res = op1 & op2;
		UpdateStatusImmShift( cpu, res, rmval, shift, imm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTst_w(CodeType code, uint32_t addr)
{
	return new OpTst_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTst_wri<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "tst.w\t" << DisasmRegister(rn) << ", " << DisasmI(imm); }}
template <	typename	ARCH>
void OpTst_wri<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR( rn ), op2 = U32(imm), res = op1 & op2;

		cpu.CPSR().Set( N, S32(res) < S32(0) );
		cpu.CPSR().Set( Z,     res == U32(0) );
		if (cfim)
		cpu.CPSR().Set( C, S32(imm) < S32(0) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTst_wri(CodeType code, uint32_t addr)
{
	return new OpTst_wri<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpClz<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "clz\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm); }}
template <	typename	ARCH>
void OpClz<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 val = cpu.GetGPR( rm );
		if (cpu.Test(val == U32(0)))
		val = U32(32);
		else
		val = U32(31) - BitScanReverse( cpu.GetGPR( rm ) );

		cpu.SetGPR( rd, val );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpClz(CodeType code, uint32_t addr)
{
	return new OpClz<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtab16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uxtab16\t"
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxtab16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		U16 lo = U16( rmval << 8 ) >> 8, hi = U16( rmval >> 8 ) >> 8;
		lo += U16( rnval >> 0 ); hi += U16( rnval >> 16 );
		cpu.SetGPR( rd, (U32( lo ) << 0) | (U32( hi ) << 16) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtab16(CodeType code, uint32_t addr)
{
	return new OpUxtab16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtab<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uxtab\t"
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxtab<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rnval + U32( U8( rmval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtab(CodeType code, uint32_t addr)
{
	return new OpUxtab<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtah<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uxtah\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxtah<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rnval + U32( U16( rmval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtah(CodeType code, uint32_t addr)
{
	return new OpUxtah<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtb16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uxtb16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxtb16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rmval & U32( 0x00ff00ff ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtb16(CodeType code, uint32_t addr)
{
	return new OpUxtb16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxtb_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uxtb.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
		if (ror) buffer << ", ror " << DisasmI(ror);
}}
template <	typename	ARCH>
void OpUxtb_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, U32( U8( rmval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxtb_w(CodeType code, uint32_t addr)
{
	return new OpUxtb_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUxth_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uxth.w\t" << DisasmRegister(rd) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpUxth_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, U32( U16( rmval ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUxth_w(CodeType code, uint32_t addr)
{
	return new OpUxth_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtab16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sxtab16\t"
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtab16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::S16 S16;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		S16 lo = S16( rmval << 8 ) >> 8, hi = S16( rmval >> 8 ) >> 8;

		lo += S16( rnval >> 0 ); hi += S16( rnval >> 16 );
		cpu.SetGPR( rd, (U32( U16( lo ) ) << 0) | (U32( U16( hi ) ) << 16) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtab16(CodeType code, uint32_t addr)
{
	return new OpSxtab16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtab<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sxtab\t"
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtab<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rnval + U32( S32( S8( rmval ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtab(CodeType code, uint32_t addr)
{
	return new OpSxtab<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtah<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sxtah\t"
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtah<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 rnval = cpu.GetGPR( rn ), rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, rnval + U32( S32( S16( rmval ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtah(CodeType code, uint32_t addr)
{
	return new OpSxtah<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtb16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sxtb16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtb16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::S16 S16;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		S16 lo = S16( rmval << 8 ) >> 8, hi = S16( rmval >> 8 ) >> 8;
		cpu.SetGPR( rd, (U32( U16( lo ) ) << 0) | (U32( U16( hi ) ) << 16) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtb16(CodeType code, uint32_t addr)
{
	return new OpSxtb16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxtb_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sxtb.w\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxtb_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S8  S8;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, U32( S32( S8( rmval ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxtb_w(CodeType code, uint32_t addr)
{
	return new OpSxtb_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSxth_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sxth.w\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << DisasmShImm( ror?3:0, ror );
}}
template <	typename	ARCH>
void OpSxth_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 rmval = RotateRight( cpu.GetGPR( rm ), ror );
		cpu.SetGPR( rd, U32( S32( S16( rmval ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSxth_w(CodeType code, uint32_t addr)
{
	return new OpSxth_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUbfx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ubfx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(lsb) << ", " << DisasmI(width);
}}
template <	typename	ARCH>
void OpUbfx<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rd, (cpu.GetGPR( rn ) << (32 - width - lsb)) >> (32 - width) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUbfx(CodeType code, uint32_t addr)
{
	return new OpUbfx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSbfx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sbfx\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(lsb) << ", " << DisasmI(width);
}}
template <	typename	ARCH>
void OpSbfx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		cpu.SetGPR( rd, U32((S32(cpu.GetGPR( rn )) << (32 - width - lsb)) >> (32 - width)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSbfx(CodeType code, uint32_t addr)
{
	return new OpSbfx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBfi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "bfi\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmI(lsb) << ", " << DisasmI(width);
}}
template <	typename	ARCH>
void OpBfi<	ARCH>::execute( ARCH & cpu)
{
	{
		// if (msb < lsb) UNPREDICTABLE
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, (cpu.GetGPR( rd ) & U32(clear)) | ((cpu.GetGPR( rn ) << lsb) & U32(~clear)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBfi(CodeType code, uint32_t addr)
{
	return new OpBfi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBfc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "bfc\t" << DisasmRegister(rd) << ", " << DisasmI(lsb) << ", " << DisasmI(width);
}}
template <	typename	ARCH>
void OpBfc<	ARCH>::execute( ARCH & cpu)
{
	{
		// if (msb < lsb) UNPREDICTABLE
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( rd, cpu.GetGPR( rd ) & U32(clear) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBfc(CodeType code, uint32_t addr)
{
	return new OpBfc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRbit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "rbit\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRbit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 src = cpu.GetGPR( rm ), dst = U32(0);
		for (int idx = 0; idx < 32; ++idx) { dst = (dst << 1) | (src & U32(1)); src >>= 1; }
		cpu.SetGPR( rd, dst );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRbit(CodeType code, uint32_t addr)
{
	return new OpRbit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRev_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "rev.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm); }}
template <	typename	ARCH>
void OpRev_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rdval = ByteSwap( rmval );

		cpu.SetGPR( rd, rdval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRev_w(CodeType code, uint32_t addr)
{
	return new OpRev_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRev16_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "rev16.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRev16_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 rmval = cpu.GetGPR( rm ), rdval = ByteSwap( RotateRight( rmval, 16 ) );
		cpu.SetGPR( rd, rdval );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRev16_w(CodeType code, uint32_t addr)
{
	return new OpRev16_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRevsh_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "revsh.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpRevsh_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U16 src( cpu.GetGPR(rm) );
		cpu.SetGPR( rd, U32(S32(S16((src >> 8) | (src << 8)))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRevsh_w(CodeType code, uint32_t addr)
{
	return new OpRevsh_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldr.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdr_imm12<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, cpu.MemURead32( addr ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_imm12(CodeType code, uint32_t addr)
{
	return new OpLdr_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdr_lit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldr.w\t" << DisasmRegister(rt) << ", [pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpLdr_lit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR_mem( rt, cpu.MemURead32( (cpu.GetGPR( 15 ) & U32( -4 )) + U32( imm ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdr_lit(CodeType code, uint32_t addr)
{
	return new OpLdr_lit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsh_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsh.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrsh_imm12<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( addr ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsh_imm12(CodeType code, uint32_t addr)
{
	return new OpLdrsh_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrsh_lit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrsh.w\t" << DisasmRegister(rt) << ", [pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpLdrsh_lit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( (cpu.GetGPR( 15 ) & U32( -4 )) + U32( imm ) ) ) ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrsh_lit(CodeType code, uint32_t addr)
{
	return new OpLdrsh_lit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrd\t" << DisasmRegister(rt1) << ", " << DisasmRegister(rt2) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpLdrd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.SetGPR_mem( rt1, cpu.MemRead32( (p?oaddr:addr) + U32(0) ) );
		cpu.SetGPR_mem( rt2, cpu.MemRead32( (p?oaddr:addr) + U32(4) ) );
		if (w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrd(CodeType code, uint32_t addr)
{
	return new OpLdrd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrd_lit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrd\t" << DisasmRegister(rt1) << ", " << DisasmRegister(rt2) << ", [pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpLdrd_lit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( 15 ) & U32( -4 ), oaddr = addr + U32( imm );
		cpu.SetGPR_mem( rt1, cpu.MemRead32( oaddr + U32(0) ) );
		cpu.SetGPR_mem( rt2, cpu.MemRead32( oaddr + U32(4) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrd_lit(CodeType code, uint32_t addr)
{
	return new OpLdrd_lit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStr_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "str.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStr_imm12<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.MemUWrite32( addr, cpu.GetGPR( rt ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStr_imm12(CodeType code, uint32_t addr)
{
	return new OpStr_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStr_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "str.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStr_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.MemUWrite32( p?oaddr:addr, cpu.GetGPR( rt ) );
		if (w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStr_imm(CodeType code, uint32_t addr)
{
	return new OpStr_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStr_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "str.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,0,imm,true,true,false);
}}
template <	typename	ARCH>
void OpStr_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), 0, imm );
		cpu.MemUWrite32( cpu.GetGPR( rn ) + isval, cpu.GetGPR( rt ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStr_reg(CodeType code, uint32_t addr)
{
	return new OpStr_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrh_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strh.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStrh_imm12<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.MemUWrite16( addr, U16( cpu.GetGPR( rt ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrh_imm12(CodeType code, uint32_t addr)
{
	return new OpStrh_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrh_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strh.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStrh_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.MemUWrite16( p?oaddr:addr, U16( cpu.GetGPR( rt ) ) );
		if (w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrh_imm(CodeType code, uint32_t addr)
{
	return new OpStrh_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrh_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strh.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,0,imm,true,true,false);
}}
template <	typename	ARCH>
void OpStrh_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), 0, imm );
		cpu.MemUWrite16( cpu.GetGPR( rn ) + isval, U16( cpu.GetGPR( rt ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrh_reg(CodeType code, uint32_t addr)
{
	return new OpStrh_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrb_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strb.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStrb_imm12<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.MemWrite8( addr, U8( cpu.GetGPR( rt ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrb_imm12(CodeType code, uint32_t addr)
{
	return new OpStrb_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrb_imm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strb.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
}}
template <	typename	ARCH>
void OpStrb_imm<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.MemWrite8( p?oaddr:addr, U8( cpu.GetGPR( rt ) ) );
		if (w) cpu.SetGPR( rn, oaddr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrb_imm(CodeType code, uint32_t addr)
{
	return new OpStrb_imm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrb_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strb.w\t" << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,0,imm,true,true,false);
}}
template <	typename	ARCH>
void OpStrb_reg<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), 0, imm );
		cpu.MemWrite8( cpu.GetGPR( rn ) + isval, U8( cpu.GetGPR( rt ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrb_reg(CodeType code, uint32_t addr)
{
	return new OpStrb_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strd\t" << DisasmRegister(rt1) << ", " << DisasmRegister(rt2) << ", "
		<< "[" << DisasmRegister(rn) << (p?"":"]") << ", " << DisasmI(imm) << (p?(w?"]!":"]"):"");
}}
template <	typename	ARCH>
void OpStrd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32( imm );
		cpu.MemWrite32( (p?oaddr:addr) + U32(0), cpu.GetGPR( rt1 ) );
		cpu.MemWrite32( (p?oaddr:addr) + U32(4), cpu.GetGPR( rt2 ) );
		if (w) cpu.SetGPR( rn, addr + U32( imm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrd(CodeType code, uint32_t addr)
{
	return new OpStrd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrt<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strt\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStrt<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.MemUWrite32( addr, cpu.GetGPR(rt) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrt(CodeType code, uint32_t addr)
{
	return new OpStrt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrht<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strht\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStrht<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.MemUWrite16( addr, U16( cpu.GetGPR(rt) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrht(CodeType code, uint32_t addr)
{
	return new OpStrht<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrbt<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strbt\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStrbt<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );
		cpu.MemWrite8( addr, U8( cpu.GetGPR(rt) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrbt(CodeType code, uint32_t addr)
{
	return new OpStrbt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPld_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pld" << (w?"w":"") << "\t" << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpPld_imm12<	ARCH>::execute( ARCH & cpu)
{
	{
		/* nop: no architecturally visible changes */
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPld_imm12(CodeType code, uint32_t addr)
{
	return new OpPld_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPld_nimm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pld" << (w?"w":"") << "\t" << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpPld_nimm<	ARCH>::execute( ARCH & cpu)
{
	{
		/* nop: no architecturally visible changes */
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPld_nimm(CodeType code, uint32_t addr)
{
	return new OpPld_nimm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPld_lit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pld" << (w?"w":"") << "\t[pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpPld_lit<	ARCH>::execute( ARCH & cpu)
{
	{
		/* nop: no architecturally visible changes */
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPld_lit(CodeType code, uint32_t addr)
{
	return new OpPld_lit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPli_imm12<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pli\t" << DisasmMemoryRI(rn,imm,true,false);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPli_imm12(CodeType code, uint32_t addr)
{
	return new OpPli_imm12<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPli_nimm<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pli\t" << DisasmMemoryRI(rn,imm,true,false);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPli_nimm(CodeType code, uint32_t addr)
{
	return new OpPli_nimm<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPli_lit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pli\t" << "[pc, " << DisasmI(imm) << "]";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPli_lit(CodeType code, uint32_t addr)
{
	return new OpPli_lit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdmdb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldmdb\t" << DisasmRegister(rn) << (w?"!":"") << ", {" << DisasmRegList(reglist) << "}";
}}
template <	typename	ARCH>
void OpLdmdb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( rn );
		LSMIter itr(LSMIter::DB, reglist);
		while (itr.next()) {
			cpu.SetGPR_mem( itr.reg(), cpu.MemRead32( base + U32(itr.offset()) ) );
		}

		bool overwritten = (reglist >> rn) & 1;
		if (w and not overwritten) cpu.SetGPR( rn, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdmdb(CodeType code, uint32_t addr)
{
	return new OpLdmdb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdmia_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldmia.w\t" << DisasmRegister(rn) << (w?"!":"") << ", {" << DisasmRegList(reglist) << "}";
}}
template <	typename	ARCH>
void OpLdmia_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( rn );
		LSMIter itr(LSMIter::IA, reglist);
		while (itr.next()) {
			cpu.SetGPR_mem( itr.reg(), cpu.MemRead32( base + U32(itr.offset()) ) );
		}

		bool overwritten = (reglist >> rn) & 1;
		if (w and not overwritten) cpu.SetGPR( rn, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdmia_w(CodeType code, uint32_t addr)
{
	return new OpLdmia_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStmdb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "stmdb\t" << DisasmRegister(rn) << (w?"!":"") << ", {" << DisasmRegList(reglist) << "}";
}}
template <	typename	ARCH>
void OpStmdb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( rn );
		LSMIter itr(LSMIter::DB, reglist);
		while (itr.next()) {
			cpu.MemWrite32( base + U32(itr.offset()), cpu.GetGPR( itr.reg() ) );
		}

		if (w) cpu.SetGPR( rn, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStmdb(CodeType code, uint32_t addr)
{
	return new OpStmdb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStmia_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "stmia.w\t" << DisasmRegister(rn) << (w?"!":"") << ", {" << DisasmRegList(reglist) << "}";
}}
template <	typename	ARCH>
void OpStmia_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base = cpu.GetGPR( rn );
		LSMIter itr(LSMIter::IA, reglist);
		while (itr.next()) {
			cpu.MemWrite32( base + U32(itr.offset()), cpu.GetGPR( itr.reg() ) );
		}

		if (w) cpu.SetGPR( rn, base + U32(itr.offset()) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStmia_w(CodeType code, uint32_t addr)
{
	return new OpStmia_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrex<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrex\t" << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpLdrex<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32( imm );

		cpu.SetExclusiveMonitors( addr, 4 );
		cpu.SetGPR_mem( rt, cpu.MemRead32( addr ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrex(CodeType code, uint32_t addr)
{
	return new OpLdrex<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrexh<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrexh\t" << DisasmRegister(rt) << ", " << "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpLdrexh<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 addr = cpu.GetGPR( rn );
		cpu.SetExclusiveMonitors( addr, 2 );
		cpu.SetGPR_mem( rt, U32( cpu.MemRead16( addr ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrexh(CodeType code, uint32_t addr)
{
	return new OpLdrexh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrexb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrexb\t" << DisasmRegister(rt) << ", " << "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpLdrexb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 addr = cpu.GetGPR( rn );
		cpu.SetExclusiveMonitors( addr, 1 );
		cpu.SetGPR_mem( rt, U32( cpu.MemRead8( addr ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrexb(CodeType code, uint32_t addr)
{
	return new OpLdrexb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdrexd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldrexd\t" << DisasmRegister(rt1) << ", " << DisasmRegister(rt2) << ", " << "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpLdrexd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );

		cpu.SetExclusiveMonitors( addr, 8 );
		cpu.SetGPR_mem( rt1, cpu.MemRead32( addr + U32(0) ) );
		cpu.SetGPR_mem( rt2, cpu.MemRead32( addr + U32(4) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdrexd(CodeType code, uint32_t addr)
{
	return new OpLdrexd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrex<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strex\t" << DisasmRegister(rd) << ", " << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpStrex<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32(imm);

		if (cpu.ExclusiveMonitorsPass(addr, 4)) {
			cpu.MemWrite32( addr, cpu.GetGPR( rt ) );
			cpu.SetGPR( rd, U32(0) );
			} else {
			cpu.SetGPR( rd, U32(1) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrex(CodeType code, uint32_t addr)
{
	return new OpStrex<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrexh<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strexh\t" << DisasmRegister(rd) << ", " << DisasmRegister(rt) << ", " << "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpStrexh<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );

		if (cpu.ExclusiveMonitorsPass(addr, 2)) {
			cpu.MemWrite16( addr, typename ARCH::U16(cpu.GetGPR( rt )) );
			cpu.SetGPR( rd, U32(0) );
			} else {
			cpu.SetGPR( rd, U32(1) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrexh(CodeType code, uint32_t addr)
{
	return new OpStrexh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrexb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strexb\t" << DisasmRegister(rd) << ", " << DisasmRegister(rt) << ", " << "[" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpStrexb<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );

		if (cpu.ExclusiveMonitorsPass(addr, 1)) {
			cpu.MemWrite8( addr, typename ARCH::U8(cpu.GetGPR( rt )) );
			cpu.SetGPR( rd, U32(0) );
			} else {
			cpu.SetGPR( rd, U32(1) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrexb(CodeType code, uint32_t addr)
{
	return new OpStrexb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStrexd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "strexd\t" << DisasmRegister(rd) << ", " << DisasmRegister(rt1) << ", " << DisasmRegister(rt2)
		<< ", [" << DisasmRegister(rn) << "]";
}}
template <	typename	ARCH>
void OpStrexd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn );

		if (cpu.ExclusiveMonitorsPass(addr, 8)) {
			cpu.MemWrite32( addr + U32(0), cpu.GetGPR( rt1 ) );
			cpu.MemWrite32( addr + U32(4), cpu.GetGPR( rt2 ) );
			cpu.SetGPR( rd, U32(0) );
			} else {
			cpu.SetGPR( rd, U32(1) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStrexd(CodeType code, uint32_t addr)
{
	return new OpStrexd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpClrex<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "clrex";
}}
template <	typename	ARCH>
void OpClrex<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.ClearExclusiveLocal();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpClrex(CodeType code, uint32_t addr)
{
	return new OpClrex<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQadd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qadd\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpQadd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int32_t const nbound = -1 << 31, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q ));
		S32 op1 = S32(cpu.GetGPR(rn)), op2 = S32(cpu.GetGPR(rm)), res = op1 + op2;

		// n is the observed negative flag and sbn is what this flag should be
		BOOL n = res < S32(0), sbn = op1 <= S32(~op2), of = not sbn and n, uf = sbn and not n;
		U32 satres = CondMove<U32>( of, pbound, uf, nbound, res );

		cpu.SetGPR( rd, satres );
		cpu.CPSR().Set( Q, BOOL(q | of | uf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQadd(CodeType code, uint32_t addr)
{
	return new OpQadd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qadd16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << 15, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			S16 op1 = S16(opn >> 16*idx), op2 = S16(opm >> 16*idx), res = op1 + op2;

			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 <= S16(~op2), of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 16*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQadd16(CodeType code, uint32_t addr)
{
	return new OpQadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qadd8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int8_t const nbound = -1 << 7, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 4; ++idx)
		{
			S8 op1 = S8(opn >> 8*idx), op2 = S8(opm >> 8*idx), res = op1 + op2;

			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S8(0), sbn = op1 <= S8(~op2), of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U8>(of, pbound, uf, nbound, res)) << 8*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQadd8(CodeType code, uint32_t addr)
{
	return new OpQadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQsub<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qsub\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpQsub<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int32_t const nbound = -1 << 31, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q ));
		S32 op1 = S32(cpu.GetGPR(rn)), op2 = S32(cpu.GetGPR(rm)), res = op1 - op2;

		// n is the observed negative flag and sbn is what this flag should be
		BOOL n = res < S32(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
		U32 satres = CondMove<U32>(of, pbound, uf, nbound, res);

		cpu.SetGPR( rd, satres );
		cpu.CPSR().Set( Q, BOOL(q | of | uf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQsub(CodeType code, uint32_t addr)
{
	return new OpQsub<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qsub16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << 15, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			S16 op1 = S16(opn >> 16*idx), op2 = S16(opm >> 16*idx), res = op1 - op2;

			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 16*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQsub16(CodeType code, uint32_t addr)
{
	return new OpQsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qsub8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int8_t const nbound = -1 << 7, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 4; ++idx)
		{
			S8 op1 = S8(opn >> 8*idx), op2 = S8(opm >> 8*idx), res = op1 - op2;

			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S8(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U8>(of, pbound, uf, nbound, res)) << 8*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQsub8(CodeType code, uint32_t addr)
{
	return new OpQsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQdadd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qdadd\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpQdadd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int32_t const nbound = -1 << 31, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q )), n, sbn, of, uf;
		S32 opn = S32(cpu.GetGPR(rn)), opm = S32(cpu.GetGPR(rm)), op1, op2, res;

		// First operation doubles opn
		op1 = opn; op2 = opn; res = op1 + op2;
		// n is the observed negative flag and sbn is what this flag should be
		n = res < S32(0); sbn = op1 <= S32(~op2); of = not sbn and n; uf = sbn and not n;
		res = CondMove<S32>(of, pbound, uf, nbound, res);
		q |= of | uf;

		// Second operation adds to opm
		op1 = opm; op2 = res; res = op1 + op2;
		// n is the observed negative flag and sbn is what this flag should be
		n = res < S32(0); sbn = op1 <= S32(~op2); of = not sbn and n; uf = sbn and not n;
		res = CondMove<S32>(of, pbound, uf, nbound, res);
		q |= of | uf;

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( Q, BOOL(q) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQdadd(CodeType code, uint32_t addr)
{
	return new OpQdadd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQdsub<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qdsub\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpQdsub<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int32_t const nbound = -1 << 31, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q )), n, sbn, of, uf;
		S32 opn = S32(cpu.GetGPR(rn)), opm = S32(cpu.GetGPR(rm)), op1, op2, res;

		// First operation doubles opn
		op1 = opn; op2 = opn; res = op1 + op2;
		// n is the observed negative flag and sbn is what this flag should be
		n = res < S32(0); sbn = op1 <= S32(~op2); of = not sbn and n; uf = sbn and not n;
		res = CondMove<S32>(of, pbound, uf, nbound, res);
		q |= of | uf;

		// Second operation subtracts from opm
		op1 = opm; op2 = res; res = op1 - op2;
		// n is the observed negative flag and sbn is what this flag should be
		n = res < S32(0); sbn = op1 < op2; of = not sbn and n; uf = sbn and not n;
		res = CondMove<S32>(of, pbound, uf, nbound, res);
		q |= of | uf;

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( Q, BOOL(q) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQdsub(CodeType code, uint32_t addr)
{
	return new OpQdsub<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpPkh<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "pkh" << (tb?"tb":"bt") << '\t' << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << DisasmShImm( tb, imm );
}}
template <	typename	ARCH>
void OpPkh<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		U32 op1 = cpu.GetGPR(rn), op2 = ComputeImmShift( cpu, cpu.GetGPR(rm), tb, imm ), res(0);

		if (tb) res = (op1 & U32(0xffff0000)) | (op2 & U32(0x0000ffff));
		else    res = (op2 & U32(0xffff0000)) | (op1 & U32(0x0000ffff));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpPkh(CodeType code, uint32_t addr)
{
	return new OpPkh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSel<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sel\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSel<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8  U8;

		U32 rnval = cpu.GetGPR( rn ), rmval = cpu.GetGPR( rm );
		U32 word_mask(0);

		{
			U8 cpsr_ge( cpu.CPSR().Get( GE ) );
			for (unsigned byte_index = 0; byte_index < 4; byte_index++) {
				U8 byte_mask = ((cpsr_ge >> byte_index) & U8(1)) - U8(1);
				word_mask |= U32(byte_mask) << (8*byte_index);
			}
		}

		U32 res = (rnval & ~word_mask) | (rmval & word_mask);

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSel(CodeType code, uint32_t addr)
{
	return new OpSel<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsat<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ssat\t" << DisasmRegister(rd) << ", " << DisasmI(sat_imm)
		<< ", " << DisasmRegister(rn) << DisasmShImm( sh, imm );
}}
template <	typename	ARCH>
void OpSsat<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		// negative bound
		int32_t const nbound = -1 << sat_imm, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q ));
		S32 src = S32(ComputeImmShift( cpu, cpu.GetGPR(rn), sh, imm ));

		BOOL of = src > S32(pbound), uf = src < S32(nbound);
		U32 res = CondMove<U32>(of, pbound, uf, nbound, src);

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( Q, BOOL(q | of | uf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsat(CodeType code, uint32_t addr)
{
	return new OpSsat<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsat16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ssat16\t" << DisasmRegister(rd) << ", " << DisasmI(sat_imm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpSsat16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << sat_imm, pbound = ~nbound;

		BOOL q = BOOL(cpu.CPSR().Get( Q ));

		U32 opn = cpu.GetGPR(rn), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			S16 src = S16(opn >> 16*idx);
			BOOL of = src > S16(pbound), uf = src < S16(nbound);
			res32 |= U32(CondMove<U16>(of,pbound,uf,nbound,src)) << 16*idx;
			q |= of | uf;
		}

		cpu.SetGPR( rd, res32 );
		cpu.CPSR().Set( Q, BOOL(q) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsat16(CodeType code, uint32_t addr)
{
	return new OpSsat16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsat<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "usat\t" << DisasmRegister(rd) << ", " << DisasmI(sat_imm)
		<< ", " << DisasmRegister(rn) << DisasmShImm(sh,imm);
}}
template <	typename	ARCH>
void OpUsat<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::BOOL BOOL;

		int32_t const bound = ~(-1 << sat_imm);

		BOOL q = BOOL(cpu.CPSR().Get( Q ));
		S32 src = S32(ComputeImmShift( cpu, cpu.GetGPR(rn), sh, imm ));

		BOOL of = src > S32(bound), uf = src < S32(0);
		U32 res = CondMove<U32>(of, bound, uf, 0, src);

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( Q, BOOL(q | of | uf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsat(CodeType code, uint32_t addr)
{
	return new OpUsat<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsat16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "usat16\t" << DisasmRegister(rd) << ", " << DisasmI(sat_imm) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpUsat16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const bound = ~(-1 << sat_imm);

		BOOL q = BOOL(cpu.CPSR().Get( Q ));

		U32 opn = cpu.GetGPR(rn), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			S16 src = S16(opn >> 16*idx);
			BOOL of = src > S16(bound), uf = src < S16(0);
			res32 |= U32(CondMove<U16>(of,bound,uf,0,src)) << 16*idx;
			q |= of | uf;
		}

		cpu.SetGPR( rd, res32 );
		cpu.CPSR().Set( Q, BOOL(q) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsat16(CodeType code, uint32_t addr)
{
	return new OpUsat16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uadd16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
		gev = ((op1 & op2) | (~res & (op1 | op2))) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUadd16(CodeType code, uint32_t addr)
{
	return new OpUadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uadd8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
		gev = ((op1 & op2) | (~res & (op1 | op2))) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUadd8(CodeType code, uint32_t addr)
{
	return new OpUadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "usub16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
		gev = ((op1 & ~op2) | (~res & (op1 | ~op2))) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsub16(CodeType code, uint32_t addr)
{
	return new OpUsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "usub8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
		gev = ((op1 & ~op2) | (~res & (op1 | ~op2))) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsub8(CodeType code, uint32_t addr)
{
	return new OpUsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sadd16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
		gev = (((op1 & op2 & ~res) | (~op1 & ~op2 & res)) ^ ~res) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSadd16(CodeType code, uint32_t addr)
{
	return new OpSadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sadd8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 & U32(~msbs)) + (op2 & U32(~msbs))) ^ ((op1 ^ op2) & U32(msbs)),
		gev = (((op1 & op2 & ~res) | (~op1 & ~op2 & res)) ^ ~res) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, res );
		cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSadd8(CodeType code, uint32_t addr)
{
	return new OpSadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ssub16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
		gev = (((op1 & ~op2 & ~res) | (~op1 & op2 & res)) ^ ~res) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( GE, ((gev>>15)|(gev>>14)|(gev>>29)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsub16(CodeType code, uint32_t addr)
{
	return new OpSsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ssub8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((op1 | U32(msbs)) - (op2 & U32(~msbs))) ^ ((op1 ^ ~op2) & U32(msbs)),
		gev = (((op1 & ~op2 & ~res) | (~op1 & op2 & res)) ^ ~res) & U32(msbs); //< GE vector

		cpu.SetGPR( rd, U32(res) );
		cpu.CPSR().Set( GE, ((gev>>7)|(gev>>14)|(gev>>21)|(gev>>28)) & U32(0xf) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsub8(CodeType code, uint32_t addr)
{
	return new OpSsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uqadd16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;

		uint16_t const bound = -1;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			U16 op1 = U16(opn >> 16*idx), op2 = U16(opm >> 16*idx), res = op1 + op2;
			res32 |= U32(CondMove<U16>(op1 > U16(~op2), bound, res)) << 16*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqadd16(CodeType code, uint32_t addr)
{
	return new OpUqadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uqadd8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U32 U32;

		uint8_t const bound = -1;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 4; ++idx)
		{
			U8 op1 = U8(opn >> 8*idx), op2 = U8(opm >> 8*idx), res = op1 + op2;
			res32 |= U32(CondMove<U8>(op1 > U8(~op2), bound, res)) << 8*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqadd8(CodeType code, uint32_t addr)
{
	return new OpUqadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uqsub16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 2; ++idx)
		{
			U16 op1 = U16(opn >> 16*idx), op2 = U16(opm >> 16*idx), res = op1 - op2;
			res32 |= U32(CondMove<U16>(op1 < op2, 0, res)) << 16*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqsub16(CodeType code, uint32_t addr)
{
	return new OpUqsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uqsub8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U32 U32;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		for (unsigned idx = 0; idx < 4; ++idx)
		{
			U8 op1 = U8(opn >> 8*idx), op2 = U8(opm >> 8*idx), res = op1 - op2;
			res32 |= U32(CondMove<U8>(op1 < op2, 0, res)) << 8*idx;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqsub8(CodeType code, uint32_t addr)
{
	return new OpUqsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsad8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "usad8\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn)
		<< ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUsad8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm), res(0);

		for (unsigned byte = 0; byte < 4; byte++) {
			U32 a = (op1 >> (8*byte)) & U32(0xff), b = (op2 >> (8*byte)) & U32(0xff), d = a - b;
			// Compute abs by arithetic means
			U32 neg( S32(d) >> 8 );
			res += ((d ^ neg) + (neg & U32(1)));
		}

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsad8(CodeType code, uint32_t addr)
{
	return new OpUsad8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uhadd16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask), lsbs(SWP<16>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = (((op1 >> 1) & U32(~msbs)) + ((op2 >> 1) & U32(~msbs))) + (op1&op2&U32(lsbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhadd16(CodeType code, uint32_t addr)
{
	return new OpUhadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uhadd8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask), lsbs(SWP<8>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = (((op1 >> 1) & U32(~msbs)) + ((op2 >> 1) & U32(~msbs))) + (op1&op2&U32(lsbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhadd8(CodeType code, uint32_t addr)
{
	return new OpUhadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShadd16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "shadd16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShadd16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask), lsbs(SWP<16>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) & U32(~msbs)) + ((op2 >> 1) & U32(~msbs))) + (op1&op2&U32(lsbs))) ^ ((op1 ^ op2) & U32(msbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShadd16(CodeType code, uint32_t addr)
{
	return new OpShadd16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShadd8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "shadd8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShadd8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask), lsbs(SWP<8>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) & U32(~msbs)) + ((op2 >> 1) & U32(~msbs))) + (op1&op2&U32(lsbs))) ^ ((op1 ^ op2) & U32(msbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShadd8(CodeType code, uint32_t addr)
{
	return new OpShadd8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uhsub16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask), lsbs(SWP<16>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) | U32(msbs)) - ((op2 >> 1) & U32(~msbs))) - (~op1&op2&U32(lsbs))) ^ U32(msbs);

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhsub16(CodeType code, uint32_t addr)
{
	return new OpUhsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uhsub8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask), lsbs(SWP<8>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) | U32(msbs)) - ((op2 >> 1) & U32(~msbs))) - (~op1&op2&U32(lsbs))) ^ U32(msbs);

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhsub8(CodeType code, uint32_t addr)
{
	return new OpUhsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShsub16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "shsub16\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShsub16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<16>::msbmask), lsbs(SWP<16>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = (((((op1 >> 1) | U32(msbs)) - ((op2 >> 1) & U32(~msbs))) - (~op1&op2&U32(lsbs)))) ^ ((~op1 ^ op2) & U32(msbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShsub16(CodeType code, uint32_t addr)
{
	return new OpShsub16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShsub8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "shsub8\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShsub8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		uint32_t const msbs(SWP<8>::msbmask), lsbs(SWP<8>::lsbmask);

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm),
		res = ((((op1 >> 1) | U32(msbs)) - ((op2 >> 1) & U32(~msbs))) - (~op1&op2&U32(lsbs))) ^ ((~op1 ^ op2) & U32(msbs));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShsub8(CodeType code, uint32_t addr)
{
	return new OpShsub8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQasx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qasx\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << 15, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		{
			S16 op1 = S16(opn), op2 = S16(opm >> 16), res = op1 - op2;
			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 0;
		}
		{
			S16 op1 = S16(opn >> 16), op2 = S16(opm), res = op1 + op2;
			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 <= S16(~op2), of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 16;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQasx(CodeType code, uint32_t addr)
{
	return new OpQasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpQsax<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "qsax\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpQsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		// negative and positive bounds
		int16_t const nbound = -1 << 15, pbound = ~nbound;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		{
			S16 op1 = S16(opn), op2 = S16(opm >> 16), res = op1 + op2;
			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 <= S16(~op2), of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 0;
		}
		{
			S16 op1 = S16(opn >> 16), op2 = S16(opm), res = op1 - op2;
			// n is the observed negative flag and sbn is what this flag should be
			BOOL n = res < S16(0), sbn = op1 < op2, of = not sbn and n, uf = sbn and not n;
			res32 |= U32(CondMove<U16>(of, pbound, uf, nbound, res)) << 16;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpQsax(CodeType code, uint32_t addr)
{
	return new OpQsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqasx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uqasx\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;

		uint16_t const bound = -1;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		{
			U16 op1 = U16(opn), op2 = U16(opm >> 16), res = op1 - op2;
			res32 |= U32(CondMove<U16>(op1 < op2, 0, res)) << 0;
		}
		{
			U16 op1 = U16(opn >> 16), op2 = U16(opm), res = op1 + op2;
			res32 |= U32(CondMove<U16>(op1 > U16(~op2), bound, res)) << 16;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqasx(CodeType code, uint32_t addr)
{
	return new OpUqasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUqsax<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uqsax\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUqsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;

		uint16_t const bound = -1;

		U32 opn = cpu.GetGPR(rn), opm = cpu.GetGPR(rm), res32 = U32(0);
		{
			U16 op1 = U16(opn), op2 = U16(opm >> 16), res = op1 + op2;
			res32 |= U32(CondMove<U16>(op1 > U16(~op2), bound, res)) << 0;
		}
		{
			U16 op1 = U16(opn >> 16), op2 = U16(opm), res = op1 - op2;
			res32 |= U32(CondMove<U16>(op1 < op2, 0, res)) << 16;
		}

		cpu.SetGPR( rd, res32 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUqsax(CodeType code, uint32_t addr)
{
	return new OpUqsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSasx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sasx\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 diff = S32(S16(op1    )) - S32(S16(op2>>16));
		S32 sum  = S32(S16(op1>>16)) + S32(S16(op2    ));

		U32 gev = (U32(sum >= S32(0)) * U32(0xc)) | (U32(diff >= S32(0)) * U32(0x3));
		U32 res = (U32(U16(sum)) << 16) | U32(U16(diff));

		cpu.CPSR().Set( GE, gev );
		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSasx(CodeType code, uint32_t addr)
{
	return new OpSasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSsax<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ssax\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 sum  = S32(S16(op1    )) + S32(S16(op2>>16));
		S32 diff = S32(S16(op1>>16)) - S32(S16(op2    ));

		U32 gev = (U32(diff >= S32(0)) * U32(0xc)) | (U32(sum >= S32(0)) * U32(0x3));
		U32 res = (U32(U16(diff)) << 16) | U32(U16(sum));

		cpu.CPSR().Set( GE, gev );
		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSsax(CodeType code, uint32_t addr)
{
	return new OpSsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUasx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uasx\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 diff = S32(U16(op1    )) - S32(U16(op2>>16));
		S32 sum  = S32(U16(op1>>16)) + S32(U16(op2    ));

		U32 gev = (U32(sum >= S32(0x10000)) * U32(0xc)) | (U32(diff >= S32(0)) * U32(0x3));
		U32 res = (U32(U16(sum)) << 16) | U32(U16(diff));

		cpu.CPSR().Set( GE, gev );
		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUasx(CodeType code, uint32_t addr)
{
	return new OpUasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUsax<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "usax\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 sum  = S32(U16(op1    )) + S32(U16(op2>>16));
		S32 diff = S32(U16(op1>>16)) - S32(U16(op2    ));

		U32 gev = (U32(diff >= S32(0)) * U32(0xc)) | (U32(sum >= S32(0x10000)) * U32(0x3));
		U32 res = (U32(U16(diff)) << 16) | U32(U16(sum));

		cpu.CPSR().Set( GE, gev );
		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUsax(CodeType code, uint32_t addr)
{
	return new OpUsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShasx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "shasx\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 diff = S32(S16(op1    )) - S32(S16(op2>>16));
		S32 sum  = S32(S16(op1>>16)) + S32(S16(op2    ));

		U32 res = (U32(U16(sum >> 1)) << 16) | U32(U16(diff >> 1));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShasx(CodeType code, uint32_t addr)
{
	return new OpShasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpShsax<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "shsax\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpShsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 sum  = S32(S16(op1    )) + S32(S16(op2>>16));
		S32 diff = S32(S16(op1>>16)) - S32(S16(op2    ));

		U32 res = (U32(U16(diff >> 1)) << 16) | U32(U16(sum >> 1));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpShsax(CodeType code, uint32_t addr)
{
	return new OpShsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhasx<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uhasx\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhasx<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 diff = S32(U16(op1    )) - S32(U16(op2>>16));
		S32 sum  = S32(U16(op1>>16)) + S32(U16(op2    ));

		U32 res = (U32(U16(sum >> 1)) << 16) | U32(U16(diff >> 1));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhasx(CodeType code, uint32_t addr)
{
	return new OpUhasx<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUhsax<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "uhsax\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUhsax<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::U16 U16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);

		S32 sum  = S32(U16(op1    )) + S32(U16(op2>>16));
		S32 diff = S32(U16(op1>>16)) - S32(U16(op2    ));

		U32 res = (U32(U16(diff >> 1)) << 16) | U32(U16(sum >> 1));

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUhsax(CodeType code, uint32_t addr)
{
	return new OpUhsax<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBl_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "bl\t0x" << std::hex << ((this->GetAddr() + 4 + imm) & -2) << std::dec;
}}
template <	typename	ARCH>
void OpBl_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( 14, cpu.GetNIA() | U32(1) );
		cpu.Branch( cpu.GetGPR( 15 ) + U32(imm), ARCH::B_CALL );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBl_w(CodeType code, uint32_t addr)
{
	return new OpBl_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBlx_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "blx\t" << std::hex << "0x" << ((this->GetAddr() + 4 + imm) & -4) << std::dec;
}}
template <	typename	ARCH>
void OpBlx_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.SetGPR( 14, cpu.GetNIA() | U32(1) );
		cpu.BranchExchange( (cpu.GetGPR( 15 ) + U32(imm)) & U32(-4), ARCH::B_CALL );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBlx_w(CodeType code, uint32_t addr)
{
	return new OpBlx_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCbnz<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cb" << (nz ? "nz" : "z") << "\t" << DisasmRegister(rn) << ", 0x" << std::hex << ((this->GetAddr() + 4 + imm) & -2) << std::dec;
}}
template <	typename	ARCH>
void OpCbnz<	ARCH>::execute( ARCH & cpu)
{
	{
		if (cpu.itblock())
		cpu.UnpredictableInsnBehaviour();

		typedef typename ARCH::U32 U32;
		typedef typename ARCH::BOOL BOOL;

		if (cpu.Test( (cpu.GetGPR( rn ) == U32(0)) xor BOOL(nz) ))
		cpu.Branch( cpu.GetGPR( 15 ) + U32(imm), ARCH::B_JMP );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCbnz(CodeType code, uint32_t addr)
{
	return new OpCbnz<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpB_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "b.w\t0x" << std::hex << ((this->GetAddr() + 4 + imm) & -2) << std::dec;
}}
template <	typename	ARCH>
void OpB_w<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		cpu.Branch( cpu.GetGPR( 15 ) + U32(imm), ARCH::B_JMP );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpB_w(CodeType code, uint32_t addr)
{
	return new OpB_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpBxj<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "bxj\t" << DisasmRegister(ra); }}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpBxj(CodeType code, uint32_t addr)
{
	return new OpBxj<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpIt<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << 'i' << DisasmITSequence(mask) << '\t' << DisasmCondition( firstcond, DisasmCondition::explicit_always );
}}
template <	typename	ARCH>
void OpIt<	ARCH>::execute( ARCH & cpu)
{
	{
		if (cpu.itblock())
		cpu.UnpredictableInsnBehaviour();

		cpu.ITSetState( firstcond, mask );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpIt(CodeType code, uint32_t addr)
{
	return new OpIt<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpNop<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "nop";
		if (idx != 0) buffer << "\t{" << idx << "}";
}}
template <	typename	ARCH>
void OpNop<	ARCH>::execute( ARCH & cpu)
{
	{
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpNop(CodeType code, uint32_t addr)
{
	return new OpNop<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTbb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "tbb\t" << DisasmMemoryRR(rn,rm,true,true,false);
}}
template <	typename	ARCH>
void OpTbb<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.Branch( cpu.GetGPR( 15 ) + (typename ARCH::U32( cpu.MemRead8( cpu.GetGPR( rn ) + cpu.GetGPR( rm ) ) ) << 1), ARCH::B_JMP );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTbb(CodeType code, uint32_t addr)
{
	return new OpTbb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpTbh<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "tbh\t" << DisasmMemoryRRI(rn,rm,0,1,true,true,false);
}}
template <	typename	ARCH>
void OpTbh<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.Branch( cpu.GetGPR( 15 ) + (typename ARCH::U32( cpu.MemURead16( cpu.GetGPR( rn ) + (cpu.GetGPR( rm ) << 1) ) ) << 1), ARCH::B_JMP );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpTbh(CodeType code, uint32_t addr)
{
	return new OpTbh<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMul_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "mul.w\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm); }}
template <	typename	ARCH>
void OpMul_w<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rd, cpu.GetGPR( rn ) * cpu.GetGPR( rm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMul_w(CodeType code, uint32_t addr)
{
	return new OpMul_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMls<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mls\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpMls<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rd, cpu.GetGPR( ra ) - (cpu.GetGPR( rn ) * cpu.GetGPR( rm )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMls(CodeType code, uint32_t addr)
{
	return new OpMls<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUmull<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "umull\t" << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUmull<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;
		typedef typename ARCH::U32 U32;
		U64 res = U64(cpu.GetGPR( rn )) * U64(cpu.GetGPR( rm ));
		cpu.SetGPR( rdlo, U32(res >> 0) );
		cpu.SetGPR( rdhi, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUmull(CodeType code, uint32_t addr)
{
	return new OpUmull<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUmlal<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "umlal\t" << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUmlal<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;
		typedef typename ARCH::U32 U32;
		U64 res = ((U64(cpu.GetGPR( rdlo ))) <<  0) | ((U64(cpu.GetGPR( rdhi ))) << 32);
		res += U64(cpu.GetGPR( rn )) * U64(cpu.GetGPR( rm ));

		cpu.SetGPR( rdlo, U32(res >> 0) );
		cpu.SetGPR( rdhi, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUmlal(CodeType code, uint32_t addr)
{
	return new OpUmlal<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUmaal<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "umaal\t" << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUmaal<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;
		typedef typename ARCH::U32 U32;
		U64 res = (U64(cpu.GetGPR( rn )) * U64(cpu.GetGPR( rm ))) + U64(cpu.GetGPR( rdlo )) + U64(cpu.GetGPR( rdhi ));
		cpu.SetGPR( rdlo, U32(res >> 0) );
		cpu.SetGPR( rdhi, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUmaal(CodeType code, uint32_t addr)
{
	return new OpUmaal<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmull<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smull\t" << DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmull<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		S64 res = S64( S32( cpu.GetGPR( rn ) ) ) * S64( S32( cpu.GetGPR( rm ) ) );
		cpu.SetGPR( rdlo, U32( res >> 0 ) );
		cpu.SetGPR( rdhi, U32( res >> 32 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmull(CodeType code, uint32_t addr)
{
	return new OpSmull<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSdiv<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sdiv\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSdiv<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		S32 op1( cpu.GetGPR(rn) ), op2( cpu.GetGPR(rm) ),
		res(0); // An untrapped division by zero result in 0.

		if (not cpu.IntegerZeroDivide( op2 == S32(0) )) {
			res = op1 / op2;
		}

		cpu.SetGPR( rd, U32(res) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSdiv(CodeType code, uint32_t addr)
{
	return new OpSdiv<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpUdiv<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "udiv\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpUdiv<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1( cpu.GetGPR(rn) ), op2( cpu.GetGPR(rm) ),
		res(0); // An untrapped division by zero result in 0.

		if (not cpu.IntegerZeroDivide( op2 == U32(0) )) {
			res = op1 / op2;
		}

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpUdiv(CodeType code, uint32_t addr)
{
	return new OpUdiv<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlalxy<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smlal" << (n?"t":"b") << (m?"t":"b") << '\t'
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmlalxy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S16 S16;

		S64 op1 = S64( S16(cpu.GetGPR(rn) >> (n ? 16 : 0)) );
		S64 op2 = S64( S16(cpu.GetGPR(rm) >> (m ? 16 : 0)) );
		S64 res = ((S64( cpu.GetGPR(rdhi) ) << 32) | S64( cpu.GetGPR(rdlo) )) + (op1 * op2);

		cpu.SetGPR( rdlo, U32( res >> 0 ) );
		cpu.SetGPR( rdhi, U32( res >> 32 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlalxy(CodeType code, uint32_t addr)
{
	return new OpSmlalxy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlal<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smlal\t"
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmlal<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		S64 op1 = S64( S32( cpu.GetGPR(rn) ) );
		S64 op2 = S64( S32( cpu.GetGPR(rm) ) );
		S64 res = ((S64( cpu.GetGPR(rdhi) ) << 32) | S64( cpu.GetGPR(rdlo) )) + (op1 * op2);

		cpu.SetGPR( rdlo, U32( res >> 0 ) );
		cpu.SetGPR( rdhi, U32( res >> 32 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlal(CodeType code, uint32_t addr)
{
	return new OpSmlal<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlaxy<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smla" << (n?"t":"b") << (m?"t":"b") << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmlaxy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		S32 mop1( S16(cpu.GetGPR(rn) >> (16*n)) ),
		mop2( S16(cpu.GetGPR(rm) >> (16*m)) );

		// Compute operands and result of signed addition
		U32 op1 = U32(mop1 * mop2),
		op2 = cpu.GetGPR(ra),
		res = op1 + op2;

		U32 overflow = ((op1 & op2 & (~res)) | ((~op1) & (~op2) & res)) >> 31;
		cpu.CPSR().Set( Q, BOOL(overflow | cpu.CPSR().Get( Q )) );

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlaxy(CodeType code, uint32_t addr)
{
	return new OpSmlaxy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmulxy<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smul" << (n?"t":"b") << (m?"t":"b") << '\t'
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmulxy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		S32 op1( S16(cpu.GetGPR(rn) >> (16*n)) ),
		op2( S16(cpu.GetGPR(rm) >> (16*m)) );

		cpu.SetGPR( rd, U32(op1 * op2) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmulxy(CodeType code, uint32_t addr)
{
	return new OpSmulxy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlawy<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smlaw" << (m?"t":"b") << '\t' << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmlawy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		S64 mop1 = S64( S32( cpu.GetGPR(rn) ) ),
		mop2( S16(cpu.GetGPR(rm) >> (16*m)) );

		U32 op1 = U32( (mop1 * mop2) >> 16 ),
		op2 = cpu.GetGPR(ra),
		res = op1 + op2;

		U32 overflow = ((op1 & op2 & (~res)) | ((~op1) & (~op2) & res)) >> 31;
		cpu.CPSR().Set( Q, BOOL(overflow | cpu.CPSR().Get( Q )) );

		cpu.SetGPR( rd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlawy(CodeType code, uint32_t addr)
{
	return new OpSmlawy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmulwy<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smulw" << (m?"t":"b") << "\t"
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmulwy<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;

		S64 op1( S32(cpu.GetGPR(rn)) ),
		op2( S16(cpu.GetGPR(rm) >> (16*m)) ),
		res64 = op1 * op2;

		cpu.SetGPR( rd, U32((res64 >> 16) & S64(0xffffffffULL)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmulwy(CodeType code, uint32_t addr)
{
	return new OpSmulwy<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlad<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smlad" << (swap?"x":"") << "\t"
		<< DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", "
		<< DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmlad<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 res = S64(product1) + S64(product2) + S64(S32(cpu.GetGPR(ra)));

		U32 saturation( res != S64(S32(res)) );

		cpu.CPSR().Set( Q, BOOL(saturation | cpu.CPSR().Get( Q )) );
		cpu.SetGPR( rd, U32(res) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlad(CodeType code, uint32_t addr)
{
	return new OpSmlad<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlald<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smlald" << (swap?"x":"") << "\t"
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm); }}
template <	typename	ARCH>
void OpSmlald<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 addend = (S64( cpu.GetGPR(rdhi) ) << 32) | S64( cpu.GetGPR(rdlo) );
		S64 res = S64(product1) + S64(product2) + addend;

		cpu.SetGPR( rdlo, U32(res      ) );
		cpu.SetGPR( rdhi, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlald(CodeType code, uint32_t addr)
{
	return new OpSmlald<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlsd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smlsd" << (swap?"x":"") << "\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmlsd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 res = S64(product1) - S64(product2) + S64(S32(cpu.GetGPR(ra)));

		U32 saturation( res != S64(S32(res)) );

		cpu.CPSR().Set( Q, BOOL(saturation | cpu.CPSR().Get( Q )) );
		cpu.SetGPR( rd, U32(res) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlsd(CodeType code, uint32_t addr)
{
	return new OpSmlsd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmlsld<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smlsld" << (swap?"x":"") << "\t"
		<< DisasmRegister(rdlo) << ", " << DisasmRegister(rdhi) << ", "
		<< DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmlsld<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 addend = (S64( cpu.GetGPR(rdhi) ) << 32) | S64( cpu.GetGPR(rdlo) );
		S64 res = S64(product1) - S64(product2) + addend;

		cpu.SetGPR( rdlo, U32(res      ) );
		cpu.SetGPR( rdhi, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmlsld(CodeType code, uint32_t addr)
{
	return new OpSmlsld<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmmla<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smmla" << (round?"r":"") << "\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmmla<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		S64 a(S32(cpu.GetGPR(ra))), n(S32(cpu.GetGPR(rn))), m(S32(cpu.GetGPR(rm)));
		S64 res = (a<<32) + n*m + (S64(round)<<31);

		cpu.SetGPR( rd, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmmla(CodeType code, uint32_t addr)
{
	return new OpSmmla<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmmls<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smmls" << (round?"r":"") << "\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm) << ", " << DisasmRegister(ra);
}}
template <	typename	ARCH>
void OpSmmls<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		S64 a(S32(cpu.GetGPR(ra))), n(S32(cpu.GetGPR(rn))), m(S32(cpu.GetGPR(rm)));
		S64 res = (a<<32) - n*m + (S64(round)<<31);

		cpu.SetGPR( rd, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmmls(CodeType code, uint32_t addr)
{
	return new OpSmmls<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmmul<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smmul" << (round?"r":"") << "\t" << DisasmRegister(rd)
		<< ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmmul<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;

		S64 n(S32(cpu.GetGPR(rn))), m(S32(cpu.GetGPR(rm)));
		S64 res = n*m + (S64(round)<<31);

		cpu.SetGPR( rd, U32(res >> 32) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmmul(CodeType code, uint32_t addr)
{
	return new OpSmmul<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmuad<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smuad" << (swap?"x":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmuad<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::BOOL BOOL;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));
		S64 res = S64(product1) + S64(product2);

		U32 saturation( res != S64(S32(res)) );

		cpu.CPSR().Set( Q, BOOL(saturation | cpu.CPSR().Get( Q )) );
		cpu.SetGPR( rd, U32(res) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmuad(CodeType code, uint32_t addr)
{
	return new OpSmuad<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmusd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "smusd" << (swap?"x":"") << "\t" << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmRegister(rm);
}}
template <	typename	ARCH>
void OpSmusd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S16 S16;

		U32 op1 = cpu.GetGPR(rn), op2 = cpu.GetGPR(rm);
		if (swap) op2 = RotateRight(op2,16);

		S32 product1 = S32(S16(op1      )) * S32(S16(op2      ));
		S32 product2 = S32(S16(op1 >> 16)) * S32(S16(op2 >> 16));

		cpu.SetGPR( rd, U32(product1 - product2) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmusd(CodeType code, uint32_t addr)
{
	return new OpSmusd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mrc\t" << uint32_t( cp_num ) << ", " << uint32_t( opc1 ) << ", ";
		if (rt == 15) buffer << "APSR_nzcv";
		else          buffer << DisasmRegister(rt);
		buffer << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm) << ", {" << unsigned( opc2 ) << "}";
}}
template <	typename	ARCH>
void OpMrc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrc(CodeType code, uint32_t addr)
{
	return new OpMrc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrc2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mrc2\t" << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", " << DisasmRegister(rt) << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm) << ", {" << unsigned(opc2) << "}";
}}
template <	typename	ARCH>
void OpMrc2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrc2(CodeType code, uint32_t addr)
{
	return new OpMrc2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMcr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mcr\t" << unsigned( cp_num ) << ", " << unsigned(opc1) << ", " << DisasmRegister(rt) << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm) << ", {" << unsigned(opc2) << "}";
}}
template <	typename	ARCH>
void OpMcr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMcr(CodeType code, uint32_t addr)
{
	return new OpMcr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMcr2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mcr2\t" << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmRegister(rt) << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm)
		<< ", {" << unsigned( opc2 ) << "}";
}}
template <	typename	ARCH>
void OpMcr2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMcr2(CodeType code, uint32_t addr)
{
	return new OpMcr2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cdp\t" << unsigned( cp_num ) << ", " << unsigned(opc1) << ", " << DisasmCPR(cr1) << ", " << DisasmCPR(cr2) << ", " << DisasmCPR(crm) << ", {" << unsigned(opc2) << "}";
}}
template <	typename	ARCH>
void OpCdp<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCdp(CodeType code, uint32_t addr)
{
	return new OpCdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCdp2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "cdp2\t" << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", "
		<< DisasmCPR(cr1) << ", " << DisasmCPR(cr2) << ", " << DisasmCPR(crm) << ", {" << unsigned(opc2) << "}";
}}
template <	typename	ARCH>
void OpCdp2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCdp2(CodeType code, uint32_t addr)
{
	return new OpCdp2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrrc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mrrc\t" << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", " << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmCPR(crm);
}}
template <	typename	ARCH>
void OpMrrc<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrrc(CodeType code, uint32_t addr)
{
	return new OpMrrc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrrc2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mrrc2\t" << unsigned( cp_num ) << ", " << unsigned( opc1 ) << ", " << DisasmRegister(rd) << ", " << DisasmRegister(rn) << ", " << DisasmCPR(crm);
}}
template <	typename	ARCH>
void OpMrrc2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrrc2(CodeType code, uint32_t addr)
{
	return new OpMrrc2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMcrr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mcrr\t" << unsigned( cp_num ) << ", " << unsigned( x ) << ", " << DisasmRegister(r0) << ", " << DisasmRegister(r1) << ", " << DisasmCPR(cr);
}}
template <	typename	ARCH>
void OpMcrr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMcrr(CodeType code, uint32_t addr)
{
	return new OpMcrr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMcrr2<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mcrr2\t" << unsigned( cp_num ) << ", " << unsigned( x ) << ", " << DisasmRegister(r0) << ", " << DisasmRegister(r1) << ", " << DisasmCPR(cr);
}}
template <	typename	ARCH>
void OpMcrr2<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMcrr2(CodeType code, uint32_t addr)
{
	return new OpMcrr2<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStc_unindexed<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "stc" << (d?"l":"") << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< "[" << DisasmRegister(rn) << "]"
		<< ", {" << unsigned( option ) << "}";
}}
template <	typename	ARCH>
void OpStc_unindexed<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStc_unindexed(CodeType code, uint32_t addr)
{
	return new OpStc_unindexed<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpStc2_unindexed<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "stc2" << (d?"l":"") << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< "[" << DisasmRegister(rn) << "]"
		<< ", {" << unsigned( option ) << "}";
}}
template <	typename	ARCH>
void OpStc2_unindexed<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpStc2_unindexed(CodeType code, uint32_t addr)
{
	return new OpStc2_unindexed<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdc_unindexed<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldc" << (d?"l":"") << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< "[" << DisasmRegister(rn) << "]"
		<< ", {" << unsigned( option ) << "}";
}}
template <	typename	ARCH>
void OpLdc_unindexed<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdc_unindexed(CodeType code, uint32_t addr)
{
	return new OpLdc_unindexed<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpLdc2_unindexed<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "ldc2" << (d?"l":"") << '\t' << unsigned( cp_num ) << ", " << DisasmCPR(crd) << ", "
		<< "[" << DisasmRegister(rn) << "]"
		<< ", {" << unsigned( option ) << "}";
}}
template <	typename	ARCH>
void OpLdc2_unindexed<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.UnpredictableInsnBehaviour();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpLdc2_unindexed(CodeType code, uint32_t addr)
{
	return new OpLdc2_unindexed<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCp15_mcr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mcr\t15, " << unsigned(opc1) << ", " << DisasmRegister(rt) << ", "
		<< DisasmCPR(crn) << ", " << DisasmCPR(crm) << ", {" << unsigned(opc2) << "}";
		cp15reg->Describe( crn, opc1, crm, opc2, buffer << " ; Write " );
}}
template <	typename	ARCH>
void OpCp15_mcr<	ARCH>::execute( ARCH & cpu)
{
	{
		cp15reg->CheckPermissions(crn, opc1, crm, opc2, cpu, true);

		cp15reg->Write( crn, opc1, crm, opc2, cpu, cpu.GetGPR(rt) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCp15_mcr(CodeType code, uint32_t addr)
{
	return new OpCp15_mcr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpCp15_mrc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mrc\t15, " << unsigned(opc1) << ", ";
		if (rt == 15) buffer << "APSR_nzcv";
		else          buffer << DisasmRegister(rt);
		buffer << ", " << DisasmCPR(crn) << ", " << DisasmCPR(crm) << ", {" << unsigned(opc2) << "}";
		cp15reg->Describe( crn, opc1, crm, opc2, buffer << " ; Read " );
}}
template <	typename	ARCH>
void OpCp15_mrc<	ARCH>::execute( ARCH & cpu)
{
	{
		cp15reg->CheckPermissions(crn, opc1, crm, opc2, cpu, true);

		typename ARCH::U32 value = cp15reg->Read( crn, opc1, crm, opc2, cpu );
		if (rt != 15)
		cpu.SetGPR( rt, value );
		else
		cpu.CPSR().Set( NZCV, value >> 28 );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpCp15_mrc(CodeType code, uint32_t addr)
{
	return new OpCp15_mrc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpNopw<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		if (imm) buffer << "nop.w\t{" << imm << "}";
		else     buffer << "nop.w";
}}
template <	typename	ARCH>
void OpNopw<	ARCH>::execute( ARCH & cpu)
{
	{
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpNopw(CodeType code, uint32_t addr)
{
	return new OpNopw<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpYield<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "yield";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpYield(CodeType code, uint32_t addr)
{
	return new OpYield<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpYield_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "yield.w";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpYield_w(CodeType code, uint32_t addr)
{
	return new OpYield_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpDbg_i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "dbg\t" << DisasmI(imm); }}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpDbg_i(CodeType code, uint32_t addr)
{
	return new OpDbg_i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpDmb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "dmb\t" << DisasmBarrierOption( opt );
}}
template <	typename	ARCH>
void OpDmb<	ARCH>::execute( ARCH & cpu)
{
	{
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpDmb(CodeType code, uint32_t addr)
{
	return new OpDmb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpDsb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "dsb\t" << DisasmBarrierOption( opt );
}}
template <	typename	ARCH>
void OpDsb<	ARCH>::execute( ARCH & cpu)
{
	{
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpDsb(CodeType code, uint32_t addr)
{
	return new OpDsb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpIsb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "isb\t" << DisasmBarrierOption( opt );
}}
template <	typename	ARCH>
void OpIsb<	ARCH>::execute( ARCH & cpu)
{
	{
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpIsb(CodeType code, uint32_t addr)
{
	return new OpIsb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpWfe<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "wfe";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpWfe(CodeType code, uint32_t addr)
{
	return new OpWfe<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpWfi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "wfi";
}}
template <	typename	ARCH>
void OpWfi<	ARCH>::execute( ARCH & cpu)
{
	{
		// if (HaveVirtExt() and not IsSecure() and not CurrentModeIsHyp() and HCR.TWI) {
			//   HSRString = Zeros(25);
			//   HSRString<0> = '0';
			//   WriteHSR('000001', HSRString);
			//   TakeHypTrapException();
			// } else

		cpu.WaitForInterrupt();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpWfi(CodeType code, uint32_t addr)
{
	return new OpWfi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSev<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sev";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSev(CodeType code, uint32_t addr)
{
	return new OpSev<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpWfe_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "wfe.w";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpWfe_w(CodeType code, uint32_t addr)
{
	return new OpWfe_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpWfi_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "wfi.w";
}}
template <	typename	ARCH>
void OpWfi_w<	ARCH>::execute( ARCH & cpu)
{
	{
		// if (HaveVirtExt() and not IsSecure() and not CurrentModeIsHyp() and HCR.TWI) {
			//   HSRString = Zeros(25);
			//   HSRString<0> = '0';
			//   WriteHSR('000001', HSRString);
			//   TakeHypTrapException();
			// } else

		cpu.WaitForInterrupt();
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpWfi_w(CodeType code, uint32_t addr)
{
	return new OpWfi_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSev_w<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "sev.w";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSev_w(CodeType code, uint32_t addr)
{
	return new OpSev_w<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRfedb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "rfedb\t" << DisasmRegister(r0) << (x ? "!" : "");
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRfedb(CodeType code, uint32_t addr)
{
	return new OpRfedb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpRfeia<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "rfeia\t" << DisasmRegister(r0) << (x ? "!" : "");
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpRfeia(CodeType code, uint32_t addr)
{
	return new OpRfeia<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSrsdb<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "srsdb\t" << DisasmRegister(r0) << (x ? "!" : "") << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSrsdb(CodeType code, uint32_t addr)
{
	return new OpSrsdb<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSrsia<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "srsia\t" << DisasmRegister(r0) << (x ? "!" : "") << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSrsia(CodeType code, uint32_t addr)
{
	return new OpSrsia<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSmc_i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "smc\t" << DisasmI(imm); }}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSmc_i(CodeType code, uint32_t addr)
{
	return new OpSmc_i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpHvc_i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{ buffer << "hvc\t" << DisasmI(imm); }}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpHvc_i(CodeType code, uint32_t addr)
{
	return new OpHvc_i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpSubspc<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "subs\tpc, lr, " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpSubspc<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 op1 = cpu.GetGPR( 14 ), op2 = U32(imm), res = op1 - op2;

		CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );

		cpu.SetGPR( 15, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpSubspc(CodeType code, uint32_t addr)
{
	return new OpSubspc<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMrs<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "mrs\t" << DisasmRegister(rd) << ", " << DisasmSpecReg(sr);
}}
template <	typename	ARCH>
void OpMrs<	ARCH>::execute( ARCH & cpu)
{
	{
		switch (sr) {
			default: cpu.UnpredictableInsnBehaviour(); break;
			case 0b0001111: cpu.SetGPR(rd, cpu.GetCPSR()); break;
			case 0b1001111: cpu.SetGPR(rd, cpu.CurrentMode().GetSPSR()); break;

			case 0b0100000: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 8)); break;
			case 0b0100001: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 9)); break;
			case 0b0100010: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 10)); break;
			case 0b0100011: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 11)); break;
			case 0b0100100: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 12)); break;
			case 0b0100101: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 13)); break;
			case 0b0100110: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::USER_MODE, 14)); break;

			case 0b0101000: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 8)); break;
			case 0b0101001: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 9)); break;
			case 0b0101010: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 10)); break;
			case 0b0101011: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 11)); break;
			case 0b0101100: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 12)); break;
			case 0b0101101: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 13)); break;
			case 0b0101110: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::FIQ_MODE, 14)); break;
			case 0b0110000: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::IRQ_MODE, 14)); break;
			case 0b0110001: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::IRQ_MODE, 13)); break;

			case 0b0110010: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::SUPERVISOR_MODE, 14)); break;
			case 0b0110011: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::SUPERVISOR_MODE, 13)); break;

			case 0b0110100: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::ABORT_MODE, 14)); break;
			case 0b0110101: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::ABORT_MODE, 13)); break;

			case 0b0110110: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::UNDEFINED_MODE, 14)); break;
			case 0b0110111: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::UNDEFINED_MODE, 13)); break;

			case 0b0111100: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::MONITOR_MODE, 14)); break;
			case 0b0111101: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::MONITOR_MODE, 13)); break;

			case 0b0111110: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::HYPERVISOR_MODE, 14)); break;
			case 0b0111111: cpu.SetGPR(rd, cpu.GetBankedRegister(PSR::HYPERVISOR_MODE, 13)); break;

			case 0b1101110: cpu.SetGPR(rd, cpu.GetMode(PSR::FIQ_MODE).GetSPSR()); break;
			case 0b1110000: cpu.SetGPR(rd, cpu.GetMode(PSR::IRQ_MODE).GetSPSR()); break;
			case 0b1110010: cpu.SetGPR(rd, cpu.GetMode(PSR::SUPERVISOR_MODE).GetSPSR()); break;
			case 0b1110100: cpu.SetGPR(rd, cpu.GetMode(PSR::ABORT_MODE).GetSPSR()); break;
			case 0b1110110: cpu.SetGPR(rd, cpu.GetMode(PSR::UNDEFINED_MODE).GetSPSR()); break;
			case 0b1111100: cpu.SetGPR(rd, cpu.GetMode(PSR::MONITOR_MODE).GetSPSR()); break;
			case 0b1111110: cpu.SetGPR(rd, cpu.GetMode(PSR::HYPERVISOR_MODE).GetSPSR()); break;
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMrs(CodeType code, uint32_t addr)
{
	return new OpMrs<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMsr_reg<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "msr\t" << DisasmSpecReg(sr) << ", " << DisasmRegister(rn);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMsr_reg(CodeType code, uint32_t addr)
{
	return new OpMsr_reg<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpMsr_reg_psr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "msr\t" << DisasmPSRMask(write_spsr,mask) << ", " << DisasmRegister(rn);
}}
template <	typename	ARCH>
void OpMsr_reg_psr<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		if (write_spsr) {
			SPSRWriteByInstr( cpu, cpu.GetGPR(rn), psr_mask );
			} else {
			CPSRWriteByInstr( cpu, cpu.GetGPR(rn), psr_mask );
			// Cannot return to Hyp mode and ThumbEE state
			if (unlikely(cpu.Test((cpu.CPSR().Get(M) == U32(PSR::HYPERVISOR_MODE)) and (cpu.CPSR().Get(J) == U32(1)) and (cpu.CPSR().Get(T) == U32(1)))))
			cpu.UnpredictableInsnBehaviour();
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpMsr_reg_psr(CodeType code, uint32_t addr)
{
	return new OpMsr_reg_psr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabs.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVabs_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vm );

		ARCH::FP::Abs( res );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_f32(CodeType code, uint32_t addr)
{
	return new OpVabs_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabs.f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVabs_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vm );

		ARCH::FP::Abs( res );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_f64(CodeType code, uint32_t addr)
{
	return new OpVabs_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vadd.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVadd_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPAdd( res, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_f32(CodeType code, uint32_t addr)
{
	return new OpVadd_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vadd.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVadd_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPAdd( res, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_f64(CodeType code, uint32_t addr)
{
	return new OpVadd_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcmp_f32d<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcmp" << (e?"e":"") << ".f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcmp_f32d<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op1 = cpu.GetVSR( vd ), op2 = cpu.GetVSR( vm );

		FPCompare( op1, op2, e, cpu, cpu.FPSCR );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcmp_f32d(CodeType code, uint32_t addr)
{
	return new OpVcmp_f32d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcmp_f64d<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcmp" << (e?"e":"") << ".f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcmp_f64d<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op1 = cpu.GetVDR( vd ), op2 = cpu.GetVDR( vm );

		FPCompare( op1, op2, e, cpu, cpu.FPSCR );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcmp_f64d(CodeType code, uint32_t addr)
{
	return new OpVcmp_f64d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcmp_f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcmp" << (e?"e":"") << ".f32\ts" << vd << ", #0.0";
}}
template <	typename	ARCH>
void OpVcmp_f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::F32 F32;
		F32 op1 = cpu.GetVSR( vd );
		F32 zero = F32(); /* default constructor is expected to zero-out */

		FPCompare( op1, zero, e, cpu, cpu.FPSCR );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcmp_f32i(CodeType code, uint32_t addr)
{
	return new OpVcmp_f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcmp_f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcmp" << (e?"e":"") << ".f64\td" << vd << ", #0.0";
}}
template <	typename	ARCH>
void OpVcmp_f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::F64 F64;
		F64 op1 = cpu.GetVDR( vd );
		F64 zero = F64(); /* default constructor is expected to zero-out */

		FPCompare( op1, zero, e, cpu, cpu.FPSCR );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcmp_f64i(CodeType code, uint32_t addr)
{
	return new OpVcmp_f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtb_f16_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt" << (t?"t":"b") << ".f16.f32\ts" << vd << ", s" << vm;
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtb_f16_f32(CodeType code, uint32_t addr)
{
	return new OpVcvtb_f16_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtb_f32_f16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt" << (t?"t":"b") << ".f32.f16\ts" << vd << ", s" << vm;
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtb_f32_f16(CodeType code, uint32_t addr)
{
	return new OpVcvtb_f32_f16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.u32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f32u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = cpu.GetVSU( vm );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f64.u32\td" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f64u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = cpu.GetVSU( vm );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64u32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.s32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f32s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( cpu.GetVSU( vm ) );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32s32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f64.s32\td" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f64s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( cpu.GetVSU( vm ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64s32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.u32.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_u32f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::U32 res;

		FPToInt( res, op, 0, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtr_u32f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvtr.u32.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvtr_u32f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::U32 res;

		FPToInt( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtr_u32f32(CodeType code, uint32_t addr)
{
	return new OpVcvtr_u32f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.u32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvt_u32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::U32 res;

		FPToInt( res, op, 0, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f64(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtr_u32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvtr.u32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvtr_u32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::U32 res;

		FPToInt( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtr_u32f64(CodeType code, uint32_t addr)
{
	return new OpVcvtr_u32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.s32.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_s32f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::S32 res;

		FPToInt( res, op, 0, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtr_s32f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvtr.s32.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvtr_s32f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::S32 res;

		FPToInt( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtr_s32f32(CodeType code, uint32_t addr)
{
	return new OpVcvtr_s32f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.s32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvt_s32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::S32 res;

		FPToInt( res, op, 0, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f64(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvtr_s32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvtr.s32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvtr_s32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::S32 res;

		FPToInt( res, op, 0, cpu, cpu.FPSCR );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvtr_s32f64(CodeType code, uint32_t addr)
{
	return new OpVcvtr_s32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.s16\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f32s16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( typename ARCH::S16( cpu.GetVSU( vd ) ) );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32s16i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.s32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f32s32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( cpu.GetVSU( vd ) );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32s32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f64.s16\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f64s16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( typename ARCH::S16( cpu.GetVSU( 2*vd ) ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64s16i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f64.s32\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f64s32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::S32 op = typename ARCH::S32( cpu.GetVSU( 2*vd ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64s32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.u16\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f32u16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = typename ARCH::U32( typename ARCH::U16( cpu.GetVSU( vd ) ) );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u16i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.u32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f32u32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = cpu.GetVSU( vd );
		typename ARCH::F32 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f64.u16\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f64u16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = typename ARCH::U32( typename ARCH::U16( cpu.GetVSU( 2*vd ) ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64u16i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f64.u32\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_f64u32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::U32 op = typename ARCH::U32( cpu.GetVSU( 2*vd ) );
		typename ARCH::F64 res;

		ARCH::FP::ItoF( res, op, imm, cpu, cpu.RoundToNearestFPSCR() );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64u32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s16f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.s16.f32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_s16f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vd );
		typename ARCH::S16 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( typename ARCH::S32( res ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s16f32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_s16f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s16f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.s16.f64\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_s16f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vd );
		typename ARCH::S16 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVDU( vd, typename ARCH::U64( typename ARCH::S64( res ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s16f64i(CodeType code, uint32_t addr)
{
	return new OpVcvt_s16f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.s32.f32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_s32f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vd );
		typename ARCH::S32 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.s32.f64\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_s32f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vd );
		typename ARCH::S32 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVDU( vd, typename ARCH::U64( typename ARCH::S64( res ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f64i(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u16f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.u16.f32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_u16f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vd );
		typename ARCH::U16 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, typename ARCH::U32( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u16f32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_u16f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u16f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.u16.f64\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_u16f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vd );
		typename ARCH::U16 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVDU( vd, typename ARCH::U64( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u16f64i(CodeType code, uint32_t addr)
{
	return new OpVcvt_u16f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.u32.f32\ts" << vd << ", s" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_u32f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vd );
		typename ARCH::U32 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVSU( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f32i(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.u32.f64\td" << vd << ", d" << vd << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVcvt_u32f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vd );
		typename ARCH::U32 res;

		FPToInt( res, op, imm, cpu, cpu.RoundTowardsZeroFPSCR() );

		cpu.SetVDU( vd, typename ARCH::U64( res ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f64i(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f64f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f64.f32\td" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f64f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 op = cpu.GetVSR( vm );
		typename ARCH::F64 res;

		FPToFP( res, op, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f64f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f64f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.f64\ts" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVcvt_f32f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 op = cpu.GetVDR( vm );
		typename ARCH::F32 res;

		FPToFP( res, op, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32f64(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdiv_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vdiv.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVdiv_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPDiv( res, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdiv_f32(CodeType code, uint32_t addr)
{
	return new OpVdiv_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdiv_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vdiv.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVdiv_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPDiv( res, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdiv_f64(CodeType code, uint32_t addr)
{
	return new OpVdiv_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfma_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfma.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVfma_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), op1 = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfma_f32(CodeType code, uint32_t addr)
{
	return new OpVfma_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfma_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfma.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVfma_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), op1 = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfma_f64(CodeType code, uint32_t addr)
{
	return new OpVfma_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfms_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfms.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVfms_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), op1 = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		ARCH::FP::Neg( op1 );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfms_f32(CodeType code, uint32_t addr)
{
	return new OpVfms_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfms_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfms.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVfms_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), op1 = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		ARCH::FP::Neg( op1 );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfms_f64(CodeType code, uint32_t addr)
{
	return new OpVfms_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfnma_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfnma.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVfnma_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), op1 = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		ARCH::FP::Neg( acc );
		ARCH::FP::Neg( op1 );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfnma_f32(CodeType code, uint32_t addr)
{
	return new OpVfnma_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfnma_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfnma.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVfnma_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), op1 = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		ARCH::FP::Neg( acc );
		ARCH::FP::Neg( op1 );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfnma_f64(CodeType code, uint32_t addr)
{
	return new OpVfnma_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfnms_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfnms.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVfnms_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), op1 = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		ARCH::FP::Neg( acc );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfnms_f32(CodeType code, uint32_t addr)
{
	return new OpVfnms_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfnms_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfnms.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVfnms_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), op1 = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		ARCH::FP::Neg( acc );
		FPMulAdd( acc, op1, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfnms_f64(CodeType code, uint32_t addr)
{
	return new OpVfnms_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldmdb_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vldmdb\t" << DisasmRegister(rn) << "!, ";
		int32_t send = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << send << "}";
}}
template <	typename	ARCH>
void OpVldmdb_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn ) - U32( regs << 2 );

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.SetVSU( vd + reg, cpu.MemRead32( base_addr + U32(4*reg) ) );
		}

		cpu.SetGPR( rn, base_addr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldmdb_f32(CodeType code, uint32_t addr)
{
	return new OpVldmdb_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldmdb_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		if (not fldm) buffer << "vldmdb";
		else          buffer << "fldmdbx";
		buffer << "\t" << DisasmRegister(rn) << "!, ";
		int32_t dend = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << dend << "}";
}}
template <	typename	ARCH>
void OpVldmdb_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn ) - U32( regs << 3 );

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.SetVSU( 2*(vd+reg) + w0, cpu.MemRead32( base_addr + U32(8*reg + 0) ) );
			cpu.SetVSU( 2*(vd+reg) + w1, cpu.MemRead32( base_addr + U32(8*reg + 4) ) );
		}

		cpu.SetGPR( rn, base_addr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldmdb_f64(CodeType code, uint32_t addr)
{
	return new OpVldmdb_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldmia_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		if ((rn == 13) and w)  buffer << "vpop\t"; /* Syntaxic Sugar */
		else                   buffer << "vldmia\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		int32_t send = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{s" << vd << "}";
		else                buffer << "{s" << vd << "-s" << send << "}";
}}
template <	typename	ARCH>
void OpVldmia_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn );

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.SetVSU( vd + reg, cpu.MemRead32( base_addr + U32(4*reg) ) );
		}

		if (w) cpu.SetGPR( rn, base_addr + U32( regs << 2 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldmia_f32(CodeType code, uint32_t addr)
{
	return new OpVldmia_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldmia_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		if (fldm)                   buffer << "fldmiax\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		else if ((rn == 13) and w)  buffer << "vpop\t"; /* Syntaxic Sugar */
		else                        buffer << "vldmia\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		int32_t dend = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{d" << vd << "}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << dend << "}";
}}
template <	typename	ARCH>
void OpVldmia_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn );

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.SetVSU( 2*(vd+reg) + w0, cpu.MemRead32( base_addr + U32(8*reg + 0) ) );
			cpu.SetVSU( 2*(vd+reg) + w1, cpu.MemRead32( base_addr + U32(8*reg + 4) ) );
		}

		if (w) cpu.SetGPR( rn, base_addr + U32( regs << 3 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldmia_f64(CodeType code, uint32_t addr)
{
	return new OpVldmia_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldr_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vldr\ts" << vd << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpVldr_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32(imm);

		cpu.SetVSU( vd, cpu.MemRead32( addr ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldr_32(CodeType code, uint32_t addr)
{
	return new OpVldr_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldr_literal_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vldr\ts" << vd << ", [pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpVldr_literal_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = (cpu.GetGPR( 15 ) & U32(-4)) + U32(imm);

		cpu.SetVSU( vd, cpu.MemRead32( addr ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldr_literal_32(CodeType code, uint32_t addr)
{
	return new OpVldr_literal_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldr_64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vldr\td" << vd << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpVldr_64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32(imm);

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		cpu.SetVSU( 2*vd + w0, cpu.MemRead32( addr + U32(0) ) );
		cpu.SetVSU( 2*vd + w1, cpu.MemRead32( addr + U32(4) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldr_64(CodeType code, uint32_t addr)
{
	return new OpVldr_64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldr_literal_64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vldr\td" << vd << ", [pc, " << DisasmI(imm) << "]";
}}
template <	typename	ARCH>
void OpVldr_literal_64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = (cpu.GetGPR( 15 ) & U32(-4)) + U32(imm);

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		cpu.SetVSU( 2*vd + w0, cpu.MemRead32( addr + U32(0) ) );
		cpu.SetVSU( 2*vd + w1, cpu.MemRead32( addr + U32(4) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldr_literal_64(CodeType code, uint32_t addr)
{
	return new OpVldr_literal_64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmla.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVmla_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), product = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_f32(CodeType code, uint32_t addr)
{
	return new OpVmla_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmla.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmla_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), product = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_f64(CodeType code, uint32_t addr)
{
	return new OpVmla_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmls.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVmls_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), product = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( product );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f32(CodeType code, uint32_t addr)
{
	return new OpVmls_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmls.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmls_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), product = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( product );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f64(CodeType code, uint32_t addr)
{
	return new OpVmls_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmla_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vnmla.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVnmla_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), product = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( product );
		ARCH::FP::Neg( acc );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmla_f32(CodeType code, uint32_t addr)
{
	return new OpVnmla_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmla_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vnmla.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVnmla_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), product = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( product );
		ARCH::FP::Neg( acc );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmla_f64(CodeType code, uint32_t addr)
{
	return new OpVnmla_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmls_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vnmls.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVnmls_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 acc = cpu.GetVSR( vd ), product = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( acc );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmls_f32(CodeType code, uint32_t addr)
{
	return new OpVnmls_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmls_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vnmls.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVnmls_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 acc = cpu.GetVDR( vd ), product = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( product, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( acc );
		FPAdd( acc, product, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, acc );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmls_f64(CodeType code, uint32_t addr)
{
	return new OpVnmls_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.f32\ts" << vd << ", "
		<< DisasmI((n << 7) | (exp << 4) | man) << "; " << float(VFPExpandImm( n, exp, man ));
}}
template <	typename	ARCH>
void OpVmov_f32i<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSR( vd, fpimm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f32i(CodeType code, uint32_t addr)
{
	return new OpVmov_f32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.f64\td" << vd << ", "
		<< DisasmI((n << 7) | (exp << 4) | man) << "; " << double(VFPExpandImm( n, exp, man ));
}}
template <	typename	ARCH>
void OpVmov_f64i<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDR( vd, fpimm );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f64i(CodeType code, uint32_t addr)
{
	return new OpVmov_f64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f32s<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVmov_f32s<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSR( vd, cpu.GetVSR( vm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f32s(CodeType code, uint32_t addr)
{
	return new OpVmov_f32s<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f64d<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmov_f64d<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDR( vd, cpu.GetVDR( vm ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f64d(CodeType code, uint32_t addr)
{
	return new OpVmov_f64d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_rs<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov\t" << DisasmRegister(rt) << ", s" << vn;
}}
template <	typename	ARCH>
void OpVmov_rs<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, cpu.GetVSU( vn ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_rs(CodeType code, uint32_t addr)
{
	return new OpVmov_rs<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_sr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov\ts" << vn << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmov_sr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSU( vn, cpu.GetGPR( rt ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_sr(CodeType code, uint32_t addr)
{
	return new OpVmov_sr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_ssrr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov\ts" << vm << ", s" << (vm+1) << ", " << DisasmRegister(rt) << ", " << DisasmRegister(rt2);
}}
template <	typename	ARCH>
void OpVmov_ssrr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSU( vm+0, cpu.GetGPR( rt  ) );
		cpu.SetVSU( vm+1, cpu.GetGPR( rt2 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_ssrr(CodeType code, uint32_t addr)
{
	return new OpVmov_ssrr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_rrss<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov\t" << DisasmRegister(rt) << ", " << DisasmRegister(rt2) << ", s" << vm << ", s" << (vm+1);
}}
template <	typename	ARCH>
void OpVmov_rrss<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt,  cpu.GetVSU( vm+0 ) );
		cpu.SetGPR( rt2, cpu.GetVSU( vm+1 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_rrss(CodeType code, uint32_t addr)
{
	return new OpVmov_rrss<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_rrd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov\t" << DisasmRegister(rt) << ", " << DisasmRegister(rt2) << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmov_rrd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt,  cpu.GetVSU( 2*vm+0 ) );
		cpu.SetGPR( rt2, cpu.GetVSU( 2*vm+1 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_rrd(CodeType code, uint32_t addr)
{
	return new OpVmov_rrd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_drr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov\td" << vm << ", " << DisasmRegister(rt) << ", " << DisasmRegister(rt2);
}}
template <	typename	ARCH>
void OpVmov_drr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVSU( 2*vm+0, cpu.GetGPR( rt  ) );
		cpu.SetVSU( 2*vm+1, cpu.GetGPR( rt2 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_drr(CodeType code, uint32_t addr)
{
	return new OpVmov_drr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmrs<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmrs\t";
		if ((rt == 15) and (spr == 1)) buffer << "APSR_nzcv";
		else                           buffer << DisasmRegister(rt);
		buffer << ", ";
		switch (spr) {
			default: buffer << "<undefined>"; return;
			case 0b0000:  buffer << "fpsid"; break;
			case 0b0001:  buffer << "fpscr"; break;
			case 0b0110:  buffer << "mvfr1"; break;
			case 0b0111:  buffer << "mvfr0"; break;
			case 0b1000:  buffer << "fpexc"; break;
		}
}}
template <	typename	ARCH>
void OpVmrs<	ARCH>::execute( ARCH & cpu)
{
	{
		if (spr == 1) {
			// cpu.CheckVFPEnabled(TRUE); cpu.SerializeVFP(); cpu.VFPExcBarrier();
			if (rt != 15)
			cpu.SetGPR( rt, cpu.FPSCR );
			else
			cpu.CPSR().Set( NZCV, NZCV.Get( cpu.FPSCR ) );
		}

		else {
			// cpu.CheckVFPEnabled(FALSE);
			typedef typename ARCH::U32 U32;

			if (unlikely( cpu.Test(cpu.CPSR().Get(M) == U32(PSR::USER_MODE)) ))
			cpu.UndefinedInstruction( this );

			switch (spr) {
			default:
				cpu.UndefinedInstruction( this );
				break;
				// case 0b0000: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.FPSID() ); break;
				// case 0b0110: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.MVFR1() ); break;
				// case 0b0111: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.MVFR0() ); break;
				case 0b1000: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.FPEXC ); break;
			}
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmrs(CodeType code, uint32_t addr)
{
	return new OpVmrs<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmsr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmsr\t";
		switch (spr) {
			default: buffer << "<undefined>"; return;
			case 0b0000:  buffer << "fpsid"; break;
			case 0b0001:  buffer << "fpscr"; break;
			case 0b0110:  buffer << "mvfr1"; break;
			case 0b0111:  buffer << "mvfr0"; break;
			case 0b1000:  buffer << "fpexc"; break;
		}
		buffer << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmsr<	ARCH>::execute( ARCH & cpu)
{
	{
		if (spr == 1) {
			// cpu.CheckVFPEnabled(TRUE); cpu.SerializeVFP(); cpu.VFPExcBarrier();
			cpu.FPSCR = cpu.GetGPR( rt );
		}

		else {
			// cpu.CheckVFPEnabled(FALSE);
			typedef typename ARCH::U32 U32;

			if (unlikely( cpu.Test(cpu.CPSR().Get(M) == U32(PSR::USER_MODE)) ))
			cpu.UndefinedInstruction( this );

			switch (spr) {
			default:
				cpu.UndefinedInstruction( this );
				break;

				// case 0b0000: /* cpu.SerializeVFP(); */ /* FPSID is read-only */ break;
				// case 0b0110: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.MVFR1() ); break;
				// case 0b0111: /* cpu.SerializeVFP(); */ cpu.SetGPR( rt, cpu.MVFR0() ); break;
				case 0b1000: /* cpu.SerializeVFP(); */ cpu.FPEXC = cpu.GetGPR( rt ); break;
			}
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmsr(CodeType code, uint32_t addr)
{
	return new OpVmsr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVmul_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( res, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_f32(CodeType code, uint32_t addr)
{
	return new OpVmul_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVmul_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( res, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_f64(CodeType code, uint32_t addr)
{
	return new OpVmul_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmul_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vnmul.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVnmul_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPMul( res, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( res );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmul_f32(CodeType code, uint32_t addr)
{
	return new OpVnmul_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVnmul_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vnmul.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVnmul_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPMul( res, op2, cpu, cpu.FPSCR );
		ARCH::FP::Neg( res );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVnmul_f64(CodeType code, uint32_t addr)
{
	return new OpVnmul_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vneg.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVneg_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vm );

		ARCH::FP::Neg( res );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f32(CodeType code, uint32_t addr)
{
	return new OpVneg_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vneg.f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVneg_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vm );

		ARCH::FP::Neg( res );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f64(CodeType code, uint32_t addr)
{
	return new OpVneg_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsqrt_f32s<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsqrt.f32\ts" << vd << ", s" << vm;
}}
template <	typename	ARCH>
void OpVsqrt_f32s<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vm );

		FPSqrt( res, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsqrt_f32s(CodeType code, uint32_t addr)
{
	return new OpVsqrt_f32s<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsqrt_f64d<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsqrt.f64\td" << vd << ", d" << vm;
}}
template <	typename	ARCH>
void OpVsqrt_f64d<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vm );

		FPSqrt( res, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsqrt_f64d(CodeType code, uint32_t addr)
{
	return new OpVsqrt_f64d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstmdb_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		if (rn == 13) buffer << "vpush\t";
		else          buffer << "vstmdb\t" << DisasmRegister(rn) << "!, ";
		int32_t send = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{s" << vd << "}";
		else                buffer << "{s" << vd << "-s" << send << "}";
}}
template <	typename	ARCH>
void OpVstmdb_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn ) - U32( regs << 2 );

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.MemWrite32( base_addr + U32(4*reg), cpu.GetVSU( vd + reg ) );
		}

		cpu.SetGPR( rn, base_addr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstmdb_f32(CodeType code, uint32_t addr)
{
	return new OpVstmdb_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstmdb_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		if (fstm)          buffer << "fstmdbx\t" << DisasmRegister(rn) << "!, ";
		else if (rn == 13) buffer << "vpush\t";
		else               buffer << "vstmdb\t" << DisasmRegister(rn) << "!, ";
		int32_t dend = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << dend << "}";
}}
template <	typename	ARCH>
void OpVstmdb_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn ) - U32( regs << 3 );

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.MemWrite32( base_addr + U32(8*reg + 0), cpu.GetVSU( 2*(vd+reg) + w0 ) );
			cpu.MemWrite32( base_addr + U32(8*reg + 4), cpu.GetVSU( 2*(vd+reg) + w1 ) );
		}

		cpu.SetGPR( rn, base_addr );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstmdb_f64(CodeType code, uint32_t addr)
{
	return new OpVstmdb_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstmia_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vstmia\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		int32_t send = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{s" << vd << "}";
		else                buffer << "{s" << vd << "-s" << send << "}";
}}
template <	typename	ARCH>
void OpVstmia_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn );

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.MemWrite32( base_addr + U32(4*reg), cpu.GetVSU( vd + reg ) );
		}

		if (w) cpu.SetGPR( rn, base_addr + U32( regs << 2 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstmia_f32(CodeType code, uint32_t addr)
{
	return new OpVstmia_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstmia_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		if (fstm) buffer << "fstmiax";
		else      buffer << "vstmia";
		buffer << "\t" << DisasmRegister(rn) << (w?"!":"") << ", ";
		int32_t dend = ((int32_t)(vd + regs))-1;
		if      (regs == 0) buffer << "{}";
		else if (regs == 1) buffer << "{d" << vd << "}";
		else                buffer << "{d" << vd << "-d" << dend << "}";
}}
template <	typename	ARCH>
void OpVstmia_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 base_addr = cpu.GetGPR( rn );

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		for (unsigned reg = 0; reg < regs; ++reg) {
			cpu.MemWrite32( base_addr + U32(8*reg + 0), cpu.GetVSU( 2*(vd+reg) + w0 ) );
			cpu.MemWrite32( base_addr + U32(8*reg + 4), cpu.GetVSU( 2*(vd+reg) + w1 ) );
		}

		if (w) cpu.SetGPR( rn, base_addr + U32( regs << 3 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstmia_f64(CodeType code, uint32_t addr)
{
	return new OpVstmia_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstr_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vstr\ts" << vn << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpVstr_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32(imm);

		cpu.MemWrite32( addr, cpu.GetVSU( vn ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstr_32(CodeType code, uint32_t addr)
{
	return new OpVstr_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstr_64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vstr\td" << vn << ", " << DisasmMemoryRI(rn,imm,true,false);
}}
template <	typename	ARCH>
void OpVstr_64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 addr = cpu.GetGPR( rn ) + U32(imm);

		// compute word swapping according to endianness
		unsigned w0 = cpu.Test( cpu.CPSR().Get(E) ) ? 1 : 0, w1 = w0 ^ 1;

		cpu.MemWrite32( addr + U32(0), cpu.GetVSU( 2*vn + w0 ) );
		cpu.MemWrite32( addr + U32(4), cpu.GetVSU( 2*vn + w1 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstr_64(CodeType code, uint32_t addr)
{
	return new OpVstr_64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsub.f32\ts" << vd << ", s" << vn << ", s" << vm;
}}
template <	typename	ARCH>
void OpVsub_f32<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F32 res = cpu.GetVSR( vn ), op2 = cpu.GetVSR( vm );

		FPSub( res, op2, cpu, cpu.FPSCR );

		cpu.SetVSR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_f32(CodeType code, uint32_t addr)
{
	return new OpVsub_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_f64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsub.f64\td" << vd << ", d" << vn << ", d" << vm;
}}
template <	typename	ARCH>
void OpVsub_f64<	ARCH>::execute( ARCH & cpu)
{
	{
		typename ARCH::F64 res = cpu.GetVDR( vn ), op2 = cpu.GetVDR( vm );

		FPSub( res, op2, cpu, cpu.FPSCR );

		cpu.SetVDR( vd, res );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_f64(CodeType code, uint32_t addr)
{
	return new OpVsub_f64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaba.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_s8(CodeType code, uint32_t addr)
{
	return new OpVaba_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaba.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_s16(CodeType code, uint32_t addr)
{
	return new OpVaba_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaba.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_s32(CodeType code, uint32_t addr)
{
	return new OpVaba_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaba.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_u8(CodeType code, uint32_t addr)
{
	return new OpVaba_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaba.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_u16(CodeType code, uint32_t addr)
{
	return new OpVaba_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaba_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaba.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaba_u32(CodeType code, uint32_t addr)
{
	return new OpVaba_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_s8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabal.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_s8qd(CodeType code, uint32_t addr)
{
	return new OpVabal_s8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabal.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_s16qd(CodeType code, uint32_t addr)
{
	return new OpVabal_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabal.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_s32qd(CodeType code, uint32_t addr)
{
	return new OpVabal_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_u8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabal.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_u8qd(CodeType code, uint32_t addr)
{
	return new OpVabal_u8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_u16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabal.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_u16qd(CodeType code, uint32_t addr)
{
	return new OpVabal_u16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabal_u32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabal.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabal_u32qd(CodeType code, uint32_t addr)
{
	return new OpVabal_u32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabd.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_s8(CodeType code, uint32_t addr)
{
	return new OpVabd_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabd.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_s16(CodeType code, uint32_t addr)
{
	return new OpVabd_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabd.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_s32(CodeType code, uint32_t addr)
{
	return new OpVabd_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabd.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_u8(CodeType code, uint32_t addr)
{
	return new OpVabd_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabd.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_u16(CodeType code, uint32_t addr)
{
	return new OpVabd_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabd.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_u32(CodeType code, uint32_t addr)
{
	return new OpVabd_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_s8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabdl.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_s8qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_s8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabdl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_s16qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabdl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_s32qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_u8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabdl.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_u8qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_u8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_u16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabdl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_u16qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_u16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabdl_u32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabdl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabdl_u32qd(CodeType code, uint32_t addr)
{
	return new OpVabdl_u32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabd_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabd.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabd_f32(CodeType code, uint32_t addr)
{
	return new OpVabd_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabs.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_s8(CodeType code, uint32_t addr)
{
	return new OpVabs_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabs.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_s16(CodeType code, uint32_t addr)
{
	return new OpVabs_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabs.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_s32(CodeType code, uint32_t addr)
{
	return new OpVabs_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVabs_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vabs.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVabs_f32v(CodeType code, uint32_t addr)
{
	return new OpVabs_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVacge_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vacge.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVacge_f32(CodeType code, uint32_t addr)
{
	return new OpVacge_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVacgt_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vacgt.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVacgt_f32(CodeType code, uint32_t addr)
{
	return new OpVacgt_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vadd.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_f32v(CodeType code, uint32_t addr)
{
	return new OpVadd_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vadd.i" << (64/CFG::elements) << "\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vn>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVadd_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < CFG::elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) + cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_i8(CodeType code, uint32_t addr)
{
	return new OpVadd_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vadd.i" << (64/CFG::elements) << "\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vn>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVadd_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < CFG::elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) + cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_i16(CodeType code, uint32_t addr)
{
	return new OpVadd_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vadd.i" << (64/CFG::elements) << "\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vn>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVadd_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < CFG::elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) + cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_i32(CodeType code, uint32_t addr)
{
	return new OpVadd_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVadd_i64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vadd.i" << (64/CFG::elements) << "\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vn>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVadd_i64<	ARCH>::execute( ARCH & cpu)
{
	{
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < CFG::elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) + cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVadd_i64(CodeType code, uint32_t addr)
{
	return new OpVadd_i64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddhn_i16dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddhn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddhn_i16dq(CodeType code, uint32_t addr)
{
	return new OpVaddhn_i16dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddhn_i32dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddhn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddhn_i32dq(CodeType code, uint32_t addr)
{
	return new OpVaddhn_i32dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddhn_i64dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddhn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddhn_i64dq(CodeType code, uint32_t addr)
{
	return new OpVaddhn_i64dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddl.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_s8(CodeType code, uint32_t addr)
{
	return new OpVaddl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_s16(CodeType code, uint32_t addr)
{
	return new OpVaddl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_s32(CodeType code, uint32_t addr)
{
	return new OpVaddl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddl.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_u8(CodeType code, uint32_t addr)
{
	return new OpVaddl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_u16(CodeType code, uint32_t addr)
{
	return new OpVaddl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddl_u32(CodeType code, uint32_t addr)
{
	return new OpVaddl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddw.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_s8(CodeType code, uint32_t addr)
{
	return new OpVaddw_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddw.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_s16(CodeType code, uint32_t addr)
{
	return new OpVaddw_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddw.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_s32(CodeType code, uint32_t addr)
{
	return new OpVaddw_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddw.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_u8(CodeType code, uint32_t addr)
{
	return new OpVaddw_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddw.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_u16(CodeType code, uint32_t addr)
{
	return new OpVaddw_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVaddw_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vaddw.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVaddw_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) + WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVaddw_u32(CodeType code, uint32_t addr)
{
	return new OpVaddw_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVand<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vand\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVand<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) & cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVand(CodeType code, uint32_t addr)
{
	return new OpVand<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbic<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vbic\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVbic<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) & ~cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbic(CodeType code, uint32_t addr)
{
	return new OpVbic<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbic_i16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vbic.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbic_i16i(CodeType code, uint32_t addr)
{
	return new OpVbic_i16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbic_i32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vbic.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbic_i32i(CodeType code, uint32_t addr)
{
	return new OpVbic_i32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbif<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vbif\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVbif<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		{
			U64 sel = cpu.GetVDE( vm+dd, 0, U64() );
			cpu.SetVDE( vd+dd, 0, U64((cpu.GetVDE( vd+dd, 0, U64() ) & sel) | (cpu.GetVDE( vn+dd, 0, U64() ) & ~sel)) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbif(CodeType code, uint32_t addr)
{
	return new OpVbif<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbit<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vbit\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVbit<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		{
			U64 sel = cpu.GetVDE( vm+dd, 0, U64() );
			cpu.SetVDE( vd+dd, 0, U64((cpu.GetVDE( vn+dd, 0, U64() ) & sel) | (cpu.GetVDE( vd+dd, 0, U64() ) & ~sel)) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbit(CodeType code, uint32_t addr)
{
	return new OpVbit<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVbsl<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vbsl\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVbsl<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		{
			U64 sel = cpu.GetVDE( vd+dd, 0, U64() );
			cpu.SetVDE( vd+dd, 0, U64((cpu.GetVDE( vn+dd, 0, U64() ) & sel) | (cpu.GetVDE( vm+dd, 0, U64() ) & ~sel)) );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVbsl(CodeType code, uint32_t addr)
{
	return new OpVbsl<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_f32(CodeType code, uint32_t addr)
{
	return new OpVceq_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_f8z(CodeType code, uint32_t addr)
{
	return new OpVceq_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_f16z(CodeType code, uint32_t addr)
{
	return new OpVceq_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_f32z(CodeType code, uint32_t addr)
{
	return new OpVceq_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVceq_i8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i8z(CodeType code, uint32_t addr)
{
	return new OpVceq_i8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVceq_i16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i16z(CodeType code, uint32_t addr)
{
	return new OpVceq_i16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVceq_i32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i32z(CodeType code, uint32_t addr)
{
	return new OpVceq_i32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVceq_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i8(CodeType code, uint32_t addr)
{
	return new OpVceq_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVceq_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i16(CodeType code, uint32_t addr)
{
	return new OpVceq_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVceq_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vceq.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVceq_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res =  OP(not (op1 == op2)) - OP(1);
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVceq_i32(CodeType code, uint32_t addr)
{
	return new OpVceq_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_f8z(CodeType code, uint32_t addr)
{
	return new OpVcge_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_f16z(CodeType code, uint32_t addr)
{
	return new OpVcge_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_f32(CodeType code, uint32_t addr)
{
	return new OpVcge_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_f32z(CodeType code, uint32_t addr)
{
	return new OpVcge_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcge_s8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s8z(CodeType code, uint32_t addr)
{
	return new OpVcge_s8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcge_s16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s16z(CodeType code, uint32_t addr)
{
	return new OpVcge_s16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcge_s32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s32z(CodeType code, uint32_t addr)
{
	return new OpVcge_s32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s8(CodeType code, uint32_t addr)
{
	return new OpVcge_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s16(CodeType code, uint32_t addr)
{
	return new OpVcge_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_s32(CodeType code, uint32_t addr)
{
	return new OpVcge_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_u8(CodeType code, uint32_t addr)
{
	return new OpVcge_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_u16(CodeType code, uint32_t addr)
{
	return new OpVcge_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcge_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcge.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcge_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 >= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcge_u32(CodeType code, uint32_t addr)
{
	return new OpVcge_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_f8z(CodeType code, uint32_t addr)
{
	return new OpVcgt_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_f16z(CodeType code, uint32_t addr)
{
	return new OpVcgt_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_f32z(CodeType code, uint32_t addr)
{
	return new OpVcgt_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_f32(CodeType code, uint32_t addr)
{
	return new OpVcgt_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcgt_s8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s8z(CodeType code, uint32_t addr)
{
	return new OpVcgt_s8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcgt_s16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s16z(CodeType code, uint32_t addr)
{
	return new OpVcgt_s16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcgt_s32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s32z(CodeType code, uint32_t addr)
{
	return new OpVcgt_s32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s8(CodeType code, uint32_t addr)
{
	return new OpVcgt_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s16(CodeType code, uint32_t addr)
{
	return new OpVcgt_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_s32(CodeType code, uint32_t addr)
{
	return new OpVcgt_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_u8(CodeType code, uint32_t addr)
{
	return new OpVcgt_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_u16(CodeType code, uint32_t addr)
{
	return new OpVcgt_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcgt_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcgt.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVcgt_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vn+dd, idx, OP()) ), op2( cpu.GetVDE(vm+dd, idx, OP()) ), res( OP(not (op1 > op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcgt_u32(CodeType code, uint32_t addr)
{
	return new OpVcgt_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcle.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_f8z(CodeType code, uint32_t addr)
{
	return new OpVcle_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcle.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_f16z(CodeType code, uint32_t addr)
{
	return new OpVcle_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcle.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_f32z(CodeType code, uint32_t addr)
{
	return new OpVcle_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_s8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcle.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcle_s8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 <= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_s8z(CodeType code, uint32_t addr)
{
	return new OpVcle_s8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_s16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcle.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcle_s16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 <= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_s16z(CodeType code, uint32_t addr)
{
	return new OpVcle_s16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcle_s32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcle.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVcle_s32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 <= op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcle_s32z(CodeType code, uint32_t addr)
{
	return new OpVcle_s32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcls_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcls.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcls_s8(CodeType code, uint32_t addr)
{
	return new OpVcls_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcls_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcls.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcls_s16(CodeType code, uint32_t addr)
{
	return new OpVcls_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcls_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcls.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcls_s32(CodeType code, uint32_t addr)
{
	return new OpVcls_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_f8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vclt.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_f8z(CodeType code, uint32_t addr)
{
	return new OpVclt_f8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_f16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vclt.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_f16z(CodeType code, uint32_t addr)
{
	return new OpVclt_f16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_f32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vclt.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_f32z(CodeType code, uint32_t addr)
{
	return new OpVclt_f32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_s8z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vclt.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVclt_s8z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 < op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_s8z(CodeType code, uint32_t addr)
{
	return new OpVclt_s8z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_s16z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vclt.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVclt_s16z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 < op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_s16z(CodeType code, uint32_t addr)
{
	return new OpVclt_s16z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclt_s32z<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vclt.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", #0";
}}
template <	typename	ARCH>
void OpVclt_s32z<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			OP op1( cpu.GetVDE(vm+dd, idx, OP()) ), op2( 0 ), res( OP(not (op1 < op2)) - OP(1) );
			cpu.SetVDE( vd+dd, idx, res );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclt_s32z(CodeType code, uint32_t addr)
{
	return new OpVclt_s32z<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclz_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vclz.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclz_i8(CodeType code, uint32_t addr)
{
	return new OpVclz_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclz_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vclz.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclz_i16(CodeType code, uint32_t addr)
{
	return new OpVclz_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVclz_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vclz.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVclz_i32(CodeType code, uint32_t addr)
{
	return new OpVclz_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcnt_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcnt.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcnt_8(CodeType code, uint32_t addr)
{
	return new OpVcnt_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f16_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f16.f32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f16_f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f16_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32_f16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.f16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32_f16(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32_f16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32_s32(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32s32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32s32vi(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32s32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u32v(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_f32u32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.f32.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_f32u32vi(CodeType code, uint32_t addr)
{
	return new OpVcvt_f32u32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.s32.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32_f32(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_s32f32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.s32.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_s32f32vi(CodeType code, uint32_t addr)
{
	return new OpVcvt_s32f32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.u32.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f32v(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVcvt_u32f32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vcvt.u32.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVcvt_u32f32vi(CodeType code, uint32_t addr)
{
	return new OpVcvt_u32f32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup_8dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vdup.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}
template <	typename	ARCH>
void OpVdup_8dp<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		OP element = cpu.GetVDE(vm, part, OP());
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup_8dp(CodeType code, uint32_t addr)
{
	return new OpVdup_8dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup_16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vdup.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}
template <	typename	ARCH>
void OpVdup_16dp<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		OP element = cpu.GetVDE(vm, part, OP());
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup_16dp(CodeType code, uint32_t addr)
{
	return new OpVdup_16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup_32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vdup.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}
template <	typename	ARCH>
void OpVdup_32dp<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		OP element = cpu.GetVDE(vm, part, OP());
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup_32dp(CodeType code, uint32_t addr)
{
	return new OpVdup_32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup8_r<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vdup.8\t" << DisasmV(vd>>q,3+q) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVdup8_r<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		OP element( cpu.GetGPR(rt) );
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup8_r(CodeType code, uint32_t addr)
{
	return new OpVdup8_r<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup16_r<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vdup.16\t" << DisasmV(vd>>q,3+q) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVdup16_r<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		OP element( cpu.GetGPR(rt) );
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup16_r(CodeType code, uint32_t addr)
{
	return new OpVdup16_r<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVdup32_r<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vdup.32\t" << DisasmV(vd>>q,3+q) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVdup32_r<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		OP element( cpu.GetGPR(rt) );
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned e=0; e < elements; ++e)
		cpu.SetVDE( vd+dd, e, element );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVdup32_r(CodeType code, uint32_t addr)
{
	return new OpVdup32_r<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVeor<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "veor\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVeor<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) ^ cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVeor(CodeType code, uint32_t addr)
{
	return new OpVeor<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVext_8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vext.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVext_8i(CodeType code, uint32_t addr)
{
	return new OpVext_8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfma_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfma.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfma_f32v(CodeType code, uint32_t addr)
{
	return new OpVfma_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVfms_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vfms.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVfms_f32v(CodeType code, uint32_t addr)
{
	return new OpVfms_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhadd.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_s8(CodeType code, uint32_t addr)
{
	return new OpVhadd_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhadd.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_s16(CodeType code, uint32_t addr)
{
	return new OpVhadd_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhadd.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_s32(CodeType code, uint32_t addr)
{
	return new OpVhadd_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhadd.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_u8(CodeType code, uint32_t addr)
{
	return new OpVhadd_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhadd.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_u16(CodeType code, uint32_t addr)
{
	return new OpVhadd_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhadd_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhadd.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhadd_u32(CodeType code, uint32_t addr)
{
	return new OpVhadd_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhsub.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_s8(CodeType code, uint32_t addr)
{
	return new OpVhsub_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhsub.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_s16(CodeType code, uint32_t addr)
{
	return new OpVhsub_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhsub.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_s32(CodeType code, uint32_t addr)
{
	return new OpVhsub_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhsub.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_u8(CodeType code, uint32_t addr)
{
	return new OpVhsub_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhsub.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_u16(CodeType code, uint32_t addr)
{
	return new OpVhsub_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVhsub_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vhsub.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVhsub_u32(CodeType code, uint32_t addr)
{
	return new OpVhsub_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << (vms.ses ? 1 : int(vms.regs)) << ".8\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx/elements)%32, idx%elements, U8(cpu.MemRead8(addr + U32(size*idx))));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U8(cpu.MemRead8(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms_8(CodeType code, uint32_t addr)
{
	return new OpVldms_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << (vms.ses ? 1 : int(vms.regs)) << ".16\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx/elements)%32, idx%elements, U16(cpu.MemRead16(addr + U32(size*idx))));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U16(cpu.MemRead16(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms_16(CodeType code, uint32_t addr)
{
	return new OpVldms_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << (vms.ses ? 1 : int(vms.regs)) << ".32\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx/elements)%32, idx%elements, U32(cpu.MemRead32(addr + U32(size*idx))));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U32(cpu.MemRead32(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms_32(CodeType code, uint32_t addr)
{
	return new OpVldms_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms_64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << (vms.ses ? 1 : int(vms.regs)) << ".64\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms_64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;
		unsigned const size = 8;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		U32 endianness = cpu.CPSR().Get(E) * U32(4);

		for (unsigned idx = 0, end = vms.regs; idx < end; ++idx)
		{
			U64 data0( cpu.MemRead32(addr + (U32(size*idx + 0) ^ endianness)) ),
			data1( cpu.MemRead32(addr + (U32(size*idx + 4) ^ endianness)) );
			cpu.SetVDE((vd+idx)%32, 0, U64((data1 << 32) | (data0 << 0)));
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms_64(CodeType code, uint32_t addr)
{
	return new OpVldms_64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms2s_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << int(regs) << ".8\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms2s_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+2*(idx%regs))%32, idx/regs, U8(cpu.MemRead8(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms2s_8(CodeType code, uint32_t addr)
{
	return new OpVldms2s_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms2s_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << int(regs) << ".16\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms2s_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+2*(idx%regs))%32, idx/regs, U16(cpu.MemRead16(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms2s_16(CodeType code, uint32_t addr)
{
	return new OpVldms2s_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldms2s_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << int(regs) << ".32\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVldms2s_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.SetVDE((vd+2*(idx%regs))%32, idx/regs, U32(cpu.MemRead32(addr + U32(size*idx))));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldms2s_32(CodeType code, uint32_t addr)
{
	return new OpVldms2s_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVld2_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld2.8\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVld2_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.SetVDE(vd+q+2*reg, idx, U8(cpu.MemRead8(addr))) ;
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVld2_8(CodeType code, uint32_t addr)
{
	return new OpVld2_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVld2_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld2.16\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVld2_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.SetVDE(vd+q+2*reg, idx, U16(cpu.MemRead16(addr))) ;
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVld2_16(CodeType code, uint32_t addr)
{
	return new OpVld2_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVld2_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld2.32\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVld2_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.SetVDE(vd+q+2*reg, idx, U32(cpu.MemRead32(addr))) ;
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVld2_32(CodeType code, uint32_t addr)
{
	return new OpVld2_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldal_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".8\t" << DisasmBunch(vd,regs+1).dspc(ds).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?8:0);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldal_8(CodeType code, uint32_t addr)
{
	return new OpVldal_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldal_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".16\t" << DisasmBunch(vd,regs+1).dspc(ds).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?16:0);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldal_16(CodeType code, uint32_t addr)
{
	return new OpVldal_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldal_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".32\t" << DisasmBunch(vd,regs+1).dspc(ds).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?32:0);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldal_32(CodeType code, uint32_t addr)
{
	return new OpVldal_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldqal_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld1.8\t" << DisasmBunch(vd,2).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?8:0);
}}
template <	typename	ARCH>
void OpVldqal_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(size) : cpu.GetGPR(rm)) );

		U8  data( cpu.MemRead8(addr) );
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0, end = elements; idx < end; ++idx)
		cpu.SetVDE(vd+q, idx, data);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldqal_8(CodeType code, uint32_t addr)
{
	return new OpVldqal_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldqal_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld1.16\t" << DisasmBunch(vd,2).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?16:0);
}}
template <	typename	ARCH>
void OpVldqal_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, align*size);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(size) : cpu.GetGPR(rm)) );

		U16  data( cpu.MemRead16(addr) );
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0, end = elements; idx < end; ++idx)
		cpu.SetVDE(vd+q, idx, data);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldqal_16(CodeType code, uint32_t addr)
{
	return new OpVldqal_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldqal_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld1.32\t" << DisasmBunch(vd,2).all_lanes() << ", " << DisasmNeonMemoryRR(rn, rm, align?32:0);
}}
template <	typename	ARCH>
void OpVldqal_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, align*size);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(size) : cpu.GetGPR(rm)) );

		U32  data( cpu.MemRead32(addr) );
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0, end = elements; idx < end; ++idx)
		cpu.SetVDE(vd+q, idx, data);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldqal_32(CodeType code, uint32_t addr)
{
	return new OpVldqal_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldsl_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".8\t" << DisasmBunch(vd, regs+1).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldsl_8(CodeType code, uint32_t addr)
{
	return new OpVldsl_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldsl_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".16\t" << DisasmBunch(vd, regs+1).dspc(ds).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldsl_16(CodeType code, uint32_t addr)
{
	return new OpVldsl_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVldsl_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vld" << int(regs+1) << ".32\t" << DisasmBunch(vd, regs+1).dspc(ds).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVldsl_32(CodeType code, uint32_t addr)
{
	return new OpVldsl_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmax.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_f32(CodeType code, uint32_t addr)
{
	return new OpVmax_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmax.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_s8(CodeType code, uint32_t addr)
{
	return new OpVmax_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmax.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_s16(CodeType code, uint32_t addr)
{
	return new OpVmax_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmax.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_s32(CodeType code, uint32_t addr)
{
	return new OpVmax_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmax.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_u8(CodeType code, uint32_t addr)
{
	return new OpVmax_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmax.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_u16(CodeType code, uint32_t addr)
{
	return new OpVmax_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmax_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmax.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmax_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Maximum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmax_u32(CodeType code, uint32_t addr)
{
	return new OpVmax_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmin.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_f32(CodeType code, uint32_t addr)
{
	return new OpVmin_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmin.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_s8(CodeType code, uint32_t addr)
{
	return new OpVmin_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmin.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_s16(CodeType code, uint32_t addr)
{
	return new OpVmin_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmin.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_s32(CodeType code, uint32_t addr)
{
	return new OpVmin_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmin.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_u8(CodeType code, uint32_t addr)
{
	return new OpVmin_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmin.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_u16(CodeType code, uint32_t addr)
{
	return new OpVmin_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmin_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmin.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmin_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(Minimum(cpu.GetVDE( vn+dd, idx, OP() ), cpu.GetVDE( vm+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmin_u32(CodeType code, uint32_t addr)
{
	return new OpVmin_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmla.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_f32v(CodeType code, uint32_t addr)
{
	return new OpVmla_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_f32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmla.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_f32dp(CodeType code, uint32_t addr)
{
	return new OpVmla_f32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVml_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << ".i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVml_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		OP sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE(vd+dd, idx, OP()) + sign * cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVml_i8(CodeType code, uint32_t addr)
{
	return new OpVml_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVml_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << ".i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVml_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		OP sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE(vd+dd, idx, OP()) + sign * cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVml_i16(CodeType code, uint32_t addr)
{
	return new OpVml_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVml_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << ".i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVml_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		OP sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE(vd+dd, idx, OP()) + sign * cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVml_i32(CodeType code, uint32_t addr)
{
	return new OpVml_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_i16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmla.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_i16dp(CodeType code, uint32_t addr)
{
	return new OpVmla_i16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmla_i32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmla.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmla_i32dp(CodeType code, uint32_t addr)
{
	return new OpVmla_i32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_s8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_s8qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_s8qd(CodeType code, uint32_t addr)
{
	return new OpVmll_s8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_s16qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_s16qd(CodeType code, uint32_t addr)
{
	return new OpVmll_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_s32qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_s32qd(CodeType code, uint32_t addr)
{
	return new OpVmll_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_u8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_u8qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_u8qd(CodeType code, uint32_t addr)
{
	return new OpVmll_u8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_u16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_u16qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_u16qd(CodeType code, uint32_t addr)
{
	return new OpVmll_u16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmll_u32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vml" << (sub?"s":"a") << "l.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmll_u32qd<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP prods[2][subs], sign(sub?-1:+1);
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		prods[q][idx] = sign * WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) * WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP(cpu.GetVDE(vd+q, idx, WOP()) + prods[q][idx]) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmll_u32qd(CodeType code, uint32_t addr)
{
	return new OpVmll_u32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlal_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmlal.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlal_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVmlal_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlal_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmlal.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlal_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVmlal_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlal_u16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmlal.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlal_u16qdp(CodeType code, uint32_t addr)
{
	return new OpVmlal_u16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlal_u32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmlal.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlal_u32qdp(CodeType code, uint32_t addr)
{
	return new OpVmlal_u32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmls.f16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f16dp(CodeType code, uint32_t addr)
{
	return new OpVmls_f16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmls.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f32v(CodeType code, uint32_t addr)
{
	return new OpVmls_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_f32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmls.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_f32dp(CodeType code, uint32_t addr)
{
	return new OpVmls_f32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_i16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmls.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_i16dp(CodeType code, uint32_t addr)
{
	return new OpVmls_i16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmls_i32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmls.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmls_i32dp(CodeType code, uint32_t addr)
{
	return new OpVmls_i32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlsl_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmlsl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlsl_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVmlsl_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlsl_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmlsl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlsl_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVmlsl_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlsl_u16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmlsl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlsl_u16qdp(CodeType code, uint32_t addr)
{
	return new OpVmlsl_u16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmlsl_u32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmlsl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmlsl_u32qdp(CodeType code, uint32_t addr)
{
	return new OpVmlsl_u32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_f32vi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.f32\t" << DisasmV(vd>>q, 3+q) << ", #" << std::setprecision(10) << fpimm;
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_f32vi(CodeType code, uint32_t addr)
{
	return new OpVmov_f32vi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmov_i8i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i8i(CodeType code, uint32_t addr)
{
	return new OpVmov_i8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmov_i16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i16i(CodeType code, uint32_t addr)
{
	return new OpVmov_i16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmov_i32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i32i(CodeType code, uint32_t addr)
{
	return new OpVmov_i32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.i64\t" << DisasmV(vd>>q, 3+q) << ", #0x" << std::hex << std::setfill('0') << std::setw(16) << imm;
}}
template <	typename	ARCH>
void OpVmov_i64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 OP;
		unsigned const elements = 1;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i64i(CodeType code, uint32_t addr)
{
	return new OpVmov_i64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_i32in<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmov_i32in<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_i32in(CodeType code, uint32_t addr)
{
	return new OpVmov_i32in<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmovl.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		typedef typename ARCH::S16 S16;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, S16( cpu.GetVDE( vm, subs*q+idx, S8() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_s8(CodeType code, uint32_t addr)
{
	return new OpVmovl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmovl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::S32 S32;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, S32( cpu.GetVDE( vm, subs*q+idx, S16() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_s16(CodeType code, uint32_t addr)
{
	return new OpVmovl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmovl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S64 S64;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, S64( cpu.GetVDE( vm, subs*q+idx, S32() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_s32(CodeType code, uint32_t addr)
{
	return new OpVmovl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmovl.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U16 U16;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, U16( cpu.GetVDE( vm, subs*q+idx, U8() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_u8(CodeType code, uint32_t addr)
{
	return new OpVmovl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmovl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, U32( cpu.GetVDE( vm, subs*q+idx, U16() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_u16(CodeType code, uint32_t addr)
{
	return new OpVmovl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmovl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmovl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, U64( cpu.GetVDE( vm, subs*q+idx, U32() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovl_u32(CodeType code, uint32_t addr)
{
	return new OpVmovl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovn_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmovn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}
template <	typename	ARCH>
void OpVmovn_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 UN;
		typedef typename ARCH::U16 UL;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		UN res[2][subs];
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = UN(cpu.GetVDE( vm+q, idx, UL() ));

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd, subs*q+idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovn_i16(CodeType code, uint32_t addr)
{
	return new OpVmovn_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovn_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmovn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}
template <	typename	ARCH>
void OpVmovn_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 UN;
		typedef typename ARCH::U32 UL;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		UN res[2][subs];
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = UN(cpu.GetVDE( vm+q, idx, UL() ));

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd, subs*q+idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovn_i32(CodeType code, uint32_t addr)
{
	return new OpVmovn_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmovn_i64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmovn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}
template <	typename	ARCH>
void OpVmovn_i64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 UN;
		typedef typename ARCH::U64 UL;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		UN res[2][subs];
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = UN(cpu.GetVDE( vm+q, idx, UL() ));

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd, subs*q+idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmovn_i64(CodeType code, uint32_t addr)
{
	return new OpVmovn_i64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_8dr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.8\t" << DisasmV(vd, 3) << DisasmVIdx(index) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmov_8dr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDE( vd, index, typename ARCH::U8(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_8dr(CodeType code, uint32_t addr)
{
	return new OpVmov_8dr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_16dr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.16\t" << DisasmV(vd, 3) << DisasmVIdx(index) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmov_16dr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDE( vd, index, typename ARCH::U16(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_16dr(CodeType code, uint32_t addr)
{
	return new OpVmov_16dr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_32dr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.32\t" << DisasmV(vd, 3) << DisasmVIdx(index) << ", " << DisasmRegister(rt);
}}
template <	typename	ARCH>
void OpVmov_32dr<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetVDE( vd, index, typename ARCH::U32(cpu.GetGPR(rt)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_32dr(CodeType code, uint32_t addr)
{
	return new OpVmov_32dr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_s8rd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.s8\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_s8rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, typename ARCH::U32( cpu.GetVDE( vn, index, typename ARCH::S8() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_s8rd(CodeType code, uint32_t addr)
{
	return new OpVmov_s8rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_u8rd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.u8\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_u8rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, typename ARCH::U32( cpu.GetVDE( vn, index, typename ARCH::U8() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_u8rd(CodeType code, uint32_t addr)
{
	return new OpVmov_u8rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_s16rd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.s16\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_s16rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, typename ARCH::U32( cpu.GetVDE( vn, index, typename ARCH::S16() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_s16rd(CodeType code, uint32_t addr)
{
	return new OpVmov_s16rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_u16rd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.u16\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_u16rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, typename ARCH::U32( cpu.GetVDE( vn, index, typename ARCH::U16() ) ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_u16rd(CodeType code, uint32_t addr)
{
	return new OpVmov_u16rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmov_32rd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmov.32\t" << DisasmRegister(rt) << ", " << DisasmV(vn, 3) << DisasmVIdx(index);
}}
template <	typename	ARCH>
void OpVmov_32rd<	ARCH>::execute( ARCH & cpu)
{
	{
		cpu.SetGPR( rt, cpu.GetVDE( vn, index, typename ARCH::U32() ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmov_32rd(CodeType code, uint32_t addr)
{
	return new OpVmov_32rd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_f32v(CodeType code, uint32_t addr)
{
	return new OpVmul_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_f32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_f32dp(CodeType code, uint32_t addr)
{
	return new OpVmul_f32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmul_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i8(CodeType code, uint32_t addr)
{
	return new OpVmul_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmul_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i16(CodeType code, uint32_t addr)
{
	return new OpVmul_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVmul_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) * cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i32(CodeType code, uint32_t addr)
{
	return new OpVmul_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i16dp(CodeType code, uint32_t addr)
{
	return new OpVmul_i16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_i32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_i32dp(CodeType code, uint32_t addr)
{
	return new OpVmul_i32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_p8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.p8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_p8(CodeType code, uint32_t addr)
{
	return new OpVmul_p8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_p16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.p16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_p16(CodeType code, uint32_t addr)
{
	return new OpVmul_p16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmul_p32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmul.p32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmul_p32(CodeType code, uint32_t addr)
{
	return new OpVmul_p32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_p8qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.p8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_p8qd(CodeType code, uint32_t addr)
{
	return new OpVmull_p8qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		typedef typename ARCH::S16 S16;
		unsigned const subs = 4;

		S16 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = S16( cpu.GetVDE( vn, subs*q+idx, S8() ) ) * S16( cpu.GetVDE( vm, subs*q+idx, S8() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s8(CodeType code, uint32_t addr)
{
	return new OpVmull_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		typedef typename ARCH::S32 S32;
		unsigned const subs = 2;

		S32 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = S32( cpu.GetVDE( vn, subs*q+idx, S16() ) ) * S32( cpu.GetVDE( vm, subs*q+idx, S16() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s16(CodeType code, uint32_t addr)
{
	return new OpVmull_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 S32;
		typedef typename ARCH::S64 S64;
		unsigned const subs = 1;

		S64 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = S64( cpu.GetVDE( vn, subs*q+idx, S32() ) ) * S64( cpu.GetVDE( vm, subs*q+idx, S32() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s32(CodeType code, uint32_t addr)
{
	return new OpVmull_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		typedef typename ARCH::U16 U16;
		unsigned const subs = 4;

		U16 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = U16( cpu.GetVDE( vn, subs*q+idx, U8() ) ) * U16( cpu.GetVDE( vm, subs*q+idx, U8() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u8(CodeType code, uint32_t addr)
{
	return new OpVmull_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		typedef typename ARCH::U32 U32;
		unsigned const subs = 2;

		U32 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = U32( cpu.GetVDE( vn, subs*q+idx, U16() ) ) * U32( cpu.GetVDE( vm, subs*q+idx, U16() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u16(CodeType code, uint32_t addr)
{
	return new OpVmull_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVmull_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;
		unsigned const subs = 1;

		U64 res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = U64( cpu.GetVDE( vn, subs*q+idx, U32() ) ) * U64( cpu.GetVDE( vm, subs*q+idx, U32() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u32(CodeType code, uint32_t addr)
{
	return new OpVmull_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVmull_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVmull_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u16qdp(CodeType code, uint32_t addr)
{
	return new OpVmull_u16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmull_u32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmull.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmull_u32qdp(CodeType code, uint32_t addr)
{
	return new OpVmull_u32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmvn_i16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmvn.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmvn_i16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(~imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmvn_i16i(CodeType code, uint32_t addr)
{
	return new OpVmvn_i16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmvn_i32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmvn.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmvn_i32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(~imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmvn_i32i(CodeType code, uint32_t addr)
{
	return new OpVmvn_i32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmvn_i32in<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmvn.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVmvn_i32in<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(~imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmvn_i32in(CodeType code, uint32_t addr)
{
	return new OpVmvn_i32in<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVmvn<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vmvn\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVmvn(CodeType code, uint32_t addr)
{
	return new OpVmvn<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vneg.f8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f8(CodeType code, uint32_t addr)
{
	return new OpVneg_f8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vneg.f16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f16(CodeType code, uint32_t addr)
{
	return new OpVneg_f16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vneg.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_f32v(CodeType code, uint32_t addr)
{
	return new OpVneg_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vneg.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVneg_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(-cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_s8(CodeType code, uint32_t addr)
{
	return new OpVneg_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vneg.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVneg_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(-cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_s16(CodeType code, uint32_t addr)
{
	return new OpVneg_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVneg_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vneg.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVneg_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(-cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVneg_s32(CodeType code, uint32_t addr)
{
	return new OpVneg_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVorn<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vorn\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVorn<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) | ~cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVorn(CodeType code, uint32_t addr)
{
	return new OpVorn<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVorr<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vorr\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVorr<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDE( vd+dd, 0, U64(cpu.GetVDE( vn+dd, 0, U64() ) | cpu.GetVDE( vm+dd, 0, U64() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVorr(CodeType code, uint32_t addr)
{
	return new OpVorr<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVorr_i16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vorr.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVorr_i16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vd+dd, idx, OP() ) | OP(imm)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVorr_i16i(CodeType code, uint32_t addr)
{
	return new OpVorr_i16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVorr_i32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vorr.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVorr_i32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vd+dd, idx, OP() ) | OP(imm)) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVorr_i32i(CodeType code, uint32_t addr)
{
	return new OpVorr_i32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadal.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_s8(CodeType code, uint32_t addr)
{
	return new OpVpadal_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadal.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_s16(CodeType code, uint32_t addr)
{
	return new OpVpadal_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadal.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_s32(CodeType code, uint32_t addr)
{
	return new OpVpadal_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadal.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_u8(CodeType code, uint32_t addr)
{
	return new OpVpadal_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadal.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_u16(CodeType code, uint32_t addr)
{
	return new OpVpadal_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadal_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadal.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadal_u32(CodeType code, uint32_t addr)
{
	return new OpVpadal_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadd_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadd.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadd_f32(CodeType code, uint32_t addr)
{
	return new OpVpadd_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadd_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadd.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVpadd_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8;

		U8 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0, end = elements/2; idx < end; ++idx)
		{
			res[dd][idx+  0] = cpu.GetVDE( vn+dd, 2*idx+0, U8() ) + cpu.GetVDE( vn+dd, 2*idx+1, U8() );
			res[dd][idx+end] = cpu.GetVDE( vm+dd, 2*idx+0, U8() ) + cpu.GetVDE( vm+dd, 2*idx+1, U8() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadd_i8(CodeType code, uint32_t addr)
{
	return new OpVpadd_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadd_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadd.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVpadd_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4;

		U16 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0, end = elements/2; idx < end; ++idx)
		{
			res[dd][idx+  0] = cpu.GetVDE( vn+dd, 2*idx+0, U16() ) + cpu.GetVDE( vn+dd, 2*idx+1, U16() );
			res[dd][idx+end] = cpu.GetVDE( vm+dd, 2*idx+0, U16() ) + cpu.GetVDE( vm+dd, 2*idx+1, U16() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadd_i16(CodeType code, uint32_t addr)
{
	return new OpVpadd_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpadd_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpadd.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVpadd_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2;

		U32 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0, end = elements/2; idx < end; ++idx)
		{
			res[dd][idx+  0] = cpu.GetVDE( vn+dd, 2*idx+0, U32() ) + cpu.GetVDE( vn+dd, 2*idx+1, U32() );
			res[dd][idx+end] = cpu.GetVDE( vm+dd, 2*idx+0, U32() ) + cpu.GetVDE( vm+dd, 2*idx+1, U32() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpadd_i32(CodeType code, uint32_t addr)
{
	return new OpVpadd_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpaddl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_s8(CodeType code, uint32_t addr)
{
	return new OpVpaddl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpaddl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_s16(CodeType code, uint32_t addr)
{
	return new OpVpaddl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpaddl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_s32(CodeType code, uint32_t addr)
{
	return new OpVpaddl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpaddl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_u8(CodeType code, uint32_t addr)
{
	return new OpVpaddl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpaddl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_u16(CodeType code, uint32_t addr)
{
	return new OpVpaddl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpaddl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpaddl.u32\t" << DisasmV(vd>>q,3+q) << ", " << DisasmV(vm>>q,3+q);
}}
template <	typename	ARCH>
void OpVpaddl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		cpu.SetVDU( vd+dd, U64(cpu.GetVDE( vm+dd, 0, U32() )) + U64(cpu.GetVDE( vm+dd, 1, U32() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpaddl_u32(CodeType code, uint32_t addr)
{
	return new OpVpaddl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmax.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_f32(CodeType code, uint32_t addr)
{
	return new OpVpmax_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmax.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_s8(CodeType code, uint32_t addr)
{
	return new OpVpmax_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmax.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_s16(CodeType code, uint32_t addr)
{
	return new OpVpmax_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmax.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_s32(CodeType code, uint32_t addr)
{
	return new OpVpmax_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmax.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_u8(CodeType code, uint32_t addr)
{
	return new OpVpmax_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmax.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_u16(CodeType code, uint32_t addr)
{
	return new OpVpmax_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmax_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmax.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmax_u32(CodeType code, uint32_t addr)
{
	return new OpVpmax_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmin.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_f32(CodeType code, uint32_t addr)
{
	return new OpVpmin_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmin.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_s8(CodeType code, uint32_t addr)
{
	return new OpVpmin_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmin.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_s16(CodeType code, uint32_t addr)
{
	return new OpVpmin_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmin.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_s32(CodeType code, uint32_t addr)
{
	return new OpVpmin_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmin.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_u8(CodeType code, uint32_t addr)
{
	return new OpVpmin_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmin.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_u16(CodeType code, uint32_t addr)
{
	return new OpVpmin_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVpmin_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vpmin.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVpmin_u32(CodeType code, uint32_t addr)
{
	return new OpVpmin_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqabs_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqabs.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqabs_s8(CodeType code, uint32_t addr)
{
	return new OpVqabs_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqabs_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqabs.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqabs_s16(CodeType code, uint32_t addr)
{
	return new OpVqabs_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqabs_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqabs.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqabs_s32(CodeType code, uint32_t addr)
{
	return new OpVqabs_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqadd.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_s8(CodeType code, uint32_t addr)
{
	return new OpVqadd_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqadd.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_s16(CodeType code, uint32_t addr)
{
	return new OpVqadd_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqadd.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_s32(CodeType code, uint32_t addr)
{
	return new OpVqadd_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqadd.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_s64(CodeType code, uint32_t addr)
{
	return new OpVqadd_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqadd.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_u8(CodeType code, uint32_t addr)
{
	return new OpVqadd_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqadd.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_u16(CodeType code, uint32_t addr)
{
	return new OpVqadd_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqadd.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_u32(CodeType code, uint32_t addr)
{
	return new OpVqadd_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqadd_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqadd.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqadd_u64(CodeType code, uint32_t addr)
{
	return new OpVqadd_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlal_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmlal.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlal_s16qd(CodeType code, uint32_t addr)
{
	return new OpVqdmlal_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlal_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmlal.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlal_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmlal_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlal_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmlal.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlal_s32qd(CodeType code, uint32_t addr)
{
	return new OpVqdmlal_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlal_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmlal.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlal_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmlal_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlsl_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmlsl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlsl_s16qd(CodeType code, uint32_t addr)
{
	return new OpVqdmlsl_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlsl_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmlsl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlsl_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmlsl_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlsl_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmlsl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlsl_s32qd(CodeType code, uint32_t addr)
{
	return new OpVqdmlsl_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmlsl_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmlsl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmlsl_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmlsl_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmulh_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmulh.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmulh_s16(CodeType code, uint32_t addr)
{
	return new OpVqdmulh_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmulh_s16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmulh.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmulh_s16dp(CodeType code, uint32_t addr)
{
	return new OpVqdmulh_s16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmulh_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmulh.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmulh_s32(CodeType code, uint32_t addr)
{
	return new OpVqdmulh_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmulh_s32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmulh.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmulh_s32dp(CodeType code, uint32_t addr)
{
	return new OpVqdmulh_s32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmull_s16qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmull.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmull_s16qd(CodeType code, uint32_t addr)
{
	return new OpVqdmull_s16qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmull_s16qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmull.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmull_s16qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmull_s16qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmull_s32qd<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmull.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmull_s32qd(CodeType code, uint32_t addr)
{
	return new OpVqdmull_s32qd<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqdmull_s32qdp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqdmull.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqdmull_s32qdp(CodeType code, uint32_t addr)
{
	return new OpVqdmull_s32qdp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqmovn.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_s16(CodeType code, uint32_t addr)
{
	return new OpVqmovn_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqmovn.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_s32(CodeType code, uint32_t addr)
{
	return new OpVqmovn_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqmovn.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_s64(CodeType code, uint32_t addr)
{
	return new OpVqmovn_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqmovn.u16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_u16(CodeType code, uint32_t addr)
{
	return new OpVqmovn_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqmovn.u32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_u32(CodeType code, uint32_t addr)
{
	return new OpVqmovn_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovn_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqmovn.u64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovn_u64(CodeType code, uint32_t addr)
{
	return new OpVqmovn_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovun_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqmovun.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovun_s16(CodeType code, uint32_t addr)
{
	return new OpVqmovun_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovun_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqmovun.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovun_s32(CodeType code, uint32_t addr)
{
	return new OpVqmovun_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqmovun_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqmovun.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqmovun_s64(CodeType code, uint32_t addr)
{
	return new OpVqmovun_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqneg_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqneg.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqneg_s8(CodeType code, uint32_t addr)
{
	return new OpVqneg_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqneg_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqneg.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqneg_s16(CodeType code, uint32_t addr)
{
	return new OpVqneg_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqneg_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqneg.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqneg_s32(CodeType code, uint32_t addr)
{
	return new OpVqneg_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrdmulh_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrdmulh.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrdmulh_s16(CodeType code, uint32_t addr)
{
	return new OpVqrdmulh_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrdmulh_s16dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrdmulh.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrdmulh_s16dp(CodeType code, uint32_t addr)
{
	return new OpVqrdmulh_s16dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrdmulh_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrdmulh.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrdmulh_s32(CodeType code, uint32_t addr)
{
	return new OpVqrdmulh_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrdmulh_s32dp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrdmulh.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm, 3) << DisasmVIdx(part);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrdmulh_s32dp(CodeType code, uint32_t addr)
{
	return new OpVqrdmulh_s32dp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_s8(CodeType code, uint32_t addr)
{
	return new OpVqrshl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_s16(CodeType code, uint32_t addr)
{
	return new OpVqrshl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_s32(CodeType code, uint32_t addr)
{
	return new OpVqrshl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_s64(CodeType code, uint32_t addr)
{
	return new OpVqrshl_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_u8(CodeType code, uint32_t addr)
{
	return new OpVqrshl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_u16(CodeType code, uint32_t addr)
{
	return new OpVqrshl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_u32(CodeType code, uint32_t addr)
{
	return new OpVqrshl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshl_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshl_u64(CodeType code, uint32_t addr)
{
	return new OpVqrshl_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_s16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshrn.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_s16dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_s16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_s32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshrn.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_s32dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_s32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_s64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshrn.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_s64dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_s64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_u16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshrn.u16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_u16dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_u16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_u32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshrn.u32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_u32dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_u32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrn_u64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshrn.u64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrn_u64dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrn_u64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrun_s16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshrun.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrun_s16dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrun_s16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrun_s32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshrun.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrun_s32dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrun_s32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqrshrun_s64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqrshrun.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqrshrun_s64dqi(CodeType code, uint32_t addr)
{
	return new OpVqrshrun_s64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s8(CodeType code, uint32_t addr)
{
	return new OpVqshl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s8i(CodeType code, uint32_t addr)
{
	return new OpVqshl_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s16(CodeType code, uint32_t addr)
{
	return new OpVqshl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s16i(CodeType code, uint32_t addr)
{
	return new OpVqshl_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s32(CodeType code, uint32_t addr)
{
	return new OpVqshl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s32i(CodeType code, uint32_t addr)
{
	return new OpVqshl_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s64(CodeType code, uint32_t addr)
{
	return new OpVqshl_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_s64i(CodeType code, uint32_t addr)
{
	return new OpVqshl_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u8(CodeType code, uint32_t addr)
{
	return new OpVqshl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u8i(CodeType code, uint32_t addr)
{
	return new OpVqshl_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u16(CodeType code, uint32_t addr)
{
	return new OpVqshl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u16i(CodeType code, uint32_t addr)
{
	return new OpVqshl_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u32(CodeType code, uint32_t addr)
{
	return new OpVqshl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u32i(CodeType code, uint32_t addr)
{
	return new OpVqshl_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u64(CodeType code, uint32_t addr)
{
	return new OpVqshl_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshl_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshl_u64i(CodeType code, uint32_t addr)
{
	return new OpVqshl_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshlu_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshlu.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshlu_s8i(CodeType code, uint32_t addr)
{
	return new OpVqshlu_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshlu_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshlu.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshlu_s16i(CodeType code, uint32_t addr)
{
	return new OpVqshlu_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshlu_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshlu.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshlu_s32i(CodeType code, uint32_t addr)
{
	return new OpVqshlu_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshlu_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshlu.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshlu_s64i(CodeType code, uint32_t addr)
{
	return new OpVqshlu_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_s16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshrn.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_s16dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_s16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_s32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshrn.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_s32dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_s32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_s64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshrn.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_s64dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_s64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_u16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshrn.u16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_u16dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_u16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_u32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshrn.u32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_u32dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_u32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrn_u64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshrn.u64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrn_u64dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrn_u64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrun_s16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshrun.s16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrun_s16dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrun_s16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrun_s32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshrun.s32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrun_s32dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrun_s32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqshrun_s64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqshrun.s64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqshrun_s64dqi(CodeType code, uint32_t addr)
{
	return new OpVqshrun_s64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqsub.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_s8(CodeType code, uint32_t addr)
{
	return new OpVqsub_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqsub.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_s16(CodeType code, uint32_t addr)
{
	return new OpVqsub_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqsub.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_s32(CodeType code, uint32_t addr)
{
	return new OpVqsub_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqsub.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_s64(CodeType code, uint32_t addr)
{
	return new OpVqsub_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqsub.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_u8(CodeType code, uint32_t addr)
{
	return new OpVqsub_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqsub.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_u16(CodeType code, uint32_t addr)
{
	return new OpVqsub_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqsub.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_u32(CodeType code, uint32_t addr)
{
	return new OpVqsub_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVqsub_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vqsub.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVqsub_u64(CodeType code, uint32_t addr)
{
	return new OpVqsub_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVraddhn_i16dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vraddhn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVraddhn_i16dq(CodeType code, uint32_t addr)
{
	return new OpVraddhn_i16dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVraddhn_i32dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vraddhn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVraddhn_i32dq(CodeType code, uint32_t addr)
{
	return new OpVraddhn_i32dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVraddhn_i64dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vraddhn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVraddhn_i64dq(CodeType code, uint32_t addr)
{
	return new OpVraddhn_i64dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrecpe_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrecpe.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrecpe_f32(CodeType code, uint32_t addr)
{
	return new OpVrecpe_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrecpe_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrecpe.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrecpe_u32(CodeType code, uint32_t addr)
{
	return new OpVrecpe_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrecps_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrecps.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrecps_f32(CodeType code, uint32_t addr)
{
	return new OpVrecps_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrev_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrev" << (64 >> op) << ".8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVrev_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, reverse_mask = (elements-1) >> op;

		U8 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		res[dd][idx] = cpu.GetVDE( vm+dd, idx ^ reverse_mask, U8() );

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrev_8(CodeType code, uint32_t addr)
{
	return new OpVrev_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrev_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrev" << (64 >> op) << ".16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVrev_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, reverse_mask = (elements-1) >> op;

		U16 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		res[dd][idx] = cpu.GetVDE( vm+dd, idx ^ reverse_mask, U16() );

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrev_16(CodeType code, uint32_t addr)
{
	return new OpVrev_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrev_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrev" << (64 >> op) << ".32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVrev_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, reverse_mask = (elements-1) >> op;

		U32 res[1<<q][elements];
		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		res[dd][idx] = cpu.GetVDE( vm+dd, idx ^ reverse_mask, U32() );

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, res[dd][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrev_32(CodeType code, uint32_t addr)
{
	return new OpVrev_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrhadd.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_s8(CodeType code, uint32_t addr)
{
	return new OpVrhadd_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrhadd.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_s16(CodeType code, uint32_t addr)
{
	return new OpVrhadd_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrhadd.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_s32(CodeType code, uint32_t addr)
{
	return new OpVrhadd_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrhadd.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_u8(CodeType code, uint32_t addr)
{
	return new OpVrhadd_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrhadd.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_u16(CodeType code, uint32_t addr)
{
	return new OpVrhadd_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrhadd_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrhadd.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrhadd_u32(CodeType code, uint32_t addr)
{
	return new OpVrhadd_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_s8(CodeType code, uint32_t addr)
{
	return new OpVrshl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_s16(CodeType code, uint32_t addr)
{
	return new OpVrshl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_s32(CodeType code, uint32_t addr)
{
	return new OpVrshl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_s64(CodeType code, uint32_t addr)
{
	return new OpVrshl_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_u8(CodeType code, uint32_t addr)
{
	return new OpVrshl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_u16(CodeType code, uint32_t addr)
{
	return new OpVrshl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_u32(CodeType code, uint32_t addr)
{
	return new OpVrshl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshl_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshl_u64(CodeType code, uint32_t addr)
{
	return new OpVrshl_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshr.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_s8i(CodeType code, uint32_t addr)
{
	return new OpVrshr_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshr.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_s16i(CodeType code, uint32_t addr)
{
	return new OpVrshr_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshr.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_s32i(CodeType code, uint32_t addr)
{
	return new OpVrshr_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshr.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_s64i(CodeType code, uint32_t addr)
{
	return new OpVrshr_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshr.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_u8i(CodeType code, uint32_t addr)
{
	return new OpVrshr_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshr.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_u16i(CodeType code, uint32_t addr)
{
	return new OpVrshr_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshr.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_u32i(CodeType code, uint32_t addr)
{
	return new OpVrshr_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshr_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshr.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshr_u64i(CodeType code, uint32_t addr)
{
	return new OpVrshr_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshrn_i16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshrn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshrn_i16dqi(CodeType code, uint32_t addr)
{
	return new OpVrshrn_i16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshrn_i32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshrn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshrn_i32dqi(CodeType code, uint32_t addr)
{
	return new OpVrshrn_i32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrshrn_i64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrshrn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrshrn_i64dqi(CodeType code, uint32_t addr)
{
	return new OpVrshrn_i64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsqrte_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsqrte.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsqrte_f32(CodeType code, uint32_t addr)
{
	return new OpVrsqrte_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsqrte_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsqrte.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsqrte_u32(CodeType code, uint32_t addr)
{
	return new OpVrsqrte_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsqrts_f32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsqrts.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsqrts_f32(CodeType code, uint32_t addr)
{
	return new OpVrsqrts_f32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsra.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_s8i(CodeType code, uint32_t addr)
{
	return new OpVrsra_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsra.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_s16i(CodeType code, uint32_t addr)
{
	return new OpVrsra_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsra.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_s32i(CodeType code, uint32_t addr)
{
	return new OpVrsra_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsra.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_s64i(CodeType code, uint32_t addr)
{
	return new OpVrsra_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsra.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_u8i(CodeType code, uint32_t addr)
{
	return new OpVrsra_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsra.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_u16i(CodeType code, uint32_t addr)
{
	return new OpVrsra_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsra.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_u32i(CodeType code, uint32_t addr)
{
	return new OpVrsra_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsra_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsra.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsra_u64i(CodeType code, uint32_t addr)
{
	return new OpVrsra_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsubhn_i16dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsubhn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsubhn_i16dq(CodeType code, uint32_t addr)
{
	return new OpVrsubhn_i16dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsubhn_i32dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsubhn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsubhn_i32dq(CodeType code, uint32_t addr)
{
	return new OpVrsubhn_i32dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVrsubhn_i64dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vrsubhn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVrsubhn_i64dq(CodeType code, uint32_t addr)
{
	return new OpVrsubhn_i64dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshl_s8i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 8; ++idx)
		cpu.SetVDE( vd+dd, idx, U8(cpu.GetVDE( vm+dd, idx, U8() ) << imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s8i(CodeType code, uint32_t addr)
{
	return new OpVshl_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshl_s16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 4; ++idx)
		cpu.SetVDE( vd+dd, idx, U16(cpu.GetVDE( vm+dd, idx, U16() ) << imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s16i(CodeType code, uint32_t addr)
{
	return new OpVshl_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshl_s32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 2; ++idx)
		cpu.SetVDE( vd+dd, idx, U32(cpu.GetVDE( vm+dd, idx, U32() ) << imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s32i(CodeType code, uint32_t addr)
{
	return new OpVshl_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshl_s64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 1; ++idx)
		cpu.SetVDE( vd+dd, idx, U64(cpu.GetVDE( vm+dd, idx, U64() ) << imm) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s64i(CodeType code, uint32_t addr)
{
	return new OpVshl_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s8(CodeType code, uint32_t addr)
{
	return new OpVshl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s16(CodeType code, uint32_t addr)
{
	return new OpVshl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s32(CodeType code, uint32_t addr)
{
	return new OpVshl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_s64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_s64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 OP;
		unsigned const elements = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_s64(CodeType code, uint32_t addr)
{
	return new OpVshl_s64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_u8(CodeType code, uint32_t addr)
{
	return new OpVshl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_u16(CodeType code, uint32_t addr)
{
	return new OpVshl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_u32(CodeType code, uint32_t addr)
{
	return new OpVshl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshl_u64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshl.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q);
}}
template <	typename	ARCH>
void OpVshl_u64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 OP;
		unsigned const elements = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, NeonSHL(cpu.GetVDE( vm+dd, idx, OP() ), typename ARCH::S8(cpu.GetVDE( vn+dd, idx, OP() ))) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshl_u64(CodeType code, uint32_t addr)
{
	return new OpVshl_u64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshll.i8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", #8";
}}
template <	typename	ARCH>
void OpVshll_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << 8 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_i8(CodeType code, uint32_t addr)
{
	return new OpVshll_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshll.i16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", #16";
}}
template <	typename	ARCH>
void OpVshll_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << 16 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_i16(CodeType code, uint32_t addr)
{
	return new OpVshll_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshll_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshll.i32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vm, 3) << ", #32";
}}
template <	typename	ARCH>
void OpVshll_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, WOP( WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) ) << 32 ) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshll_i32(CodeType code, uint32_t addr)
{
	return new OpVshll_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshr.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_s8i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 S8;
		unsigned const shift = imm > 7 ? 7 : imm;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 8; ++idx)
		cpu.SetVDE( vd+dd, idx, S8(cpu.GetVDE( vm+dd, idx, S8() ) >> shift) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_s8i(CodeType code, uint32_t addr)
{
	return new OpVshr_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshr.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_s16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 S16;
		unsigned const shift = imm > 15 ? 15 : imm;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 4; ++idx)
		cpu.SetVDE( vd+dd, idx, S16(cpu.GetVDE( vm+dd, idx, S16() ) >> shift) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_s16i(CodeType code, uint32_t addr)
{
	return new OpVshr_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshr.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_s32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 S32;
		unsigned const shift = imm > 31 ? 31 : imm;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 2; ++idx)
		cpu.SetVDE( vd+dd, idx, S32(cpu.GetVDE( vm+dd, idx, S32() ) >> shift) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_s32i(CodeType code, uint32_t addr)
{
	return new OpVshr_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshr.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_s64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S64 S64;
		unsigned const shift = imm > 63 ? 63 : imm;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 1; ++idx)
		cpu.SetVDE( vd+dd, idx, S64(cpu.GetVDE( vm+dd, idx, S64() ) >> shift) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_s64i(CodeType code, uint32_t addr)
{
	return new OpVshr_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshr.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_u8i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		U8 mask(~(uint8_t(-1) << imm_));

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 8; ++idx)
		cpu.SetVDE( vd+dd, idx, U8(cpu.GetVDE( vm+dd, idx, U8() ) >> imm & mask) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_u8i(CodeType code, uint32_t addr)
{
	return new OpVshr_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshr.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_u16i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 U16;
		U16 mask(~(uint16_t(-1) << imm_));

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 4; ++idx)
		cpu.SetVDE( vd+dd, idx, U16(cpu.GetVDE( vm+dd, idx, U16() ) >> imm & mask) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_u16i(CodeType code, uint32_t addr)
{
	return new OpVshr_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshr.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_u32i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		U32 mask(~(uint32_t(-1) << imm_));

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 2; ++idx)
		cpu.SetVDE( vd+dd, idx, U32(cpu.GetVDE( vm+dd, idx, U32() ) >> imm & mask) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_u32i(CodeType code, uint32_t addr)
{
	return new OpVshr_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshr_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshr.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}
template <	typename	ARCH>
void OpVshr_u64i<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 U64;
		U64 mask(~(uint64_t(-1) << imm_));

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < 1; ++idx)
		cpu.SetVDE( vd+dd, idx, U64(cpu.GetVDE( vm+dd, idx, U64() ) >> imm & mask) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshr_u64i(CodeType code, uint32_t addr)
{
	return new OpVshr_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshrn_i16dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshrn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshrn_i16dqi(CodeType code, uint32_t addr)
{
	return new OpVshrn_i16dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshrn_i32dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshrn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshrn_i32dqi(CodeType code, uint32_t addr)
{
	return new OpVshrn_i32dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVshrn_i64dqi<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vshrn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vm>>1, 4) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVshrn_i64dqi(CodeType code, uint32_t addr)
{
	return new OpVshrn_i64dqi<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsli_8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsli.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsli_8i(CodeType code, uint32_t addr)
{
	return new OpVsli_8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsli_16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsli.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsli_16i(CodeType code, uint32_t addr)
{
	return new OpVsli_16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsli_32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsli.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsli_32i(CodeType code, uint32_t addr)
{
	return new OpVsli_32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsli_64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsli.64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsli_64i(CodeType code, uint32_t addr)
{
	return new OpVsli_64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_s8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsra.s8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_s8i(CodeType code, uint32_t addr)
{
	return new OpVsra_s8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_s16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsra.s16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_s16i(CodeType code, uint32_t addr)
{
	return new OpVsra_s16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_s32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsra.s32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_s32i(CodeType code, uint32_t addr)
{
	return new OpVsra_s32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_s64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsra.s64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_s64i(CodeType code, uint32_t addr)
{
	return new OpVsra_s64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_u8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsra.u8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_u8i(CodeType code, uint32_t addr)
{
	return new OpVsra_u8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_u16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsra.u16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_u16i(CodeType code, uint32_t addr)
{
	return new OpVsra_u16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_u32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsra.u32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_u32i(CodeType code, uint32_t addr)
{
	return new OpVsra_u32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsra_u64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsra.u64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsra_u64i(CodeType code, uint32_t addr)
{
	return new OpVsra_u64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsri_8i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsri.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsri_8i(CodeType code, uint32_t addr)
{
	return new OpVsri_8i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsri_16i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsri.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsri_16i(CodeType code, uint32_t addr)
{
	return new OpVsri_16i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsri_32i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsri.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsri_32i(CodeType code, uint32_t addr)
{
	return new OpVsri_32i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsri_64i<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsri.64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q) << ", " << DisasmI(imm);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsri_64i(CodeType code, uint32_t addr)
{
	return new OpVsri_64i<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << (vms.ses ? 1 : int(vms.regs)) << ".8\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite8(addr + U32(size*idx), cpu.GetVDE((vd+idx/elements)%32, idx%elements, U8()));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite8(addr + U32(size*idx), cpu.GetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U8()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms_8(CodeType code, uint32_t addr)
{
	return new OpVstms_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << (vms.ses ? 1 : int(vms.regs)) << ".16\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite16(addr + U32(size*idx), cpu.GetVDE((vd+idx/elements)%32, idx%elements, U16()));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite16(addr + U32(size*idx), cpu.GetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U16()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms_16(CodeType code, uint32_t addr)
{
	return new OpVstms_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << (vms.ses ? 1 : int(vms.regs)) << ".32\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		if (vms.ses)
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite32(addr + U32(size*idx), cpu.GetVDE((vd+idx/elements)%32, idx%elements, U32()));
		else
		for (unsigned idx = 0, end = vms.regs*elements; idx < end; ++idx)
		cpu.MemWrite32(addr + U32(size*idx), cpu.GetVDE((vd+idx%vms.regs)%32, idx/vms.regs, U32()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms_32(CodeType code, uint32_t addr)
{
	return new OpVstms_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms_64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << (vms.ses ? 1 : int(vms.regs)) << ".64\t" << DisasmBunch(vd, vms.regs) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms_64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U64 U64;
		unsigned const size = 8;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(vms.regs*8) : cpu.GetGPR(rm)) );

		U32 endianness = cpu.CPSR().Get(E) * U32(4);

		for (unsigned idx = 0, end = vms.regs; idx < end; ++idx)
		{
			U64 data = cpu.GetVDE((vd+idx)%32, 0, U64());
			for (unsigned part = 0; part < 2; ++part)
			cpu.MemWrite32(addr + (U32(size*idx + 4*part) ^ endianness), U32(data >> 32*part));
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms_64(CodeType code, uint32_t addr)
{
	return new OpVstms_64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms2s_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << int(regs) << ".8\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms2s_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.MemWrite8(addr + U32(size*idx), cpu.GetVDE((vd+2*(idx%regs))%32, idx/regs, U8()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms2s_8(CodeType code, uint32_t addr)
{
	return new OpVstms2s_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms2s_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << int(regs) << ".16\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms2s_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.MemWrite16(addr + U32(size*idx), cpu.GetVDE((vd+2*(idx%regs))%32, idx/regs, U16()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms2s_16(CodeType code, uint32_t addr)
{
	return new OpVstms2s_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstms2s_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << int(regs) << ".32\t" << DisasmBunch(vd, regs).dspc(true) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstms2s_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(regs*8) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0, end = regs*elements; idx < end; ++idx)
		cpu.MemWrite32(addr + U32(size*idx), cpu.GetVDE((vd+2*(idx%regs))%32, idx/regs, U32()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstms2s_32(CodeType code, uint32_t addr)
{
	return new OpVstms2s_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVst2_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst2.8\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVst2_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const elements = 8, size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.MemWrite8(addr, cpu.GetVDE(vd+q+2*reg, idx, U8()));
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVst2_8(CodeType code, uint32_t addr)
{
	return new OpVst2_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVst2_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst2.16\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVst2_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const elements = 4, size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.MemWrite16(addr, cpu.GetVDE(vd+q+2*reg, idx, U16()));
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVst2_16(CodeType code, uint32_t addr)
{
	return new OpVst2_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVst2_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst2.32\t" << DisasmBunch(vd, 4) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVst2_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const elements = 2, size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32(32) : cpu.GetGPR(rm)) );

		for (unsigned q = 0; q < 2; ++q)
		for (unsigned idx = 0; idx < elements; ++idx)
		for (unsigned reg = 0; reg < 2; ++reg)
		{
			cpu.MemWrite32(addr, cpu.GetVDE(vd+q+2*reg, idx, U32()));
			addr += U32(size);
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVst2_32(CodeType code, uint32_t addr)
{
	return new OpVst2_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstsl_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << int(regs+1) << ".8\t" << DisasmBunch(vd, regs+1).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstsl_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U8 U8;
		unsigned const size = 1;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32((regs+1)*size) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0; idx <= regs; ++idx)
		cpu.MemWrite8(addr + U32(size*idx), cpu.GetVDE((vd+idx)%32, part, U8()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstsl_8(CodeType code, uint32_t addr)
{
	return new OpVstsl_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstsl_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << int(regs+1) << ".16\t" << DisasmBunch(vd, regs+1).dspc(ds).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstsl_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		typedef typename ARCH::U16 U16;
		unsigned const size = 2;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32((regs+1)*size) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0; idx <= regs; ++idx)
		cpu.MemWrite16(addr + U32(size*idx), cpu.GetVDE((vd+(idx<<ds))%32, part, U16()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstsl_16(CodeType code, uint32_t addr)
{
	return new OpVstsl_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVstsl_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vst" << int(regs+1) << ".32\t" << DisasmBunch(vd, regs+1).dspc(ds).lidx(part) << ", " << DisasmNeonMemoryRR(rn, rm, 8*alignment);
}}
template <	typename	ARCH>
void OpVstsl_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 U32;
		unsigned const size = 4;

		U32 addr( cpu.GetGPR(rn) );
		cpu.CheckAlignment(addr, alignment);

		if (rm != 15)
		cpu.SetGPR( rn, addr + (rm == 13 ? U32((regs+1)*size) : cpu.GetGPR(rm)) );

		for (unsigned idx = 0; idx <= regs; ++idx)
		cpu.MemWrite32(addr + U32(size*idx), cpu.GetVDE((vd+(idx<<ds))%32, part, U32()));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVstsl_32(CodeType code, uint32_t addr)
{
	return new OpVstsl_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_f32v<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsub.f32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_f32v(CodeType code, uint32_t addr)
{
	return new OpVsub_f32v<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsub.i8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVsub_i8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) - cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_i8(CodeType code, uint32_t addr)
{
	return new OpVsub_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_i16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsub.i16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVsub_i16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) - cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_i16(CodeType code, uint32_t addr)
{
	return new OpVsub_i16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_i32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsub.i32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVsub_i32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) - cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_i32(CodeType code, uint32_t addr)
{
	return new OpVsub_i32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsub_i64<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsub.i64\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVsub_i64<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U64 OP;
		unsigned const elements = 1;

		// CheckAdvSIMDEnabled();
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		cpu.SetVDE( vd+dd, idx, OP(cpu.GetVDE( vn+dd, idx, OP() ) - cpu.GetVDE( vm+dd, idx, OP() )) );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsub_i64(CodeType code, uint32_t addr)
{
	return new OpVsub_i64<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubhn_i16dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubhn.i16\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubhn_i16dq(CodeType code, uint32_t addr)
{
	return new OpVsubhn_i16dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubhn_i32dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubhn.i32\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubhn_i32dq(CodeType code, uint32_t addr)
{
	return new OpVsubhn_i32dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubhn_i64dq<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubhn.i64\t" << DisasmV(vd, 3) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm>>1, 4);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubhn_i64dq(CodeType code, uint32_t addr)
{
	return new OpVsubhn_i64dq<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubl.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_s8(CodeType code, uint32_t addr)
{
	return new OpVsubl_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubl.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_s16(CodeType code, uint32_t addr)
{
	return new OpVsubl_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubl.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_s32(CodeType code, uint32_t addr)
{
	return new OpVsubl_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubl.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_u8(CodeType code, uint32_t addr)
{
	return new OpVsubl_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubl.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_u16(CodeType code, uint32_t addr)
{
	return new OpVsubl_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubl_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubl.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn, 3) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubl_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = WOP( cpu.GetVDE( vn, subs*q+idx, OP() ) ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubl_u32(CodeType code, uint32_t addr)
{
	return new OpVsubl_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_s8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubw.s8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_s8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S8 OP;
		typedef typename ARCH::S16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_s8(CodeType code, uint32_t addr)
{
	return new OpVsubw_s8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_s16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubw.s16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_s16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S16 OP;
		typedef typename ARCH::S32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_s16(CodeType code, uint32_t addr)
{
	return new OpVsubw_s16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_s32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubw.s32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_s32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::S32 OP;
		typedef typename ARCH::S64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_s32(CodeType code, uint32_t addr)
{
	return new OpVsubw_s32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_u8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubw.u8\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_u8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		typedef typename ARCH::U16 WOP;
		unsigned const subs = 4;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_u8(CodeType code, uint32_t addr)
{
	return new OpVsubw_u8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_u16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubw.u16\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_u16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		typedef typename ARCH::U32 WOP;
		unsigned const subs = 2;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_u16(CodeType code, uint32_t addr)
{
	return new OpVsubw_u16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVsubw_u32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vsubw.u32\t" << DisasmV(vd>>1, 4) << ", " << DisasmV(vn>>1, 4) << ", " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVsubw_u32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		typedef typename ARCH::U64 WOP;
		unsigned const subs = 1;

		WOP res[2][subs];
		// CheckAdvSIMDEnabled();
		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		res[q][idx] = cpu.GetVDE( vn+q, idx, WOP() ) - WOP( cpu.GetVDE( vm, subs*q+idx, OP() ) );

		for (unsigned q = 0, qe = 2; q < qe; ++q)
		for (unsigned idx = 0; idx < subs; ++idx)
		cpu.SetVDE( vd+q, idx, res[q][idx] );
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVsubw_u32(CodeType code, uint32_t addr)
{
	return new OpVsubw_u32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVswp<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vswp\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVswp(CodeType code, uint32_t addr)
{
	return new OpVswp<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtbl_8d<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vtbl.8\t" << DisasmV(vd, 3) << ", {" << DisasmBunch(vn, regs+1) << "}, " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVtbl_8d<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		for (unsigned e=0; e < 8; e += 1)
		cpu.SetVDE(vd, e, cpu.GetTVU8(vn, 8, regs+1, cpu.GetVDE(vm, e, U8()), U8(0)));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtbl_8d(CodeType code, uint32_t addr)
{
	return new OpVtbl_8d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtbx_8d<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vtbx.8\t" << DisasmV(vd, 3) << ", {" << DisasmBunch(vn, regs+1) << "}, " << DisasmV(vm, 3);
}}
template <	typename	ARCH>
void OpVtbx_8d<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 U8;
		for (unsigned e=0; e < 8; e += 1)
		cpu.SetVDE(vd, e, cpu.GetTVU8(vn, 8, regs+1, cpu.GetVDE(vm, e, U8()), cpu.GetVDE(vd, e, U8())));
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtbx_8d(CodeType code, uint32_t addr)
{
	return new OpVtbx_8d<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtrn_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vtrn.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtrn_8(CodeType code, uint32_t addr)
{
	return new OpVtrn_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtrn_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vtrn.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtrn_16(CodeType code, uint32_t addr)
{
	return new OpVtrn_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtrn_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vtrn.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtrn_32(CodeType code, uint32_t addr)
{
	return new OpVtrn_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtst_i8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vtst.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtst_i8(CodeType code, uint32_t addr)
{
	return new OpVtst_i8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtst_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vtst.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtst_16(CodeType code, uint32_t addr)
{
	return new OpVtst_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVtst_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vtst.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vn>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVtst_32(CodeType code, uint32_t addr)
{
	return new OpVtst_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVuzp_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vuzp.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVuzp_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[0*pack+(dd*elements+idx)] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[1*pack+(dd*elements+idx)] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[2*(dd*elements+idx)+0] );
			cpu.SetVDE( vm+dd, idx, zipped[2*(dd*elements+idx)+1] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVuzp_8(CodeType code, uint32_t addr)
{
	return new OpVuzp_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVuzp_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vuzp.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVuzp_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[0*pack+(dd*elements+idx)] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[1*pack+(dd*elements+idx)] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[2*(dd*elements+idx)+0] );
			cpu.SetVDE( vm+dd, idx, zipped[2*(dd*elements+idx)+1] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVuzp_16(CodeType code, uint32_t addr)
{
	return new OpVuzp_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVuzp_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vuzp.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVuzp_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[0*pack+(dd*elements+idx)] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[1*pack+(dd*elements+idx)] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[2*(dd*elements+idx)+0] );
			cpu.SetVDE( vm+dd, idx, zipped[2*(dd*elements+idx)+1] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVuzp_32(CodeType code, uint32_t addr)
{
	return new OpVuzp_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVzip_8<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vzip.8\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVzip_8<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U8 OP;
		unsigned const elements = 8;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[2*(dd*elements+idx)+0] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[2*(dd*elements+idx)+1] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[0*pack+(dd*elements+idx)] );
			cpu.SetVDE( vm+dd, idx, zipped[1*pack+(dd*elements+idx)] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVzip_8(CodeType code, uint32_t addr)
{
	return new OpVzip_8<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVzip_16<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vzip.16\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVzip_16<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U16 OP;
		unsigned const elements = 4;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[2*(dd*elements+idx)+0] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[2*(dd*elements+idx)+1] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[0*pack+(dd*elements+idx)] );
			cpu.SetVDE( vm+dd, idx, zipped[1*pack+(dd*elements+idx)] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVzip_16(CodeType code, uint32_t addr)
{
	return new OpVzip_16<	ARCH>(code, addr);
}

template <	typename	ARCH>
void OpVzip_32<	ARCH>::disasm( ARCH & cpu,
std::ostream & buffer)
{
	{
		buffer << "vzip.32\t" << DisasmV(vd>>q, 3+q) << ", " << DisasmV(vm>>q, 3+q);
}}
template <	typename	ARCH>
void OpVzip_32<	ARCH>::execute( ARCH & cpu)
{
	{
		typedef typename ARCH::U32 OP;
		unsigned const elements = 2;

		// CheckAdvSIMDEnabled();
		unsigned const pack = elements<<q;
		OP zipped[2*pack];
		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			zipped[2*(dd*elements+idx)+0] = cpu.GetVDE( vd+dd, idx, OP() );
			zipped[2*(dd*elements+idx)+1] = cpu.GetVDE( vm+dd, idx, OP() );
		}

		for (unsigned dd = 0, dde = 1<<q; dd < dde; ++dd)
		for (unsigned idx = 0; idx < elements; ++idx)
		{
			cpu.SetVDE( vd+dd, idx, zipped[0*pack+(dd*elements+idx)] );
			cpu.SetVDE( vm+dd, idx, zipped[1*pack+(dd*elements+idx)] );
		}
}}

template <	typename	ARCH>
static Operation<	ARCH> *DecodeOpVzip_32(CodeType code, uint32_t addr)
{
	return new OpVzip_32<	ARCH>(code, addr);
}

template <	typename	ARCH>
OpLdrh_imm<	ARCH>::OpLdrh_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrh_imm")
{
	rn = uint8_t(code & 0xf);
	offset = uint8_t((code >> 16) & 0xff);
	w = uint8_t((code >> 24) & 0x1);
	u = uint8_t((code >> 25) & 0x1);
	p = uint8_t((code >> 26) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = ((not p) and (not w)) or (rn == 15) or (rt == 13) or (rt == 15) or (w and (rt == rn));
}

template <	typename	ARCH>
OpLdrh_reg<	ARCH>::OpLdrh_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrh_reg")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpLdrb_imm<	ARCH>::OpLdrb_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrb_imm")
{
	rn = uint8_t(code & 0xf);
	offset = uint8_t((code >> 16) & 0xff);
	w = uint8_t((code >> 24) & 0x1);
	u = uint8_t((code >> 25) & 0x1);
	p = uint8_t((code >> 26) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = ((not p) and (not w)) or (rn == 15) or (rt == 13) or (rt == 15) or (w and (rt == rn));
}

template <	typename	ARCH>
OpLdrb_reg<	ARCH>::OpLdrb_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrb_reg")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpLdrsb_imm<	ARCH>::OpLdrsb_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsb_imm")
{
	rn = uint8_t(code & 0xf);
	offset = uint8_t((code >> 16) & 0xff);
	w = uint8_t((code >> 24) & 0x1);
	u = uint8_t((code >> 25) & 0x1);
	p = uint8_t((code >> 26) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = ((not p) and (not w)) or (rn == 15) or (rt == 13) or (rt == 15) or (w and (rt == rn));
}

template <	typename	ARCH>
OpLdrsb_reg<	ARCH>::OpLdrsb_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsb_reg")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpLdrht<	ARCH>::OpLdrht(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrht")
{
	rn = uint8_t(code & 0xf);
	imm = uint8_t((code >> 16) & 0xff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrbt<	ARCH>::OpLdrbt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrbt")
{
	rn = uint8_t(code & 0xf);
	imm = uint8_t((code >> 16) & 0xff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrsbt<	ARCH>::OpLdrsbt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsbt")
{
	rn = uint8_t(code & 0xf);
	imm = uint8_t((code >> 16) & 0xff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpMov_reg_shift<	ARCH>::OpMov_reg_shift(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mov_reg_shift")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
	imm = uint8_t((code >> 6) & 0x1f);
	shift = uint8_t((code >> 11) & 0x3);
}

template <	typename	ARCH>
OpOrn<	ARCH>::OpOrn(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orn")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpOrn_rri<	ARCH>::OpOrn_rri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orn_rri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	cfim = (imm2|imm1) >= 0x400;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpOrr_w<	ARCH>::OpOrr_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orr_w")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpOrr_wrri<	ARCH>::OpOrr_wrri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orr_wrri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	cfim = (imm2|imm1) >= 0x400;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpLdr_imm<	ARCH>::OpLdr_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_imm")
{
	rn = uint8_t(code & 0xf);
	offset = uint8_t((code >> 16) & 0xff);
	w = uint8_t((code >> 24) & 0x1);
	u = uint8_t((code >> 25) & 0x1);
	p = uint8_t((code >> 26) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = ((not p) and (not w)) or (rn == 15) or (w and (rt == rn));
}

template <	typename	ARCH>
OpLdr_reg<	ARCH>::OpLdr_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_reg")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpLdrh_imm12<	ARCH>::OpLdrh_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrh_imm12")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrh_lit<	ARCH>::OpLdrh_lit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrh_lit")
{
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrsh_imm<	ARCH>::OpLdrsh_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsh_imm")
{
	rn = uint8_t(code & 0xf);
	offset = uint8_t((code >> 16) & 0xff);
	w = uint8_t((code >> 24) & 0x1);
	u = uint8_t((code >> 25) & 0x1);
	p = uint8_t((code >> 26) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = ((not p) and (not w)) or (rn == 15) or (rt == 13) or (rt == 15) or (w and (rt == rn));
}

template <	typename	ARCH>
OpLdrsh_reg<	ARCH>::OpLdrsh_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsh_reg")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpLdrb_imm12<	ARCH>::OpLdrb_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrb_imm12")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrb_lit<	ARCH>::OpLdrb_lit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrb_lit")
{
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrsb_imm12<	ARCH>::OpLdrsb_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsb_imm12")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrsb_lit<	ARCH>::OpLdrsb_lit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsb_lit")
{
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrt<	ARCH>::OpLdrt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrt")
{
	rn = uint8_t(code & 0xf);
	imm = uint8_t((code >> 16) & 0xff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrsht<	ARCH>::OpLdrsht(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsht")
{
	rn = uint8_t(code & 0xf);
	imm = uint8_t((code >> 16) & 0xff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpPld_reg<	ARCH>::OpPld_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pld_reg")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
}

template <	typename	ARCH>
OpPli_reg<	ARCH>::OpPli_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pli_reg")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
}

template <	typename	ARCH>
OpUsada8<	ARCH>::OpUsada8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usada8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	ra = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (ra == 13);
}

template <	typename	ARCH>
OpBcc_w<	ARCH>::OpBcc_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bcc_w")
{
	imm1 = uint32_t(code & 0x3f) << 12;
	cond = uint8_t((code >> 6) & 0xf);
	imm4 = ((int32_t)(((code >> 10) & 0x1) << 31) >> 31) << 20;
	imm0 = uint16_t((code >> 16) & 0x7ff) << 1;
	imm3 = uint32_t((code >> 27) & 0x1) << 19;
	imm2 = uint32_t((code >> 29) & 0x1) << 18;
	imm = imm4|imm3|imm2|imm1|imm0;
	reject = (cond & 0xe) == 0xe;
}

template <	typename	ARCH>
OpMla<	ARCH>::OpMla(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mla")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	ra = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (ra == 13) or (ra == 15);
}

template <	typename	ARCH>
OpStc<	ARCH>::OpStc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stc")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	d = uint8_t((code >> 6) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	p = uint8_t((code >> 8) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	cp_num = uint8_t((code >> 24) & 0xf);
	crd = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p) and (not u) and (not d) and (not w);
}

template <	typename	ARCH>
OpStc2<	ARCH>::OpStc2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stc2")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	d = uint8_t((code >> 6) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	p = uint8_t((code >> 8) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	cp_num = uint8_t((code >> 24) & 0xf);
	crd = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p) and (not u) and (not d) and (not w);
}

template <	typename	ARCH>
OpLdc<	ARCH>::OpLdc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldc")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	d = uint8_t((code >> 6) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	p = uint8_t((code >> 8) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	cp_num = uint8_t((code >> 24) & 0xf);
	crd = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p) and (not u) and (not d) and (not w);
}

template <	typename	ARCH>
OpLdc2<	ARCH>::OpLdc2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldc2")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	d = uint8_t((code >> 6) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	p = uint8_t((code >> 8) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	cp_num = uint8_t((code >> 24) & 0xf);
	crd = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p) and (not u) and (not d) and (not w);
}

template <	typename	ARCH>
OpCps<	ARCH>::OpCps(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cps")
{
	mode = uint8_t((code >> 16) & 0x1f);
	f = uint8_t((code >> 21) & 0x1);
	i = uint8_t((code >> 22) & 0x1);
	a = uint8_t((code >> 23) & 0x1);
	chmod = uint8_t((code >> 24) & 0x1);
	dis = uint8_t((code >> 25) & 0x1);
	chitm = uint8_t((code >> 26) & 0x1);
	reject = (not chmod and (mode != 0)) or
	(chitm xor (a or i or f)) or
	(not (chmod or chitm)) or
	(not chitm and dis);
	psr_mask = a*A.getmask<uint32_t>()|i*I.getmask<uint32_t>()|f*F.getmask<uint32_t>()|chmod*M.getmask<uint32_t>();
	psr_bits = dis*(A.getmask<uint32_t>()|I.getmask<uint32_t>()|F.getmask<uint32_t>())|mode;
}

template <	typename	ARCH>
OpVshll_s8<	ARCH>::OpVshll_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_s8")
{
	imm = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_s16<	ARCH>::OpVshll_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_s16")
{
	imm = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_s32<	ARCH>::OpVshll_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_s32")
{
	imm = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_u8<	ARCH>::OpVshll_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_u8")
{
	imm = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_u16<	ARCH>::OpVshll_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_u16")
{
	imm = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_u32<	ARCH>::OpVshll_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_u32")
{
	imm = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpAdc<	ARCH>::OpAdc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adc")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpAdd_1<	ARCH>::OpAdd_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_1")
{
	rd = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	imm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpAdd_2<	ARCH>::OpAdd_2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_2")
{
	imm = uint8_t(code & 0xff);
	rdn = uint8_t((code >> 8) & 0x7);
}

template <	typename	ARCH>
OpAdd_3<	ARCH>::OpAdd_3(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_3")
{
	rd = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpAdd_4<	ARCH>::OpAdd_4(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_4")
{
	rdn0 = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0xf);
	rdn1 = uint8_t((code >> 7) & 0x1) << 3;
	rdn = rdn1|rdn0;
}

template <	typename	ARCH>
OpAdd_4_pc<	ARCH>::OpAdd_4_pc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_4_pc")
{
	rm = uint8_t((code >> 3) & 0xf);
}

template <	typename	ARCH>
OpAdr<	ARCH>::OpAdr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adr")
{
	imm = uint16_t(code & 0xff) << 2;
	rd = uint8_t((code >> 8) & 0x7);
}

template <	typename	ARCH>
OpAdd_6<	ARCH>::OpAdd_6(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_6")
{
	imm = uint16_t(code & 0xff) << 2;
	rd = uint8_t((code >> 8) & 0x7);
}

template <	typename	ARCH>
OpAdd_7<	ARCH>::OpAdd_7(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_7")
{
	imm = uint16_t(code & 0x7f) << 2;
}

template <	typename	ARCH>
OpAnd<	ARCH>::OpAnd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "and")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpAsr_reg<	ARCH>::OpAsr_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "asr_reg")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpBic<	ARCH>::OpBic(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bic")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpCmn<	ARCH>::OpCmn(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmn")
{
	rn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpCmp_1<	ARCH>::OpCmp_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmp_1")
{
	imm = uint8_t(code & 0xff);
	rn = uint8_t((code >> 8) & 0x7);
}

template <	typename	ARCH>
OpCmp_2<	ARCH>::OpCmp_2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmp_2")
{
	rn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpCmp_3<	ARCH>::OpCmp_3(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmp_3")
{
	rn0 = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0xf);
	rn1 = uint8_t((code >> 7) & 0x1) << 3;
	rn = rn1|rn0;
	reject = ((rn < 8) and (rm < 8)) or (rn == 15) or (rm == 15);
}

template <	typename	ARCH>
OpEor<	ARCH>::OpEor(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "eor")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpLsl_reg<	ARCH>::OpLsl_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "lsl_reg")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpLsr_reg<	ARCH>::OpLsr_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "lsr_reg")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpMov_1<	ARCH>::OpMov_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mov_1")
{
	imm = uint8_t(code & 0xff);
	rd = uint8_t((code >> 8) & 0x7);
}

template <	typename	ARCH>
OpMov_3<	ARCH>::OpMov_3(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mov_3")
{
	rd0 = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0xf);
	rd1 = uint8_t((code >> 7) & 0x1) << 3;
	rd = rd1|rd0;
}

template <	typename	ARCH>
OpMov_3_pc<	ARCH>::OpMov_3_pc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mov_3_pc")
{
	rm = uint8_t((code >> 3) & 0xf);
}

template <	typename	ARCH>
OpMvn<	ARCH>::OpMvn(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mvn")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpNeg<	ARCH>::OpNeg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "neg")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpOrr<	ARCH>::OpOrr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "orr")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpRor_reg<	ARCH>::OpRor_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ror_reg")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpSbc<	ARCH>::OpSbc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbc")
{
	rdn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpSub_1<	ARCH>::OpSub_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sub_1")
{
	rd = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	imm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpSub_2<	ARCH>::OpSub_2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sub_2")
{
	imm = uint8_t(code & 0xff);
	rdn = uint8_t((code >> 8) & 0x7);
}

template <	typename	ARCH>
OpSub_3<	ARCH>::OpSub_3(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sub_3")
{
	rd = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpSub_4<	ARCH>::OpSub_4(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sub_4")
{
	imm = uint16_t(code & 0x7f) << 2;
}

template <	typename	ARCH>
OpTst<	ARCH>::OpTst(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "tst")
{
	rn = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpRev<	ARCH>::OpRev(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rev")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpRev16<	ARCH>::OpRev16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rev16")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpRevsh<	ARCH>::OpRevsh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "revsh")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpSetend<	ARCH>::OpSetend(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "setend")
{
	endianness = uint8_t((code >> 3) & 0x1);
}

template <	typename	ARCH>
OpLdr_1<	ARCH>::OpLdr_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_1")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	imm = uint8_t((code >> 6) & 0x1f) << 2;
}

template <	typename	ARCH>
OpLdr_2<	ARCH>::OpLdr_2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_2")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpLdr_lit_s<	ARCH>::OpLdr_lit_s(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_lit_s")
{
	imm = uint16_t(code & 0xff) << 2;
	rt = uint8_t((code >> 8) & 0x7);
}

template <	typename	ARCH>
OpLdr_4<	ARCH>::OpLdr_4(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_4")
{
	imm = uint16_t(code & 0xff) << 2;
	rt = uint8_t((code >> 8) & 0x7);
}

template <	typename	ARCH>
OpLdrb_1<	ARCH>::OpLdrb_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrb_1")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	imm = uint8_t((code >> 6) & 0x1f);
}

template <	typename	ARCH>
OpLdrb_2<	ARCH>::OpLdrb_2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrb_2")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpLdrh_1<	ARCH>::OpLdrh_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrh_1")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	imm = uint8_t((code >> 6) & 0x1f) << 1;
}

template <	typename	ARCH>
OpLdrh_2<	ARCH>::OpLdrh_2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrh_2")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpLdrsb<	ARCH>::OpLdrsb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsb")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpLdrsh<	ARCH>::OpLdrsh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsh")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpStr_1<	ARCH>::OpStr_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "str_1")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	imm = uint8_t((code >> 6) & 0x1f) << 2;
}

template <	typename	ARCH>
OpStr_2<	ARCH>::OpStr_2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "str_2")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpStr_3<	ARCH>::OpStr_3(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "str_3")
{
	imm = uint16_t(code & 0xff) << 2;
	rt = uint8_t((code >> 8) & 0x7);
}

template <	typename	ARCH>
OpStrb_1<	ARCH>::OpStrb_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strb_1")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	imm = uint8_t((code >> 6) & 0x1f);
}

template <	typename	ARCH>
OpStrb_2<	ARCH>::OpStrb_2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strb_2")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpStrh_1<	ARCH>::OpStrh_1(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strh_1")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	imm = uint8_t((code >> 6) & 0x1f) << 1;
}

template <	typename	ARCH>
OpStrh_2<	ARCH>::OpStrh_2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strh_2")
{
	rt = uint8_t(code & 0x7);
	rn = uint8_t((code >> 3) & 0x7);
	rm = uint8_t((code >> 6) & 0x7);
}

template <	typename	ARCH>
OpLdmia<	ARCH>::OpLdmia(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldmia")
{
	reglist = uint32_t(code & 0xff);
	rn = uint8_t((code >> 8) & 0x7);
	reject = (reglist == 0);
}

template <	typename	ARCH>
OpPop<	ARCH>::OpPop(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pop")
{
	reglist0 = uint8_t(code & 0xff);
	reglist1 = uint16_t((code >> 8) & 0x1) << 15;
	reglist = reglist1|reglist0;
	reject = (reglist == 0);
}

template <	typename	ARCH>
OpPush<	ARCH>::OpPush(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "push")
{
	reglist0 = uint8_t(code & 0xff);
	reglist1 = uint16_t((code >> 8) & 0x1) << 14;
	reglist = reglist1|reglist0;
	reject = (reglist == 0);
}

template <	typename	ARCH>
OpStmia<	ARCH>::OpStmia(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stmia")
{
	reglist = uint8_t(code & 0xff);
	rn = uint8_t((code >> 8) & 0x7);
	reject = (reglist == 0) or (((reglist & (reglist-1)) >> rn) & 1);
}

template <	typename	ARCH>
OpMul<	ARCH>::OpMul(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mul")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpSxtb<	ARCH>::OpSxtb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtb")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpSxth<	ARCH>::OpSxth(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxth")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpUxtb<	ARCH>::OpUxtb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtb")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpUxth<	ARCH>::OpUxth(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxth")
{
	rd = uint8_t(code & 0x7);
	rm = uint8_t((code >> 3) & 0x7);
}

template <	typename	ARCH>
OpBcc<	ARCH>::OpBcc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bcc")
{
	imm = ((int32_t)((code & 0xff) << 24) >> 24) << 1;
	cond = uint8_t((code >> 8) & 0xf);
	reject = cond == 0xe;
}

template <	typename	ARCH>
OpB<	ARCH>::OpB(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "b")
{
	imm = ((int32_t)((code & 0x7ff) << 21) >> 21) << 1;
}

template <	typename	ARCH>
OpBx<	ARCH>::OpBx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bx")
{
	rm = uint8_t((code >> 3) & 0xf);
}

template <	typename	ARCH>
OpBlx<	ARCH>::OpBlx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "blx")
{
	rm = uint8_t((code >> 3) & 0xf);
}

template <	typename	ARCH>
OpSwi<	ARCH>::OpSwi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "swi")
{
	imm = uint8_t(code & 0xff);
}

template <	typename	ARCH>
OpBkpt<	ARCH>::OpBkpt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bkpt")
{
	imm = uint8_t(code & 0xff);
}

template <	typename	ARCH>
OpCpsi<	ARCH>::OpCpsi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cpsi")
{
	f = uint8_t(code & 0x1);
	i = uint8_t((code >> 1) & 0x1);
	a = uint8_t((code >> 2) & 0x1);
	dis = uint8_t((code >> 4) & 0x1);
	reject = (not (a or i or f));
	psr_mask = a*A.getmask<uint32_t>()|i*I.getmask<uint32_t>()|f*F.getmask<uint32_t>();
	psr_bits = dis*(A.getmask<uint32_t>()|I.getmask<uint32_t>()|F.getmask<uint32_t>());
}

template <	typename	ARCH>
OpMov_wri<	ARCH>::OpMov_wri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mov_wri")
{
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	cfim = (imm2|imm1) >= 0x400;
	reject = (rd == 13) or (rd == 15);
}

template <	typename	ARCH>
OpMov_w<	ARCH>::OpMov_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mov_w")
{
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = rd == 15 or rm == 15 or ((rd == 13 or rm == 13) and (s or rd == rm));
}

template <	typename	ARCH>
OpMovt<	ARCH>::OpMovt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "movt")
{
	imm3 = uint16_t(code & 0xf) << 12;
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rsd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = imm3|imm2|imm1|imm0;
	reject = (rsd == 13) or (rsd == 15);
}

template <	typename	ARCH>
OpMovw<	ARCH>::OpMovw(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "movw")
{
	imm3 = uint16_t(code & 0xf) << 12;
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = imm3|imm2|imm1|imm0;
	reject = (rd == 13) or (rd == 15);
}

template <	typename	ARCH>
OpMvn_w<	ARCH>::OpMvn_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mvn_w")
{
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpMvn_wri<	ARCH>::OpMvn_wri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mvn_wri")
{
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	cfim = (imm2|imm1) >= 0x400;
	reject = (rd == 13) or (rd == 15);
}

template <	typename	ARCH>
OpShift_w<	ARCH>::OpShift_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shift_w")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	shift = uint8_t((code >> 5) & 0x3);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSub_w<	ARCH>::OpSub_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sub_w")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 15) or (rn == 15) or (rm == 13) or (rm == 15) or ((rd == 13) and (rn != 13));
}

template <	typename	ARCH>
OpSub_wrri<	ARCH>::OpSub_wrri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sub_wrri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	reject = (rd == 15) or (rn == 15) or ((rd == 13) and (rn != 13));
}

template <	typename	ARCH>
OpSubw<	ARCH>::OpSubw(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "subw")
{
	rn = uint8_t(code & 0xf);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = imm2|imm1|imm0;
	reject = (rd == 15) or (rn == 15) or ((rd == 13) and (rn != 13));
}

template <	typename	ARCH>
OpAdr_subw<	ARCH>::OpAdr_subw(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adr_subw")
{
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = imm2|imm1|imm0;
	reject = (rd == 13) or (rd == 15);
}

template <	typename	ARCH>
OpSbc_w<	ARCH>::OpSbc_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbc_w")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSbc_wrri<	ARCH>::OpSbc_wrri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbc_wrri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpRsb<	ARCH>::OpRsb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsb")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpRsb_rri<	ARCH>::OpRsb_rri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rsb_rri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpAdd_w<	ARCH>::OpAdd_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_w")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 15) or (rn == 15) or (rm == 13) or (rm == 15) or ((rd == 13) and (rn != 13));
}

template <	typename	ARCH>
OpAdd_wrri<	ARCH>::OpAdd_wrri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "add_wrri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	reject = (rd == 15) or (rn == 15) or ((rd == 13) and (rn != 13));
}

template <	typename	ARCH>
OpAddw<	ARCH>::OpAddw(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "addw")
{
	rn = uint8_t(code & 0xf);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = imm2|imm1|imm0;
	reject = (rd == 15) or (rn == 15) or ((rd == 13) and (rn != 13));
}

template <	typename	ARCH>
OpAdr_addw<	ARCH>::OpAdr_addw(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adr_addw")
{
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = imm2|imm1|imm0;
	reject = (rd == 13) or (rd == 15);
}

template <	typename	ARCH>
OpAdc_w<	ARCH>::OpAdc_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adc_w")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpAdc_wrri<	ARCH>::OpAdc_wrri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "adc_wrri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpEor_w<	ARCH>::OpEor_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "eor_w")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpEor_wrri<	ARCH>::OpEor_wrri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "eor_wrri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	cfim = (imm2|imm1) >= 0x400;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpBic_w<	ARCH>::OpBic_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bic_w")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpBic_wrri<	ARCH>::OpBic_wrri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bic_wrri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	cfim = (imm2|imm1) >= 0x400;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpAnd_w<	ARCH>::OpAnd_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "and_w")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpAnd_wrri<	ARCH>::OpAnd_wrri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "and_wrri")
{
	rn = uint8_t(code & 0xf);
	s = uint8_t((code >> 4) & 0x1);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	cfim = (imm2|imm1) >= 0x400;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpCmp_w<	ARCH>::OpCmp_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmp_w")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpCmp_wri<	ARCH>::OpCmp_wri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmp_wri")
{
	rn = uint8_t(code & 0xf);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	reject = (rn == 15);
}

template <	typename	ARCH>
OpCmn_w<	ARCH>::OpCmn_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmn_w")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpCmn_wri<	ARCH>::OpCmn_wri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cmn_wri")
{
	rn = uint8_t(code & 0xf);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	reject = (rn == 15);
}

template <	typename	ARCH>
OpTeq<	ARCH>::OpTeq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "teq")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpTeq_wri<	ARCH>::OpTeq_wri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "teq_wri")
{
	rn = uint8_t(code & 0xf);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	cfim = (imm2|imm1) >= 0x400;
	reject = (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpTst_w<	ARCH>::OpTst_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "tst_w")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	shift = uint8_t((code >> 20) & 0x3);
	imm0 = uint8_t((code >> 22) & 0x3);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpTst_wri<	ARCH>::OpTst_wri(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "tst_wri")
{
	rn = uint8_t(code & 0xf);
	imm2 = uint16_t((code >> 10) & 0x1) << 11;
	imm0 = uint8_t((code >> 16) & 0xff);
	imm1 = uint16_t((code >> 28) & 0x7) << 8;
	imm = ThumbExpandImm( imm2|imm1|imm0 );
	cfim = (imm2|imm1) >= 0x400;
	reject = (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpClz<	ARCH>::OpClz(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "clz")
{
	rm = uint8_t(code & 0xf);
	rm_ = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rm != rm_);
}

template <	typename	ARCH>
OpUxtab16<	ARCH>::OpUxtab16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtab16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpUxtab<	ARCH>::OpUxtab(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtab")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpUxtah<	ARCH>::OpUxtah(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtah")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpUxtb16<	ARCH>::OpUxtb16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtb16")
{
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUxtb_w<	ARCH>::OpUxtb_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxtb_w")
{
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUxth_w<	ARCH>::OpUxth_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uxth_w")
{
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSxtab16<	ARCH>::OpSxtab16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtab16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpSxtab<	ARCH>::OpSxtab(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtab")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpSxtah<	ARCH>::OpSxtah(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtah")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpSxtb16<	ARCH>::OpSxtb16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtb16")
{
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSxtb_w<	ARCH>::OpSxtb_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxtb_w")
{
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSxth_w<	ARCH>::OpSxth_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sxth_w")
{
	rm = uint8_t((code >> 16) & 0xf);
	rotate = uint8_t((code >> 20) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	ror = 8*rotate;
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUbfx<	ARCH>::OpUbfx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ubfx")
{
	rn = uint8_t(code & 0xf);
	widthm1 = uint8_t((code >> 16) & 0x1f);
	lsb0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	lsb1 = uint8_t((code >> 28) & 0x7) << 2;
	lsb = lsb1|lsb0;
	width = widthm1+1;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or ((lsb + widthm1) > 31);
}

template <	typename	ARCH>
OpSbfx<	ARCH>::OpSbfx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sbfx")
{
	rn = uint8_t(code & 0xf);
	widthm1 = uint8_t((code >> 16) & 0x1f);
	lsb0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	lsb1 = uint8_t((code >> 28) & 0x7) << 2;
	lsb = lsb1|lsb0;
	width = widthm1+1;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (lsb + widthm1) > 31;
}

template <	typename	ARCH>
OpBfi<	ARCH>::OpBfi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bfi")
{
	rn = uint8_t(code & 0xf);
	msb = uint8_t((code >> 16) & 0x1f);
	lsb0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	lsb1 = uint8_t((code >> 28) & 0x7) << 2;
	lsb = lsb1|lsb0;
	width = msb-lsb+1;
	clear = ~(((uint64_t(1) << width)-1) << lsb);
	reject = msb < lsb;
}

template <	typename	ARCH>
OpBfc<	ARCH>::OpBfc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bfc")
{
	msb = uint8_t((code >> 16) & 0x1f);
	lsb0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	lsb1 = uint8_t((code >> 28) & 0x7) << 2;
	lsb = lsb1|lsb0;
	width = msb-lsb+1;
	clear = ~(((uint64_t(1) << width)-1) << lsb);
	reject = msb < lsb;
}

template <	typename	ARCH>
OpRbit<	ARCH>::OpRbit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rbit")
{
	rm = uint8_t(code & 0xf);
	rm_ = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rm != rm_);
}

template <	typename	ARCH>
OpRev_w<	ARCH>::OpRev_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rev_w")
{
	rm = uint8_t(code & 0xf);
	rm_ = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rm != rm_);
}

template <	typename	ARCH>
OpRev16_w<	ARCH>::OpRev16_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rev16_w")
{
	rm = uint8_t(code & 0xf);
	rm_ = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rm != rm_);
}

template <	typename	ARCH>
OpRevsh_w<	ARCH>::OpRevsh_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "revsh_w")
{
	rm = uint8_t(code & 0xf);
	rm_ = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rm != rm_);
}

template <	typename	ARCH>
OpLdr_imm12<	ARCH>::OpLdr_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_imm12")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15);
}

template <	typename	ARCH>
OpLdr_lit<	ARCH>::OpLdr_lit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldr_lit")
{
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpLdrsh_imm12<	ARCH>::OpLdrsh_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsh_imm12")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrsh_lit<	ARCH>::OpLdrsh_lit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrsh_lit")
{
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpLdrd<	ARCH>::OpLdrd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrd")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	p = uint8_t((code >> 8) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	rt2 = uint8_t((code >> 24) & 0xf);
	rt1 = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (not p and not w) or (rn == 15) or (w and ((rt1 == rn) or (rt2 == rn))) or
	(rt1 == 13) or (rt1 == 15) or (rt2 == 13) or (rt2 == 15) or (rt1 == rt2);
}

template <	typename	ARCH>
OpLdrd_lit<	ARCH>::OpLdrd_lit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrd_lit")
{
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	rt2 = uint8_t((code >> 24) & 0xf);
	rt1 = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = (rt1 == 13) or (rt1 == 15) or (rt2 == 13) or (rt2 == 15) or (rt1 == rt2);
}

template <	typename	ARCH>
OpStr_imm12<	ARCH>::OpStr_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "str_imm12")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 15);
}

template <	typename	ARCH>
OpStr_imm<	ARCH>::OpStr_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "str_imm")
{
	rn = uint8_t(code & 0xf);
	offset = uint8_t((code >> 16) & 0xff);
	w = uint8_t((code >> 24) & 0x1);
	u = uint8_t((code >> 25) & 0x1);
	p = uint8_t((code >> 26) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = ((not p) and (not w)) or (rn == 15) or (rt == 15) or (w and (rt == rn));
}

template <	typename	ARCH>
OpStr_reg<	ARCH>::OpStr_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "str_reg")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpStrh_imm12<	ARCH>::OpStrh_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strh_imm12")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpStrh_imm<	ARCH>::OpStrh_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strh_imm")
{
	rn = uint8_t(code & 0xf);
	offset = uint8_t((code >> 16) & 0xff);
	w = uint8_t((code >> 24) & 0x1);
	u = uint8_t((code >> 25) & 0x1);
	p = uint8_t((code >> 26) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = ((not p) and (not w)) or (rn == 15) or (rt == 13) or (rt == 15) or (w and (rt == rn));
}

template <	typename	ARCH>
OpStrh_reg<	ARCH>::OpStrh_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strh_reg")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpStrb_imm12<	ARCH>::OpStrb_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strb_imm12")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xfff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpStrb_imm<	ARCH>::OpStrb_imm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strb_imm")
{
	rn = uint8_t(code & 0xf);
	offset = uint8_t((code >> 16) & 0xff);
	w = uint8_t((code >> 24) & 0x1);
	u = uint8_t((code >> 25) & 0x1);
	p = uint8_t((code >> 26) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = ((not p) and (not w)) or (rn == 15) or (rt == 13) or (rt == 15) or (w and (rt == rn));
}

template <	typename	ARCH>
OpStrb_reg<	ARCH>::OpStrb_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strb_reg")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	imm = uint8_t((code >> 20) & 0x3);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpStrd<	ARCH>::OpStrd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strd")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	p = uint8_t((code >> 8) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	rt2 = uint8_t((code >> 24) & 0xf);
	rt1 = uint8_t((code >> 28) & 0xf);
	imm = u?offset:-offset;
	reject = ((not p) and (not w)) or
	(w and ((rn == rt1) or (rn == rt2))) or
	(rn == 15) or (rt1 == 13) or (rt1 == 15) or (rt2 == 13) or (rt2 == 15);
}

template <	typename	ARCH>
OpStrt<	ARCH>::OpStrt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strt")
{
	rn = uint8_t(code & 0xf);
	imm = uint8_t((code >> 16) & 0xff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpStrht<	ARCH>::OpStrht(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strht")
{
	rn = uint8_t(code & 0xf);
	imm = uint8_t((code >> 16) & 0xff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpStrbt<	ARCH>::OpStrbt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strbt")
{
	rn = uint8_t(code & 0xf);
	imm = uint8_t((code >> 16) & 0xff);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rn == 15) or (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpPld_imm12<	ARCH>::OpPld_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pld_imm12")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	imm = uint16_t((code >> 16) & 0xfff);
}

template <	typename	ARCH>
OpPld_nimm<	ARCH>::OpPld_nimm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pld_nimm")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	offset = uint8_t((code >> 16) & 0xff);
	imm = -offset;
}

template <	typename	ARCH>
OpPld_lit<	ARCH>::OpPld_lit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pld_lit")
{
	w = uint8_t((code >> 5) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xfff);
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpPli_imm12<	ARCH>::OpPli_imm12(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pli_imm12")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xfff);
}

template <	typename	ARCH>
OpPli_nimm<	ARCH>::OpPli_nimm(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pli_nimm")
{
	rn = uint8_t(code & 0xf);
	offset = uint8_t((code >> 16) & 0xff);
	imm = -offset;
}

template <	typename	ARCH>
OpPli_lit<	ARCH>::OpPli_lit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pli_lit")
{
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xfff);
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpLdmdb<	ARCH>::OpLdmdb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldmdb")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	reglist = uint16_t((code >> 16) & 0xffff);
	reject = (rn == 15) or ((reglist & (reglist-1))==0) or ((reglist >> 13) & 1) or
	((reglist >> 15) & (reglist >> 14) & 1) or (w and ((reglist >> rn) & 1));
}

template <	typename	ARCH>
OpLdmia_w<	ARCH>::OpLdmia_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldmia_w")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	reglist = uint16_t((code >> 16) & 0xffff);
	reject = (rn == 15) or ((reglist & (reglist-1))==0) or ((reglist >> 13) & 1) or
	((reglist >> 15) & (reglist >> 14) & 1) or (w and ((reglist >> rn) & 1));
}

template <	typename	ARCH>
OpStmdb<	ARCH>::OpStmdb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stmdb")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	reglist = uint16_t((code >> 16) & 0xffff);
	reject = (rn == 15) or ((reglist & (reglist-1))==0) or
	((reglist >> 13) & 1) or ((reglist >> 15) & 1) or
	(w and ((reglist >> rn) & 1));
}

template <	typename	ARCH>
OpStmia_w<	ARCH>::OpStmia_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stmia_w")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	reglist = uint16_t((code >> 16) & 0xffff);
	reject = (rn == 15) or ((reglist & (reglist-1))==0) or
	((reglist >> 13) & 1) or ((reglist >> 15) & 1) or
	(w and ((reglist >> rn) & 1));
}

template <	typename	ARCH>
OpLdrex<	ARCH>::OpLdrex(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrex")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xff) << 2;
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rt == 13) or (rt == 15) or (rn == 15);
}

template <	typename	ARCH>
OpLdrexh<	ARCH>::OpLdrexh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrexh")
{
	rn = uint8_t(code & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rt == 13) or (rt == 15) or (rn == 15);
}

template <	typename	ARCH>
OpLdrexb<	ARCH>::OpLdrexb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrexb")
{
	rn = uint8_t(code & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rt == 13) or (rt == 15) or (rn == 15);
}

template <	typename	ARCH>
OpLdrexd<	ARCH>::OpLdrexd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldrexd")
{
	rn = uint8_t(code & 0xf);
	rt2 = uint8_t((code >> 24) & 0xf);
	rt1 = uint8_t((code >> 28) & 0xf);
	reject = (rt1 == 13) or (rt1 == 15) or (rt2 == 13) or (rt2 == 15) or (rt1 == rt2) or (rn == 15);
}

template <	typename	ARCH>
OpStrex<	ARCH>::OpStrex(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strex")
{
	rn = uint8_t(code & 0xf);
	imm = uint16_t((code >> 16) & 0xff) << 2;
	rd = uint8_t((code >> 24) & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rt == 13) or (rt == 15) or (rn == 15) or
	(rd == rn) or (rd == rt);
}

template <	typename	ARCH>
OpStrexh<	ARCH>::OpStrexh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strexh")
{
	rn = uint8_t(code & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rt == 13) or (rt == 15) or (rn == 15) or
	(rd == rn) or (rd == rt);
}

template <	typename	ARCH>
OpStrexb<	ARCH>::OpStrexb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strexb")
{
	rn = uint8_t(code & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rt == 13) or (rt == 15) or (rn == 15) or
	(rd == rn) or (rd == rt);
}

template <	typename	ARCH>
OpStrexd<	ARCH>::OpStrexd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "strexd")
{
	rn = uint8_t(code & 0xf);
	rd = uint8_t((code >> 16) & 0xf);
	rt2 = uint8_t((code >> 24) & 0xf);
	rt1 = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rt1 == 13) or (rt1 == 15) or (rt2 == 13) or (rt2 == 15) or (rn == 15) or
	(rd == rn) or (rd == rt1) or (rd == rt2);
}

template <	typename	ARCH>
OpClrex<	ARCH>::OpClrex(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "clrex")
{
}

template <	typename	ARCH>
OpQadd<	ARCH>::OpQadd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qadd")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpQadd16<	ARCH>::OpQadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qadd16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpQadd8<	ARCH>::OpQadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qadd8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpQsub<	ARCH>::OpQsub(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qsub")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpQsub16<	ARCH>::OpQsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qsub16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpQsub8<	ARCH>::OpQsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qsub8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpQdadd<	ARCH>::OpQdadd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qdadd")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpQdsub<	ARCH>::OpQdsub(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qdsub")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rm == 13) or (rm == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpPkh<	ARCH>::OpPkh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "pkh")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	tb = uint8_t((code >> 21) & 0x1) << 1;
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSel<	ARCH>::OpSel(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sel")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSsat<	ARCH>::OpSsat(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssat")
{
	rn = uint8_t(code & 0xf);
	sh = uint8_t((code >> 5) & 0x1) << 1;
	sat_imm = uint8_t((code >> 16) & 0x1f);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (sh and not imm);
}

template <	typename	ARCH>
OpSsat16<	ARCH>::OpSsat16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssat16")
{
	rn = uint8_t(code & 0xf);
	sat_imm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpUsat<	ARCH>::OpUsat(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usat")
{
	rn = uint8_t(code & 0xf);
	sh = uint8_t((code >> 5) & 0x1) << 1;
	sat_imm = uint8_t((code >> 16) & 0x1f);
	imm0 = uint8_t((code >> 22) & 0x3);
	rd = uint8_t((code >> 24) & 0xf);
	imm1 = uint8_t((code >> 28) & 0x7) << 2;
	imm = imm1|imm0;
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (sh and not imm);
}

template <	typename	ARCH>
OpUsat16<	ARCH>::OpUsat16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usat16")
{
	rn = uint8_t(code & 0xf);
	sat_imm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15);
}

template <	typename	ARCH>
OpUadd16<	ARCH>::OpUadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uadd16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUadd8<	ARCH>::OpUadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uadd8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUsub16<	ARCH>::OpUsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usub16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUsub8<	ARCH>::OpUsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usub8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSadd16<	ARCH>::OpSadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sadd16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSadd8<	ARCH>::OpSadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sadd8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSsub16<	ARCH>::OpSsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssub16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSsub8<	ARCH>::OpSsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssub8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUqadd16<	ARCH>::OpUqadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqadd16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUqadd8<	ARCH>::OpUqadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqadd8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUqsub16<	ARCH>::OpUqsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqsub16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUqsub8<	ARCH>::OpUqsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqsub8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUsad8<	ARCH>::OpUsad8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usad8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUhadd16<	ARCH>::OpUhadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhadd16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUhadd8<	ARCH>::OpUhadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhadd8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpShadd16<	ARCH>::OpShadd16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shadd16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpShadd8<	ARCH>::OpShadd8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shadd8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUhsub16<	ARCH>::OpUhsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhsub16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUhsub8<	ARCH>::OpUhsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhsub8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpShsub16<	ARCH>::OpShsub16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shsub16")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpShsub8<	ARCH>::OpShsub8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shsub8")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpQasx<	ARCH>::OpQasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qasx")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpQsax<	ARCH>::OpQsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "qsax")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUqasx<	ARCH>::OpUqasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqasx")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUqsax<	ARCH>::OpUqsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uqsax")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSasx<	ARCH>::OpSasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sasx")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSsax<	ARCH>::OpSsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ssax")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUasx<	ARCH>::OpUasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uasx")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUsax<	ARCH>::OpUsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "usax")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpShasx<	ARCH>::OpShasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shasx")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpShsax<	ARCH>::OpShsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "shsax")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUhasx<	ARCH>::OpUhasx(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhasx")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpUhsax<	ARCH>::OpUhsax(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "uhsax")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpBl_w<	ARCH>::OpBl_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bl_w")
{
	imm1 = ((int32_t)((code & 0x7ff) << 21) >> 21) << 12;
	imm0 = uint16_t((code >> 16) & 0x7ff) << 1;
	j2 = uint32_t((code >> 27) & 0x1) << 22;
	j1 = uint32_t((code >> 29) & 0x1) << 23;
	imm = (imm1|imm0)^j1^j2^0xc00000;
}

template <	typename	ARCH>
OpBlx_w<	ARCH>::OpBlx_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "blx_w")
{
	imm1 = ((int32_t)((code & 0x7ff) << 21) >> 21) << 12;
	imm0 = uint16_t((code >> 17) & 0x3ff) << 2;
	j2 = uint32_t((code >> 27) & 0x1) << 22;
	j1 = uint32_t((code >> 29) & 0x1) << 23;
	imm = (imm1|imm0)^j1^j2^0xc00000;
}

template <	typename	ARCH>
OpCbnz<	ARCH>::OpCbnz(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cbnz")
{
	rn = uint8_t(code & 0x7);
	imm0 = uint8_t((code >> 3) & 0x1f) << 1;
	imm1 = uint8_t((code >> 9) & 0x1) << 6;
	nz = uint8_t((code >> 11) & 0x1);
	imm = imm1 | imm0;
}

template <	typename	ARCH>
OpB_w<	ARCH>::OpB_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "b_w")
{
	imm1 = uint32_t(code & 0x3ff) << 12;
	imm4 = ((int32_t)(((code >> 10) & 0x1) << 31) >> 31) << 22;
	imm0 = uint16_t((code >> 16) & 0x7ff) << 1;
	imm2 = uint32_t((code >> 27) & 0x1) << 22;
	imm3 = uint32_t((code >> 29) & 0x1) << 23;
	imm = imm4^(imm3|imm2|imm1|imm0)^0xc00000;
}

template <	typename	ARCH>
OpBxj<	ARCH>::OpBxj(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "bxj")
{
	ra = uint8_t(code & 0xf);
}

template <	typename	ARCH>
OpIt<	ARCH>::OpIt(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "it")
{
	mask = uint8_t(code & 0xf);
	firstcond = uint8_t((code >> 4) & 0xf);
	reject = mask == 0;
}

template <	typename	ARCH>
OpNop<	ARCH>::OpNop(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "nop")
{
	idx = uint8_t((code >> 4) & 0xf);
}

template <	typename	ARCH>
OpTbb<	ARCH>::OpTbb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "tbb")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
}

template <	typename	ARCH>
OpTbh<	ARCH>::OpTbh(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "tbh")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
}

template <	typename	ARCH>
OpMul_w<	ARCH>::OpMul_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mul_w")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpMls<	ARCH>::OpMls(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mls")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
	ra = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (ra == 13) or (ra == 15);
}

template <	typename	ARCH>
OpUmull<	ARCH>::OpUmull(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "umull")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rdhi = uint8_t((code >> 24) & 0xf);
	rdlo = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 13) or (rdhi == 15) or (rdlo == 13) or (rdlo == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (rdhi == rdlo);
}

template <	typename	ARCH>
OpUmlal<	ARCH>::OpUmlal(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "umlal")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rdhi = uint8_t((code >> 24) & 0xf);
	rdlo = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 13) or (rdhi == 15) or (rdlo == 13) or (rdlo == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (rdhi == rdlo);
}

template <	typename	ARCH>
OpUmaal<	ARCH>::OpUmaal(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "umaal")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rdhi = uint8_t((code >> 24) & 0xf);
	rdlo = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 13) or (rdhi == 15) or (rdlo == 13) or (rdlo == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (rdhi == rdlo);
}

template <	typename	ARCH>
OpSmull<	ARCH>::OpSmull(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smull")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rdhi = uint8_t((code >> 24) & 0xf);
	rdlo = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 13) or (rdhi == 15) or (rdlo == 13) or (rdlo == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (rdhi == rdlo);
}

template <	typename	ARCH>
OpSdiv<	ARCH>::OpSdiv(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sdiv")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
}

template <	typename	ARCH>
OpUdiv<	ARCH>::OpUdiv(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "udiv")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rd = uint8_t((code >> 24) & 0xf);
}

template <	typename	ARCH>
OpSmlalxy<	ARCH>::OpSmlalxy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlalxy")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	m = uint8_t((code >> 20) & 0x1);
	n = uint8_t((code >> 21) & 0x1);
	rdhi = uint8_t((code >> 24) & 0xf);
	rdlo = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 13) or (rdhi == 15) or (rdlo == 13) or (rdlo == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (rdhi == rdlo);
}

template <	typename	ARCH>
OpSmlal<	ARCH>::OpSmlal(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlal")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	rdhi = uint8_t((code >> 24) & 0xf);
	rdlo = uint8_t((code >> 28) & 0xf);
	reject = (rdhi == 13) or (rdhi == 15) or (rdlo == 13) or (rdlo == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (rdhi == rdlo);
}

template <	typename	ARCH>
OpSmlaxy<	ARCH>::OpSmlaxy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlaxy")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	m = uint8_t((code >> 20) & 0x1);
	n = uint8_t((code >> 21) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	ra = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (ra == 13) or (ra == 15);
}

template <	typename	ARCH>
OpSmulxy<	ARCH>::OpSmulxy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smulxy")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	m = uint8_t((code >> 20) & 0x1);
	n = uint8_t((code >> 21) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSmlawy<	ARCH>::OpSmlawy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlawy")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	m = uint8_t((code >> 20) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	ra = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (ra == 13) or (ra == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSmulwy<	ARCH>::OpSmulwy(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smulwy")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	m = uint8_t((code >> 20) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSmlad<	ARCH>::OpSmlad(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlad")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	swap = uint8_t((code >> 20) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	ra = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (ra == 13) or (ra == 15);
}

template <	typename	ARCH>
OpSmlald<	ARCH>::OpSmlald(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlald")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	swap = uint8_t((code >> 20) & 0x1);
	rdhi = uint8_t((code >> 24) & 0xf);
	rdlo = uint8_t((code >> 28) & 0xf);
	reject = (rdlo == 13) or (rdlo == 15) or (rdhi == 13) or (rdhi == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (rdlo == rdhi);
}

template <	typename	ARCH>
OpSmlsd<	ARCH>::OpSmlsd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlsd")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	swap = uint8_t((code >> 20) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	ra = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (ra == 13) or (ra == 15);
}

template <	typename	ARCH>
OpSmlsld<	ARCH>::OpSmlsld(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smlsld")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	swap = uint8_t((code >> 20) & 0x1);
	rdhi = uint8_t((code >> 24) & 0xf);
	rdlo = uint8_t((code >> 28) & 0xf);
	reject = (rdlo == 13) or (rdlo == 15) or (rdhi == 13) or (rdhi == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (rdlo == rdhi);
}

template <	typename	ARCH>
OpSmmla<	ARCH>::OpSmmla(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smmla")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	round = uint8_t((code >> 20) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	ra = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (ra == 13) or (ra == 15);
}

template <	typename	ARCH>
OpSmmls<	ARCH>::OpSmmls(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smmls")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	round = uint8_t((code >> 20) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	ra = uint8_t((code >> 28) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15) or (ra == 13) or (ra == 15);
}

template <	typename	ARCH>
OpSmmul<	ARCH>::OpSmmul(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smmul")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	round = uint8_t((code >> 20) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSmuad<	ARCH>::OpSmuad(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smuad")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	swap = uint8_t((code >> 20) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpSmusd<	ARCH>::OpSmusd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smusd")
{
	rn = uint8_t(code & 0xf);
	rm = uint8_t((code >> 16) & 0xf);
	swap = uint8_t((code >> 20) & 0x1);
	rd = uint8_t((code >> 24) & 0xf);
	reject = (rd == 13) or (rd == 15) or (rn == 13) or (rn == 15) or (rm == 13) or (rm == 15);
}

template <	typename	ARCH>
OpMrc<	ARCH>::OpMrc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrc")
{
	crn = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 5) & 0x7);
	crm = uint8_t((code >> 16) & 0xf);
	opc2 = uint8_t((code >> 21) & 0x7);
	cp_num = uint8_t((code >> 24) & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMrc2<	ARCH>::OpMrc2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrc2")
{
	crn = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 5) & 0x7);
	crm = uint8_t((code >> 16) & 0xf);
	opc2 = uint8_t((code >> 21) & 0x7);
	cp_num = uint8_t((code >> 24) & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMcr<	ARCH>::OpMcr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mcr")
{
	crn = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 5) & 0x7);
	crm = uint8_t((code >> 16) & 0xf);
	opc2 = uint8_t((code >> 21) & 0x7);
	cp_num = uint8_t((code >> 24) & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMcr2<	ARCH>::OpMcr2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mcr2")
{
	crn = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 5) & 0x7);
	crm = uint8_t((code >> 16) & 0xf);
	opc2 = uint8_t((code >> 21) & 0x7);
	cp_num = uint8_t((code >> 24) & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpCdp<	ARCH>::OpCdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cdp")
{
	cr2 = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 4) & 0xf);
	crm = uint8_t((code >> 16) & 0xf);
	opc2 = uint8_t((code >> 21) & 0x7);
	cp_num = uint8_t((code >> 24) & 0xf);
	cr1 = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpCdp2<	ARCH>::OpCdp2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cdp2")
{
	cr2 = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 4) & 0xf);
	crm = uint8_t((code >> 16) & 0xf);
	opc2 = uint8_t((code >> 21) & 0x7);
	cp_num = uint8_t((code >> 24) & 0xf);
	cr1 = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMrrc<	ARCH>::OpMrrc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrrc")
{
	rn = uint8_t(code & 0xf);
	crm = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 20) & 0xf);
	cp_num = uint8_t((code >> 24) & 0xf);
	rd = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMrrc2<	ARCH>::OpMrrc2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrrc2")
{
	rn = uint8_t(code & 0xf);
	crm = uint8_t((code >> 16) & 0xf);
	opc1 = uint8_t((code >> 20) & 0xf);
	cp_num = uint8_t((code >> 24) & 0xf);
	rd = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMcrr<	ARCH>::OpMcrr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mcrr")
{
	r1 = uint8_t(code & 0xf);
	cr = uint8_t((code >> 16) & 0xf);
	x = uint8_t((code >> 20) & 0xf);
	cp_num = uint8_t((code >> 24) & 0xf);
	r0 = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpMcrr2<	ARCH>::OpMcrr2(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mcrr2")
{
	r1 = uint8_t(code & 0xf);
	cr = uint8_t((code >> 16) & 0xf);
	x = uint8_t((code >> 20) & 0xf);
	cp_num = uint8_t((code >> 24) & 0xf);
	r0 = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpStc_unindexed<	ARCH>::OpStc_unindexed(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stc_unindexed")
{
	rn = uint8_t(code & 0xf);
	d = uint8_t((code >> 6) & 0x1);
	option = uint8_t((code >> 16) & 0xff);
	cp_num = uint8_t((code >> 24) & 0xf);
	crd = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpStc2_unindexed<	ARCH>::OpStc2_unindexed(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "stc2_unindexed")
{
	rn = uint8_t(code & 0xf);
	d = uint8_t((code >> 6) & 0x1);
	option = uint8_t((code >> 16) & 0xff);
	cp_num = uint8_t((code >> 24) & 0xf);
	crd = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpLdc_unindexed<	ARCH>::OpLdc_unindexed(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldc_unindexed")
{
	rn = uint8_t(code & 0xf);
	d = uint8_t((code >> 6) & 0x1);
	option = uint8_t((code >> 16) & 0xff);
	cp_num = uint8_t((code >> 24) & 0xf);
	crd = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpLdc2_unindexed<	ARCH>::OpLdc2_unindexed(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "ldc2_unindexed")
{
	rn = uint8_t(code & 0xf);
	d = uint8_t((code >> 6) & 0x1);
	option = uint8_t((code >> 16) & 0xff);
	cp_num = uint8_t((code >> 24) & 0xf);
	crd = uint8_t((code >> 28) & 0xf);
}

template <	typename	ARCH>
OpCp15_mcr<	ARCH>::OpCp15_mcr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cp15_mcr")
{
	crn = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 5) & 0x7);
	crm = uint8_t((code >> 16) & 0xf);
	opc2 = uint8_t((code >> 21) & 0x7);
	rt = uint8_t((code >> 28) & 0xf);
	cp15reg = ARCH::CP15GetRegister(crn, opc1, crm, opc2);
	reject = (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpCp15_mrc<	ARCH>::OpCp15_mrc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "cp15_mrc")
{
	crn = uint8_t(code & 0xf);
	opc1 = uint8_t((code >> 5) & 0x7);
	crm = uint8_t((code >> 16) & 0xf);
	opc2 = uint8_t((code >> 21) & 0x7);
	rt = uint8_t((code >> 28) & 0xf);
	cp15reg = ARCH::CP15GetRegister(crn, opc1, crm, opc2);
	reject = (rt == 13);
}

template <	typename	ARCH>
OpNopw<	ARCH>::OpNopw(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "nopw")
{
	imm = uint8_t((code >> 16) & 0xff);
}

template <	typename	ARCH>
OpYield<	ARCH>::OpYield(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "yield")
{
}

template <	typename	ARCH>
OpYield_w<	ARCH>::OpYield_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "yield_w")
{
}

template <	typename	ARCH>
OpDbg_i<	ARCH>::OpDbg_i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "dbg_i")
{
	imm = uint8_t((code >> 16) & 0xf);
}

template <	typename	ARCH>
OpDmb<	ARCH>::OpDmb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "dmb")
{
	opt = uint8_t((code >> 16) & 0xf);
	reject = (opt & 2) == 0;
}

template <	typename	ARCH>
OpDsb<	ARCH>::OpDsb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "dsb")
{
	opt = uint8_t((code >> 16) & 0xf);
	reject = (opt & 2) == 0;
}

template <	typename	ARCH>
OpIsb<	ARCH>::OpIsb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "isb")
{
	opt = uint8_t((code >> 16) & 0xf);
	reject = opt == 15;
}

template <	typename	ARCH>
OpWfe<	ARCH>::OpWfe(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "wfe")
{
}

template <	typename	ARCH>
OpWfi<	ARCH>::OpWfi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "wfi")
{
}

template <	typename	ARCH>
OpSev<	ARCH>::OpSev(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sev")
{
}

template <	typename	ARCH>
OpWfe_w<	ARCH>::OpWfe_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "wfe_w")
{
}

template <	typename	ARCH>
OpWfi_w<	ARCH>::OpWfi_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "wfi_w")
{
}

template <	typename	ARCH>
OpSev_w<	ARCH>::OpSev_w(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "sev_w")
{
}

template <	typename	ARCH>
OpRfedb<	ARCH>::OpRfedb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rfedb")
{
	r0 = uint8_t(code & 0xf);
	x = uint8_t((code >> 5) & 0x1);
}

template <	typename	ARCH>
OpRfeia<	ARCH>::OpRfeia(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "rfeia")
{
	r0 = uint8_t(code & 0xf);
	x = uint8_t((code >> 5) & 0x1);
}

template <	typename	ARCH>
OpSrsdb<	ARCH>::OpSrsdb(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "srsdb")
{
	r0 = uint8_t(code & 0xf);
	x = uint8_t((code >> 5) & 0x1);
	imm = uint8_t((code >> 16) & 0x1f);
}

template <	typename	ARCH>
OpSrsia<	ARCH>::OpSrsia(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "srsia")
{
	r0 = uint8_t(code & 0xf);
	x = uint8_t((code >> 5) & 0x1);
	imm = uint8_t((code >> 16) & 0x1f);
}

template <	typename	ARCH>
OpSmc_i<	ARCH>::OpSmc_i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "smc_i")
{
	imm0 = uint8_t(code & 0xf);
	imm2 = uint16_t((code >> 16) & 0xf) << 12;
	imm1 = uint16_t((code >> 20) & 0xff) << 4;
	imm = imm2|imm1|imm0;
}

template <	typename	ARCH>
OpHvc_i<	ARCH>::OpHvc_i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "hvc_i")
{
	imm1 = uint16_t(code & 0xf) << 12;
	imm0 = uint16_t((code >> 16) & 0xfff);
	imm = imm1|imm0;
}

template <	typename	ARCH>
OpSubspc<	ARCH>::OpSubspc(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "subspc")
{
	imm = uint8_t((code >> 16) & 0xff);
}

template <	typename	ARCH>
OpMrs<	ARCH>::OpMrs(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "mrs")
{
	sr0 = uint8_t(code & 0xf);
	sr2 = uint8_t((code >> 4) & 0x1) << 6;
	sr1 = uint8_t((code >> 20) & 0x3) << 4;
	rd = uint8_t((code >> 24) & 0xf);
	sr = sr2|sr1|sr0;
}

template <	typename	ARCH>
OpMsr_reg<	ARCH>::OpMsr_reg(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "msr_reg")
{
	rn = uint8_t(code & 0xf);
	sr2 = uint8_t((code >> 4) & 0x1) << 6;
	sr1 = uint8_t((code >> 20) & 0x3) << 4;
	sr0 = uint8_t((code >> 24) & 0xf);
	sr = sr2|sr1|sr0;
}

template <	typename	ARCH>
OpMsr_reg_psr<	ARCH>::OpMsr_reg_psr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "msr_reg_psr")
{
	rn = uint8_t(code & 0xf);
	write_spsr = uint8_t((code >> 4) & 0x1);
	mask = uint8_t((code >> 24) & 0xf);
	psr_mask = (((mask*0x00204081)&0x01010101)*0xff) &
	(write_spsr ? -1 : ~0x0700fc20) /* Does not affect execution state bits other than E */;
}

template <	typename	ARCH>
OpVabs_f32<	ARCH>::OpVabs_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_f32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVabs_f64<	ARCH>::OpVabs_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_f64")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVadd_f32<	ARCH>::OpVadd_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVadd_f64<	ARCH>::OpVadd_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVcmp_f32d<	ARCH>::OpVcmp_f32d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcmp_f32d")
{
	vd1 = uint8_t((code >> 6) & 0x1);
	vm0 = uint8_t((code >> 16) & 0xf) << 1;
	vm1 = uint8_t((code >> 21) & 0x1);
	e = uint8_t((code >> 23) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcmp_f64d<	ARCH>::OpVcmp_f64d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcmp_f64d")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	e = uint8_t((code >> 23) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcmp_f32i<	ARCH>::OpVcmp_f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcmp_f32i")
{
	vd1 = uint8_t((code >> 6) & 0x1);
	e = uint8_t((code >> 23) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf) << 1;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcmp_f64i<	ARCH>::OpVcmp_f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcmp_f64i")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	e = uint8_t((code >> 23) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtb_f16_f32<	ARCH>::OpVcvtb_f16_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtb_f16_f32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	t = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtb_f32_f16<	ARCH>::OpVcvtb_f32_f16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtb_f32_f16")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	t = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32u32<	ARCH>::OpVcvt_f32u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64u32<	ARCH>::OpVcvt_f64u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64u32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32s32<	ARCH>::OpVcvt_f32s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32s32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64s32<	ARCH>::OpVcvt_f64s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u32f32<	ARCH>::OpVcvt_u32f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtr_u32f32<	ARCH>::OpVcvtr_u32f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtr_u32f32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u32f64<	ARCH>::OpVcvt_u32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f64")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtr_u32f64<	ARCH>::OpVcvtr_u32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtr_u32f64")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s32f32<	ARCH>::OpVcvt_s32f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtr_s32f32<	ARCH>::OpVcvtr_s32f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtr_s32f32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s32f64<	ARCH>::OpVcvt_s32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f64")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvtr_s32f64<	ARCH>::OpVcvtr_s32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvtr_s32f64")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32s16i<	ARCH>::OpVcvt_f32s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32s16i")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32s32i<	ARCH>::OpVcvt_f32s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32s32i")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64s16i<	ARCH>::OpVcvt_f64s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64s16i")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64s32i<	ARCH>::OpVcvt_f64s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64s32i")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32u16i<	ARCH>::OpVcvt_f32u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u16i")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32u32i<	ARCH>::OpVcvt_f32u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u32i")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64u16i<	ARCH>::OpVcvt_f64u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64u16i")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64u32i<	ARCH>::OpVcvt_f64u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64u32i")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s16f32i<	ARCH>::OpVcvt_s16f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s16f32i")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s16f64i<	ARCH>::OpVcvt_s16f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s16f64i")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s32f32i<	ARCH>::OpVcvt_s32f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f32i")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_s32f64i<	ARCH>::OpVcvt_s32f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f64i")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u16f32i<	ARCH>::OpVcvt_u16f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u16f32i")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u16f64i<	ARCH>::OpVcvt_u16f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u16f64i")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 16-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u32f32i<	ARCH>::OpVcvt_u32f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f32i")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_u32f64i<	ARCH>::OpVcvt_u32f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f64i")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm1 = uint8_t((code >> 16) & 0xf) << 1;
	imm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 32-(imm1|imm0);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f64f32<	ARCH>::OpVcvt_f64f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f64f32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVcvt_f32f64<	ARCH>::OpVcvt_f32f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32f64")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVdiv_f32<	ARCH>::OpVdiv_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdiv_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVdiv_f64<	ARCH>::OpVdiv_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdiv_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfma_f32<	ARCH>::OpVfma_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfma_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfma_f64<	ARCH>::OpVfma_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfma_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfms_f32<	ARCH>::OpVfms_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfms_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfms_f64<	ARCH>::OpVfms_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfms_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfnma_f32<	ARCH>::OpVfnma_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfnma_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfnma_f64<	ARCH>::OpVfnma_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfnma_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfnms_f32<	ARCH>::OpVfnms_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfnms_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVfnms_f64<	ARCH>::OpVfnms_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfnms_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVldmdb_f32<	ARCH>::OpVldmdb_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldmdb_f32")
{
	rn = uint8_t(code & 0xf);
	vd0 = uint8_t((code >> 6) & 0x1);
	regs = uint8_t((code >> 16) & 0xff);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldmdb_f64<	ARCH>::OpVldmdb_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldmdb_f64")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	fldm = uint8_t((code >> 16) & 0x1);
	regs = uint8_t((code >> 17) & 0x7f);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldmia_f32<	ARCH>::OpVldmia_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldmia_f32")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 6) & 0x1);
	regs = uint8_t((code >> 16) & 0xff);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldmia_f64<	ARCH>::OpVldmia_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldmia_f64")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	fldm = uint8_t((code >> 16) & 0x1);
	regs = uint8_t((code >> 17) & 0x7f);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldr_32<	ARCH>::OpVldr_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldr_32")
{
	rn = uint8_t(code & 0xf);
	vd0 = uint8_t((code >> 6) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vd = vd1|vd0;
	imm = u?offset:-offset;
	reject = rn == 15;
}

template <	typename	ARCH>
OpVldr_literal_32<	ARCH>::OpVldr_literal_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldr_literal_32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vd = vd1|vd0;
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpVldr_64<	ARCH>::OpVldr_64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldr_64")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = u?offset:-offset;
	reject = rn == 15;
}

template <	typename	ARCH>
OpVldr_literal_64<	ARCH>::OpVldr_literal_64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldr_literal_64")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpVmla_f32<	ARCH>::OpVmla_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmla_f64<	ARCH>::OpVmla_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd0|vd1;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmls_f32<	ARCH>::OpVmls_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmls_f64<	ARCH>::OpVmls_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd0|vd1;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmla_f32<	ARCH>::OpVnmla_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmla_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmla_f64<	ARCH>::OpVnmla_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmla_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmls_f32<	ARCH>::OpVnmls_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmls_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmls_f64<	ARCH>::OpVnmls_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmls_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmov_f32i<	ARCH>::OpVmov_f32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f32i")
{
	exp = uint8_t(code & 0x7);
	n = uint8_t((code >> 3) & 0x1);
	vd0 = uint8_t((code >> 6) & 0x1);
	man = uint8_t((code >> 16) & 0xf);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vd = vd1|vd0;
	fpimm = typename ARCH::F32(VFPExpandImm( n, exp, man ));
}

template <	typename	ARCH>
OpVmov_f64i<	ARCH>::OpVmov_f64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f64i")
{
	exp = uint8_t(code & 0x7);
	n = uint8_t((code >> 3) & 0x1);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	man = uint8_t((code >> 16) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	fpimm = typename ARCH::F64(VFPExpandImm( n, exp, man ));
}

template <	typename	ARCH>
OpVmov_f32s<	ARCH>::OpVmov_f32s(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f32s")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVmov_f64d<	ARCH>::OpVmov_f64d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f64d")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVmov_rs<	ARCH>::OpVmov_rs(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_rs")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vn0 = uint8_t((code >> 23) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmov_sr<	ARCH>::OpVmov_sr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_sr")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vn0 = uint8_t((code >> 23) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmov_ssrr<	ARCH>::OpVmov_ssrr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_ssrr")
{
	rt2 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
}

template <	typename	ARCH>
OpVmov_rrss<	ARCH>::OpVmov_rrss(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_rrss")
{
	rt2 = uint8_t(code & 0xf);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	rt = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
}

template <	typename	ARCH>
OpVmov_rrd<	ARCH>::OpVmov_rrd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_rrd")
{
	rt2 = uint8_t(code & 0xf);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vm = vm0|vm1;
}

template <	typename	ARCH>
OpVmov_drr<	ARCH>::OpVmov_drr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_drr")
{
	rt2 = uint8_t(code & 0xf);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vm = vm0|vm1;
}

template <	typename	ARCH>
OpVmrs<	ARCH>::OpVmrs(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmrs")
{
	spr = uint8_t(code & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rt == 13) or ((rt == 15) and (spr != 1));
}

template <	typename	ARCH>
OpVmsr<	ARCH>::OpVmsr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmsr")
{
	spr = uint8_t(code & 0xf);
	rt = uint8_t((code >> 28) & 0xf);
	reject = (rt == 13) or (rt == 15);
}

template <	typename	ARCH>
OpVmul_f32<	ARCH>::OpVmul_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmul_f64<	ARCH>::OpVmul_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmul_f32<	ARCH>::OpVnmul_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmul_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVnmul_f64<	ARCH>::OpVnmul_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vnmul_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVneg_f32<	ARCH>::OpVneg_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f32")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVneg_f64<	ARCH>::OpVneg_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f64")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVsqrt_f32s<	ARCH>::OpVsqrt_f32s(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsqrt_f32s")
{
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVsqrt_f64d<	ARCH>::OpVsqrt_f64d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsqrt_f64d")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstmdb_f32<	ARCH>::OpVstmdb_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstmdb_f32")
{
	rn = uint8_t(code & 0xf);
	vd0 = uint8_t((code >> 6) & 0x1);
	regs = uint8_t((code >> 16) & 0xff);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstmdb_f64<	ARCH>::OpVstmdb_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstmdb_f64")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	fstm = uint8_t((code >> 16) & 0x1);
	regs = uint8_t((code >> 17) & 0x7f);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstmia_f32<	ARCH>::OpVstmia_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstmia_f32")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	vd0 = uint8_t((code >> 6) & 0x1);
	regs = uint8_t((code >> 16) & 0xff);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstmia_f64<	ARCH>::OpVstmia_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstmia_f64")
{
	rn = uint8_t(code & 0xf);
	w = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	fstm = uint8_t((code >> 16) & 0x1);
	regs = uint8_t((code >> 17) & 0x7f);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVstr_32<	ARCH>::OpVstr_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstr_32")
{
	rn = uint8_t(code & 0xf);
	vn0 = uint8_t((code >> 6) & 0x1);
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	vn1 = uint8_t((code >> 28) & 0xf) << 1;
	vn = vn1|vn0;
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpVstr_64<	ARCH>::OpVstr_64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstr_64")
{
	rn = uint8_t(code & 0xf);
	vn1 = uint8_t((code >> 6) & 0x1) << 4;
	u = uint8_t((code >> 7) & 0x1);
	offset = uint16_t((code >> 16) & 0xff) << 2;
	vn0 = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	imm = u?offset:-offset;
}

template <	typename	ARCH>
OpVsub_f32<	ARCH>::OpVsub_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_f32")
{
	vn1 = uint8_t(code & 0xf) << 1;
	vd0 = uint8_t((code >> 6) & 0x1);
	vm1 = uint8_t((code >> 16) & 0xf) << 1;
	vm0 = uint8_t((code >> 21) & 0x1);
	vn0 = uint8_t((code >> 23) & 0x1);
	vd1 = uint8_t((code >> 28) & 0xf) << 1;
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVsub_f64<	ARCH>::OpVsub_f64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_f64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVaba_s8<	ARCH>::OpVaba_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_s16<	ARCH>::OpVaba_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_s32<	ARCH>::OpVaba_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_u8<	ARCH>::OpVaba_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_u16<	ARCH>::OpVaba_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaba_u32<	ARCH>::OpVaba_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaba_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabal_s8qd<	ARCH>::OpVabal_s8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_s8qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_s16qd<	ARCH>::OpVabal_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_s16qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_s32qd<	ARCH>::OpVabal_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_s32qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_u8qd<	ARCH>::OpVabal_u8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_u8qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_u16qd<	ARCH>::OpVabal_u16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_u16qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabal_u32qd<	ARCH>::OpVabal_u32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabal_u32qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabd_s8<	ARCH>::OpVabd_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_s16<	ARCH>::OpVabd_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_s32<	ARCH>::OpVabd_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_u8<	ARCH>::OpVabd_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_u16<	ARCH>::OpVabd_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabd_u32<	ARCH>::OpVabd_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabdl_s8qd<	ARCH>::OpVabdl_s8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_s8qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_s16qd<	ARCH>::OpVabdl_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_s16qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_s32qd<	ARCH>::OpVabdl_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_s32qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_u8qd<	ARCH>::OpVabdl_u8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_u8qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_u16qd<	ARCH>::OpVabdl_u16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_u16qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabdl_u32qd<	ARCH>::OpVabdl_u32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabdl_u32qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVabd_f32<	ARCH>::OpVabd_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabd_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVabs_s8<	ARCH>::OpVabs_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_s8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVabs_s16<	ARCH>::OpVabs_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVabs_s32<	ARCH>::OpVabs_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVabs_f32v<	ARCH>::OpVabs_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vabs_f32v")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVacge_f32<	ARCH>::OpVacge_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vacge_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVacgt_f32<	ARCH>::OpVacgt_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vacgt_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_f32v<	ARCH>::OpVadd_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_f32v")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_i8<	ARCH>::OpVadd_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_i8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_i16<	ARCH>::OpVadd_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_i16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_i32<	ARCH>::OpVadd_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_i32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVadd_i64<	ARCH>::OpVadd_i64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vadd_i64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVaddhn_i16dq<	ARCH>::OpVaddhn_i16dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddhn_i16dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vm0 | vn0) & 1;
}

template <	typename	ARCH>
OpVaddhn_i32dq<	ARCH>::OpVaddhn_i32dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddhn_i32dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vm0 | vn0) & 1;
}

template <	typename	ARCH>
OpVaddhn_i64dq<	ARCH>::OpVaddhn_i64dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddhn_i64dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vm0 | vn0) & 1;
}

template <	typename	ARCH>
OpVaddl_s8<	ARCH>::OpVaddl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_s16<	ARCH>::OpVaddl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_s32<	ARCH>::OpVaddl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_u8<	ARCH>::OpVaddl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_u16<	ARCH>::OpVaddl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddl_u32<	ARCH>::OpVaddl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddl_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVaddw_s8<	ARCH>::OpVaddw_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_s16<	ARCH>::OpVaddw_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_s32<	ARCH>::OpVaddw_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_u8<	ARCH>::OpVaddw_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_u16<	ARCH>::OpVaddw_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVaddw_u32<	ARCH>::OpVaddw_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vaddw_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVand<	ARCH>::OpVand(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vand")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVbic<	ARCH>::OpVbic(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbic")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVbic_i16i<	ARCH>::OpVbic_i16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbic_i16i")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 25) & 0x1) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVbic_i32i<	ARCH>::OpVbic_i32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbic_i32i")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 25) & 0x3) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVbif<	ARCH>::OpVbif(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbif")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVbit<	ARCH>::OpVbit(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbit")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVbsl<	ARCH>::OpVbsl(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vbsl")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVceq_f32<	ARCH>::OpVceq_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVceq_f8z<	ARCH>::OpVceq_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_f8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_f16z<	ARCH>::OpVceq_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_f16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_f32z<	ARCH>::OpVceq_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_f32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_i8z<	ARCH>::OpVceq_i8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_i16z<	ARCH>::OpVceq_i16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_i32z<	ARCH>::OpVceq_i32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVceq_i8<	ARCH>::OpVceq_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVceq_i16<	ARCH>::OpVceq_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVceq_i32<	ARCH>::OpVceq_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vceq_i32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_f8z<	ARCH>::OpVcge_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_f8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_f16z<	ARCH>::OpVcge_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_f16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_f32<	ARCH>::OpVcge_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_f32z<	ARCH>::OpVcge_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_f32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_s8z<	ARCH>::OpVcge_s8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_s16z<	ARCH>::OpVcge_s16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_s32z<	ARCH>::OpVcge_s32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcge_s8<	ARCH>::OpVcge_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_s16<	ARCH>::OpVcge_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_s32<	ARCH>::OpVcge_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_u8<	ARCH>::OpVcge_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_u16<	ARCH>::OpVcge_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcge_u32<	ARCH>::OpVcge_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcge_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_f8z<	ARCH>::OpVcgt_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_f8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_f16z<	ARCH>::OpVcgt_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_f16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_f32z<	ARCH>::OpVcgt_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_f32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_f32<	ARCH>::OpVcgt_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_s8z<	ARCH>::OpVcgt_s8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_s16z<	ARCH>::OpVcgt_s16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_s32z<	ARCH>::OpVcgt_s32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcgt_s8<	ARCH>::OpVcgt_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_s16<	ARCH>::OpVcgt_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_s32<	ARCH>::OpVcgt_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_u8<	ARCH>::OpVcgt_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_u16<	ARCH>::OpVcgt_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcgt_u32<	ARCH>::OpVcgt_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcgt_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVcle_f8z<	ARCH>::OpVcle_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_f8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_f16z<	ARCH>::OpVcle_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_f16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_f32z<	ARCH>::OpVcle_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_f32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_s8z<	ARCH>::OpVcle_s8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_s8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_s16z<	ARCH>::OpVcle_s16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_s16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcle_s32z<	ARCH>::OpVcle_s32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcle_s32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcls_s8<	ARCH>::OpVcls_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcls_s8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcls_s16<	ARCH>::OpVcls_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcls_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcls_s32<	ARCH>::OpVcls_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcls_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_f8z<	ARCH>::OpVclt_f8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_f8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_f16z<	ARCH>::OpVclt_f16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_f16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_f32z<	ARCH>::OpVclt_f32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_f32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_s8z<	ARCH>::OpVclt_s8z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_s8z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_s16z<	ARCH>::OpVclt_s16z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_s16z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclt_s32z<	ARCH>::OpVclt_s32z(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclt_s32z")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclz_i8<	ARCH>::OpVclz_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclz_i8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclz_i16<	ARCH>::OpVclz_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclz_i16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVclz_i32<	ARCH>::OpVclz_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vclz_i32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcnt_8<	ARCH>::OpVcnt_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcnt_8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_f16_f32<	ARCH>::OpVcvt_f16_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f16_f32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVcvt_f32_f16<	ARCH>::OpVcvt_f32_f16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32_f16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVcvt_f32_s32<	ARCH>::OpVcvt_f32_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_f32s32vi<	ARCH>::OpVcvt_f32s32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32s32vi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 32-imm_;
	vd = vd1|vd0;
	vm = vm1|vm0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_f32u32v<	ARCH>::OpVcvt_f32u32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u32v")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_f32u32vi<	ARCH>::OpVcvt_f32u32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_f32u32vi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_s32_f32<	ARCH>::OpVcvt_s32_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32_f32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_s32f32vi<	ARCH>::OpVcvt_s32f32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_s32f32vi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	imm = 32-imm_;
	vd = vd1|vd0;
	vm = vm1|vm0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_u32f32v<	ARCH>::OpVcvt_u32f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f32v")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVcvt_u32f32vi<	ARCH>::OpVcvt_u32f32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vcvt_u32f32vi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVdup_8dp<	ARCH>::OpVdup_8dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup_8dp")
{
	part = uint8_t((code >> 1) & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVdup_16dp<	ARCH>::OpVdup_16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup_16dp")
{
	part = uint8_t((code >> 2) & 0x3);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVdup_32dp<	ARCH>::OpVdup_32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup_32dp")
{
	part = uint8_t((code >> 3) & 0x1);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVdup8_r<	ARCH>::OpVdup8_r(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup8_r")
{
	vd0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	reject = vd0 & q or rt == 15 or rt == 13;
}

template <	typename	ARCH>
OpVdup16_r<	ARCH>::OpVdup16_r(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup16_r")
{
	vd0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	reject = vd0 & q or rt == 15 or rt == 13;
}

template <	typename	ARCH>
OpVdup32_r<	ARCH>::OpVdup32_r(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vdup32_r")
{
	vd0 = uint8_t(code & 0xf);
	q = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	reject = vd0 & q or rt == 15 or rt == 13;
}

template <	typename	ARCH>
OpVeor<	ARCH>::OpVeor(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "veor")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVext_8i<	ARCH>::OpVext_8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vext_8i")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	imm = uint8_t((code >> 24) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q or imm>>3 & ~q;
}

template <	typename	ARCH>
OpVfma_f32v<	ARCH>::OpVfma_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfma_f32v")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVfms_f32v<	ARCH>::OpVfms_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vfms_f32v")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_s8<	ARCH>::OpVhadd_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_s16<	ARCH>::OpVhadd_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_s32<	ARCH>::OpVhadd_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_u8<	ARCH>::OpVhadd_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_u16<	ARCH>::OpVhadd_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhadd_u32<	ARCH>::OpVhadd_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhadd_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_s8<	ARCH>::OpVhsub_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_s16<	ARCH>::OpVhsub_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_s32<	ARCH>::OpVhsub_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_u8<	ARCH>::OpVhsub_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_u16<	ARCH>::OpVhsub_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVhsub_u32<	ARCH>::OpVhsub_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vhsub_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVldms_8<	ARCH>::OpVldms_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	opcode = uint8_t((code >> 24) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVldms_16<	ARCH>::OpVldms_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	opcode = uint8_t((code >> 24) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVldms_32<	ARCH>::OpVldms_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	opcode = uint8_t((code >> 24) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVldms_64<	ARCH>::OpVldms_64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms_64")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	opcode = uint8_t((code >> 24) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = not vms.ses or align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVldms2s_8<	ARCH>::OpVldms2s_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms2s_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	rlist = uint8_t((code >> 26) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVldms2s_16<	ARCH>::OpVldms2s_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms2s_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	rlist = uint8_t((code >> 26) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVldms2s_32<	ARCH>::OpVldms2s_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldms2s_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	rlist = uint8_t((code >> 26) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVld2_8<	ARCH>::OpVld2_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vld2_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVld2_16<	ARCH>::OpVld2_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vld2_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVld2_32<	ARCH>::OpVld2_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vld2_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVldal_8<	ARCH>::OpVldal_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldal_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	ds = uint8_t((code >> 21) & 0x1);
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldal_16<	ARCH>::OpVldal_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldal_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	ds = uint8_t((code >> 21) & 0x1);
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldal_32<	ARCH>::OpVldal_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldal_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	ds = uint8_t((code >> 21) & 0x1);
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVldqal_8<	ARCH>::OpVldqal_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldqal_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	reject = align or vd > 30;
}

template <	typename	ARCH>
OpVldqal_16<	ARCH>::OpVldqal_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldqal_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	reject = vd > 30;
}

template <	typename	ARCH>
OpVldqal_32<	ARCH>::OpVldqal_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldqal_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	reject = vd > 30;
}

template <	typename	ARCH>
OpVldsl_8<	ARCH>::OpVldsl_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldsl_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	part = uint8_t((code >> 21) & 0x7);
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = align*(regs+1);
	reject = alignment & (alignment-1);
}

template <	typename	ARCH>
OpVldsl_16<	ARCH>::OpVldsl_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldsl_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	ds = uint8_t((code >> 21) & 0x1);
	part = uint8_t((code >> 22) & 0x3);
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = align*2*(regs+1);
	reject = (ds and regs == 0) or (alignment & (alignment-1));
}

template <	typename	ARCH>
OpVldsl_32<	ARCH>::OpVldsl_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vldsl_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	ds = uint8_t((code >> 22) & 0x1);
	part = uint8_t((code >> 23) & 0x1);
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = align==3 ? 4 : align==2 ? 16 : align==1 ? 8 : 0;
	reject = (ds and regs == 0) or ((0x8ec6 >> 4*regs >> align) & 1);
}

template <	typename	ARCH>
OpVmax_f32<	ARCH>::OpVmax_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_s8<	ARCH>::OpVmax_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_s16<	ARCH>::OpVmax_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_s32<	ARCH>::OpVmax_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_u8<	ARCH>::OpVmax_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_u16<	ARCH>::OpVmax_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmax_u32<	ARCH>::OpVmax_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmax_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_f32<	ARCH>::OpVmin_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_s8<	ARCH>::OpVmin_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_s16<	ARCH>::OpVmin_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_s32<	ARCH>::OpVmin_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_u8<	ARCH>::OpVmin_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_u16<	ARCH>::OpVmin_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmin_u32<	ARCH>::OpVmin_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmin_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmla_f32v<	ARCH>::OpVmla_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_f32v")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmla_f32dp<	ARCH>::OpVmla_f32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_f32dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVml_i8<	ARCH>::OpVml_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vml_i8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	sub = uint8_t((code >> 12) & 0x1);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVml_i16<	ARCH>::OpVml_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vml_i16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	sub = uint8_t((code >> 12) & 0x1);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVml_i32<	ARCH>::OpVml_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vml_i32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	sub = uint8_t((code >> 12) & 0x1);
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmla_i16dp<	ARCH>::OpVmla_i16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_i16dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmla_i32dp<	ARCH>::OpVmla_i32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmla_i32dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmll_s8qd<	ARCH>::OpVmll_s8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_s8qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	sub = uint8_t((code >> 25) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_s16qd<	ARCH>::OpVmll_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_s16qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	sub = uint8_t((code >> 25) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_s32qd<	ARCH>::OpVmll_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_s32qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	sub = uint8_t((code >> 25) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_u8qd<	ARCH>::OpVmll_u8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_u8qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	sub = uint8_t((code >> 25) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_u16qd<	ARCH>::OpVmll_u16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_u16qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	sub = uint8_t((code >> 25) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmll_u32qd<	ARCH>::OpVmll_u32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmll_u32qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	sub = uint8_t((code >> 25) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlal_s16qdp<	ARCH>::OpVmlal_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlal_s16qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlal_s32qdp<	ARCH>::OpVmlal_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlal_s32qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlal_u16qdp<	ARCH>::OpVmlal_u16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlal_u16qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlal_u32qdp<	ARCH>::OpVmlal_u32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlal_u32qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmls_f16dp<	ARCH>::OpVmls_f16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f16dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmls_f32v<	ARCH>::OpVmls_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f32v")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmls_f32dp<	ARCH>::OpVmls_f32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_f32dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmls_i16dp<	ARCH>::OpVmls_i16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_i16dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmls_i32dp<	ARCH>::OpVmls_i32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmls_i32dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmlsl_s16qdp<	ARCH>::OpVmlsl_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlsl_s16qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlsl_s32qdp<	ARCH>::OpVmlsl_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlsl_s32qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlsl_u16qdp<	ARCH>::OpVmlsl_u16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlsl_u16qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmlsl_u32qdp<	ARCH>::OpVmlsl_u32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmlsl_u32qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmov_f32vi<	ARCH>::OpVmov_f32vi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_f32vi")
{
	exp = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	n = uint8_t((code >> 12) & 0x1);
	man = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	fpimm = (n?-1:1)*(float((0x10+man)<<(exp^4))/128);
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i8i<	ARCH>::OpVmov_i8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i8i")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = imm2|imm1|imm0;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i16i<	ARCH>::OpVmov_i16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i16i")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 25) & 0x1) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i32i<	ARCH>::OpVmov_i32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i32i")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 25) & 0x3) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i64i<	ARCH>::OpVmov_i64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i64i")
{
	d = uint8_t(code & 0x1);
	c = uint8_t((code >> 1) & 0x1);
	b = uint8_t((code >> 2) & 0x1);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	a = uint8_t((code >> 12) & 0x1);
	h = uint8_t((code >> 16) & 0x1);
	g = uint8_t((code >> 17) & 0x1);
	f = uint8_t((code >> 18) & 0x1);
	e = uint8_t((code >> 19) & 0x1);
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = ((uint64_t(a)<<56)|(uint64_t(b)<<48)|(uint64_t(c)<<40)|(uint64_t(d)<<32)|(uint64_t(e)<<24)|(uint64_t(f)<<16)|(uint64_t(g)<<8)|(uint64_t(h)<<0))*0xff;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmov_i32in<	ARCH>::OpVmov_i32in(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_i32in")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 24) & 0x1) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (((imm2|imm1|imm0)+1) << (shift+8))-1;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmovl_s8<	ARCH>::OpVmovl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_s8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_s16<	ARCH>::OpVmovl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_s32<	ARCH>::OpVmovl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_u8<	ARCH>::OpVmovl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_u8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_u16<	ARCH>::OpVmovl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_u16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovl_u32<	ARCH>::OpVmovl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovl_u32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmovn_i16<	ARCH>::OpVmovn_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovn_i16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVmovn_i32<	ARCH>::OpVmovn_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovn_i32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVmovn_i64<	ARCH>::OpVmovn_i64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmovn_i64")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVmov_8dr<	ARCH>::OpVmov_8dr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_8dr")
{
	vd0 = uint8_t(code & 0xf);
	index1 = uint8_t((code >> 5) & 0x1) << 2;
	index0 = uint8_t((code >> 21) & 0x3);
	vd1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_16dr<	ARCH>::OpVmov_16dr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_16dr")
{
	vd0 = uint8_t(code & 0xf);
	index1 = uint8_t((code >> 5) & 0x1) << 1;
	index0 = uint8_t((code >> 22) & 0x1);
	vd1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_32dr<	ARCH>::OpVmov_32dr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_32dr")
{
	vd0 = uint8_t(code & 0xf);
	index = uint8_t((code >> 5) & 0x1);
	vd1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
}

template <	typename	ARCH>
OpVmov_s8rd<	ARCH>::OpVmov_s8rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_s8rd")
{
	vn0 = uint8_t(code & 0xf);
	index1 = uint8_t((code >> 5) & 0x1) << 2;
	index0 = uint8_t((code >> 21) & 0x3);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_u8rd<	ARCH>::OpVmov_u8rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_u8rd")
{
	vn0 = uint8_t(code & 0xf);
	index1 = uint8_t((code >> 5) & 0x1) << 2;
	index0 = uint8_t((code >> 21) & 0x3);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_s16rd<	ARCH>::OpVmov_s16rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_s16rd")
{
	vn0 = uint8_t(code & 0xf);
	index1 = uint8_t((code >> 5) & 0x1) << 1;
	index0 = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_u16rd<	ARCH>::OpVmov_u16rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_u16rd")
{
	vn0 = uint8_t(code & 0xf);
	index1 = uint8_t((code >> 5) & 0x1) << 1;
	index0 = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
	index = index1|index0;
}

template <	typename	ARCH>
OpVmov_32rd<	ARCH>::OpVmov_32rd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmov_32rd")
{
	vn0 = uint8_t(code & 0xf);
	index = uint8_t((code >> 5) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	rt = uint8_t((code >> 28) & 0xf);
	vn = vn1|vn0;
}

template <	typename	ARCH>
OpVmul_f32v<	ARCH>::OpVmul_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_f32v")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_f32dp<	ARCH>::OpVmul_f32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_f32dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmul_i8<	ARCH>::OpVmul_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_i16<	ARCH>::OpVmul_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_i32<	ARCH>::OpVmul_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_i16dp<	ARCH>::OpVmul_i16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i16dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmul_i32dp<	ARCH>::OpVmul_i32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_i32dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVmul_p8<	ARCH>::OpVmul_p8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_p8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_p16<	ARCH>::OpVmul_p16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_p16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmul_p32<	ARCH>::OpVmul_p32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmul_p32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVmull_p8qd<	ARCH>::OpVmull_p8qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_p8qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s8<	ARCH>::OpVmull_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s16<	ARCH>::OpVmull_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s32<	ARCH>::OpVmull_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u8<	ARCH>::OpVmull_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u16<	ARCH>::OpVmull_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u32<	ARCH>::OpVmull_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s16qdp<	ARCH>::OpVmull_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s16qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_s32qdp<	ARCH>::OpVmull_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_s32qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u16qdp<	ARCH>::OpVmull_u16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u16qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmull_u32qdp<	ARCH>::OpVmull_u32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmull_u32qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVmvn_i16i<	ARCH>::OpVmvn_i16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmvn_i16i")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 25) & 0x1) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmvn_i32i<	ARCH>::OpVmvn_i32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmvn_i32i")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 25) & 0x3) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmvn_i32in<	ARCH>::OpVmvn_i32in(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmvn_i32in")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 24) & 0x1) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (((imm2|imm1|imm0)+1) << (shift+8))-1;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVmvn<	ARCH>::OpVmvn(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vmvn")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_f8<	ARCH>::OpVneg_f8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_f16<	ARCH>::OpVneg_f16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_f32v<	ARCH>::OpVneg_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_f32v")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_s8<	ARCH>::OpVneg_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_s8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_s16<	ARCH>::OpVneg_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVneg_s32<	ARCH>::OpVneg_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vneg_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVorn<	ARCH>::OpVorn(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vorn")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVorr<	ARCH>::OpVorr(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vorr")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVorr_i16i<	ARCH>::OpVorr_i16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vorr_i16i")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 25) & 0x1) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVorr_i32i<	ARCH>::OpVorr_i32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vorr_i32i")
{
	imm1 = uint8_t(code & 0x7) << 4;
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	imm2 = uint8_t((code >> 12) & 0x1) << 7;
	imm0 = uint8_t((code >> 16) & 0xf);
	q = uint8_t((code >> 22) & 0x1);
	shift = uint8_t((code >> 25) & 0x3) << 3;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	imm = (imm2|imm1|imm0) << shift;
	reject = vd0 & q;
}

template <	typename	ARCH>
OpVpadal_s8<	ARCH>::OpVpadal_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_s8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_s16<	ARCH>::OpVpadal_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_s32<	ARCH>::OpVpadal_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_u8<	ARCH>::OpVpadal_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_u8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_u16<	ARCH>::OpVpadal_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_u16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadal_u32<	ARCH>::OpVpadal_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadal_u32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpadd_f32<	ARCH>::OpVpadd_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadd_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpadd_i8<	ARCH>::OpVpadd_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadd_i8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q or q;
}

template <	typename	ARCH>
OpVpadd_i16<	ARCH>::OpVpadd_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadd_i16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q or q;
}

template <	typename	ARCH>
OpVpadd_i32<	ARCH>::OpVpadd_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpadd_i32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q or q;
}

template <	typename	ARCH>
OpVpaddl_s8<	ARCH>::OpVpaddl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_s8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_s16<	ARCH>::OpVpaddl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_s32<	ARCH>::OpVpaddl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_u8<	ARCH>::OpVpaddl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_u8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_u16<	ARCH>::OpVpaddl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_u16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpaddl_u32<	ARCH>::OpVpaddl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpaddl_u32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVpmax_f32<	ARCH>::OpVpmax_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_s8<	ARCH>::OpVpmax_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_s16<	ARCH>::OpVpmax_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_s32<	ARCH>::OpVpmax_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_u8<	ARCH>::OpVpmax_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_u16<	ARCH>::OpVpmax_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmax_u32<	ARCH>::OpVpmax_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmax_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_f32<	ARCH>::OpVpmin_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_s8<	ARCH>::OpVpmin_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_s16<	ARCH>::OpVpmin_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_s32<	ARCH>::OpVpmin_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_u8<	ARCH>::OpVpmin_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_u16<	ARCH>::OpVpmin_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVpmin_u32<	ARCH>::OpVpmin_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vpmin_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqabs_s8<	ARCH>::OpVqabs_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqabs_s8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqabs_s16<	ARCH>::OpVqabs_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqabs_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqabs_s32<	ARCH>::OpVqabs_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqabs_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqadd_s8<	ARCH>::OpVqadd_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_s16<	ARCH>::OpVqadd_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_s32<	ARCH>::OpVqadd_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_s64<	ARCH>::OpVqadd_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_s64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_u8<	ARCH>::OpVqadd_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_u16<	ARCH>::OpVqadd_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_u32<	ARCH>::OpVqadd_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqadd_u64<	ARCH>::OpVqadd_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqadd_u64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqdmlal_s16qd<	ARCH>::OpVqdmlal_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlal_s16qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlal_s16qdp<	ARCH>::OpVqdmlal_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlal_s16qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlal_s32qd<	ARCH>::OpVqdmlal_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlal_s32qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlal_s32qdp<	ARCH>::OpVqdmlal_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlal_s32qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlsl_s16qd<	ARCH>::OpVqdmlsl_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlsl_s16qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlsl_s16qdp<	ARCH>::OpVqdmlsl_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlsl_s16qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlsl_s32qd<	ARCH>::OpVqdmlsl_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlsl_s32qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmlsl_s32qdp<	ARCH>::OpVqdmlsl_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmlsl_s32qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmulh_s16<	ARCH>::OpVqdmulh_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmulh_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqdmulh_s16dp<	ARCH>::OpVqdmulh_s16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmulh_s16dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVqdmulh_s32<	ARCH>::OpVqdmulh_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmulh_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqdmulh_s32dp<	ARCH>::OpVqdmulh_s32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmulh_s32dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVqdmull_s16qd<	ARCH>::OpVqdmull_s16qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmull_s16qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmull_s16qdp<	ARCH>::OpVqdmull_s16qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmull_s16qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmull_s32qd<	ARCH>::OpVqdmull_s32qd(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmull_s32qd")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqdmull_s32qdp<	ARCH>::OpVqdmull_s32qdp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqdmull_s32qdp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVqmovn_s16<	ARCH>::OpVqmovn_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_s32<	ARCH>::OpVqmovn_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_s64<	ARCH>::OpVqmovn_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_s64")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_u16<	ARCH>::OpVqmovn_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_u16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_u32<	ARCH>::OpVqmovn_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_u32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovn_u64<	ARCH>::OpVqmovn_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovn_u64")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovun_s16<	ARCH>::OpVqmovun_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovun_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovun_s32<	ARCH>::OpVqmovun_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovun_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqmovun_s64<	ARCH>::OpVqmovun_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqmovun_s64")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqneg_s8<	ARCH>::OpVqneg_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqneg_s8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqneg_s16<	ARCH>::OpVqneg_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqneg_s16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqneg_s32<	ARCH>::OpVqneg_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqneg_s32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVqrdmulh_s16<	ARCH>::OpVqrdmulh_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrdmulh_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrdmulh_s16dp<	ARCH>::OpVqrdmulh_s16dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrdmulh_s16dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0x7);
	part0 = uint8_t((code >> 19) & 0x1);
	part1 = uint8_t((code >> 21) & 0x1) << 1;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	part = part1|part0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVqrdmulh_s32<	ARCH>::OpVqrdmulh_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrdmulh_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrdmulh_s32dp<	ARCH>::OpVqrdmulh_s32dp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrdmulh_s32dp")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	q = uint8_t((code >> 12) & 0x1);
	vm = uint8_t((code >> 16) & 0xf);
	part = uint8_t((code >> 21) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_s8<	ARCH>::OpVqrshl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_s16<	ARCH>::OpVqrshl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_s32<	ARCH>::OpVqrshl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_s64<	ARCH>::OpVqrshl_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_s64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_u8<	ARCH>::OpVqrshl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_u16<	ARCH>::OpVqrshl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_u32<	ARCH>::OpVqrshl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshl_u64<	ARCH>::OpVqrshl_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshl_u64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqrshrn_s16dqi<	ARCH>::OpVqrshrn_s16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_s16dqi")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_s32dqi<	ARCH>::OpVqrshrn_s32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_s32dqi")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_s64dqi<	ARCH>::OpVqrshrn_s64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_s64dqi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_u16dqi<	ARCH>::OpVqrshrn_u16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_u16dqi")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_u32dqi<	ARCH>::OpVqrshrn_u32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_u32dqi")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrn_u64dqi<	ARCH>::OpVqrshrn_u64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrn_u64dqi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrun_s16dqi<	ARCH>::OpVqrshrun_s16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrun_s16dqi")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrun_s32dqi<	ARCH>::OpVqrshrun_s32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrun_s32dqi")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqrshrun_s64dqi<	ARCH>::OpVqrshrun_s64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqrshrun_s64dqi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshl_s8<	ARCH>::OpVqshl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_s8i<	ARCH>::OpVqshl_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s8i")
{
	imm = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_s16<	ARCH>::OpVqshl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_s16i<	ARCH>::OpVqshl_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s16i")
{
	imm = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_s32<	ARCH>::OpVqshl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_s32i<	ARCH>::OpVqshl_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s32i")
{
	imm = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_s64<	ARCH>::OpVqshl_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_s64i<	ARCH>::OpVqshl_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_s64i")
{
	imm = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_u8<	ARCH>::OpVqshl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_u8i<	ARCH>::OpVqshl_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u8i")
{
	imm = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_u16<	ARCH>::OpVqshl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_u16i<	ARCH>::OpVqshl_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u16i")
{
	imm = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_u32<	ARCH>::OpVqshl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_u32i<	ARCH>::OpVqshl_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u32i")
{
	imm = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshl_u64<	ARCH>::OpVqshl_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqshl_u64i<	ARCH>::OpVqshl_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshl_u64i")
{
	imm = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshlu_s8i<	ARCH>::OpVqshlu_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshlu_s8i")
{
	imm = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshlu_s16i<	ARCH>::OpVqshlu_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshlu_s16i")
{
	imm = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshlu_s32i<	ARCH>::OpVqshlu_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshlu_s32i")
{
	imm = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshlu_s64i<	ARCH>::OpVqshlu_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshlu_s64i")
{
	imm = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVqshrn_s16dqi<	ARCH>::OpVqshrn_s16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_s16dqi")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_s32dqi<	ARCH>::OpVqshrn_s32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_s32dqi")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_s64dqi<	ARCH>::OpVqshrn_s64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_s64dqi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_u16dqi<	ARCH>::OpVqshrn_u16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_u16dqi")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_u32dqi<	ARCH>::OpVqshrn_u32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_u32dqi")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrn_u64dqi<	ARCH>::OpVqshrn_u64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrn_u64dqi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrun_s16dqi<	ARCH>::OpVqshrun_s16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrun_s16dqi")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrun_s32dqi<	ARCH>::OpVqshrun_s32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrun_s32dqi")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqshrun_s64dqi<	ARCH>::OpVqshrun_s64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqshrun_s64dqi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVqsub_s8<	ARCH>::OpVqsub_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_s16<	ARCH>::OpVqsub_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_s32<	ARCH>::OpVqsub_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_s64<	ARCH>::OpVqsub_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_s64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_u8<	ARCH>::OpVqsub_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_u16<	ARCH>::OpVqsub_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_u32<	ARCH>::OpVqsub_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVqsub_u64<	ARCH>::OpVqsub_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vqsub_u64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVraddhn_i16dq<	ARCH>::OpVraddhn_i16dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vraddhn_i16dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVraddhn_i32dq<	ARCH>::OpVraddhn_i32dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vraddhn_i32dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVraddhn_i64dq<	ARCH>::OpVraddhn_i64dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vraddhn_i64dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVrecpe_f32<	ARCH>::OpVrecpe_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrecpe_f32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrecpe_u32<	ARCH>::OpVrecpe_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrecpe_u32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrecps_f32<	ARCH>::OpVrecps_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrecps_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrev_8<	ARCH>::OpVrev_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrev_8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	op = uint8_t((code >> 23) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or op > 2;
}

template <	typename	ARCH>
OpVrev_16<	ARCH>::OpVrev_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrev_16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	op = uint8_t((code >> 23) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or op > 1;
}

template <	typename	ARCH>
OpVrev_32<	ARCH>::OpVrev_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrev_32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	op = uint8_t((code >> 23) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or op > 0;
}

template <	typename	ARCH>
OpVrhadd_s8<	ARCH>::OpVrhadd_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_s16<	ARCH>::OpVrhadd_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_s32<	ARCH>::OpVrhadd_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_u8<	ARCH>::OpVrhadd_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_u16<	ARCH>::OpVrhadd_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrhadd_u32<	ARCH>::OpVrhadd_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrhadd_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_s8<	ARCH>::OpVrshl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_s16<	ARCH>::OpVrshl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_s32<	ARCH>::OpVrshl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_s64<	ARCH>::OpVrshl_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_s64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_u8<	ARCH>::OpVrshl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_u16<	ARCH>::OpVrshl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_u32<	ARCH>::OpVrshl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshl_u64<	ARCH>::OpVrshl_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshl_u64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrshr_s8i<	ARCH>::OpVrshr_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_s8i")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_s16i<	ARCH>::OpVrshr_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_s16i")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_s32i<	ARCH>::OpVrshr_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_s32i")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrshr_s64i<	ARCH>::OpVrshr_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_s64i")
{
	imm_ = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_u8i<	ARCH>::OpVrshr_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_u8i")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_u16i<	ARCH>::OpVrshr_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_u16i")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshr_u32i<	ARCH>::OpVrshr_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_u32i")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrshr_u64i<	ARCH>::OpVrshr_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshr_u64i")
{
	imm_ = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrshrn_i16dqi<	ARCH>::OpVrshrn_i16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshrn_i16dqi")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVrshrn_i32dqi<	ARCH>::OpVrshrn_i32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshrn_i32dqi")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVrshrn_i64dqi<	ARCH>::OpVrshrn_i64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrshrn_i64dqi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVrsqrte_f32<	ARCH>::OpVrsqrte_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsqrte_f32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrsqrte_u32<	ARCH>::OpVrsqrte_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsqrte_u32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrsqrts_f32<	ARCH>::OpVrsqrts_f32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsqrts_f32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVrsra_s8i<	ARCH>::OpVrsra_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_s8i")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_s16i<	ARCH>::OpVrsra_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_s16i")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_s32i<	ARCH>::OpVrsra_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_s32i")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrsra_s64i<	ARCH>::OpVrsra_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_s64i")
{
	imm_ = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_u8i<	ARCH>::OpVrsra_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_u8i")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_u16i<	ARCH>::OpVrsra_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_u16i")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsra_u32i<	ARCH>::OpVrsra_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_u32i")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVrsra_u64i<	ARCH>::OpVrsra_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsra_u64i")
{
	imm_ = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVrsubhn_i16dq<	ARCH>::OpVrsubhn_i16dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsubhn_i16dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVrsubhn_i32dq<	ARCH>::OpVrsubhn_i32dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsubhn_i32dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVrsubhn_i64dq<	ARCH>::OpVrsubhn_i64dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vrsubhn_i64dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVshl_s8i<	ARCH>::OpVshl_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s8i")
{
	imm = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshl_s16i<	ARCH>::OpVshl_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s16i")
{
	imm = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshl_s32i<	ARCH>::OpVshl_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s32i")
{
	imm = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshl_s64i<	ARCH>::OpVshl_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s64i")
{
	imm = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshl_s8<	ARCH>::OpVshl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_s16<	ARCH>::OpVshl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_s32<	ARCH>::OpVshl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_s64<	ARCH>::OpVshl_s64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_s64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_u8<	ARCH>::OpVshl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_u16<	ARCH>::OpVshl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_u32<	ARCH>::OpVshl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshl_u64<	ARCH>::OpVshl_u64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshl_u64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVshll_i8<	ARCH>::OpVshll_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_i8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_i16<	ARCH>::OpVshll_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_i16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshll_i32<	ARCH>::OpVshll_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshll_i32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVshr_s8i<	ARCH>::OpVshr_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_s8i")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_s16i<	ARCH>::OpVshr_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_s16i")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_s32i<	ARCH>::OpVshr_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_s32i")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVshr_s64i<	ARCH>::OpVshr_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_s64i")
{
	imm_ = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_u8i<	ARCH>::OpVshr_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_u8i")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_u16i<	ARCH>::OpVshr_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_u16i")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshr_u32i<	ARCH>::OpVshr_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_u32i")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVshr_u64i<	ARCH>::OpVshr_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshr_u64i")
{
	imm_ = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVshrn_i16dqi<	ARCH>::OpVshrn_i16dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshrn_i16dqi")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVshrn_i32dqi<	ARCH>::OpVshrn_i32dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshrn_i32dqi")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVshrn_i64dqi<	ARCH>::OpVshrn_i64dqi(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vshrn_i64dqi")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = vm0 & 1;
}

template <	typename	ARCH>
OpVsli_8i<	ARCH>::OpVsli_8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsli_8i")
{
	imm = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsli_16i<	ARCH>::OpVsli_16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsli_16i")
{
	imm = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsli_32i<	ARCH>::OpVsli_32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsli_32i")
{
	imm = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsli_64i<	ARCH>::OpVsli_64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsli_64i")
{
	imm = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_s8i<	ARCH>::OpVsra_s8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_s8i")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_s16i<	ARCH>::OpVsra_s16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_s16i")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_s32i<	ARCH>::OpVsra_s32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_s32i")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVsra_s64i<	ARCH>::OpVsra_s64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_s64i")
{
	imm_ = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_u8i<	ARCH>::OpVsra_u8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_u8i")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_u16i<	ARCH>::OpVsra_u16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_u16i")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsra_u32i<	ARCH>::OpVsra_u32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_u32i")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVsra_u64i<	ARCH>::OpVsra_u64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsra_u64i")
{
	imm_ = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsri_8i<	ARCH>::OpVsri_8i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsri_8i")
{
	imm_ = uint8_t(code & 0x7);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 8-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsri_16i<	ARCH>::OpVsri_16i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsri_16i")
{
	imm_ = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 16-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVsri_32i<	ARCH>::OpVsri_32i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsri_32i")
{
	imm_ = uint8_t(code & 0x1f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 32-imm_;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVsri_64i<	ARCH>::OpVsri_64i(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsri_64i")
{
	imm_ = uint8_t(code & 0x3f);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	imm = 64-imm_;
	reject = (vd0|vm0) & q;
}

template <	typename	ARCH>
OpVstms_8<	ARCH>::OpVstms_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	opcode = uint8_t((code >> 24) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVstms_16<	ARCH>::OpVstms_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	opcode = uint8_t((code >> 24) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVstms_32<	ARCH>::OpVstms_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	opcode = uint8_t((code >> 24) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVstms_64<	ARCH>::OpVstms_64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms_64")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	opcode = uint8_t((code >> 24) & 0xf);
	vd0 = uint8_t((code >> 28) & 0xf);
	vms = opcode;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = not vms.ses or align > (__builtin_ctz(vms.regs)+1) or (vd+vms.regs) > 32;
}

template <	typename	ARCH>
OpVstms2s_8<	ARCH>::OpVstms2s_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms2s_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	rlist = uint8_t((code >> 26) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVstms2s_16<	ARCH>::OpVstms2s_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms2s_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	rlist = uint8_t((code >> 26) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVstms2s_32<	ARCH>::OpVstms2s_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstms2s_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	rlist = uint8_t((code >> 26) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	regs = 4-rlist;
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = regs < 2 or align > (__builtin_ctz(regs)+1) or (vd+2*regs) > 33;
}

template <	typename	ARCH>
OpVst2_8<	ARCH>::OpVst2_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vst2_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVst2_16<	ARCH>::OpVst2_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vst2_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVst2_32<	ARCH>::OpVst2_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vst2_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = (align?4:0) << align;
	reject = vd+4 > 32;
}

template <	typename	ARCH>
OpVstsl_8<	ARCH>::OpVstsl_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstsl_8")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	part = uint8_t((code >> 21) & 0x7);
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = align*(regs+1);
	reject = alignment & (alignment-1) or alignment == 1 or (vd+regs) >= 32;
}

template <	typename	ARCH>
OpVstsl_16<	ARCH>::OpVstsl_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstsl_16")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x1);
	ds = uint8_t((code >> 21) & 0x1);
	part = uint8_t((code >> 22) & 0x3);
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = align*2*(regs+1);
	reject = (ds and regs == 0) or (alignment & (alignment-1)) or (vd+(regs<<ds)) >= 32;
}

template <	typename	ARCH>
OpVstsl_32<	ARCH>::OpVstsl_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vstsl_32")
{
	rn = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	rm = uint8_t((code >> 16) & 0xf);
	align = uint8_t((code >> 20) & 0x3);
	ds = uint8_t((code >> 22) & 0x1);
	part = uint8_t((code >> 23) & 0x1);
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vd = vd1|vd0;
	alignment = align==3 ? 4 : align==2 ? 16 : align==1 ? 8 : 0;
	reject = (ds and regs == 0) or ((0x8ec6 >> 4*regs >> align) & 1) or (vd+(regs<<ds)) >= 32;
}

template <	typename	ARCH>
OpVsub_f32v<	ARCH>::OpVsub_f32v(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_f32v")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsub_i8<	ARCH>::OpVsub_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_i8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsub_i16<	ARCH>::OpVsub_i16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_i16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsub_i32<	ARCH>::OpVsub_i32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_i32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsub_i64<	ARCH>::OpVsub_i64(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsub_i64")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVsubhn_i16dq<	ARCH>::OpVsubhn_i16dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubhn_i16dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVsubhn_i32dq<	ARCH>::OpVsubhn_i32dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubhn_i32dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVsubhn_i64dq<	ARCH>::OpVsubhn_i64dq(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubhn_i64dq")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vn0|vm0) & 1;
}

template <	typename	ARCH>
OpVsubl_s8<	ARCH>::OpVsubl_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_s16<	ARCH>::OpVsubl_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_s32<	ARCH>::OpVsubl_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_u8<	ARCH>::OpVsubl_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_u16<	ARCH>::OpVsubl_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubl_u32<	ARCH>::OpVsubl_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubl_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vd0 & 1;
}

template <	typename	ARCH>
OpVsubw_s8<	ARCH>::OpVsubw_s8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_s8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_s16<	ARCH>::OpVsubw_s16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_s16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_s32<	ARCH>::OpVsubw_s32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_s32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_u8<	ARCH>::OpVsubw_u8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_u8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_u16<	ARCH>::OpVsubw_u16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_u16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVsubw_u32<	ARCH>::OpVsubw_u32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vsubw_u32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0|vn0) & 1;
}

template <	typename	ARCH>
OpVswp<	ARCH>::OpVswp(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vswp")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVtbl_8d<	ARCH>::OpVtbl_8d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtbl_8d")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vn+regs >= 32;
}

template <	typename	ARCH>
OpVtbx_8d<	ARCH>::OpVtbx_8d(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtbx_8d")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	regs = uint8_t((code >> 24) & 0x3);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = vn+regs >= 32;
}

template <	typename	ARCH>
OpVtrn_8<	ARCH>::OpVtrn_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtrn_8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVtrn_16<	ARCH>::OpVtrn_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtrn_16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVtrn_32<	ARCH>::OpVtrn_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtrn_32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q;
}

template <	typename	ARCH>
OpVtst_i8<	ARCH>::OpVtst_i8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtst_i8")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVtst_16<	ARCH>::OpVtst_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtst_16")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVtst_32<	ARCH>::OpVtst_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vtst_32")
{
	vn0 = uint8_t(code & 0xf);
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vn1 = uint8_t((code >> 23) & 0x1) << 4;
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	vn = vn1|vn0;
	reject = (vd0 | vm0 | vn0) & q;
}

template <	typename	ARCH>
OpVuzp_8<	ARCH>::OpVuzp_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vuzp_8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVuzp_16<	ARCH>::OpVuzp_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vuzp_16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVuzp_32<	ARCH>::OpVuzp_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vuzp_32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = not q or (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVzip_8<	ARCH>::OpVzip_8(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vzip_8")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVzip_16<	ARCH>::OpVzip_16(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vzip_16")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
OpVzip_32<	ARCH>::OpVzip_32(CodeType code, uint32_t addr) : Operation<	ARCH>(code, addr, "vzip_32")
{
	vd1 = uint8_t((code >> 6) & 0x1) << 4;
	vm0 = uint8_t((code >> 16) & 0xf);
	vm1 = uint8_t((code >> 21) & 0x1) << 4;
	q = uint8_t((code >> 22) & 0x1);
	vd0 = uint8_t((code >> 28) & 0xf);
	vm = vm1|vm0;
	vd = vd1|vd0;
	reject = not q or (vd0 | vm0) & q or vd == vm;
}

template <	typename	ARCH>
DecodeTableEntry<	ARCH>::DecodeTableEntry(CodeType opcode, CodeType opcode_mask, Operation<	ARCH> *(*decode)(CodeType, uint32_t))
{
	this->opcode = opcode;
	this->opcode_mask = opcode_mask;
	this->decode = decode;
}

template <	typename	ARCH>
Decoder<	ARCH>::Decoder()

{
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x180ffbaUL, 0xf90ffbfUL, DecodeOpVzip_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x180ffb6UL, 0xf90ffbfUL, DecodeOpVzip_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x180ffb2UL, 0xf90ffbfUL, DecodeOpVzip_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ffbaUL, 0xf90ffbfUL, DecodeOpVuzp_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ffb6UL, 0xf90ffbfUL, DecodeOpVuzp_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ffb2UL, 0xf90ffbfUL, DecodeOpVuzp_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ef20UL, 0xf10ffb0UL, DecodeOpVtst_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ef10UL, 0xf10ffb0UL, DecodeOpVtst_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ef00UL, 0xf10ffb0UL, DecodeOpVtst_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x80ffbaUL, 0xf90ffbfUL, DecodeOpVtrn_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x80ffb6UL, 0xf90ffbfUL, DecodeOpVtrn_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x80ffb2UL, 0xf90ffbfUL, DecodeOpVtrn_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x840ffb0UL, 0xc50ffb0UL, DecodeOpVtbx_8d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ffb0UL, 0xc50ffb0UL, DecodeOpVtbl_8d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xffb2UL, 0xf90ffbfUL, DecodeOpVswp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ffa0UL, 0xf50ffb0UL, DecodeOpVsubw_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ff90UL, 0xf50ffb0UL, DecodeOpVsubw_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ff80UL, 0xf50ffb0UL, DecodeOpVsubw_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300efa0UL, 0xf50ffb0UL, DecodeOpVsubw_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ef90UL, 0xf50ffb0UL, DecodeOpVsubw_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ef80UL, 0xf50ffb0UL, DecodeOpVsubw_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffa0UL, 0xf50ffb0UL, DecodeOpVsubl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ff90UL, 0xf50ffb0UL, DecodeOpVsubl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ff80UL, 0xf50ffb0UL, DecodeOpVsubl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200efa0UL, 0xf50ffb0UL, DecodeOpVsubl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ef90UL, 0xf50ffb0UL, DecodeOpVsubl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ef80UL, 0xf50ffb0UL, DecodeOpVsubl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600efa0UL, 0xf50ffb0UL, DecodeOpVsubhn_i64dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ef90UL, 0xf50ffb0UL, DecodeOpVsubhn_i32dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ef80UL, 0xf50ffb0UL, DecodeOpVsubhn_i16dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ff30UL, 0xf10ffb0UL, DecodeOpVsub_i64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ff20UL, 0xf10ffb0UL, DecodeOpVsub_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ff10UL, 0xf10ffb0UL, DecodeOpVsub_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ff00UL, 0xf10ffb0UL, DecodeOpVsub_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd00ef20UL, 0xf10ffb0UL, DecodeOpVsub_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f980UL, 0xc00ffb0UL, DecodeOpVstsl_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400f980UL, 0xc00ffb0UL, DecodeOpVstsl_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf980UL, 0xc00ffb0UL, DecodeOpVstsl_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x380f900UL, 0xfc0ffb0UL, DecodeOpVst2_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x340f900UL, 0xfc0ffb0UL, DecodeOpVst2_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300f900UL, 0xfc0ffb0UL, DecodeOpVst2_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x180f900UL, 0x3c0ffb0UL, DecodeOpVstms2s_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x140f900UL, 0x3c0ffb0UL, DecodeOpVstms2s_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100f900UL, 0x3c0ffb0UL, DecodeOpVstms2s_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc0f900UL, 0xc0ffb0UL, DecodeOpVstms_64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x80f900UL, 0xc0ffb0UL, DecodeOpVstms_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x40f900UL, 0xc0ffb0UL, DecodeOpVstms_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf900UL, 0xc0ffb0UL, DecodeOpVstms_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x490ff80UL, 0xf90ff80UL, DecodeOpVsri_64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ffa0UL, 0xf90ffa0UL, DecodeOpVsri_32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ff90UL, 0xf90ffb0UL, DecodeOpVsri_16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ff88UL, 0xf90ffb8UL, DecodeOpVsri_8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x190ff80UL, 0xf90ff80UL, DecodeOpVsra_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ffa0UL, 0xf90ffa0UL, DecodeOpVsra_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ff90UL, 0xf90ffb0UL, DecodeOpVsra_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ff88UL, 0xf90ffb8UL, DecodeOpVsra_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x190ef80UL, 0xf90ff80UL, DecodeOpVsra_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110efa0UL, 0xf90ffa0UL, DecodeOpVsra_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ef90UL, 0xf90ffb0UL, DecodeOpVsra_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ef88UL, 0xf90ffb8UL, DecodeOpVsra_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x590ff80UL, 0xf90ff80UL, DecodeOpVsli_64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ffa0UL, 0xf90ffa0UL, DecodeOpVsli_32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ff90UL, 0xf90ffb0UL, DecodeOpVsli_16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ff88UL, 0xf90ffb8UL, DecodeOpVsli_8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810efa0UL, 0xfd0ffa0UL, DecodeOpVshrn_i64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ef90UL, 0xfd0ffb0UL, DecodeOpVshrn_i32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ef88UL, 0xfd0ffb8UL, DecodeOpVshrn_i16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x90ff80UL, 0xf90ff80UL, DecodeOpVshr_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ffa0UL, 0xf90ffa0UL, DecodeOpVshr_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ff90UL, 0xf90ffb0UL, DecodeOpVshr_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ff88UL, 0xf90ffb8UL, DecodeOpVshr_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x90ef80UL, 0xf90ff80UL, DecodeOpVshr_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10efa0UL, 0xf90ffa0UL, DecodeOpVshr_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ef90UL, 0xf90ffb0UL, DecodeOpVshr_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ef88UL, 0xf90ffb8UL, DecodeOpVshr_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ffbaUL, 0xfd0ffbfUL, DecodeOpVshll_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ffb6UL, 0xfd0ffbfUL, DecodeOpVshll_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ffb2UL, 0xfd0ffbfUL, DecodeOpVshll_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ff30UL, 0xf10ffb0UL, DecodeOpVshl_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ff20UL, 0xf10ffb0UL, DecodeOpVshl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ff10UL, 0xf10ffb0UL, DecodeOpVshl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ff00UL, 0xf10ffb0UL, DecodeOpVshl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ef30UL, 0xf10ffb0UL, DecodeOpVshl_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ef20UL, 0xf10ffb0UL, DecodeOpVshl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ef10UL, 0xf10ffb0UL, DecodeOpVshl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ef00UL, 0xf10ffb0UL, DecodeOpVshl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x590ef80UL, 0xf90ff80UL, DecodeOpVshl_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510efa0UL, 0xf90ffa0UL, DecodeOpVshl_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ef90UL, 0xf90ffb0UL, DecodeOpVshl_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ef88UL, 0xf90ffb8UL, DecodeOpVshl_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ffa0UL, 0xf50ffb0UL, DecodeOpVrsubhn_i64dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ff90UL, 0xf50ffb0UL, DecodeOpVrsubhn_i32dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ff80UL, 0xf50ffb0UL, DecodeOpVrsubhn_i16dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x390ff80UL, 0xf90ff80UL, DecodeOpVrsra_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ffa0UL, 0xf90ffa0UL, DecodeOpVrsra_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ff90UL, 0xf90ffb0UL, DecodeOpVrsra_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ff88UL, 0xf90ffb8UL, DecodeOpVrsra_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x390ef80UL, 0xf90ff80UL, DecodeOpVrsra_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310efa0UL, 0xf90ffa0UL, DecodeOpVrsra_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ef90UL, 0xf90ffb0UL, DecodeOpVrsra_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ef88UL, 0xf90ffb8UL, DecodeOpVrsra_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf10ef20UL, 0xf10ffb0UL, DecodeOpVrsqrts_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x480ffbbUL, 0xf90ffbfUL, DecodeOpVrsqrte_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x580ffbbUL, 0xf90ffbfUL, DecodeOpVrsqrte_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x850efa0UL, 0xfd0ffa0UL, DecodeOpVrshrn_i64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x850ef90UL, 0xfd0ffb0UL, DecodeOpVrshrn_i32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x850ef88UL, 0xfd0ffb8UL, DecodeOpVrshrn_i16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x290ff80UL, 0xf90ff80UL, DecodeOpVrshr_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ffa0UL, 0xf90ffa0UL, DecodeOpVrshr_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ff90UL, 0xf90ffb0UL, DecodeOpVrshr_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ff88UL, 0xf90ffb8UL, DecodeOpVrshr_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x290ef80UL, 0xf90ff80UL, DecodeOpVrshr_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210efa0UL, 0xf90ffa0UL, DecodeOpVrshr_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ef90UL, 0xf90ffb0UL, DecodeOpVrshr_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ef88UL, 0xf90ffb8UL, DecodeOpVrshr_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ff30UL, 0xf10ffb0UL, DecodeOpVrshl_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ff20UL, 0xf10ffb0UL, DecodeOpVrshl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ff10UL, 0xf10ffb0UL, DecodeOpVrshl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ff00UL, 0xf10ffb0UL, DecodeOpVrshl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ef30UL, 0xf10ffb0UL, DecodeOpVrshl_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ef20UL, 0xf10ffb0UL, DecodeOpVrshl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ef10UL, 0xf10ffb0UL, DecodeOpVrshl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ef00UL, 0xf10ffb0UL, DecodeOpVrshl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ff20UL, 0xf10ffb0UL, DecodeOpVrhadd_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ff10UL, 0xf10ffb0UL, DecodeOpVrhadd_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ff00UL, 0xf10ffb0UL, DecodeOpVrhadd_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ef20UL, 0xf10ffb0UL, DecodeOpVrhadd_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ef10UL, 0xf10ffb0UL, DecodeOpVrhadd_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ef00UL, 0xf10ffb0UL, DecodeOpVrhadd_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xffb8UL, 0xe10ffbfUL, DecodeOpVrev_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xffb4UL, 0xe10ffbfUL, DecodeOpVrev_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xffb0UL, 0xe10ffbfUL, DecodeOpVrev_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf10ef00UL, 0xf10ffb0UL, DecodeOpVrecps_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ffbbUL, 0xf90ffbfUL, DecodeOpVrecpe_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ffbbUL, 0xf90ffbfUL, DecodeOpVrecpe_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ffa0UL, 0xf50ffb0UL, DecodeOpVraddhn_i64dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ff90UL, 0xf50ffb0UL, DecodeOpVraddhn_i32dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ff80UL, 0xf50ffb0UL, DecodeOpVraddhn_i16dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ff30UL, 0xf10ffb0UL, DecodeOpVqsub_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ff20UL, 0xf10ffb0UL, DecodeOpVqsub_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ff10UL, 0xf10ffb0UL, DecodeOpVqsub_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ff00UL, 0xf10ffb0UL, DecodeOpVqsub_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ef30UL, 0xf10ffb0UL, DecodeOpVqsub_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ef20UL, 0xf10ffb0UL, DecodeOpVqsub_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ef10UL, 0xf10ffb0UL, DecodeOpVqsub_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x210ef00UL, 0xf10ffb0UL, DecodeOpVqsub_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ffa0UL, 0xfd0ffa0UL, DecodeOpVqshrun_s64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ff90UL, 0xfd0ffb0UL, DecodeOpVqshrun_s32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ff88UL, 0xfd0ffb8UL, DecodeOpVqshrun_s16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ffa0UL, 0xfd0ffa0UL, DecodeOpVqshrn_u64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ff90UL, 0xfd0ffb0UL, DecodeOpVqshrn_u32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ff88UL, 0xfd0ffb8UL, DecodeOpVqshrn_u16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910efa0UL, 0xfd0ffa0UL, DecodeOpVqshrn_s64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ef90UL, 0xfd0ffb0UL, DecodeOpVqshrn_s32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ef88UL, 0xfd0ffb8UL, DecodeOpVqshrn_s16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x690ff80UL, 0xf90ff80UL, DecodeOpVqshlu_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x610ffa0UL, 0xf90ffa0UL, DecodeOpVqshlu_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x610ff90UL, 0xf90ffb0UL, DecodeOpVqshlu_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x610ff88UL, 0xf90ffb8UL, DecodeOpVqshlu_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x790ff80UL, 0xf90ff80UL, DecodeOpVqshl_u64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ff30UL, 0xf10ffb0UL, DecodeOpVqshl_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ffa0UL, 0xf90ffa0UL, DecodeOpVqshl_u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ff20UL, 0xf10ffb0UL, DecodeOpVqshl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ff90UL, 0xf90ffb0UL, DecodeOpVqshl_u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ff10UL, 0xf10ffb0UL, DecodeOpVqshl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ff88UL, 0xf90ffb8UL, DecodeOpVqshl_u8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ff00UL, 0xf10ffb0UL, DecodeOpVqshl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x790ef80UL, 0xf90ff80UL, DecodeOpVqshl_s64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ef30UL, 0xf10ffb0UL, DecodeOpVqshl_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710efa0UL, 0xf90ffa0UL, DecodeOpVqshl_s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ef20UL, 0xf10ffb0UL, DecodeOpVqshl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ef90UL, 0xf90ffb0UL, DecodeOpVqshl_s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ef10UL, 0xf10ffb0UL, DecodeOpVqshl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ef88UL, 0xf90ffb8UL, DecodeOpVqshl_s8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x410ef00UL, 0xf10ffb0UL, DecodeOpVqshl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x850ffa0UL, 0xfd0ffa0UL, DecodeOpVqrshrun_s64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x850ff90UL, 0xfd0ffb0UL, DecodeOpVqrshrun_s32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x850ff88UL, 0xfd0ffb8UL, DecodeOpVqrshrun_s16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x950ffa0UL, 0xfd0ffa0UL, DecodeOpVqrshrn_u64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x950ff90UL, 0xfd0ffb0UL, DecodeOpVqrshrn_u32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x950ff88UL, 0xfd0ffb8UL, DecodeOpVqrshrn_u16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x950efa0UL, 0xfd0ffa0UL, DecodeOpVqrshrn_s64dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x950ef90UL, 0xfd0ffb0UL, DecodeOpVqrshrn_s32dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x950ef88UL, 0xfd0ffb8UL, DecodeOpVqrshrn_s16dqi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ff30UL, 0xf10ffb0UL, DecodeOpVqrshl_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ff20UL, 0xf10ffb0UL, DecodeOpVqrshl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ff10UL, 0xf10ffb0UL, DecodeOpVqrshl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ff00UL, 0xf10ffb0UL, DecodeOpVqrshl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ef30UL, 0xf10ffb0UL, DecodeOpVqrshl_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ef20UL, 0xf10ffb0UL, DecodeOpVqrshl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ef10UL, 0xf10ffb0UL, DecodeOpVqrshl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x510ef00UL, 0xf10ffb0UL, DecodeOpVqrshl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd40efa0UL, 0xf50efb0UL, DecodeOpVqrdmulh_s32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ff20UL, 0xf10ffb0UL, DecodeOpVqrdmulh_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd40ef90UL, 0xf50efb0UL, DecodeOpVqrdmulh_s16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ff10UL, 0xf10ffb0UL, DecodeOpVqrdmulh_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x780ffb8UL, 0xf90ffbfUL, DecodeOpVqneg_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x780ffb4UL, 0xf90ffbfUL, DecodeOpVqneg_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x780ffb0UL, 0xf90ffbfUL, DecodeOpVqneg_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x240ffbaUL, 0xfd0ffbfUL, DecodeOpVqmovun_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x240ffb6UL, 0xfd0ffbfUL, DecodeOpVqmovun_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x240ffb2UL, 0xfd0ffbfUL, DecodeOpVqmovun_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2c0ffbaUL, 0xfd0ffbfUL, DecodeOpVqmovn_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2c0ffb6UL, 0xfd0ffbfUL, DecodeOpVqmovn_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2c0ffb2UL, 0xfd0ffbfUL, DecodeOpVqmovn_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x280ffbaUL, 0xfd0ffbfUL, DecodeOpVqmovn_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x280ffb6UL, 0xfd0ffbfUL, DecodeOpVqmovn_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x280ffb2UL, 0xfd0ffbfUL, DecodeOpVqmovn_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40efa0UL, 0xf50ffb0UL, DecodeOpVqdmull_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd00efa0UL, 0xf50ffb0UL, DecodeOpVqdmull_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40ef90UL, 0xf50ffb0UL, DecodeOpVqdmull_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd00ef90UL, 0xf50ffb0UL, DecodeOpVqdmull_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc40efa0UL, 0xf50efb0UL, DecodeOpVqdmulh_s32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ef20UL, 0xf10ffb0UL, DecodeOpVqdmulh_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc40ef90UL, 0xf50efb0UL, DecodeOpVqdmulh_s16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ef10UL, 0xf10ffb0UL, DecodeOpVqdmulh_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x740efa0UL, 0xf50ffb0UL, DecodeOpVqdmlsl_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00efa0UL, 0xf50ffb0UL, DecodeOpVqdmlsl_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x740ef90UL, 0xf50ffb0UL, DecodeOpVqdmlsl_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ef90UL, 0xf50ffb0UL, DecodeOpVqdmlsl_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x340efa0UL, 0xf50ffb0UL, DecodeOpVqdmlal_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x900efa0UL, 0xf50ffb0UL, DecodeOpVqdmlal_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x340ef90UL, 0xf50ffb0UL, DecodeOpVqdmlal_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x900ef90UL, 0xf50ffb0UL, DecodeOpVqdmlal_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ff30UL, 0xf10ffb0UL, DecodeOpVqadd_u64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ff20UL, 0xf10ffb0UL, DecodeOpVqadd_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ff10UL, 0xf10ffb0UL, DecodeOpVqadd_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ff00UL, 0xf10ffb0UL, DecodeOpVqadd_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ef30UL, 0xf10ffb0UL, DecodeOpVqadd_s64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ef20UL, 0xf10ffb0UL, DecodeOpVqadd_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ef10UL, 0xf10ffb0UL, DecodeOpVqadd_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ef00UL, 0xf10ffb0UL, DecodeOpVqadd_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ffb8UL, 0xf90ffbfUL, DecodeOpVqabs_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ffb4UL, 0xf90ffbfUL, DecodeOpVqabs_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ffb0UL, 0xf90ffbfUL, DecodeOpVqabs_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ff20UL, 0xf10ffb0UL, DecodeOpVpmin_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ff10UL, 0xf10ffb0UL, DecodeOpVpmin_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ff00UL, 0xf10ffb0UL, DecodeOpVpmin_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ef20UL, 0xf10ffb0UL, DecodeOpVpmin_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ef10UL, 0xf10ffb0UL, DecodeOpVpmin_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ef00UL, 0xf10ffb0UL, DecodeOpVpmin_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00ff20UL, 0xf10ffb0UL, DecodeOpVpmin_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ff20UL, 0xf10ffb0UL, DecodeOpVpmax_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ff10UL, 0xf10ffb0UL, DecodeOpVpmax_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ff00UL, 0xf10ffb0UL, DecodeOpVpmax_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ef20UL, 0xf10ffb0UL, DecodeOpVpmax_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ef10UL, 0xf10ffb0UL, DecodeOpVpmax_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ef00UL, 0xf10ffb0UL, DecodeOpVpmax_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00ff00UL, 0xf10ffb0UL, DecodeOpVpmax_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x280ffb8UL, 0xf90ffbfUL, DecodeOpVpaddl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x280ffb4UL, 0xf90ffbfUL, DecodeOpVpaddl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x280ffb0UL, 0xf90ffbfUL, DecodeOpVpaddl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffb8UL, 0xf90ffbfUL, DecodeOpVpaddl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffb4UL, 0xf90ffbfUL, DecodeOpVpaddl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffb0UL, 0xf90ffbfUL, DecodeOpVpaddl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ef20UL, 0xf10ffb0UL, DecodeOpVpadd_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ef10UL, 0xf10ffb0UL, DecodeOpVpadd_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ef00UL, 0xf10ffb0UL, DecodeOpVpadd_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd00ff00UL, 0xf10ffb0UL, DecodeOpVpadd_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x680ffb8UL, 0xf90ffbfUL, DecodeOpVpadal_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x680ffb4UL, 0xf90ffbfUL, DecodeOpVpadal_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x680ffb0UL, 0xf90ffbfUL, DecodeOpVpadal_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ffb8UL, 0xf90ffbfUL, DecodeOpVpadal_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ffb4UL, 0xf90ffbfUL, DecodeOpVpadal_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ffb0UL, 0xf90ffbfUL, DecodeOpVpadal_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ef80UL, 0x9b0efb8UL, DecodeOpVorr_i32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ef80UL, 0xdb0efb8UL, DecodeOpVorr_i16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ef20UL, 0xf10ffb0UL, DecodeOpVorr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ef30UL, 0xf10ffb0UL, DecodeOpVorn<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x380ffb9UL, 0xf90ffbfUL, DecodeOpVneg_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x380ffb5UL, 0xf90ffbfUL, DecodeOpVneg_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x380ffb1UL, 0xf90ffbfUL, DecodeOpVneg_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x780ffb9UL, 0xf90ffbfUL, DecodeOpVneg_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x780ffb5UL, 0xf90ffbfUL, DecodeOpVneg_f16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x780ffb1UL, 0xf90ffbfUL, DecodeOpVneg_f8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x580ffb0UL, 0xf90ffbfUL, DecodeOpVmvn<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc30ef80UL, 0xeb0efb8UL, DecodeOpVmvn_i32in<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x30ef80UL, 0x9b0efb8UL, DecodeOpVmvn_i32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x830ef80UL, 0xdb0efb8UL, DecodeOpVmvn_i16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40ffa0UL, 0xf50ffb0UL, DecodeOpVmull_u32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40ff90UL, 0xf50ffb0UL, DecodeOpVmull_u16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40efa0UL, 0xf50ffb0UL, DecodeOpVmull_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40ef90UL, 0xf50ffb0UL, DecodeOpVmull_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00ffa0UL, 0xf50ffb0UL, DecodeOpVmull_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00ff90UL, 0xf50ffb0UL, DecodeOpVmull_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00ff80UL, 0xf50ffb0UL, DecodeOpVmull_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00efa0UL, 0xf50ffb0UL, DecodeOpVmull_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00ef90UL, 0xf50ffb0UL, DecodeOpVmull_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00ef80UL, 0xf50ffb0UL, DecodeOpVmull_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00ef80UL, 0xf50ffb0UL, DecodeOpVmull_p8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ff20UL, 0xf10ffb0UL, DecodeOpVmul_p32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ff10UL, 0xf10ffb0UL, DecodeOpVmul_p16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ff00UL, 0xf10ffb0UL, DecodeOpVmul_p8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x840efa0UL, 0xf50efb0UL, DecodeOpVmul_i32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x840ef90UL, 0xf50efb0UL, DecodeOpVmul_i16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ef20UL, 0xf10ffb0UL, DecodeOpVmul_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ef10UL, 0xf10ffb0UL, DecodeOpVmul_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x910ef00UL, 0xf10ffb0UL, DecodeOpVmul_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x940efa0UL, 0xf50efb0UL, DecodeOpVmul_f32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd10ff00UL, 0xf10ffb0UL, DecodeOpVmul_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ee10UL, 0xf7fffd0UL, DecodeOpVmov_32rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb30ee90UL, 0xf3fffd0UL, DecodeOpVmov_u16rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb30ee10UL, 0xf3fffd0UL, DecodeOpVmov_s16rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10eed0UL, 0xf1fffd0UL, DecodeOpVmov_u8rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ee50UL, 0xf1fffd0UL, DecodeOpVmov_s8rd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ee00UL, 0xf7fffd0UL, DecodeOpVmov_32dr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb30ee00UL, 0xf3fffd0UL, DecodeOpVmov_16dr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ee40UL, 0xf1fffd0UL, DecodeOpVmov_8dr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffbaUL, 0xfd0ffbfUL, DecodeOpVmovn_i64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffb6UL, 0xfd0ffbfUL, DecodeOpVmovn_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffb2UL, 0xfd0ffbfUL, DecodeOpVmovn_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ffa0UL, 0xfd0ffbfUL, DecodeOpVmovl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ff90UL, 0xfd0ffbfUL, DecodeOpVmovl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ff88UL, 0xfd0ffbfUL, DecodeOpVmovl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10efa0UL, 0xfd0ffbfUL, DecodeOpVmovl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ef90UL, 0xfd0ffbfUL, DecodeOpVmovl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ef88UL, 0xfd0ffbfUL, DecodeOpVmovl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc10ef80UL, 0xeb0efb8UL, DecodeOpVmov_i32in<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe30ef80UL, 0xfb0efb8UL, DecodeOpVmov_i64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ef80UL, 0x9b0efb8UL, DecodeOpVmov_i32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ef80UL, 0xdb0efb8UL, DecodeOpVmov_i16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe10ef80UL, 0xfb0efb8UL, DecodeOpVmov_i8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf10ef80UL, 0xfb0efb8UL, DecodeOpVmov_f32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x640ffa0UL, 0xf50ffb0UL, DecodeOpVmlsl_u32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x640ff90UL, 0xf50ffb0UL, DecodeOpVmlsl_u16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x640efa0UL, 0xf50ffb0UL, DecodeOpVmlsl_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x640ef90UL, 0xf50ffb0UL, DecodeOpVmlsl_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x440efa0UL, 0xf50efb0UL, DecodeOpVmls_i32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x440ef90UL, 0xf50efb0UL, DecodeOpVmls_i16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x540efa0UL, 0xf50efb0UL, DecodeOpVmls_f32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd10ef20UL, 0xf10ffb0UL, DecodeOpVmls_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x540ef90UL, 0xf50ffb0UL, DecodeOpVmls_f16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x240ffa0UL, 0xf50ffb0UL, DecodeOpVmlal_u32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x240ff90UL, 0xf50ffb0UL, DecodeOpVmlal_u16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x240efa0UL, 0xf50ffb0UL, DecodeOpVmlal_s32qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x240ef90UL, 0xf50ffb0UL, DecodeOpVmlal_s16qdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ffa0UL, 0xd50ffb0UL, DecodeOpVmll_u32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ff90UL, 0xd50ffb0UL, DecodeOpVmll_u16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ff80UL, 0xd50ffb0UL, DecodeOpVmll_u8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800efa0UL, 0xd50ffb0UL, DecodeOpVmll_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ef90UL, 0xd50ffb0UL, DecodeOpVmll_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ef80UL, 0xd50ffb0UL, DecodeOpVmll_s8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x40efa0UL, 0xf50efb0UL, DecodeOpVmla_i32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x40ef90UL, 0xf50efb0UL, DecodeOpVmla_i16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x900ef20UL, 0xf10efb0UL, DecodeOpVml_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x900ef10UL, 0xf10efb0UL, DecodeOpVml_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x900ef00UL, 0xf10efb0UL, DecodeOpVml_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x140efa0UL, 0xf50efb0UL, DecodeOpVmla_f32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd10ef00UL, 0xf10ffb0UL, DecodeOpVmla_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x610ff20UL, 0xf10ffb0UL, DecodeOpVmin_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x610ff10UL, 0xf10ffb0UL, DecodeOpVmin_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x610ff00UL, 0xf10ffb0UL, DecodeOpVmin_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x610ef20UL, 0xf10ffb0UL, DecodeOpVmin_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x610ef10UL, 0xf10ffb0UL, DecodeOpVmin_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x610ef00UL, 0xf10ffb0UL, DecodeOpVmin_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00ef20UL, 0xf10ffb0UL, DecodeOpVmin_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ff20UL, 0xf10ffb0UL, DecodeOpVmax_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ff10UL, 0xf10ffb0UL, DecodeOpVmax_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ff00UL, 0xf10ffb0UL, DecodeOpVmax_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ef20UL, 0xf10ffb0UL, DecodeOpVmax_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ef10UL, 0xf10ffb0UL, DecodeOpVmax_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ef00UL, 0xf10ffb0UL, DecodeOpVmax_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00ef00UL, 0xf10ffb0UL, DecodeOpVmax_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f9a0UL, 0xc00ffb0UL, DecodeOpVldsl_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400f9a0UL, 0xc00ffb0UL, DecodeOpVldsl_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf9a0UL, 0xc00ffb0UL, DecodeOpVldsl_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xca0f9a0UL, 0xfe0ffb0UL, DecodeOpVldqal_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc60f9a0UL, 0xfe0ffb0UL, DecodeOpVldqal_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc20f9a0UL, 0xfe0ffb0UL, DecodeOpVldqal_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc80f9a0UL, 0xcc0ffb0UL, DecodeOpVldal_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc40f9a0UL, 0xcc0ffb0UL, DecodeOpVldal_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00f9a0UL, 0xcc0ffb0UL, DecodeOpVldal_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x380f920UL, 0xfc0ffb0UL, DecodeOpVld2_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x340f920UL, 0xfc0ffb0UL, DecodeOpVld2_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300f920UL, 0xfc0ffb0UL, DecodeOpVld2_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x180f920UL, 0x3c0ffb0UL, DecodeOpVldms2s_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x140f920UL, 0x3c0ffb0UL, DecodeOpVldms2s_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100f920UL, 0x3c0ffb0UL, DecodeOpVldms2s_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc0f920UL, 0xc0ffb0UL, DecodeOpVldms_64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x80f920UL, 0xc0ffb0UL, DecodeOpVldms_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x40f920UL, 0xc0ffb0UL, DecodeOpVldms_16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf920UL, 0xc0ffb0UL, DecodeOpVldms_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ff20UL, 0xf10ffb0UL, DecodeOpVhsub_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ff10UL, 0xf10ffb0UL, DecodeOpVhsub_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ff00UL, 0xf10ffb0UL, DecodeOpVhsub_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ef20UL, 0xf10ffb0UL, DecodeOpVhsub_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ef10UL, 0xf10ffb0UL, DecodeOpVhsub_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ef00UL, 0xf10ffb0UL, DecodeOpVhsub_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xff20UL, 0xf10ffb0UL, DecodeOpVhadd_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xff10UL, 0xf10ffb0UL, DecodeOpVhadd_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xff00UL, 0xf10ffb0UL, DecodeOpVhadd_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xef20UL, 0xf10ffb0UL, DecodeOpVhadd_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xef10UL, 0xf10ffb0UL, DecodeOpVhadd_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xef00UL, 0xf10ffb0UL, DecodeOpVhadd_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc10ef20UL, 0xf10ffb0UL, DecodeOpVfms_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc10ef00UL, 0xf10ffb0UL, DecodeOpVfma_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xefb0UL, 0x10ffb0UL, DecodeOpVext_8i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ff00UL, 0xf10ffb0UL, DecodeOpVeor<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ee80UL, 0xf7fffd0UL, DecodeOpVdup32_r<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb30ee80UL, 0xf7fffd0UL, DecodeOpVdup16_r<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10eec0UL, 0xf7fffd0UL, DecodeOpVdup8_r<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00ffb4UL, 0xf90ffb7UL, DecodeOpVdup_32dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00ffb2UL, 0xf90ffb3UL, DecodeOpVdup_16dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc00ffb1UL, 0xf90ffb1UL, DecodeOpVdup_8dp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf10ffa0UL, 0xf90ffa0UL, DecodeOpVcvt_u32f32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x780ffbbUL, 0xf90ffbfUL, DecodeOpVcvt_u32f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf10efa0UL, 0xf90ffa0UL, DecodeOpVcvt_s32f32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ffbbUL, 0xf90ffbfUL, DecodeOpVcvt_s32_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe10ffa0UL, 0xf90ffa0UL, DecodeOpVcvt_f32u32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x680ffbbUL, 0xf90ffbfUL, DecodeOpVcvt_f32u32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe10efa0UL, 0xf90ffa0UL, DecodeOpVcvt_f32s32vi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ffbbUL, 0xf90ffbfUL, DecodeOpVcvt_f32_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ffb6UL, 0xfd0ffbfUL, DecodeOpVcvt_f32_f16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ffb6UL, 0xfd0ffbfUL, DecodeOpVcvt_f16_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ffb0UL, 0xf90ffbfUL, DecodeOpVcnt_8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x480ffb8UL, 0xf90ffbfUL, DecodeOpVclz_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x480ffb4UL, 0xf90ffbfUL, DecodeOpVclz_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x480ffb0UL, 0xf90ffbfUL, DecodeOpVclz_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffb9UL, 0xf90ffbfUL, DecodeOpVclt_s32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffb5UL, 0xf90ffbfUL, DecodeOpVclt_s16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x200ffb1UL, 0xf90ffbfUL, DecodeOpVclt_s8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ffb9UL, 0xf90ffbfUL, DecodeOpVclt_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ffb5UL, 0xf90ffbfUL, DecodeOpVclt_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x600ffb1UL, 0xf90ffbfUL, DecodeOpVclt_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ffb8UL, 0xf90ffbfUL, DecodeOpVcls_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ffb4UL, 0xf90ffbfUL, DecodeOpVcls_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ffb0UL, 0xf90ffbfUL, DecodeOpVcls_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x180ffb9UL, 0xf90ffbfUL, DecodeOpVcle_s32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x180ffb5UL, 0xf90ffbfUL, DecodeOpVcle_s16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x180ffb1UL, 0xf90ffbfUL, DecodeOpVcle_s8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x580ffb9UL, 0xf90ffbfUL, DecodeOpVcle_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x580ffb5UL, 0xf90ffbfUL, DecodeOpVcle_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x580ffb1UL, 0xf90ffbfUL, DecodeOpVcle_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ff20UL, 0xf10ffb0UL, DecodeOpVcgt_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ff10UL, 0xf10ffb0UL, DecodeOpVcgt_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ff00UL, 0xf10ffb0UL, DecodeOpVcgt_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ef20UL, 0xf10ffb0UL, DecodeOpVcgt_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ef10UL, 0xf10ffb0UL, DecodeOpVcgt_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ef00UL, 0xf10ffb0UL, DecodeOpVcgt_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xffb9UL, 0xf90ffbfUL, DecodeOpVcgt_s32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xffb5UL, 0xf90ffbfUL, DecodeOpVcgt_s16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xffb1UL, 0xf90ffbfUL, DecodeOpVcgt_s8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00ff20UL, 0xf10ffb0UL, DecodeOpVcgt_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ffb9UL, 0xf90ffbfUL, DecodeOpVcgt_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ffb5UL, 0xf90ffbfUL, DecodeOpVcgt_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ffb1UL, 0xf90ffbfUL, DecodeOpVcgt_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ff20UL, 0xf10ffb0UL, DecodeOpVcge_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ff10UL, 0xf10ffb0UL, DecodeOpVcge_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ff00UL, 0xf10ffb0UL, DecodeOpVcge_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ef20UL, 0xf10ffb0UL, DecodeOpVcge_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ef10UL, 0xf10ffb0UL, DecodeOpVcge_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x310ef00UL, 0xf10ffb0UL, DecodeOpVcge_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x80ffb9UL, 0xf90ffbfUL, DecodeOpVcge_s32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x80ffb5UL, 0xf90ffbfUL, DecodeOpVcge_s16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x80ffb1UL, 0xf90ffbfUL, DecodeOpVcge_s8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x480ffb9UL, 0xf90ffbfUL, DecodeOpVcge_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00ff00UL, 0xf10ffb0UL, DecodeOpVcge_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x480ffb5UL, 0xf90ffbfUL, DecodeOpVcge_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x480ffb1UL, 0xf90ffbfUL, DecodeOpVcge_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ff20UL, 0xf10ffb0UL, DecodeOpVceq_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ff10UL, 0xf10ffb0UL, DecodeOpVceq_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x810ff00UL, 0xf10ffb0UL, DecodeOpVceq_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ffb9UL, 0xf90ffbfUL, DecodeOpVceq_i32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ffb5UL, 0xf90ffbfUL, DecodeOpVceq_i16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ffb1UL, 0xf90ffbfUL, DecodeOpVceq_i8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ffb9UL, 0xf90ffbfUL, DecodeOpVceq_f32z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ffb5UL, 0xf90ffbfUL, DecodeOpVceq_f16z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ffb1UL, 0xf90ffbfUL, DecodeOpVceq_f8z<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00ef00UL, 0xf10ffb0UL, DecodeOpVceq_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ff10UL, 0xf10ffb0UL, DecodeOpVbsl<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ff20UL, 0xf10ffb0UL, DecodeOpVbit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ff30UL, 0xf10ffb0UL, DecodeOpVbif<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x130ef80UL, 0x9b0efb8UL, DecodeOpVbic_i32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x930ef80UL, 0xdb0efb8UL, DecodeOpVbic_i16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ef10UL, 0xf10ffb0UL, DecodeOpVbic<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x110ef00UL, 0xf10ffb0UL, DecodeOpVand<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ffa0UL, 0xf50ffb0UL, DecodeOpVaddw_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ff90UL, 0xf50ffb0UL, DecodeOpVaddw_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ff80UL, 0xf50ffb0UL, DecodeOpVaddw_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100efa0UL, 0xf50ffb0UL, DecodeOpVaddw_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ef90UL, 0xf50ffb0UL, DecodeOpVaddw_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x100ef80UL, 0xf50ffb0UL, DecodeOpVaddw_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xffa0UL, 0xf50ffb0UL, DecodeOpVaddl_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xff90UL, 0xf50ffb0UL, DecodeOpVaddl_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xff80UL, 0xf50ffb0UL, DecodeOpVaddl_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xefa0UL, 0xf50ffb0UL, DecodeOpVaddl_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xef90UL, 0xf50ffb0UL, DecodeOpVaddl_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xef80UL, 0xf50ffb0UL, DecodeOpVaddl_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400efa0UL, 0xf50ffb0UL, DecodeOpVaddhn_i64dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ef90UL, 0xf50ffb0UL, DecodeOpVaddhn_i32dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x400ef80UL, 0xf50ffb0UL, DecodeOpVaddhn_i16dq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ef30UL, 0xf10ffb0UL, DecodeOpVadd_i64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ef20UL, 0xf10ffb0UL, DecodeOpVadd_i32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ef10UL, 0xf10ffb0UL, DecodeOpVadd_i16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800ef00UL, 0xf10ffb0UL, DecodeOpVadd_i8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd00ef00UL, 0xf10ffb0UL, DecodeOpVadd_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe10ff20UL, 0xf10ffb0UL, DecodeOpVacgt_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe10ff00UL, 0xf10ffb0UL, DecodeOpVacge_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ffb9UL, 0xf90ffbfUL, DecodeOpVabs_f32v<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ffb9UL, 0xf90ffbfUL, DecodeOpVabs_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ffb5UL, 0xf90ffbfUL, DecodeOpVabs_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x300ffb1UL, 0xf90ffbfUL, DecodeOpVabs_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd00ff20UL, 0xf10ffb0UL, DecodeOpVabd_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ffa0UL, 0xf50ffb0UL, DecodeOpVabdl_u32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ff90UL, 0xf50ffb0UL, DecodeOpVabdl_u16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ff80UL, 0xf50ffb0UL, DecodeOpVabdl_u8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700efa0UL, 0xf50ffb0UL, DecodeOpVabdl_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ef90UL, 0xf50ffb0UL, DecodeOpVabdl_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ef80UL, 0xf50ffb0UL, DecodeOpVabdl_s8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ff20UL, 0xf10ffb0UL, DecodeOpVabd_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ff10UL, 0xf10ffb0UL, DecodeOpVabd_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ff00UL, 0xf10ffb0UL, DecodeOpVabd_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ef20UL, 0xf10ffb0UL, DecodeOpVabd_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ef10UL, 0xf10ffb0UL, DecodeOpVabd_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x700ef00UL, 0xf10ffb0UL, DecodeOpVabd_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ffa0UL, 0xf50ffb0UL, DecodeOpVabal_u32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ff90UL, 0xf50ffb0UL, DecodeOpVabal_u16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ff80UL, 0xf50ffb0UL, DecodeOpVabal_u8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500efa0UL, 0xf50ffb0UL, DecodeOpVabal_s32qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ef90UL, 0xf50ffb0UL, DecodeOpVabal_s16qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x500ef80UL, 0xf50ffb0UL, DecodeOpVabal_s8qd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ff20UL, 0xf10ffb0UL, DecodeOpVaba_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ff10UL, 0xf10ffb0UL, DecodeOpVaba_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ff00UL, 0xf10ffb0UL, DecodeOpVaba_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ef20UL, 0xf10ffb0UL, DecodeOpVaba_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ef10UL, 0xf10ffb0UL, DecodeOpVaba_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x710ef00UL, 0xf10ffb0UL, DecodeOpVaba_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40ee30UL, 0xf50ffb0UL, DecodeOpVsub_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40ee30UL, 0xf50ffb0UL, DecodeOpVsub_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ed00UL, 0xf00ff30UL, DecodeOpVstr_64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ed00UL, 0xf00ff30UL, DecodeOpVstr_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ec80UL, 0xf00ff90UL, DecodeOpVstmia_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ec80UL, 0xf00ff90UL, DecodeOpVstmia_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ed20UL, 0xf00ffb0UL, DecodeOpVstmdb_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ed20UL, 0xf00ffb0UL, DecodeOpVstmdb_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eeb1UL, 0xfd0ffbfUL, DecodeOpVsqrt_f64d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eeb1UL, 0xfd0ffbfUL, DecodeOpVsqrt_f32s<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eeb1UL, 0xfd0ffbfUL, DecodeOpVneg_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eeb1UL, 0xfd0ffbfUL, DecodeOpVneg_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40ee20UL, 0xf50ffb0UL, DecodeOpVnmul_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40ee20UL, 0xf50ffb0UL, DecodeOpVnmul_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ee20UL, 0xf50ffb0UL, DecodeOpVmul_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ee20UL, 0xf50ffb0UL, DecodeOpVmul_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10eee0UL, 0xffffff0UL, DecodeOpVmsr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10eef0UL, 0xffffff0UL, DecodeOpVmrs<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ec40UL, 0xfd0fff0UL, DecodeOpVmov_drr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb10ec50UL, 0xfd0fff0UL, DecodeOpVmov_rrd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ec50UL, 0xfd0fff0UL, DecodeOpVmov_rrss<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ec40UL, 0xfd0fff0UL, DecodeOpVmov_ssrr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ee00UL, 0xf7ffff0UL, DecodeOpVmov_sr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ee10UL, 0xf7ffff0UL, DecodeOpVmov_rs<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eeb0UL, 0xfd0ffbfUL, DecodeOpVmov_f64d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eeb0UL, 0xfd0ffbfUL, DecodeOpVmov_f32s<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00eeb0UL, 0xff0ffb0UL, DecodeOpVmov_f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00eeb0UL, 0xff0ffb0UL, DecodeOpVmov_f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ee10UL, 0xf50ffb0UL, DecodeOpVnmls_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ee10UL, 0xf50ffb0UL, DecodeOpVnmls_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40ee10UL, 0xf50ffb0UL, DecodeOpVnmla_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40ee10UL, 0xf50ffb0UL, DecodeOpVnmla_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40ee00UL, 0xf50ffb0UL, DecodeOpVmls_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40ee00UL, 0xf50ffb0UL, DecodeOpVmls_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ee00UL, 0xf50ffb0UL, DecodeOpVmla_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ee00UL, 0xf50ffb0UL, DecodeOpVmla_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ed1fUL, 0xf00ff3fUL, DecodeOpVldr_literal_64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ed10UL, 0xf00ff30UL, DecodeOpVldr_64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ed1fUL, 0xf00ff3fUL, DecodeOpVldr_literal_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ed10UL, 0xf00ff30UL, DecodeOpVldr_32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ec90UL, 0xf00ff90UL, DecodeOpVldmia_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ec90UL, 0xf00ff90UL, DecodeOpVldmia_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ed30UL, 0xf00ffb0UL, DecodeOpVldmdb_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ed30UL, 0xf00ffb0UL, DecodeOpVldmdb_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ee90UL, 0xf50ffb0UL, DecodeOpVfnms_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ee90UL, 0xf50ffb0UL, DecodeOpVfnms_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40ee90UL, 0xf50ffb0UL, DecodeOpVfnma_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40ee90UL, 0xf50ffb0UL, DecodeOpVfnma_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eea0UL, 0xf50ffb0UL, DecodeOpVfms_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eea0UL, 0xf50ffb0UL, DecodeOpVfms_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00eea0UL, 0xf50ffb0UL, DecodeOpVfma_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00eea0UL, 0xf50ffb0UL, DecodeOpVfma_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ee80UL, 0xf50ffb0UL, DecodeOpVdiv_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ee80UL, 0xf50ffb0UL, DecodeOpVdiv_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eeb7UL, 0xfd0ffbfUL, DecodeOpVcvt_f32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eeb7UL, 0xfd0ffbfUL, DecodeOpVcvt_f64f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eebfUL, 0xfd0ffbfUL, DecodeOpVcvt_u32f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eebfUL, 0xfd0ffbfUL, DecodeOpVcvt_u32f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eebfUL, 0xfd0ffbfUL, DecodeOpVcvt_u16f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eebfUL, 0xfd0ffbfUL, DecodeOpVcvt_u16f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eebeUL, 0xfd0ffbfUL, DecodeOpVcvt_s32f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eebeUL, 0xfd0ffbfUL, DecodeOpVcvt_s32f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eebeUL, 0xfd0ffbfUL, DecodeOpVcvt_s16f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eebeUL, 0xfd0ffbfUL, DecodeOpVcvt_s16f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eebbUL, 0xfd0ffbfUL, DecodeOpVcvt_f64u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eebbUL, 0xfd0ffbfUL, DecodeOpVcvt_f64u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eebbUL, 0xfd0ffbfUL, DecodeOpVcvt_f32u32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eebbUL, 0xfd0ffbfUL, DecodeOpVcvt_f32u16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eebaUL, 0xfd0ffbfUL, DecodeOpVcvt_f64s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eebaUL, 0xfd0ffbfUL, DecodeOpVcvt_f64s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eebaUL, 0xfd0ffbfUL, DecodeOpVcvt_f32s32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eebaUL, 0xfd0ffbfUL, DecodeOpVcvt_f32s16i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eebdUL, 0xfd0ffbfUL, DecodeOpVcvtr_s32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eebdUL, 0xfd0ffbfUL, DecodeOpVcvt_s32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eebdUL, 0xfd0ffbfUL, DecodeOpVcvtr_s32f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eebdUL, 0xfd0ffbfUL, DecodeOpVcvt_s32f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eebcUL, 0xfd0ffbfUL, DecodeOpVcvtr_u32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eebcUL, 0xfd0ffbfUL, DecodeOpVcvt_u32f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eebcUL, 0xfd0ffbfUL, DecodeOpVcvtr_u32f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eebcUL, 0xfd0ffbfUL, DecodeOpVcvt_u32f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eeb8UL, 0xfd0ffbfUL, DecodeOpVcvt_f64s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eeb8UL, 0xfd0ffbfUL, DecodeOpVcvt_f32s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eeb8UL, 0xfd0ffbfUL, DecodeOpVcvt_f64u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eeb8UL, 0xfd0ffbfUL, DecodeOpVcvt_f32u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eeb2UL, 0xf50ffbfUL, DecodeOpVcvtb_f32_f16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eeb3UL, 0xf50ffbfUL, DecodeOpVcvtb_f16_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eeb5UL, 0xf7fffbfUL, DecodeOpVcmp_f64i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eeb5UL, 0xf7fffbfUL, DecodeOpVcmp_f32i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb40eeb4UL, 0xf50ffbfUL, DecodeOpVcmp_f64d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa40eeb4UL, 0xf50ffbfUL, DecodeOpVcmp_f32d<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb00ee30UL, 0xf50ffb0UL, DecodeOpVadd_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa00ee30UL, 0xf50ffb0UL, DecodeOpVadd_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc0eeb0UL, 0xfd0ffbfUL, DecodeOpVabs_f64<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xac0eeb0UL, 0xfd0ffbfUL, DecodeOpVabs_f32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000f380UL, 0xf0ffffe0UL, DecodeOpMsr_reg_psr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000f380UL, 0xf0cfffe0UL, DecodeOpMsr_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000f3e0UL, 0xf0cfffe0UL, DecodeOpMrs<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8f00f3deUL, 0xff00ffffUL, DecodeOpSubspc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000f7e0UL, 0xf000fff0UL, DecodeOpHvc_i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000f7f0UL, 0xf000fff0UL, DecodeOpSmc_i<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc000e980UL, 0xffe0ffd0UL, DecodeOpSrsia<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc000e800UL, 0xffe0ffd0UL, DecodeOpSrsdb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc000e990UL, 0xffffffd0UL, DecodeOpRfeia<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc000e810UL, 0xffffffd0UL, DecodeOpRfedb<	ARCH>));
	if( ARCH::Config::insns7 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x8004f3afUL, 0xffffffffUL, DecodeOpSev_w<	ARCH>));
	if( ARCH::Config::insns7 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x8003f3afUL, 0xffffffffUL, DecodeOpWfi_w<	ARCH>));
	if( ARCH::Config::insns7 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x8002f3afUL, 0xffffffffUL, DecodeOpWfe_w<	ARCH>));
	if( ARCH::Config::insns7 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xbf40UL, 0xffffUL, DecodeOpSev<	ARCH>));
	if( ARCH::Config::insns7 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xbf30UL, 0xffffUL, DecodeOpWfi<	ARCH>));
	if( ARCH::Config::insns7 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xbf20UL, 0xffffUL, DecodeOpWfe<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8f60f3bfUL, 0xfff0ffffUL, DecodeOpIsb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8f40f3bfUL, 0xfff0ffffUL, DecodeOpDsb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8f50f3bfUL, 0xfff0ffffUL, DecodeOpDmb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x80f0f3afUL, 0xfff0ffffUL, DecodeOpDbg_i<	ARCH>));
	if( ARCH::Config::insns7 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x8001f3afUL, 0xffffffffUL, DecodeOpYield_w<	ARCH>));
	if( ARCH::Config::insns7 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xbf10UL, 0xffffUL, DecodeOpYield<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000f3afUL, 0xff00ffffUL, DecodeOpNopw<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf10ee10UL, 0xf10ff10UL, DecodeOpCp15_mrc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf10ee00UL, 0xf10ff10UL, DecodeOpCp15_mcr<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc90UL, 0xffb0UL, DecodeOpLdc2_unindexed<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xec90UL, 0xffb0UL, DecodeOpLdc_unindexed<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc80UL, 0xffb0UL, DecodeOpStc2_unindexed<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xec80UL, 0xffb0UL, DecodeOpStc_unindexed<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc40UL, 0xfff0UL, DecodeOpMcrr2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xec40UL, 0xfff0UL, DecodeOpMcrr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc50UL, 0xfff0UL, DecodeOpMrrc2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xec50UL, 0xfff0UL, DecodeOpMrrc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xfe00UL, 0x10ff00UL, DecodeOpCdp2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xee00UL, 0x10ff00UL, DecodeOpCdp<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10fe00UL, 0x10ff10UL, DecodeOpMcr2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ee00UL, 0x10ff10UL, DecodeOpMcr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10fe10UL, 0x10ff10UL, DecodeOpMrc2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10ee10UL, 0x10ff10UL, DecodeOpMrc<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fb40UL, 0xf0e0fff0UL, DecodeOpSmusd<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fb20UL, 0xf0e0fff0UL, DecodeOpSmuad<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fb50UL, 0xf0e0fff0UL, DecodeOpSmmul<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfb60UL, 0xe0fff0UL, DecodeOpSmmls<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfb50UL, 0xe0fff0UL, DecodeOpSmmla<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xc0fbd0UL, 0xe0fff0UL, DecodeOpSmlsld<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfb40UL, 0xe0fff0UL, DecodeOpSmlsd<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xc0fbc0UL, 0xe0fff0UL, DecodeOpSmlald<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfb20UL, 0xe0fff0UL, DecodeOpSmlad<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fb30UL, 0xf0e0fff0UL, DecodeOpSmulwy<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfb30UL, 0xe0fff0UL, DecodeOpSmlawy<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fb10UL, 0xf0c0fff0UL, DecodeOpSmulxy<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfb10UL, 0xc0fff0UL, DecodeOpSmlaxy<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfbc0UL, 0xf0fff0UL, DecodeOpSmlal<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x80fbc0UL, 0xc0fff0UL, DecodeOpSmlalxy<	ARCH>));
	if( ARCH::Config::insnsRM ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf0f0fbb0UL, 0xf0f0fff0UL, DecodeOpUdiv<	ARCH>));
	if( ARCH::Config::insnsRM ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf0f0fb90UL, 0xf0f0fff0UL, DecodeOpSdiv<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xfb80UL, 0xf0fff0UL, DecodeOpSmull<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x60fbe0UL, 0xf0fff0UL, DecodeOpUmaal<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xfbe0UL, 0xf0fff0UL, DecodeOpUmlal<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xfba0UL, 0xf0fff0UL, DecodeOpUmull<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x10fb00UL, 0xf0fff0UL, DecodeOpMls<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fb00UL, 0xf0f0fff0UL, DecodeOpMul_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf010e8d0UL, 0xfff0fff0UL, DecodeOpTbh<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000e8d0UL, 0xfff0fff0UL, DecodeOpTbb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbf00UL, 0xff0fUL, DecodeOpNop<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbf00UL, 0xff00UL, DecodeOpIt<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8f00f3c0UL, 0xfffffff0UL, DecodeOpBxj<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x9000f000UL, 0xd000f800UL, DecodeOpB_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb100UL, 0xf500UL, DecodeOpCbnz<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc000f000UL, 0xd001f800UL, DecodeOpBlx_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd000f000UL, 0xd000f800UL, DecodeOpBl_w<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf060fae0UL, 0xf0f0fff0UL, DecodeOpUhsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf060faa0UL, 0xf0f0fff0UL, DecodeOpUhasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf020fae0UL, 0xf0f0fff0UL, DecodeOpShsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf020faa0UL, 0xf0f0fff0UL, DecodeOpShasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf040fae0UL, 0xf0f0fff0UL, DecodeOpUsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf040faa0UL, 0xf0f0fff0UL, DecodeOpUasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fae0UL, 0xf0f0fff0UL, DecodeOpSsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000faa0UL, 0xf0f0fff0UL, DecodeOpSasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf050fae0UL, 0xf0f0fff0UL, DecodeOpUqsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf050faa0UL, 0xf0f0fff0UL, DecodeOpUqasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf010fae0UL, 0xf0f0fff0UL, DecodeOpQsax<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf010faa0UL, 0xf0f0fff0UL, DecodeOpQasx<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf020fac0UL, 0xf0f0fff0UL, DecodeOpShsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf020fad0UL, 0xf0f0fff0UL, DecodeOpShsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf060fac0UL, 0xf0f0fff0UL, DecodeOpUhsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf060fad0UL, 0xf0f0fff0UL, DecodeOpUhsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf020fa80UL, 0xf0f0fff0UL, DecodeOpShadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf020fa90UL, 0xf0f0fff0UL, DecodeOpShadd16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf060fa80UL, 0xf0f0fff0UL, DecodeOpUhadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf060fa90UL, 0xf0f0fff0UL, DecodeOpUhadd16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fb70UL, 0xf0f0fff0UL, DecodeOpUsad8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf050fac0UL, 0xf0f0fff0UL, DecodeOpUqsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf050fad0UL, 0xf0f0fff0UL, DecodeOpUqsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf050fa80UL, 0xf0f0fff0UL, DecodeOpUqadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf050fa90UL, 0xf0f0fff0UL, DecodeOpUqadd16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fac0UL, 0xf0f0fff0UL, DecodeOpSsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fad0UL, 0xf0f0fff0UL, DecodeOpSsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fa80UL, 0xf0f0fff0UL, DecodeOpSadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fa90UL, 0xf0f0fff0UL, DecodeOpSadd16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf040fac0UL, 0xf0f0fff0UL, DecodeOpUsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf040fad0UL, 0xf0f0fff0UL, DecodeOpUsub16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf040fa80UL, 0xf0f0fff0UL, DecodeOpUadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf040fa90UL, 0xf0f0fff0UL, DecodeOpUadd16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3a0UL, 0xf0f0fff0UL, DecodeOpUsat16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf380UL, 0x8020ffd0UL, DecodeOpUsat<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf320UL, 0xf0f0fff0UL, DecodeOpSsat16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf300UL, 0x8020ffd0UL, DecodeOpSsat<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080faa0UL, 0xf0f0fff0UL, DecodeOpSel<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xeac0UL, 0x8010fff0UL, DecodeOpPkh<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf0b0fa80UL, 0xf0f0fff0UL, DecodeOpQdsub<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf090fa80UL, 0xf0f0fff0UL, DecodeOpQdadd<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf010fac0UL, 0xf0f0fff0UL, DecodeOpQsub8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf010fad0UL, 0xf0f0fff0UL, DecodeOpQsub16<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf0a0fa80UL, 0xf0f0fff0UL, DecodeOpQsub<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf010fa80UL, 0xf0f0fff0UL, DecodeOpQadd8<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf010fa90UL, 0xf0f0fff0UL, DecodeOpQadd16<	ARCH>));
	if( ARCH::Config::insns5E ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa80UL, 0xf0f0fff0UL, DecodeOpQadd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8f2ff3bfUL, 0xffffffffUL, DecodeOpClrex<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x70e8c0UL, 0xf0fff0UL, DecodeOpStrexd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf40e8c0UL, 0xff0fff0UL, DecodeOpStrexb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf50e8c0UL, 0xff0fff0UL, DecodeOpStrexh<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe840UL, 0xfff0UL, DecodeOpStrex<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7fe8d0UL, 0xfffff0UL, DecodeOpLdrexd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf4fe8d0UL, 0xffffff0UL, DecodeOpLdrexb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf5fe8d0UL, 0xffffff0UL, DecodeOpLdrexh<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00e850UL, 0xf00fff0UL, DecodeOpLdrex<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe880UL, 0xffd0UL, DecodeOpStmia_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe900UL, 0xffd0UL, DecodeOpStmdb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe890UL, 0xffd0UL, DecodeOpLdmia_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe910UL, 0xffd0UL, DecodeOpLdmdb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000f91fUL, 0xf000ff7fUL, DecodeOpPli_lit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc00f910UL, 0xff00fff0UL, DecodeOpPli_nimm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000f990UL, 0xf000fff0UL, DecodeOpPli_imm12<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000f81fUL, 0xf000ff5fUL, DecodeOpPld_lit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc00f810UL, 0xff00ffd0UL, DecodeOpPld_nimm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000f890UL, 0xf000ffd0UL, DecodeOpPld_imm12<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00f800UL, 0xf00fff0UL, DecodeOpStrbt<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00f820UL, 0xf00fff0UL, DecodeOpStrht<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00f840UL, 0xf00fff0UL, DecodeOpStrt<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe840UL, 0xfe50UL, DecodeOpStrd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf800UL, 0xfc0fff0UL, DecodeOpStrb_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f800UL, 0x800fff0UL, DecodeOpStrb_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf880UL, 0xfff0UL, DecodeOpStrb_imm12<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf820UL, 0xfc0fff0UL, DecodeOpStrh_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f820UL, 0x800fff0UL, DecodeOpStrh_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf8a0UL, 0xfff0UL, DecodeOpStrh_imm12<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf840UL, 0xfc0fff0UL, DecodeOpStr_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f840UL, 0x800fff0UL, DecodeOpStr_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf8c0UL, 0xfff0UL, DecodeOpStr_imm12<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe95fUL, 0xff7fUL, DecodeOpLdrd_lit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe850UL, 0xfe50UL, DecodeOpLdrd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf93fUL, 0xff7fUL, DecodeOpLdrsh_lit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf9b0UL, 0xfff0UL, DecodeOpLdrsh_imm12<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf85fUL, 0xff7fUL, DecodeOpLdr_lit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf8d0UL, 0xfff0UL, DecodeOpLdr_imm12<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf0b0fa90UL, 0xf0f0fff0UL, DecodeOpRevsh_w<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xf090fa90UL, 0xf0f0fff0UL, DecodeOpRev16_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa90UL, 0xf0f0fff0UL, DecodeOpRev_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf0a0fa90UL, 0xf0f0fff0UL, DecodeOpRbit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf36fUL, 0x8020ffffUL, DecodeOpBfc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf360UL, 0x8020fff0UL, DecodeOpBfi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf340UL, 0x8020fff0UL, DecodeOpSbfx<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf3c0UL, 0x8020fff0UL, DecodeOpUbfx<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa0fUL, 0xf0c0ffffUL, DecodeOpSxth_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa4fUL, 0xf0c0ffffUL, DecodeOpSxtb_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa2fUL, 0xf0c0ffffUL, DecodeOpSxtb16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa00UL, 0xf0c0fff0UL, DecodeOpSxtah<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa40UL, 0xf0c0fff0UL, DecodeOpSxtab<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa20UL, 0xf0c0fff0UL, DecodeOpSxtab16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa1fUL, 0xf0c0ffffUL, DecodeOpUxth_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa5fUL, 0xf0c0ffffUL, DecodeOpUxtb_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa3fUL, 0xf0c0ffffUL, DecodeOpUxtb16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa10UL, 0xf0c0fff0UL, DecodeOpUxtah<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa50UL, 0xf0c0fff0UL, DecodeOpUxtab<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fa30UL, 0xf0c0fff0UL, DecodeOpUxtab16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080fab0UL, 0xf0f0fff0UL, DecodeOpClz<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00f010UL, 0x8f00fbf0UL, DecodeOpTst_wri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00ea10UL, 0x8f00fff0UL, DecodeOpTst_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00f090UL, 0x8f00fbf0UL, DecodeOpTeq_wri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00ea90UL, 0x8f00fff0UL, DecodeOpTeq<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00f110UL, 0x8f00fbf0UL, DecodeOpCmn_wri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00eb10UL, 0x8f00fff0UL, DecodeOpCmn_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00f1b0UL, 0x8f00fbf0UL, DecodeOpCmp_wri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf00ebb0UL, 0x8f00fff0UL, DecodeOpCmp_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000UL, 0x8000fbe0UL, DecodeOpAnd_wrri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea00UL, 0x8000ffe0UL, DecodeOpAnd_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf020UL, 0x8000fbe0UL, DecodeOpBic_wrri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea20UL, 0x8000ffe0UL, DecodeOpBic_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf080UL, 0x8000fbe0UL, DecodeOpEor_wrri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea80UL, 0x8000ffe0UL, DecodeOpEor_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf140UL, 0x8000fbe0UL, DecodeOpAdc_wrri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb40UL, 0x8000ffe0UL, DecodeOpAdc_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf20fUL, 0x8000fbffUL, DecodeOpAdr_addw<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf200UL, 0x8000fbf0UL, DecodeOpAddw<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf100UL, 0x8000fbe0UL, DecodeOpAdd_wrri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb00UL, 0x8000ffe0UL, DecodeOpAdd_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf1c0UL, 0x8000fbe0UL, DecodeOpRsb_rri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xebc0UL, 0x8000ffe0UL, DecodeOpRsb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf160UL, 0x8000fbe0UL, DecodeOpSbc_wrri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeb60UL, 0x8000ffe0UL, DecodeOpSbc_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2afUL, 0x8000fbffUL, DecodeOpAdr_subw<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2a0UL, 0x8000fbf0UL, DecodeOpSubw<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf1a0UL, 0x8000fbe0UL, DecodeOpSub_wrri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xeba0UL, 0x8000ffe0UL, DecodeOpSub_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000fa00UL, 0xf0f0ff80UL, DecodeOpShift_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf06fUL, 0x8000fbefUL, DecodeOpMvn_wri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea6fUL, 0x8000ffefUL, DecodeOpMvn_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf240UL, 0x8000fbf0UL, DecodeOpMovw<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf2c0UL, 0x8000fbf0UL, DecodeOpMovt<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea4fUL, 0x8000ffefUL, DecodeOpMov_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf04fUL, 0x8000fbefUL, DecodeOpMov_wri<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xb660UL, 0xffe8UL, DecodeOpCpsi<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbe00UL, 0xff00UL, DecodeOpBkpt<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xdf00UL, 0xff00UL, DecodeOpSwi<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0x4780UL, 0xff87UL, DecodeOpBlx<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4700UL, 0xff87UL, DecodeOpBx<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe000UL, 0xf800UL, DecodeOpB<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xd000UL, 0xf000UL, DecodeOpBcc<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xb280UL, 0xffc0UL, DecodeOpUxth<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xb2c0UL, 0xffc0UL, DecodeOpUxtb<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xb200UL, 0xffc0UL, DecodeOpSxth<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xb240UL, 0xffc0UL, DecodeOpSxtb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4340UL, 0xffc0UL, DecodeOpMul<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc000UL, 0xf800UL, DecodeOpStmia<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb400UL, 0xfe00UL, DecodeOpPush<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xbc00UL, 0xfe00UL, DecodeOpPop<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xc800UL, 0xf800UL, DecodeOpLdmia<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5200UL, 0xfe00UL, DecodeOpStrh_2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000UL, 0xf800UL, DecodeOpStrh_1<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5400UL, 0xfe00UL, DecodeOpStrb_2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7000UL, 0xf800UL, DecodeOpStrb_1<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x9000UL, 0xf800UL, DecodeOpStr_3<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5000UL, 0xfe00UL, DecodeOpStr_2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6000UL, 0xf800UL, DecodeOpStr_1<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5e00UL, 0xfe00UL, DecodeOpLdrsh<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5600UL, 0xfe00UL, DecodeOpLdrsb<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5a00UL, 0xfe00UL, DecodeOpLdrh_2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8800UL, 0xf800UL, DecodeOpLdrh_1<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5c00UL, 0xfe00UL, DecodeOpLdrb_2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x7800UL, 0xf800UL, DecodeOpLdrb_1<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x9800UL, 0xf800UL, DecodeOpLdr_4<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4800UL, 0xf800UL, DecodeOpLdr_lit_s<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x5800UL, 0xfe00UL, DecodeOpLdr_2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x6800UL, 0xf800UL, DecodeOpLdr_1<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xb650UL, 0xfff7UL, DecodeOpSetend<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xbac0UL, 0xffc0UL, DecodeOpRevsh<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xba40UL, 0xffc0UL, DecodeOpRev16<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xba00UL, 0xffc0UL, DecodeOpRev<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4200UL, 0xffc0UL, DecodeOpTst<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb080UL, 0xff80UL, DecodeOpSub_4<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1a00UL, 0xfe00UL, DecodeOpSub_3<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3800UL, 0xf800UL, DecodeOpSub_2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1e00UL, 0xfe00UL, DecodeOpSub_1<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4180UL, 0xffc0UL, DecodeOpSbc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x41c0UL, 0xffc0UL, DecodeOpRor_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4300UL, 0xffc0UL, DecodeOpOrr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4240UL, 0xffc0UL, DecodeOpNeg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x43c0UL, 0xffc0UL, DecodeOpMvn<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4687UL, 0xff87UL, DecodeOpMov_3_pc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4600UL, 0xff00UL, DecodeOpMov_3<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2000UL, 0xf800UL, DecodeOpMov_1<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x40c0UL, 0xffc0UL, DecodeOpLsr_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4080UL, 0xffc0UL, DecodeOpLsl_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4040UL, 0xffc0UL, DecodeOpEor<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4500UL, 0xff00UL, DecodeOpCmp_3<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4280UL, 0xffc0UL, DecodeOpCmp_2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x2800UL, 0xf800UL, DecodeOpCmp_1<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x42c0UL, 0xffc0UL, DecodeOpCmn<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4380UL, 0xffc0UL, DecodeOpBic<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4100UL, 0xffc0UL, DecodeOpAsr_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4000UL, 0xffc0UL, DecodeOpAnd<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xb000UL, 0xff80UL, DecodeOpAdd_7<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa800UL, 0xf800UL, DecodeOpAdd_6<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa000UL, 0xf800UL, DecodeOpAdr<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4487UL, 0xff87UL, DecodeOpAdd_4_pc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4400UL, 0xff00UL, DecodeOpAdd_4<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1800UL, 0xfe00UL, DecodeOpAdd_3<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x3000UL, 0xf800UL, DecodeOpAdd_2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x1c00UL, 0xfe00UL, DecodeOpAdd_1<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x4140UL, 0xffc0UL, DecodeOpAdc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ffa0UL, 0xfd0ffa0UL, DecodeOpVshll_u32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ff90UL, 0xfd0ffb0UL, DecodeOpVshll_u16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ff88UL, 0xfd0ffb8UL, DecodeOpVshll_u8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10efa0UL, 0xfd0ffa0UL, DecodeOpVshll_s32<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ef90UL, 0xfd0ffb0UL, DecodeOpVshll_s16<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xa10ef88UL, 0xfd0ffb8UL, DecodeOpVshll_s8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000f3afUL, 0xf800ffffUL, DecodeOpCps<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc10UL, 0xfe10UL, DecodeOpLdc2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xec10UL, 0xfe10UL, DecodeOpLdc<	ARCH>));
	if( ARCH::Config::insns5T ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfc00UL, 0xfe10UL, DecodeOpStc2<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xec00UL, 0xfe10UL, DecodeOpStc<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xfb00UL, 0xf0fff0UL, DecodeOpMla<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x8000f000UL, 0xd000f800UL, DecodeOpBcc_w<	ARCH>));
	if( ARCH::Config::insns6 ) decode_table.push_back(DecodeTableEntry<	ARCH>(0xfb70UL, 0xf0fff0UL, DecodeOpUsada8<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000f910UL, 0xffc0fff0UL, DecodeOpPli_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf000f810UL, 0xffc0ffd0UL, DecodeOpPld_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00f930UL, 0xf00fff0UL, DecodeOpLdrsht<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00f850UL, 0xf00fff0UL, DecodeOpLdrt<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf91fUL, 0xff7fUL, DecodeOpLdrsb_lit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf990UL, 0xfff0UL, DecodeOpLdrsb_imm12<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf81fUL, 0xff7fUL, DecodeOpLdrb_lit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf890UL, 0xfff0UL, DecodeOpLdrb_imm12<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf930UL, 0xfc0fff0UL, DecodeOpLdrsh_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f930UL, 0x800fff0UL, DecodeOpLdrsh_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf83fUL, 0xff7fUL, DecodeOpLdrh_lit<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf8b0UL, 0xfff0UL, DecodeOpLdrh_imm12<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf850UL, 0xfc0fff0UL, DecodeOpLdr_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f850UL, 0x800fff0UL, DecodeOpLdr_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf040UL, 0x8000fbe0UL, DecodeOpOrr_wrri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea40UL, 0x8000ffe0UL, DecodeOpOrr_w<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf060UL, 0x8000fbe0UL, DecodeOpOrn_rri<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xea60UL, 0x8000ffe0UL, DecodeOpOrn<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x0UL, 0xe000UL, DecodeOpMov_reg_shift<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00f910UL, 0xf00fff0UL, DecodeOpLdrsbt<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00f810UL, 0xf00fff0UL, DecodeOpLdrbt<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xe00f830UL, 0xf00fff0UL, DecodeOpLdrht<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf910UL, 0xfc0fff0UL, DecodeOpLdrsb_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f910UL, 0x800fff0UL, DecodeOpLdrsb_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf810UL, 0xfc0fff0UL, DecodeOpLdrb_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f810UL, 0x800fff0UL, DecodeOpLdrb_imm<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0xf830UL, 0xfc0fff0UL, DecodeOpLdrh_reg<	ARCH>));
	decode_table.push_back(DecodeTableEntry<	ARCH>(0x800f830UL, 0x800fff0UL, DecodeOpLdrh_imm<	ARCH>));
}

template <	typename	ARCH>
Decoder<	ARCH>::~Decoder()
{
}

template <	typename	ARCH>
Operation<	ARCH> *Decoder<	ARCH>::NCDecode(uint32_t addr, CodeType code)
{
	Operation<	ARCH> *operation;
	unsigned int count = decode_table.size();
	unsigned int idx;
	for(idx = 0; idx < count; idx++)
	{
		if((code & decode_table[idx].opcode_mask) == decode_table[idx].opcode)
		{
			operation = decode_table[idx].decode(code, addr);
			return operation;
		}
	}
	operation = new Operation<	ARCH>(code, addr, "???");
	return operation;
}

} } } } } } }
